#!/usr/bin/env bash

source $SIMPLETON_LIB/command-prep "$0" "$@" || exit 1

source $SIMPLETON_LIB/lifted-bash || exit 1
source $SIMPLETON_LIB/bash-debugger || exit 1
source $SIMPLETON_LIB/bash-lib || exit 1
source $SIMPLETON_LIB/omni-log || exit 1
source $SIMPLETON_LIB/omni-navigator || exit 1
source $SIMPLETON_LIB/cell-lib || exit 1
source $SIMPLETON_LIB/help-lib || exit 1
source $SIMPLETON_LIB/clean-lib || exit 1

parameters_to_env "$@"
if [[ "${real_params:-}" ]]; then
  set -- "${real_params[@]}"; shift
fi
autorepair_level=${autorepair_level:-${repair:-1}}
bash_lifted_init || exit 1
cell_lib_init || exit 1

show_flag_usage() {
  out "Flags are shortcuts for longer settings, and only the following are defined:"
  out "  Flag   Equivalent setting"
  out "  ------ -----------------------------"
  out "  -a     trace_var_always=t"
  out "  -d     log=debug"
  out "  -i     log=id2"
  out "  -r     recursive_command=t"
  out "  -s     trace_structure=t"
  out "  -t     out_form=table"
  out "  -v     log=verbose"
}

handle_flag() {
  begin_function
    local flags=${1#-} flag

    begin_while [[ "$flags" ]]; doo
      flag=${flags:0:1}
      flags=${flags#?}
      case $flag in
        \?|\?\?)
          show_flag_usage
          fail1
          ;;
        a)
          trace_var_always=t
          ;;
        d)
          log=debug
          ;;
        i)
          show_debug_id=a
          ;;
        r)
          recursive_command=t
          ;;
        s)
          trace_structure=t
          ;;
        t)
          out_form=table
          ;;
        v)
          log=verbose
          ;;
        *)
          log_fatal "Unknown flag: $flag"
          show_flag_usage
          fail1
          ;;
      esac
    end_while
  end_function
  handle_return
}

show_usage() {
  begin_function
    local indent=${indent:-0}
    out "Usage: ${0##*/} ({cells..} {commands..}).."

    (( indent += 2 ))
    local d=
    d+="Parameters are cells followed by commands to be run on those cells. "
    d+="Any number of cell/command combinations can be given, which will be executed sequentially. "
    d+="If two cells are given in a row with no command in between, the commands following the last "
    d+="cell will be applied to all of the cells preceeding them. "
    d+="key=value parameters may be put anywhere in the parameter list and will apply to all commands. "
    d+="This also applies to flag shortcuts. "
    d+="If no cell path is specified, the cell path is taken from the current folder. "
    d+="If help or -h or --help or ? is given as any of the parameters, "
    d+="documentation for the given cells or commands is printed instead of executing commands. "
    d+="If ?? is given, more verbose help will be given if available. "
    d+="key=? form can be used to get documentation about a specific variable/key/dimension. "
    d+="-? can be used to get documentation for flags which are shortcuts of normal key parameters. "
    d+="$NL$NL"
    d+="Use \`cell . help\` to see help specific to the current cell (you can replace . with any cell name also)."
    echo "$d" | fold -s -w $((COLUMNS-2)) | indent $indent

    (( indent -= 2 ))
    out "${NL}Possible Commands:"
    (( indent += 2 ))
    local command_info command_name infos
    infos=$(find1 $path_to_commands -name '*.info' -not -name 'all.info' | sort -g) || fail
    {
      begin_for command_info in $infos; doo
        command_name=${command_info%.info}
        command_name=${command_name##*/}
        source $command_info || fail
        if [[ "$command_description" ]]; then
          local short_desc=$command_description
          trim_ws short_desc
          short_desc=${short_desc%%$NL*}
          echo "$command_name $short_desc"
        else
          echo "$command_name Please add a description to this command in $cell_command"
        fi
      end_for
    } | column -l 2 -t | indent $indent

    if [[ "${command_aliases:-}" ]]; then
      local i
      (( indent -= 2 ))
      out "${NL}Command aliases (may be used as shortcuts of the given commands):"
      (( indent += 2 ))
      {
        echo "ALIAS SUBSTITUTED-FOR"
        begin_for (( i = 0; i < ${#command_aliases[*]}; i++ )); doo
          echo "${command_aliases[$i]} ${command_alias_command[$i]}"
        end_for
      } | column -l 2 -t | indent $indent
    fi

  end_function
  handle_return
}

get_help_depth_and_flags() {
  begin_function
    if [[ "${parameter_questions:-}" ]]; then
      : ${help_depth:=2}
    else
      : ${help_depth:=0}
    fi
    begin_for parameter in ${parameters[*]}; doo
      case $parameter in
        help|--help|-h|\?)
          (( help_depth++ )) 
        ;;
        -*)
          handle_flag $parameter || fail
        ;;
        \?\?)
          (( help_depth += 2 )) 
        ;;
      esac
    end_for
  end_function
  debug_return_vars=help_depth
  handle_return
}

get_cells() {
  begin_function
    for (( ; current_parameter_index < ${#parameters[*]}; current_parameter_index++ )); do
      local parameter=${parameters[$current_parameter_index]}
      case $parameter in
        help|-*|\?|\?\?)
          :
        ;;
        *)
          if [[ ! -d $parameter ]]; then
            # is a command
            succeed
          else
            cells+=( $parameter )
          fi
        ;;
      esac
    done
  end_function
  handle_return
}

get_commands() {
  begin_function
    for (( ; current_parameter_index < ${#parameters[*]}; current_parameter_index++ )); do
      local parameter=${parameters[$current_parameter_index]}
      case $parameter in
        help|-*|\?|\?\?)
          :
        ;;
        *)
          leftover_command=
          if [[ "${leftovers:-}" ]]; then
            leftover_command=${leftovers[*]}
            leftover_command=${leftover_command// /-}-$parameter
          fi

          if [[ -f "$path_to_commands/$parameter.info" ]]; then
            commands+=( $parameter )
          elif array_contains command_aliases $parameter; then
            commands+=( $parameter )
          elif [[ -f "$path_to_commands/$leftover_command.info" ]]; then
            commands+=( $leftover_command )
            leftovers=()
          elif [[ -d $parameter ]]; then
            # it's a cell
            succeed
          else
            leftovers+=( $parameter )
          fi
        ;;
      esac
    done
  end_function
  handle_return
}

handle_leftovers() {
  begin_function
    local leftover
    for leftover in "${leftovers[@]}"; do
      if (( help_depth > 0 )); then
        local subs=( $path_to_commands/$leftovers-*.info )
        if [[ "$subs" != *\** ]]; then
          out "Choose a subcommand of $leftover:$NL"
          local sub
          for sub in ${subs[*]}; do
            local command=${sub##*/}
            command=${command%.info}
            commands+=( $command )
          done
          continue
        fi
      fi
      show_usage 
      fail_later1; break 2
    done
  end_function
  handle_return
}

handle_cell() {
  local cell_path=$1

  local log_show_vars='^cell_path'
  begin_function_hi

    local omni_log_job_id job_id_log=${home_job_path:-$HOME/.simpleton/job-log}

    cell_path=$(unrealpath $cell_path) || {
      log_fatal "Invalid cell path: $cell_path"
      fail1
      }

    if (( ${#commands[*]} > 0 )); then
      if [[ $multi_cell == f ]]; then
        execute_commands $cell_path ${commands[*]} || fail
      else
        fork execute_commands $cell_path ${commands[*]} || fail
      fi
    elif [[ ! "${parameter_questions:-}" ]]; then
      show_cell_help $cell_path || fail
    else # parameter_questions
      show_parameters_help || fail
    fi
    first_cell=f

  end_function
  handle_return
}

reset_flags() {
  trace_var_always=f
  log=info
  show_debug_id=n
  recursive_command=f
}

top_level() {
  local parameters=( "$@" ) \

  begin_function

    local cell_path \
      path_to_commands=$SIMPLETON_REPO/command \
      first_command=t \
      first_cell=t \
      multi_cell=f \
      multi_commands=f \
      clean_cells=${clean_cells:-${clean_cell:-${clean:-}}} \
      recursive_command=${recursive_command:-${recursive:-f}} \

    reset_flags
    get_help_depth_and_flags || fail

    command="$original_cmd" omni_log_init || fail

    local current_parameter_index=0 leftovers=() leftover_command handled=0
    begin_while true; doo

      cells=() \
      commands=() \
      leftovers=() \

      if [[ -e $path_to_commands/all.info ]]; then
        source $path_to_commands/all.info || fail
      fi
      get_cells || fail
      get_commands || fail
      handle_leftovers || fail

      if (( ${#commands[*]} > 1 )); then
        multi_commands=t
      fi

      if (( ${#cells[*]} > 1 )); then
        multi_cell=t
      fi

      if [[ ! "${cells:-}" ]]; then
        if [[ ! "${commands:-}" && ! "${parameter_questions:-}" ]]; then
          if (( handled == 0 )); then
            show_usage
            succeed
          else
            # nothing else to do
            succeed
          fi
        fi
        cells=( . )
      fi

      if [[ "${commands:-}" && ! "${parameter_questions:-}" ]] && (( help_depth > 0 )); then
        begin_for command in ${commands[*]}; doo
          show_help_for_command $command || fail
        end_for
        succeed
      fi

      begin_for cell_path in ${cells[*]}; doo
        handle_cell $cell_path || fail
        (( handled++ ))
      end_for

      if (( current_parameter_index >= ${#parameters[*]} )); then
        succeed
      fi

    end_while

  end_function

  if [[ "${zombie_lap_total:-}" ]]; then
    out "${NL}Performance counters:"
    zombie_lap_summary
  fi

  if [[ $trace_time == t ]]; then
    trace_time_summarize
  fi

  handle_return
}

debugger_init || exit 1
top_level "${real_params[@]}"

