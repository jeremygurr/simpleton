#!/usr/bin/env bash

original_cmd="$0 $*"
source $SIMPLETON_REPO/lib/command-prep "$0" "$@" || exit 1
set "${real_params[@]}"; shift

source $SIMPLETON_REPO/lib/bash-debugger || exit 1
source $SIMPLETON_REPO/lib/omni-log-aliases || exit 1
source $SIMPLETON_REPO/lib/bash-lib || exit 1
source $SIMPLETON_REPO/lib/omni-log || exit 1
source $SIMPLETON_REPO/lib/omni-navigator || exit 1
source $SIMPLETON_REPO/lib/cell-lib || exit 1

scan_commands() {
  begin_function
    local parameter leftovers=
    begin_for parameter in ${parameters[*]}; doo
      case $parameter in
        help|\?|--help|-h)
          help_mode=t
        ;;
        *)
          if [[ -f "$path_to_commands/$parameter" ]]; then
            commands+=( $parameter )
          elif [[ -e $parameter ]]; then
            cells+=( $parameter )
          elif [[ -e $PWD/$parameter ]]; then
            cells+=( $PWD/$parameter )
          else
            leftovers+=( $parameter )
          fi
        ;;
      esac
    end_for
    if [[ "$leftovers" ]]; then
      log_fatal "Unidentified commands: ${leftovers[*]}"
      show_usage 
      fail1
    fi
  end_function
  handle_return
}

handle_command() {
  local command=$1

  begin_function

      case $command in
        shell)
          export prompt_name='cell shell'
          bash --init-file <(
            cat \
            /etc/profile \
            $SIMPLETON_REPO/lib/bash-lib \
            $SIMPLETON_REPO/lib/omni-log \
            $SIMPLETON_REPO/lib/omni-navigator \
            $SIMPLETON_REPO/lib/bash-debugger \
            $SIMPLETON_REPO/lib/cell-lib \
            $SIMPLETON_REPO/lib/cell-shell-prep \
            )
        ;;
        clean)
          get_bottom_cell $cell_path || fail
          if [[ ! "$bottom_cell" ]]; then
            log_fatal "Not a valid cell: $cell_path"
            fail1
          fi
          local cell_path=$bottom_cell
          log_info "Cleaning $cell_path..." 
          local clean_file=$cell_path/.dna/op/clean.bash
          if [[ -f $clean_file ]]; then
            source $clean_file || fail
            clean || fail
          else
            local x

            begin_for x in $cell_path/.cyto* $cell_path/*:*; doo
              log_info "Removing ${x#$cell_path/}"
              rm -rf $x &>/dev/null
            end_for

            begin_for x in $cell_path/*; doo
              if [[ ! -d $x && -e $x ]]; then
                log_info "Removing ${x#$cell_path/}"
                rm $x &>/dev/null
              fi
            end_for
            log_info "Cleaned."
          fi
        ;;
        *)
          next=
          if [[ $((i+1)) -lt ${#commands[*]} ]]; then
            next=${commands[$((i+1))]}
          fi
          if [[ $next == --help || $next == -h || $next == help ]]; then
            show_help_for_command $command
            (( i++ ))
          else
            get_bottom_cell $cell_path || fail
            if [[ "$bottom_cell" ]]; then
              cell_path=$bottom_cell
            fi
            local omni_log_job_id job_id_log=${home_job_path:-$HOME/.simpleton/job-log}

            if [[ ! -d ${job_id_log%/*} ]]; then
              mkdir -p ${job_id_log%/*} || fail
            fi

            local needs_update=${needs_update:-} \
              command_to_log="${original_cmd#* }" \
              top_level_command=t \
              saved_command=$command

            local command_successful=f
            execute_command $cell_path $command || fail
            if [[ $command_successful == f ]]; then
              log_error "Command failed: $command"
              fail1
            fi
          fi
        ;;
      esac

  end_function
  handle_return

}

handle_cell() {
  local cell_path=$1

  begin_function

    cell_path=$(unrealpath $cell_path) || {
      log_fatal "Failed to resolve path for $cell_path"
      fail1
      }

    local next
    if (( ${#commands[*]} == 0 )); then
      show_cell_help $cell_path || fail
    else
      begin_for command in ${commands[*]}; doo
        if [[ $help_mode == t ]]; then
          show_help_for_command $command || fail
        else
          handle_command $command || fail
        fi
        first_command=f
      end_for
    fi

  end_function
  handle_return
}

top_level() {
  local parameters=( "$@" ) \

  begin_function

    command="$original_cmd" omni_log_init || fail

    local help_mode=f \
      cell_path \
      path_to_commands=$SIMPLETON_REPO/command \
      first_command=t \
      multi_cell=f \
      commands=() \

    if [[ "${cells:-}" ]]; then
      cells=( $cells )
    elif [[ "${cell:-}" ]]; then
      cells=( $cell )
    fi

    scan_commands || fail

    if [[ ! "${cells:-}" ]]; then
      if [[ $help_mode == t ]]; then
        show_usage
        succeed
      else
        cells=( . )
      fi
    fi

    if (( ${#cells[*]} > 1 )); then
      multi_cell=t
    fi

    begin_for cell_path in ${cells[*]}; doo
      handle_cell $cell_path || fail
    end_for

  end_function
  handle_return
}

show_cell_help() {
  local cell_path=$1
  begin_function

    get_bottom_cell $cell_path || {
      log_fatal "No cell found here: $cell_path"
      fail1
      }
    local cell_path=$bottom_cell
    can_create_cyto=f
    switch_context || fail
    if [[ $multi_cell == t ]]; then
      out "$hbar_equals"
    fi

    out "Cell: $short_cell"
    if [[ "${cell_description:-}" ]]; then
      out "  $cell_description"
    else
      out "  No description for this cell. Set cell_description variable in context file."
    fi

    local required=()

    if [[ "${leaf_dims:-}" ]]; then
      out "Dimensions:"
      show_dimensions ${leaf_dims[*]} || fail
    fi

    if [[ "${sub_dims:-}" || "${props:-}" ]]; then
      out "Other parameters:"
      if [[ "${sub_dims:-}" ]]; then
        show_dimensions ${sub_dims[*]} || fail
      fi
      if [[ "${props:-}" ]]; then
        show_dimensions ${props[*]} || fail
      fi
    fi

    if [[ "${required:-}" ]]; then
      out "Required parameters: ${required[*]}"
    fi

  end_function
  handle_return
}

show_dimensions() {
  local dims=( $* ) dim description values is_required
  begin_function
    begin_for dim in ${dims[*]}; doo
      if [[ -v ${dim}_description ]]; then
        eval "description=\$${dim}_description" || fail
      else
        description='No description'
      fi
      out "  $dim: $description"
      if function_exists ${dim}_expand; then
        values=
        is_required=f

        local problem=
        eval "value='' ${dim}_expand" &>/dev/null || is_required=t
        if [[ "$problem" ]]; then
          is_required=t
        fi

        if [[ "$values" ]]; then
          if [[ "$values" == $empty_member ]]; then
            out "    default: (empty)"
          else
            out "    default: ${values[*]}"
          fi
        elif [[ $is_required == f ]]; then
          out "    optional"
        else
          required+=( $dim )
        fi

        if [[ -v ${dim}_examples ]]; then
          eval "local examples=( \"\${${dim}_examples[@]}\" )"
          local example_count=${#examples[*]} i index_string=
          for ((i=0; i<example_count; i++)); do
            if [[ example_count -gt 1 ]]; then
              index_string=" #$((i+1))"
            fi
            out "    example$index_string: ${examples[$i]}"
          done
        fi

      fi
    end_for
  end_function
  handle_return
}

show_help_for_command() {
  local command=$1
  begin_function
    get_bottom_cell $cell_path || fail
    if [[ "$bottom_cell" ]]; then
      local cell_path=$bottom_cell \
        can_create_cyto=f
      switch_context || fail
      [[ $first_command == f ]] && out ''
      out "Command: $command"
      if [[ -f $path_to_commands/$command.info ]]; then
        source $path_to_commands/$command.info || fail
        out "  $command_description"
        local name description default default_string i
        if [[ "${parameter_names:-}" ]]; then
          out "Parameters:"
          begin_for ((i=0; i<${#parameter_names[*]}; i++)); doo
            parameter="${parameter_names[$i]}"
            description="${parameter_descriptions[$i]}"
            default="${parameter_defaults[$i]}"
            default_string=
            [[ "$default" ]] && default_string=" default: $default"
            out "  $parameter: $description$default_string"
          end_for
        fi
      fi
    fi
  end_function
  handle_return
}

show_usage() {
  warn "Usage: ${0##*/} {command(s)}"
  local command
  if [[ -d "$cell_path/.cyto" ]]; then
    warn "Commands:"
    for command in $(find1 $cell_path/.cyto/command | sort); do
      if [[ -f $command ]]; then
        source $command || fail
      elif [[ -d $command ]]; then
        local first_file=$(find1 $command -type f | sort -g | head -n 1)
        if [[ "$first_file" ]]; then
          source $first_file || fail
        fi
      fi
      local command_name=${command##*/}
      local command_description=describe_${command_name}
      command_description=${!command_description:-}
      if [[ "$command_description" ]]; then
        warn "  $command_name $COL20$command_description"
      else
        warn "  $command_name ${COL20}Please add a description to this command in $command"
      fi
    done
  else
    warn "  either run this command inside of a cell folder, or specify"
    warn "  the cell variable with the path to a cell. "
    warn "  example: cell cell=/some/cell update"
  fi
  return 0
}

debugger_init || exit 1
top_level "$@"

