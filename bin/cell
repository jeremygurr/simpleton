#!/usr/bin/env bash

source $SIMPLETON_LIB/lifted-bash || exit 1
source $SIMPLETON_LIB/cell-lib || exit 1

command_detail=${command_detail:-0}
parameters_to_env "$@" || exit 1
if [[ "${real_params:-}" ]]; then
  set -- "${real_params[@]}"; shift
fi

lifted_bash_init || exit 1
cell_lib_init || exit 1

recursive_command=${recursive_command:-${recursive:-f}}

# overrides what is in lifted-bash
show_flag_usage_custom() {
  out "  -f     refresh=t (force refresh only current cell)"
  out "  -ff    fresh=0 (force refresh of current cell and important upstreams)"
  out "  -fff   fresh=0 and pre_validate=f (don't check to see if the change is already applied)"
  out "  -r     apply command recusively. Only used by status for now."
  out "  -R     replay=t (if cell supports replay)"
  out "  -s     synchronous mode (parallel_execution=f)"
  out "  -t     out_form=table (used for get command)"
}

# overrides what is in lifted-bash
# return 0 if the flag was handled, 1 otherwise
handle_flag_custom() {
  local flag=$1 # single character flag to be handled
  case $flag in
	f)
	  if [[ "${fresh:-}" == 0 ]]; then
		pre_validate=f
	  elif [[ "${refresh:-}" == t ]]; then
		fresh=0
	  else
		refresh=t
	  fi
	  return 0
	  ;;
	R)
	  replay=t
	  return 0
	  ;;
	s)
	  parallel_execution=f
	  return 0
	  ;;
	r)
	  recursive_command=t
	  return 0
	  ;;
	t)
	  out_form=table
	  return 0
	  ;;
  esac
  return 1;
}

commands=()

name=update description="Updates product of this cell" new_command 

name=fresh default=inf description="Minimum freshness required. 
  0 = update no matter what. 
  5m = update if fresh within 5 minutes. 
  2h = update if fresh within 2 hours. 
  inf = ignore freshness." add_parameter 

name=refresh default=f description="Allows for direct control over whether a cell needs to be updated.
  t = mark all cells in this tree as stale (needing to be updated).
  f = only update cells which need to be updated
" add_parameter

name=risk_tolerance short=risk default=low description="Maximum risk tolerance. Low risk means only operations with virtually
  no chance of causing problems will be allowed. If you attept to update a cell that is higher risk than the
  tolerance specified, that update will fail.
  0 = low = restriced to read only operations, no changes will be made to anything.
  1 = medium = very safe changes are allowed which can only result in low impact outages at worst.
  2 = high = production outage may occur if you aren't sure of what you are doing, but there will be many 
    checks in place to minimize the chance of this.
  3 = very_high = production outage may occur, and there aren't a lot of safe guards in place, so you really
    need to know what you are doing and what these scripts do on a low level before attempting these commands.
" add_parameter

name=mock description="Switch to the given mocked cell result. 
Set mock=f to turn off mocking and go back to real cell computation.
" add_parameter

name=confirm_dims default=t description="Will ask user before running a top level command if the derived dims are valid before updating.
If set to 'a' it will confirm for every cell, not just the top one.
" add_parameter

name=show_dims default=t description="Will display the dims for the top cell if set to t.
If set to 'a' it will show the dims for every cell.
" add_parameter

name=pre_validate default=t description="Whether validation cells/functions should be run before update
" add_parameter

name=post_validate default=t description="Whether validation cells/functions should be run after update
" add_parameter

name=validate default=t description="Sets both pre_validate and post_validate to this value
" add_parameter

name=up_only description="Only runs upstreams matching the given values
" add_parameter

name=debug_log description="Starts debugger when a log line containing this string is written
" add_parameter

show_usage() {
  begin_function
    local indent=${indent:-0}
    out "Usage: ${0##*/} ({cells..} {commands..}).."

    indent
    local d=
    d+="Parameters are cells followed by commands to be run on those cells. "
    d+="Any number of cell/command combinations can be given, which will be executed sequentially. "
    d+="If two cells are given in a row with no command in between, the commands following the last "
    d+="cell will be applied to all of the cells preceeding them. "
    d+="key=value parameters may be put anywhere in the parameter list and will apply to all commands. "
    d+="This also applies to flag shortcuts. "
    d+="If no cell path is specified, the cell path is taken from the current folder. "
    d+="If help or -h or --help or ? is given as any of the parameters, "
    d+="documentation for the given cells or commands is printed instead of executing commands. "
    d+="If ?? is given, more verbose help will be given if available. "
    d+="key=? form can be used to get documentation about a specific variable/key/dimension. "
    d+="-? can be used to get documentation for flags which are shortcuts of normal key parameters. "
    d+="Soft interrupt feature: While a command is executing, you may press enter to pause execution. "
    d+="$NL$NL"
    d+="Use \`cell . help\` to see help specific to the current cell (you can replace . with any cell name also)."
    echo "$d" | fold -s -w $((COLUMNS-2)) | indent_stream $indent

    outdent
    out "${NL}Possible Commands:"
    indent
    local name
    {
      begin_for name in ${commands[*]}; doo
        local -n command_description=command_${name}_description
        if [[ "$command_description" ]]; then
          local short_desc=$command_description
          trim_ws short_desc
          short_desc=${short_desc%%$NL*}
          echo "$name $short_desc"
        else
          echo "$name Please add a description to this command in $cell_command"
        fi
      end_for
    } | column -l 2 -t | indent_stream $indent

    local -n command_aliases=command_${name}_aliases
    local -n command_alias_command=command_${name}_alias_command
    if [[ "${command_aliases:-}" ]]; then
      local i
      (( indent -= 2 ))
      out "${NL}Command aliases (may be used as shortcuts of the given commands):"
      (( indent += 2 ))
      {
        echo "ALIAS SUBSTITUTED-FOR"
        begin_for (( i = 0; i < ${#command_aliases[*]}; i++ )); doo
          echo "${command_aliases[$i]} ${command_alias_command[$i]}"
        end_for
      } | column -l 2 -t | indent_stream $indent
    fi

  end_function
  handle_return
}

is_command() {
  local parameter=$1
  [[ " ${commands[*]} " == *" $parameter "* ]] \
  || array_contains command_aliases $parameter
}

get_cells() {
  begin_function
    for (( ; current_parameter_index < ${#parameters[*]}; current_parameter_index++ )); do
      local parameter=${parameters[$current_parameter_index]}
      case $parameter in
        help|-*|\?|\?\?)
          :
        ;;
        *)
          if is_command $parameter; then
            abort
          elif [[ -d $parameter ]]; then
            cells+=( $parameter )
          else
            log_fatal "Not a command or cell: $parameter"
            fail1
          fi
        ;;
      esac
    done
  end_function
  handle_return
}

get_commands() {
  begin_function
    for (( ; current_parameter_index < ${#parameters[*]}; current_parameter_index++ )); do
      local parameter=${parameters[$current_parameter_index]}
      case $parameter in
        help|-*|\?|\?\?)
          :
        ;;
        *)
          leftover_command=
          if [[ "${leftovers:-}" ]]; then
            leftover_command=${leftovers[*]}
            leftover_command=${leftover_command// /-}-$parameter
          fi

          if is_command $parameter; then
             || array_contains command_aliases $parameter; then
            cell_commands+=( $parameter )
          elif is_command $leftover_command; then
            cell_commands+=( $leftover_command )
            leftovers=()
          elif [[ -d $parameter ]]; then
            # it's a cell
            abort
          else
            leftovers+=( $parameter )
          fi
        ;;
      esac
    done
  end_function
  handle_return
}

get_sub_commands() {
  local command_prefix=$1 command
  subs=()
  for command in ${commands[*]}; do
    if [[ $command == ${command_prefix}-* ]]; then
      subs+=( $command )
    fi
  done
}

handle_leftovers() {
  begin_function
    local leftover
    for leftover in "${leftovers[@]}"; do
      if (( help_depth > 0 )); then
        local subs
        get_sub_commands $leftover || fail
        if [[ "$subs" ]]; then
          out "Choose a subcommand of $leftover:$NL"
          cell_commands+=( ${subs[*]} )
          continue
        fi
      fi
      show_usage 
      fail_later1; break 2
    done
  end_function
  handle_return
}

handle_questions() {
  local error_if_unresolved=${error_if_unresolved:-f}
  begin_function
    local remaining= name
    if [[ "${parameter_questions:-}" ]]; then
      for name in $parameter_questions; do
        local found_help=f
        show_parameter_help_single || fail
        if [[ $found_help == f ]]; then
          remaining+="$name "
        fi
      done
      if [[ "$remaining" ]]; then
        if [[ $error_if_unresolved == t ]]; then
          log_error "Unknown parameter(s): $remaining"
          fail1
        else
          parameter_questions="${remaining% }"
        fi
      else
        succeed
      fi
    fi
  end_function
  handle_return
}

handle_cell() {
  local cell_path=$1

  local log_show_vars='^cell_path'
  begin_function

    if [[ -e "$cell_path" ]]; then
      cell_path=$(unrealpath $cell_path) || {
        log_fatal "Invalid cell path: $cell_path"
        fail1
        }
    fi

    if (( ${#cell_commands[*]} > 0 )); then
      if [[ $multi_cell == f ]]; then
        execute_commands $cell_path ${cell_commands[*]} || fail
      else
        fork execute_commands $cell_path ${cell_commands[*]} || fail
      fi
    elif [[ ! "${parameter_questions:-}" ]]; then
      show_cell_help $cell_path || fail
    else # parameter_questions
      show_parameters_help || fail
    fi
    first_cell=f

  end_function
  handle_return
}

get_help_depth_and_flags() {
  local parameters=( "$@" )
  begin_function

    for parameter in ${parameters[*]}; do
      case $parameter in
        help|--help|-h|\?)
          (( help_depth++ )) 
        ;;
        -*)
          handle_flag $parameter || fail
        ;;
        \?\?)
          (( help_depth += 2 )) 
        ;;
      esac
    done
  end_function
  if (( help_depth >= 2 )); then
    (( command_detail++ ))
  fi
  debug_return_vars=help_depth
  handle_return
}

top_level() {
  local parameters=( "$@" ) \

  begin_function

    local cell_path \
      first_command=t \
      first_cell=t \
      multi_cell=f \
      multi_commands=f \
      clean_cells=${clean_cells:-${clean_cell:-${clean:-}}} \

    get_help_depth_and_flags "${parameters[@]}" || fail

    local current_parameter_index=0 leftovers=() leftover_command handled=0
    begin_while true; doo

      cells=() \
      cell_commands=() \
      leftovers=() \

      if [[ -e $path_to_commands/all.info ]]; then
        source $path_to_commands/all.info || fail
      fi
      handle_questions || fail
      get_cells || fail
      get_commands || fail
      handle_leftovers || fail

      if (( ${#cell_commands[*]} > 1 )); then
        multi_commands=t
      fi

      if (( ${#cells[*]} > 1 )); then
        multi_cell=t
      fi

      if [[ ! "${cells:-}" ]]; then
        if [[ ! "${cell_commands:-}" && ! "${parameter_questions:-}" ]]; then
          if (( handled == 0 )); then
            show_usage
            abort
          else
            # nothing else to do
            abort
          fi
        fi

        local potential_cell=$(realpath .) seed_path=
        if [[ $potential_cell == /seed/* ]]; then
          seed_path=$potential_cell
          potential_cell=/work${potential_cell#/seed}
        fi
        while [[ $potential_cell == */.* && $potential_cell == /*/*/* ]]; do
          potential_cell=${potential_cell%/*}
        done
        if [[ "$seed_path" ]]; then
          while [[ $seed_path == */.* && $seed_path == /seed/*/* ]]; do
            seed_path=${seed_path%/*}
          done
        fi

        cells=( $potential_cell )
      fi

      if [[ "${cell_commands:-}" && ! "${parameter_questions:-}" ]] && (( help_depth > 0 )); then
        local cell_command
        begin_for cell_command in ${cell_commands[*]}; doo
          show_help_for_command $cell_command || fail
        end_for
        abort
      fi

      begin_for cell_path in ${cells[*]}; doo
        handle_cell $cell_path || fail
        (( handled++ ))
      end_for

      if (( current_parameter_index >= ${#parameters[*]} )); then
        abort
      fi

    end_while

  end_function

  if [[ "${zombie_lap_total:-}" ]]; then
    out "${NL}Performance counters:"
    zombie_lap_summary
  fi

  if [[ $trace_time == t ]]; then
    trace_time_summarize
  fi

  handle_return
}

top_level "${real_params[@]}"

