#!/usr/bin/env bash

get_formatted_data() {
  begin_function

    local i field value o c r row row_type

    o=
    row_type=header
    if function_exists each_field; then
      begin_for (( c = 0; c < selected_count; c++ )); doo
        i=${selected_field_indices[$c]}
        field=${data_fields[$i]}
        value=${data_fields[$i]}
        each_field || fail
      end_for
    fi

    execute_if_exists after_row || fail

    row_type=data
    begin_for (( r = 0; r < row_count; r++ )); doo
      o=
      row=( ${data[$r]} )
      if function_exists each_field; then
        begin_for (( c = 0; c < selected_count; c++ )); doo
          i=${selected_field_indices[$c]}
          field=${data_fields[$i]}
          value=${row[$i]}
          each_field || fail
        end_for
      fi
      execute_if_exists after_row || fail
    end_for

  end_function
  local log_return_vars=formatted_data
  handle_return
}

display_data_raw() {
  begin_function

    each_field() {
      o+="$value "
    }

    local formatted_data=
    get_formatted_data || fail
    out -n "$formatted_data"

  end_function
  handle_return
}

display_data_simple() {
  begin_function

    local formatted_data= o c r v row

    each_field() {
      apad o "$field" "$value "
    }

    get_formatted_data || fail
    formatted_data=
    # done twice, first time it calculates the boundaries
    get_formatted_data || fail
    out -n "$formatted_data"

  end_function
  handle_return
}

display_data_table() {
  begin_function

    local formatted_data o c r v row

    each_field() {
      apad o "$field" "| $value "
    }

    formatted_data=
    get_formatted_data || fail

    after_row() {
      o+="|"
      formatted_data+="$o$NL"
      if [[ $row_type == header ]]; then
        formatted_data+="$bar$NL"
      fi
    }

    local c i f bar="+" length pad
    begin_for (( c = 0; c < selected_count; c++ )); doo
      i=${selected_field_indices[$c]}
      f="${data_fields[$i]}"
      length=${apad_size[$f]}
      printf -v pad %$((length-1))s
      pad=${pad// /-}
      bar+="$pad+"
    end_for

    formatted_data="$bar$NL"
    # done twice, first time it calculates the boundaries
    get_formatted_data || fail
    formatted_data+="$bar$NL"

    out -n "$formatted_data"

  end_function
  handle_return
}

display_data_json() {
  begin_function

    local formatted_data o c r v row

    each_field() {
      if [[ $row_type == data ]]; then
        o+="\"$field\":\"$value\","
      fi
    }

    after_row() {
      if [[ $row_type == data ]]; then
        o=${o%,}
        o+="},{"
        formatted_data+="$o"
      fi
    }

    formatted_data="[{"
    get_formatted_data || fail
    formatted_data=${formatted_data%'},{'}
    formatted_data+="}]$NL"

    out -n "$formatted_data"

  end_function
  handle_return
}

display_data_kv() {
  begin_function

    local formatted_data o c r v row

    each_field() {
      if [[ $row_type == data ]]; then
        o+="$field=$value "
      fi
    }

    after_row() {
      if [[ $row_type == data ]]; then
        formatted_data+="${o% }$NL"
      fi
    }

    formatted_data=
    get_formatted_data || fail

    out -n "$formatted_data"

  end_function
  handle_return
}

get_selected_field_indices() {
  begin_function
    local field i found

    out_fields=" $out_fields "
    out_fields=${out_fields// all / ${data_fields[*]} }
    out_fields=${out_fields# }
    out_fields=${out_fields% }

    begin_for field in ${out_fields}; doo
      found=f
      begin_for (( i = 0; i < field_count; i++ )); doo
        if [[ "${data_fields[$i]}" == "$field" ]]; then
          found=t
          selected_field_indices+=( $i )
          break
        fi
      end_for
      if [[ $found == f ]]; then
        log_fatal "Field not found: $field. Must be one of: ${data_fields[*]}"
        fail1
      fi
    end_for
    selected_count=${#selected_field_indices[*]}
  end_function
  handle_return
}

get_single_column() {
  local index=$1
  begin_function

    local value r row

    single_column=
    begin_for (( r = 0; r < row_count; r++ )); doo
      row=( ${data[$r]} )
      value=${row[$index]}
      single_column+="$value$NL"
    end_for

  end_function
  local log_return_vars=single_column
  handle_return
}

handle_sorting() {
  begin_function
    local sort_flags=
    if [[ $out_sort == -* ]]; then
      out_sort=${out_sort#-}
      sort_flags='-r'
    fi

    local i sort_field_index=
    begin_for (( i = 0; i < field_count; i++ )); doo
      if [[ "${data_fields[$i]}" == "$out_sort" ]]; then
        sort_field_index=$i
        break
      fi
    end_for

    if [[ ! "$sort_field_index" ]]; then
      log_fatal "Invalid sort field: $out_sort"
      fail1
    fi

    local single_column
    get_single_column $sort_field_index || fail
    local result=$(echo -n "$single_column" | sort $sort_flags) || fail
    local from_data=( "${data[@]}" ) 

    data=( )
    OIFS=$IFS
    IFS="$NL"
    local r v sort_field_value row
    begin_for v in ${result}; doo
      IFS=$OIFS
      local from_data_size=${#from_data[@]}
      begin_for r in ${!from_data[*]}; doo
        row=( ${from_data[$r]} )
        sort_field_value=${row[$sort_field_index]}
        if [[ "$sort_field_value" == "$v" ]]; then
          data+=( "${from_data[$r]}" )
          unset from_data[$r]
          break
        fi
      end_for
    end_for
    IFS=$OIFS
  end_function
  handle_return
}

get_command_output() {
  begin_function
    if [[ "$get_show_file" && -f "$out_path/$get_show_file" ]]; then
      cat $out_path/$get_show_file || fail
    else
      if is_array data; then

        local selected_field_indices=() \
          field_count=${#data_fields[*]} \
          selected_count \
          row_count=${#data[*]} \

        get_selected_field_indices || fail
        if [[ "$out_sort" ]]; then
          handle_sorting || fail
        fi

        unset each_field

        after_row() {
          formatted_data+="$o$NL"
        }

        case $out_form in 
          r|raw)
            display_data_raw || fail
          ;;
          s|simple)
            display_data_simple || fail
          ;;
          t|table)
            display_data_table || fail
          ;;
          j|json)
            display_data_json || fail
          ;;
          k|kv)
            display_data_kv || fail
          ;;
          *)
            log_fatal "Unknown form: $out_form. Choose from one of: raw simple"
            fail1
          ;;
        esac
      elif [[ -v data ]]; then
        out "$data"
      else
        out "No data"
      fi
    fi
  end_function
  handle_return
}

get_command_load_data() {
  begin_function

    local prefix_dim=${prefix_dim:-} \
      prefix_member=${prefix_member:-}

    if [[ "${member:-}" ]]; then
      prefix_dim+="$dim "
      local q=$member
      quotes=single shell_quote_var q || fail
      prefix_member+="$q "
      local sane_value
      get_sane_value "$member" || fail
      cell_path=$parent_cell/$dim:$sane_value
      switch_context || fail
    fi

    if [[ $cell_is_leaf == t ]]; then

      if [[ -f $out_path/auto/data.tab ]]; then
        local make_or_load=load data data_fields 
        make_or_load_dna_tab $out_path/auto/data.tab data || fail
        if (( ${#agg_data_fields[*]} == 0 )); then
          agg_data_fields=( $prefix_dim "${data_fields[@]}" )
        fi
        agg_data+=( $prefix_member "${data[@]}" )
      fi

    else
      par=f fork=f \
      function=get_command_load_data \
      parent_cell=$cell_path \
      for_each_member $leaf_dims || fail
      switch_context || fail
    fi

  end_function
  handle_return
}

get_command() {
  begin_function

    local out_form=${out_form:-${form:-simple}} \
      out_fields=${out_fields:-${fields:-${field:-all}}} \
      cell_path=${cell_path:-} \
      out_sort=${out_sort:-${sort:-}} \
      agg_data=() \
      agg_data_fields=() \

    get_command_load_data || fail
    data=( "${agg_data[@]}" )
    data_fields=( "${agg_data_fields[@]}" )

    if function_exists get_op; then
      execute_op get || fail
    else
      local get_show_file=${get_show_file:-}
      get_command_output
    fi

    command_successful=t

  end_function
  handle_return
}

