#!/usr/bin/env bash

get_formatted_data() {
  begin_function

    local i field value o c row row_type row_begin 

    o=
    row_type=header
    if function_exists each_field; then
      begin_for (( c = 0; c < selected_count; c++ )); doo
        i=${selected_field_indices[$c]}
        field=${table_fields[$i]}
        value=$field
        each_field || fail
      end_for
    fi

    execute_if_exists after_row || fail

    row_type=data
    local row_count=$row_count
    if [[ "$out_limit" ]]; then
      row_count=$out_limit
    fi

    begin_for (( row = 0; row < row_count; row++ )); doo
      o=
      (( row_begin = field_count * row ))
      local is_valid
      check_table_row || fail
      if [[ $is_valid == t ]]; then
        if function_exists each_field; then
          begin_for (( c = 0; c < selected_count; c++ )); doo
            i=${selected_field_indices[$c]}
            field=${table_fields[$i]}
            value=${table_data[$((i + row_begin))]}
            each_field || fail
          end_for
        fi
        execute_if_exists after_row || fail
      fi
    end_for

  end_function
  local log_return_vars=formatted_data
  handle_return
}

display_data_raw() {
  begin_function

    each_field() {
      if [[ $row_type == header ]]; then
        value=${value^^}
      fi
      o+="$value "
    }

    local formatted_data=
    get_formatted_data || fail
    out_no_nl "$formatted_data"

  end_function
  handle_return
}

display_data_simple() {
  begin_function

    local formatted_data= o c r v row

    each_field() {
      if [[ $row_type == header ]]; then
        value=${value^^}
      fi
      apad o "$field" "$value "
    }

    get_formatted_data || fail
    formatted_data=
    # done twice, first time it calculates the boundaries
    get_formatted_data || fail
    out_no_nl "$formatted_data"

  end_function
  handle_return
}

display_data_long() {
  begin_function

    local formatted_data o c r v row

    each_field() {
      if [[ $row_type != header ]]; then
        formatted_data+="  $WHITE$field:$RESET $value$NL"
      fi
    }

    after_row() {
      if [[ $row_type != header ]]; then
        formatted_data+="$NL"
      fi
    }

    formatted_data=
    get_formatted_data || fail
    out_no_nl "$formatted_data"

  end_function
  handle_return
}

display_data_table() {
  begin_function

    local formatted_data o c r v row

    each_field() {
      if [[ $row_type == header ]]; then
        value=${value^^}
      fi
      apad o "$field" "| $value "
    }

    formatted_data=
    get_formatted_data || fail

    after_row() {
      o+="|"
      formatted_data+="$o$NL"
      if [[ $row_type == header ]]; then
        formatted_data+="$bar$NL"
      fi
    }

    local c i f bar="+" length pad
    begin_for (( c = 0; c < selected_count; c++ )); doo
      i=${selected_field_indices[$c]}
      f="${table_fields[$i]}"
      length=${apad_size[$f]}
      printf -v pad %$((length-1))s
      pad=${pad// /-}
      bar+="$pad+"
    end_for

    formatted_data="$bar$NL"
    # done twice, first time it calculates the boundaries
    get_formatted_data || fail
    formatted_data+="$bar$NL"

    out_no_nl "$formatted_data"

  end_function
  handle_return
}

display_data_json() {
  begin_function

    local formatted_data o c r v row

    each_field() {
      if [[ $row_type == data ]]; then
        o+="\"$field\":\"$value\","
      fi
    }

    after_row() {
      if [[ $row_type == data ]]; then
        o=${o%,}
        o+="},{"
        formatted_data+="$o"
      fi
    }

    formatted_data="[{"
    get_formatted_data || fail
    formatted_data=${formatted_data%'},{'}
    formatted_data+="}]$NL"

    out_no_nl "$formatted_data"

  end_function
  handle_return
}

display_data_kv() {
  begin_function

    local formatted_data o c r v row

    each_field() {
      if [[ $row_type == data ]]; then
        quotes=double shell_quote_var value
        o+="$field=$value "
      fi
    }

    after_row() {
      if [[ $row_type == data ]]; then
        formatted_data+="${o% }$NL"
      fi
    }

    formatted_data=
    get_formatted_data || fail

    out_no_nl "$formatted_data"

  end_function
  handle_return
}

get_selected_field_indices() {
  begin_function
    local field i found

    out_fields=" $out_fields "
    out_fields=${out_fields// all / ${table_fields[*]} }
    out_fields=${out_fields# }
    out_fields=${out_fields% }

    begin_for field in ${out_fields}; doo
      found=f
      begin_for (( i = 0; i < field_count; i++ )); doo
        if [[ "${table_fields[$i]}" == "$field" ]]; then
          found=t
          selected_field_indices+=( $i )
          break
        fi
      end_for
      if [[ $found == f ]]; then
        log_fatal "Field not found: $field. Must be one of: ${table_fields[*]}"
        fail1
      fi
    end_for
    selected_count=${#selected_field_indices[*]}
  end_function
  handle_return
}

# inputs:
#   $1           field index
#   field_count
# output:
#   single_column
get_single_column() {
  local field_index=$1
  begin_function

    local value row t

    single_column=
    begin_for (( row = 0; row < row_count; row++ )); doo
      (( t = row * field_count + field_index ))
      value=${table_data[$t]}
      single_column+="$value$NL"
    end_for

  end_function
  local log_return_vars=single_column
  handle_return
}

# inputs:
#   row_count
#   field_count
#   out_sort
#   table_data
# outputs:
#   table_data
handle_sorting() {
  begin_function
    local sort_flags=
    if [[ $out_sort == -* ]]; then
      out_sort=${out_sort#-}
      sort_flags='-r'
    fi

    local i sort_field_index=
    begin_for (( i = 0; i < field_count; i++ )); doo
      if [[ "${table_fields[$i]}" == "$out_sort" ]]; then
        sort_field_index=$i
        break
      fi
    end_for

    if [[ ! "$sort_field_index" ]]; then
      log_fatal "Invalid sort field: $out_sort"
      fail1
    fi

    local single_column result
    get_single_column $sort_field_index || fail
    result=$(echo -n "$single_column" | sort -u $sort_flags) || fail
    local from_data=( "${table_data[@]}" ) 

    table_data=( )
    OIFS=$IFS
    IFS="$NL"
    local v sort_field_value row t beginning_of_row
    begin_for v in ${result}; doo
      IFS=$OIFS
      local from_data_size=${#from_data[*]}
      begin_for (( row = 0; row < row_count; row++ )); doo
        (( beginning_of_row = row * field_count ))
        (( t = beginning_of_row + sort_field_index ))
        sort_field_value=${from_data[$t]}
        if [[ "$sort_field_value" == "$v" ]]; then
          table_data+=( "${from_data[@]:beginning_of_row:field_count}" )
        fi
      end_for
    end_for
    IFS=$OIFS
  end_function
  handle_return
}

get_command_output() {
  begin_function
    if [[ "$get_show_file" && -f "$out_path/$get_show_file" ]]; then
      if [[ "$out_limit" ]]; then
        cat $out_path/$get_show_file | head -n $out_limit || fail
      else
        cat $out_path/$get_show_file || fail
      fi
    else
      if is_array table_data; then

        local selected_field_indices=() \
          field_count=${#table_fields[*]} \
          selected_count \
          row_count=${#table_data[*]} \

        if (( field_count == 0 )); then
          log_fatal "field_count can't be 0."
          fail1
        fi

        (( row_count /= field_count ))
        get_selected_field_indices || fail
        if [[ "$out_sort" ]]; then
          handle_sorting || fail
        fi

        unset each_field

        after_row() {
          formatted_data+="$o$NL"
        }

        case $out_form in 
          r|raw)
            display_data_raw || fail
          ;;
          s|simple)
            display_data_simple || fail
          ;;
          t|table)
            display_data_table || fail
          ;;
          j|json)
            display_data_json || fail
          ;;
          k|kv)
            display_data_kv || fail
          ;;
          l|long)
            display_data_long || fail
          ;;
          *)
            log_fatal "Unknown form: $out_form. Choose from one of: raw simple table json kv"
            fail1
          ;;
        esac
      elif [[ -v table_data ]]; then
        out "$table_data"
      else
        out "No data"
      fi
    fi
  end_function
  handle_return
}

get_command_load_data_member() {
  local log_show_vars='dim member'
  begin_function_hi

    local child_dims=${child_dims:-}

    remove_word_from_string out_fields $dim

    local sane_value
    get_sane_value "$member" || fail
    local cell_path=$parent_cell/$dim:$sane_value
    if [[ ! -d "$cell_path" ]]; then
      succeed
    fi

    load_branch_info || fail
    switch_context $cell_path || fail

    get_command_load_data || fail

  end_function
  handle_return
}

get_command_load_data_branch() {
  begin_function
    par=f fork=f \
    function=get_command_load_data_member \
    parent_cell=$cell_path \
    anchor_dims= \
    get_members_from=existing_branches \
    for_each_member $child_dims || fail

    if [[ $used_default_fields == t ]]; then
      out_fields="$child_dims $out_fields"
    fi

    # Is this really needed?
    cell_path=$original_cell_path
  end_function
  handle_return
}

get_command_load_data_leaf() {
  begin_function

    if [[ -f $out_path/output.tab ]]; then

      local context_type= output_table output_fields
      load_dna_item $out_path/output.tab || fail

      local extra_fields=${trunk_dims[*]}

      if (( ${#table_fields[*]} == 0 )); then
        table_fields=( ${extra_fields[*]} ${output_fields[*]} )
      else
        local d i=0
        begin_for d in ${extra_fields[*]} ${output_fields[@]}; doo
          if [[ -v table_fields[$i] && "${table_fields[$i]}" != "$d" ]]; then
            log_fatal "Different data columns across cells not supported yet"
            fail1
          fi
          (( i++ ))
        end_for
      fi

      coord_type=branch dim_type=ddim convert_coords_to_dims || fail
      local row dim \
        field_count=${#output_fields[*]} data_count=${#output_data[*]}
      local row_count=$((data_count/field_count)) start
      for (( row = 0; row < row_count; row++ )); do
        for dim in ${trunk_dims[*]}; do
          local -n trunk_member=d_$dim
          if [[ -v trunk_member ]]; then
            table_data+=( "${trunk_member}" )
          else
            table_data+=( "(unset)" )
          fi
        done
        (( start = row * field_count ))
        table_data+=( "${output_data[@]:$start:$field_count}" )
      done

    fi

    if [[ $execute_inner != n && "${inner:-}" ]]; then
      local i_path inners
      inners=$(find1 $inner_path -type d -not -name '.*') || fail
      begin_for i_path in $inners; doo
        parent_cell=$cell_path cell_path=$i_path get_command_load_data || fail
      end_for
    fi

  end_function
  handle_return
}

get_command_load_data() {
  begin_function

    local \
      original_anchor_dims=$anchor_dims \
      original_cell_path=$cell_path \
      extra_fields=${extra_fields:-} \

    if [[ "${localize_dims:-}" ]]; then
      eval "local $localize_dims" || fail
      eval "local $localize_reverse_dims" || fail
    fi

    if [[ $cell_is_leaf == t ]]; then
      get_command_load_data_leaf || fail
    else
      get_command_load_data_branch || fail
    fi

  end_function
  handle_return
}

fields_get_choices() {
  local output_table output_fields
  load_dna_item $out_path/output.tab || fail
  choices=( ${output_fields[*]} )
}

get_command_handle_questions() {
  begin_function
    local -n parameter_names=parameter_names_command \
      parameter_defaults=parameter_defaults_command \

    local pq
    begin_for pq in $parameter_questions; doo
      case $pq in
        out_fields|fields|field)
          out_fields_choices=${table_fields[*]}

          local i
          begin_for i in ${!parameter_names[*]}; doo
            if [[ out_fields == "${parameter_names[$i]}" ]]; then
              parameter_defaults[$i]=$out_fields
            fi
          end_for

          show_parameter_help_single out_fields || fail
        ;;
        *)
          show_parameter_help_single $pq || fail
        ;;
      esac
    end_for
  end_function
  handle_return
}

default_out_fields=
get_command() {
  begin_function

    local cell_path=${cell_path:-}

    load_branch_info || fail
    switch_context $cell_path || {
      log_fatal "Context failed to load for $short_cell"
      fail1
    }
    setup_dims || fail

    # might need this to access trunk dims outside of anchors?
    #calc_coords || fail

    local out_form=${out_form:-${form:-${default_out_form:-simple}}} \
      out_fields=${out_fields:-${fields:-${field:-}}} \
      out_sort=${out_sort:-${sort:-${default_sort:-}}} \
      out_limit=${out_limit:-${limit:-}} \
      table_data=() \
      table_fields=() \
      used_default_fields=f \

    if [[ ! "$out_fields" || $out_fields == \? ]]; then
      out_fields=${default_out_fields:-all} \
      used_default_fields=t
    fi

    if function_exists get_op; then
      execute_op get || fail
    else

      get_command_load_data || fail

      if [[ "${parameter_questions:-}" ]]; then
        get_command_handle_questions || fail
        command_successful=t
        succeed
      fi

      local get_show_file=${get_show_file:-}
      get_command_output

    fi

    command_successful=t

  end_function
  handle_return
}

