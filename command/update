#!/usr/bin/env bash

get_upstream_needs_update() {

  local log_show_vars=short_cell log_vars=cell_path
  begin_function_hi
    if [[ "${up_path:-}" && -d "$up_path" ]] \
       && (( check_upstream_depth > 0 )); then
      #log_debug "Checking upstream of $short_cell"
      local -r upstream_cells=( 
        $(find1 $up_path -not -name '.*' | sort -g) 
        ) || fail
      local upstream up_part
      begin_for upstream in ${upstream_cells[*]}; doo

        up_part=${upstream##*/}
        log_debug "Checking $up_part"
        if [[ ! -e $upstream/chosen ]]; then
          log_debug "Cyto up is missing, needs update"
          needs_update=t
          break
        fi

        # recursive
        check_upstream_depth=$((check_upstream_depth-1)) get_needs_update $upstream/chosen || fail

        if [[ $needs_update == t ]]; then
          break
        fi

      end_for
    fi

    # restore context
    switch_context || fail

  end_function
  handle_return

}

get_leaf_needs_update() {
  needs_update=
  if [[ ! "${leaf_path:-}" ]]; then
    log_fatal "leaf_path is missing"
    return 1
  fi
  local leaf_cell_path=$cell_path$leaf_path

  if [[ -d $leaf_cell_path ]]; then
    # recursive
    get_needs_update $leaf_cell_path || return 1
  else
    needs_update=t
  fi

  if [[ $needs_update == t ]]; then
    leave_loop=1
  fi
  return 0
}

# returns needs_update
get_needs_update() {
  if [[ ! -e $1 ]]; then
    log_fatal "Cell doesn't exist: $1"
    stack_trace
    return 1
  fi

  local cell_path=$(realpath $1)

  local log_show_vars=^cell_path
  begin_function_hi

    local localize_dims=${localize_dims:-}
    if [[ "${localize_dims:-local}" != local ]]; then
      eval "$localize_dims" || fail
    fi

    switch_context || fail

    local status_path=$cell_path/.cyto/status \
      up_path=$cell_path/.cyto/up \
      log_message="No update needed" \
      check_upstream_depth=${check_upstream_depth:-1}

    if [[ "$needs_update" ]]; then
      # needs_update is already known, don't need to compute it again
      log_message="needs_update is already set."
      succeed
    fi

    if [[ ! -e $cell_path/.dna ]]; then
      log_fatal "Attempted to run get_needs_update on folder that is not a cell: $cell_path"
      fail1
    fi

    if [[ "$out_file" && ! -e "$out_path/$out_file" ]]; then
      needs_update=t
      log_message="Needs update because output file doesn't exist"
    elif (( refresh_less_than > update_cost ))
    then
      needs_update=t
      log_message="Needs update because update_cost ($update_cost) < refresh_less_than ($refresh_less_than)"
    elif [[ ! -e $status_path/last-good-update-end ]]
    then
      needs_update=t
      log_message="Needs update because cell has never been updated successfully"
    elif [[ ! -e $status_path/up-to-date ]]
    then
      needs_update=t
      log_message="Needs update because something changed"
 #    elif get_prop_changed $cell_path || fail
 #         [[ $prop_changed == t ]]
 #    then
 #      needs_update=t
 #      log_message="Needs update because properties have changed"
    elif get_is_stale $status_path || fail
         [[ $is_stale == t ]]
    then
      needs_update=t
      log_message="Needs update because cell is stale"
#    elif [[ -v leaf_dims ]] \
#         && { 
#           function=get_leaf_needs_update \
#             for_each_leaf_flat ${leaf_dims[*]} || fail 
#         } \
#         && { 
#           switch_context || fail
#         } \
#         && [[ $needs_update == t ]]
#    then
#      log_message="Needs update because at least one leaf cell is out of date"
#    elif [[ -v up_path ]] \
#         && { get_upstream_needs_update || fail; } \
#         && [[ $needs_update == t ]]
#    then
#      log_message="Needs update because at least one upstream cell is out of date"
    elif [[ -v leaf_dims ]]
    then
      needs_update=t
      log_message="Needs update because cell has leaves"
    elif [[ "${downstream_ref_path:-}" ]] && \
      [[ "$(readlink ${downstream_ref_path}/chosen)" != $cell_path ]]
    then
      needs_update=t
      log_message="Needs update because downstream_ref_path is outdated"
    elif local data_valid=t
      ignore_missing=t execute_op check || fail
      [[ $data_valid == f ]]
    then
      needs_update=t
      log_message="Needs update because current value does not match intended value"
    fi

  end_function

  if succeeded; then
    local level=log_verbose
    if [[ ${cell_is_leaf:-t} == t || $show_branches == t || $top_level_command == t ]]; then
      level=log_info
    fi
    action=update_check $level "$log_message ($short_cell)"
  else
    action=update_check log_fatal "Failed to check update need"
  fi

  if [[ ! "$needs_update" ]]; then
    needs_update=f
  fi

  handle_return
}

pre_update() {
  begin_function_hi

    update_successful= \
    something_changed=f \
    member_count=0 \
    cell_locks= \

    write_lock=t \
      timeout=$lock_timeout \
      cell_lock $cell_path || fail

    defer "cell_unlock $cell_path"

    if [[ -v current_job_path ]]; then
      safe_link $current_job_path $running_job_path || fail
      defer "rm $running_job_path"
    fi

    touch $status_path/last-update-start || fail
    # this needs to be at the beginning of the update so other processes
    #   could potentially invalidate it, requiring another update
    touch $status_path/up-to-date || fail

    if [[ $reuse_existing_out == t && -f $status_path/last-good-update-end ]]; then
      # Don't allow cells to reuse old data when it is mid-modification and this update fails
      rm $status_path/last-good-update-end || fail
    fi

  end_function
  handle_return
}

create_downstream_links() {
  begin_function_hi

    if [[ "${downstream_ref_path:-}" ]]; then
      local cell_path down_cell_path down_cell_name

      get_bottom_cell ${downstream_ref_path%/*} || fail
      down_cell_path=$bottom_cell

      get_cell_name $down_cell_path || fail
      down_cell_name=${cell_name%% *}

      local down_link=$down_path/$down_cell_name
      if [[ ! -e $down_link ]]; then
        if [[ ! -d $down_path ]]; then
          mkdir $down_path || fail
        fi
        safe_link $down_cell_path $down_link || fail
      else
        local link_target=$(readlink $down_link) || fail
        if [[ $link_target != $down_cell_path ]]; then
          log_fatal "Link conflict: A link already exists but doesn't point to the same place."
          log_fatal "  $link_target is expected to point to $down_cell_path"
        fi
      fi
    fi

  end_function
  handle_return
}

# inputs: 
#   upstream
prep_upstream() {
  local log_show_vars=^upstream
  begin_function_hi

    # down_fresh may be used by prep script to propagate freshness requirements to upstream
    down_fresh=$required_freshness

    # This may be overridden by upstream prep file to customize how failure of this upstream is handled
    handle_upstream_result() {
      if [[ $update_successful == f ]]; then
        log_error "Failed to update upstream cell $upstream"
      fi
    }

    # Don't inherit parent's freshness requirements, 
    #   only what upstream prep explicitly states
    # extra_dims includes dimensions that need to be promoted in upstream that don't
    #   exist in branch_dims
    fresh=$down_fresh required_freshness= default_freshness= extra_dims=

    if [[ -f $upstream/prep ]]; then
      log_debug "Executing upstream prep: $upstream/prep"
      source $upstream/prep || fail
      setup_dep_defaults || fail
    fi

  end_function
  handle_return
}

# needs_update is guaranteed to be set after this completes successfully
update_upstream_choose() {

  local log_show_vars=^upstream
  begin_function_hi

    local choices=$(find1 $upstream/choices -not -name ".*" | sort -g) || fail

    if [[ ! "$choices" ]]; then
      log_fatal "No choices defined for upstream $upstream"
      fail1
    fi

    # are any already updated?
    local choice
    if [[ ! "$needs_update" ]]; then
      begin_for choice in $choices; doo

        get_needs_update $choice || fail
        if [[ "$needs_update" == f ]]; then
          chosen=$choice
          break
        fi

      end_for
    fi

    if [[ ! "$chosen" ]]; then
      chosen=${choices%% *}
      needs_update=t
    fi

  end_function
  local log_return_vars=chosen
  handle_return

}

update_upstream_get_locks() {
  local log_show_vars=^upstream
  begin_function_hi

    local lock 
    local -r shared_lock_path=$upstream/chosen/.cyto/shared-locks
    if [[ -d $shared_lock_path ]]; then
      local shared_locks=$(find1 $shared_lock_path -not -name ".*" | sort -g) || fail
      begin_for lock in $shared_locks; doo
        write_lock=f \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for
    fi

    local -r exclusive_lock_path=$upstream/chosen/.cyto/exclusive-locks
    if [[ -d $exclusive_lock_path ]]; then
      local exclusive_locks=$(find1 $exclusive_lock_path -not -name ".*" | sort -g) || fail
      begin_for lock in $exclusive_locks; doo
        write_lock=t \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for
    fi

    # obtain lock from upstream cell
    write_lock=f \
      timeout=$lock_timeout \
      cell_lock $upstream/chosen || fail

  end_function
  handle_return
}

# inputs: 
#   upstream: a folder in .dna/up
update_upstream() {

  local required_freshness=$required_freshness fresh=$fresh \
    default_freshness=$default_freshness 

  if [[ -e $upstream/.dna ]]; then
    log_fatal "update_upstream upstream field should be a path to a upstream spec, not a cell"
    fail1
  fi

  local log_show_vars=^upstream 
  begin_function_hi

    local needs_update=

    prep_upstream || fail

    local chosen=
    update_upstream_choose || fail

    if [[ ! "$chosen" ]]; then
      log_fatal "chosen was not set."
      fail1
    fi

    if [[ ! -e $upstream/chosen ]]; then
      needs_update=t
    fi

    if [[ $needs_update == t ]]; then

      needs_update= \
      top_level_command=f \
      downstream_ref_path=$upstream \
      execute_command "$(realpath $chosen)" update || fail

      if [[ $something_changed == t ]]; then
        previous_upstream_changed=t
      fi

      handle_upstream_result || fail

      if [[ $update_successful == f ]]; then
        break
      fi

    fi
    
    update_upstream_get_locks || fail

  end_function
  handle_return
}

update_upstreams() {
  begin_function

    update_successful=t
    touch $status_path/deps-up-to-date || fail

    if [[ -d "${up_path:-}" ]]; then

      local previous_upstream_changed=f upstream upstreams

      upstreams=$(find1 $up_path -not -name '.*' | sort -g) || fail
      begin_for upstream in $upstreams; doo
        update_upstream || fail
        if [[ $update_successful == f ]]; then
          break
        fi
      end_for
      switch_context || fail

    fi

  end_function

  if failed || [[ $update_successful == f ]]; then
    rm $status_path/deps-up-to-date 
    update_successful=f
  fi

  handle_return
}

link_dim_parts() {
  local from_path=$from_path to_path=$to_path
  begin_function
    local contents=$(find1 $from_path -not -name '.*') || fail
    begin_for part in $contents; doo
      if [[ "$part" == */up \
         || "$part" == */down \
         || "$part" == */out \
         ]]; then
        continue
      elif [[ "$part" == */var \
           || "$part" == */fun \
           ]]; then
        contents=$(find1 $part -not -name '.*') || fail
        local folder=${part##*/} part2
        begin_for part2 in $contents; doo
          if [[ ! -d $to_path/$folder ]]; then
            mkdir $to_path/$folder || fail
          fi
          safe_link $(realpath $part2) $to_path/$folder/ || fail
        end_for
      else
        safe_link $(realpath $part) $to_path/ || fail
      fi
    end_for 
  end_function
  handle_return
}

create_sub_cell() {
  local sub_cell=$sub_cell \
    parent_cell=$parent_cell \
    parent_seed=$parent_seed

  local log_show_vars='^sub_cell'
  begin_function

    local short_cell
    get_short_cell $sub_cell 
    log_debug "Creating sub cell $short_cell"

    if [[ "$sub_cell" == */.dna* ]]; then
      log_fatal "Internal error: Invalid sub_cell $sub_cell."
      log_fatal "We should not be creating a sub cell inside of a dna folder"
      fail1
    fi

    if [[ -e $sub_cell ]]; then
      log_fatal "sub_cell already exists: $sub_cell"
      fail1
    fi

    if [[ "$parent_cell" == "$sub_cell" ]]; then
      log_fatal "Can't create sub cells in a cell without parents: $sub_cell"
      stack_trace
      fail1
    fi

    parent_path=$parent_cell \
    seed_path=$parent_seed \
    member=$member \
    plant_member || fail

  end_function
  handle_return
}

update_member() {
  local sane_value member_path \
    log_vars=member log_show_vars=member \
    downstream_ref_path=${downstream_ref_path:-}

  begin_function

    get_sane_value "$member" || fail
    member_path=$cell_path/$dim:$sane_value

    local needs_update=
    if [[ ! -d $member_path ]]; then
      parent_cell=$cell_path \
      parent_seed=$seed_path \
      sub_cell=$member_path \
      create_sub_cell || fail
      needs_update=t
    else
      get_needs_update $member_path || fail
    fi

    if [[ $needs_update == t ]]; then

      if (( member_count > 1 )); then
        log_debug "More than one member found ($member_count), not passing downstream_ref_path."
        downstream_ref_path=
      elif [[ "$downstream_ref_path" ]]; then
        log_debug "Only one member found, passing downstream_ref_path: $downstream_ref_path"
      fi

      top_level_command=f \
      execute_command $member_path update || fail

      if [[ $update_successful == f ]]; then
        log_error "Failed to update member cell $member"
        reply_to_caller "update_successful=f" || fail
      else 
        update_successful=
      fi
    fi

    if (( member_count == 1 )); then
      downstream_ref_path=
    fi

  end_function
  handle_return
}

update_members() {
  begin_function_hi
    update_successful=
    par=t fork=f function=update_member for_each_member "${leaf_dims[0]}" || fail
    switch_context || fail
    if [[ ${update_successful:=t} == f ]]; then
      log_fatal "Failed to update some member(s)"
      fail1
    fi
  end_function
  handle_return
}

compare_files_or_dirs() {
  local left=$1 right=$2
  begin_function
    if [[ -d $left ]]; then
      if [[ -d $right ]]; then
        local sub_full sub already_checked files

        files=$(find1 $left -not -name '.*') || fail
        begin_for sub_full in $files; doo
          sub=${sub_full##*/}
          compare_files_or_dirs $left/$sub $right/$sub || fail
          if [[ $changed == t ]]; then
            succeed
          fi
          already_checked+=" $sub"
        end_for
        already_checked+=' '

        files=$(find1 $right -not -name '.*') || fail
        begin_for sub_full in $files; doo
          sub=${sub_full##*/}
          if [[ "$already_checked" =~ \ $sub\  ]]; then
            continue
          fi
          compare_files_or_dirs $right/$sub $left/$sub || fail
          if [[ $changed == t ]]; then
            succeed
          fi
        end_for

      else
        changed=t
      fi
    elif [[ -f $left ]]; then
      if [[ -f $right ]]; then
        if files_are_different $left $right &>/dev/null; then
          changed=t
        else
          changed=f
        fi
      else
        changed=t
      fi
    else
      changed=f
    fi
  end_function
  handle_return
}

update_self_move_out_path() {
  begin_function

    if [[ -e $out_path.old ]]; then
      rm -rf $out_path.old || fail
    fi

    local f
    begin_for f in .dna .cyto .dim; doo
      if [[ -e $out_path/$f ]]; then
        if [[ ! -e $out_path.new/$f ]]; then
          mv $out_path/$f $out_path.new/$f || fail
        else
          log_fatal "Target $f folder already exists, when it shouldn't"
          fail1
        fi
      fi
    end_for

    if [[ -d $out_path ]]; then
      mv $out_path $out_path.old || fail
    fi

    mv $out_path.new $out_path || fail
    something_changed=t

    if [[ -e $out_path.old ]]; then
      rm -rf $out_path.old || fail
    fi

  end_function
  handle_return
}

update_self() {
  local log_vars='short_cell'
  begin_function

    log_debug "Executing local update of $short_cell$attempt_string" 

    update_successful=
    can_retry=f

    local reuse_existing_out=${reuse_existing_out:-t}

    local out_path=$cell_path
    if [[ $reuse_existing_out == f ]]; then
      out_path=$cell_path.new
      if [[ -d $out_path ]]; then
        rm -rf $out_path || fail
      fi
      if [[ ! -d $out_path ]] && ! mkdir $out_path 2>/dev/null; then
        log_debug "Could not make dir $out_path, falling back to $cell_path"
        out_path=$cell_path
      fi
    else
      # allow update code to set this, since we can't compare when changes are made in place
      something_changed=
    fi

    local missing=t
    tee_output_to_log || fail
    ignore_missing=t execute_op update || fail
    completion_time=$EPOCHSECONDS
    untee_output || fail

    if [[ $missing == t ]]; then
      update_successful=t
    else
      update_successful=${update_successful:-f}
    fi

    if [[ $reuse_existing_out == f && -d $cell_path.new ]]; then
      out_path=$cell_path
      if [[ $update_successful == t ]]; then
        local changed
        compare_files_or_dirs $out_path $out_path.new || fail
        if [[ $changed == f ]]; then
          rm -rf $out_path.new || fail
        else
          update_self_move_out_path || fail
        fi
      fi
    else # $reuse_existing_out == t
      # if update code didn't set this, we must assume the worst
      if [[ ! "$something_changed" ]]; then
        something_changed=t
      fi
    fi

  end_function
  untee_output  # in case update failed and block was exited early
  handle_return
}

update_self_retry_loop() {
  begin_function_hi

    ref_group=none \
    delay=$retry_delay \
    can_update=t \

    if [[ "$update_successful" ]]; then
      can_update=f
    fi

    if [[ $can_update == t ]]; then
      for ((retry=0; retry < retry_max; retry++)); do

        if [[ $retry -gt 0 ]]; then
          log_info "Waiting $delay seconds before trying again" 
          sleep $delay
          let 'delay *= retry_scale' || true
        fi

        local attempt_string=
        if (( retry_max > 1 )); then
          attempt_string=", attempt $((retry+1)) of $retry_max"
        fi
          
        update_self || fail

        [[ $can_retry == f || $update_successful == t ]] && break

      done
    fi

    update_successful=${update_successful:-t}

  end_function
  handle_return
}

check_results() {
  begin_function_hi

    if [[ $can_update == t ]]; then
      if [[ $update_successful == t && $post_validate == t ]]; then
        log_debug "Post validating"
        local data_valid=f
        can_retry=f
        execute_op check || return 1
        if [[ $data_valid == f ]]; then
          log_warn "Data is not valid"
          update_successful=f
        else
          log_debug "Data is valid"
        fi
      fi
    else
      update_successful=t
    fi

  end_function
  handle_return
}

post_update() {
  local result_string
  begin_function_hi

    completion_time=${completion_time:-$EPOCHSECONDS}
    if [[ $update_successful == t ]]; then
      result_string="successful"
    else
      result_string="failed"
      update_successful=f
    fi

    if [[ $pretend == f ]]; then

      if [[ $update_successful == t ]]; then
        touch -d @$completion_time $status_path/last-good-update-end || fail
        cp -a $status_path/last-update-start \
              $status_path/last-good-update-start || fail
        if [[ -v current_job_path ]]; then
          force=t safe_link $current_job_path $job_path/last-success || fail
        fi
        if [[ "${props:-}" ]]; then
          update_prop_hash || fail
        fi
        if [[ $something_changed == t ]]; then
          from_cell=$cell_path \
            propagate_change_to_downstream || fail
        fi
      else
        touch -d @$completion_time $status_path/last-bad-update-end || fail
        force=t safe_link $current_job_path $job_path/last-failure || fail
        cp -a $status_path/last-update-start \
              $status_path/last-bad-update-start || fail
      fi

      if [[ $cell_is_leaf == t || $show_branches == t ]]; then
        log_info "Update $result_string. ($short_cell)"
      else
        log_debug "Update $result_string. ($short_cell)"
      fi

    else
      log_info "Pretend update $result_string."
    fi

    if [[ "${reply_file:-}" ]]; then
      echo "update_successful=${update_successful:-}" >>$reply_file || fail
    fi

    cell_unlock $cell_path || fail

    if [[ -v running_job_path ]]; then
      rm $running_job_path || fail
    fi

  end_function
  handle_return
}

is_leaf_cell() {
  local cell_path=$1
  [[ ! -d $cell_path/.dna/dim ]]
}

get_dep_member() {

  if [[ -f $dep_cell/.dna/context-before ]]; then
    source $dep_cell/.dna/context-before || return 1
  else
    log_fatal "Missing context-before in $dep_cell/.dna."
    log_fatal "Should have been generated by update of it's trunk."
    log_fatal "Maybe try to run a clean on it and update again."
    return 1
  fi

  if [[ ! -v $dep_dim ]]; then
    log_fatal "Missing member for $dep_dim."
    log_fatal "This should have been defined in $dep_cell/.dna/context-before"
    return 1
  fi

  dep_member=${!dep_dim}
  return 0
}

update_command() {
  begin_function

    local leave_loop=0 \
      something_changed=f \
      needs_update=${needs_update:-}

    create_downstream_links || fail
    if [[ "${downstream_ref_path:-}" ]]; then
      log_debug "Linking upstream cell to it's downstream cell cyto up folder"
      force=t safe_link $cell_path $downstream_ref_path/chosen || fail
    fi

    if [[ ! "$needs_update" ]]; then
      get_needs_update $cell_path || fail
    else
      log_debug "needs_update already known ($needs_update)"
    fi

    if [[ $needs_update == f ]]; then
      update_successful=t
      succeed
    fi

    pre_update || fail
    plant_seed_internal "$seed_path" "$cell_path" || fail

    if [[ "$update_successful" != f ]]; then
      update_upstreams || fail
    fi

    if [[ $update_successful == t ]]; then
      if [[ $cell_is_leaf == t ]]; then
        if function_exists update_op; then
          update_successful=
          update_self_retry_loop || fail
          check_results || fail
        fi
      else
        if [[ "${leaf_dims:-}" ]]; then
          update_members || fail
        else
          log_fatal "Internal error: cell is not a leaf, yet it doesn't have leaf dims?"
          fail1
        fi
      fi
    fi

    post_update || fail

  end_function

  if [[ "$update_successful" == t ]]; then
    command_successful=t
  fi

  handle_return
}

