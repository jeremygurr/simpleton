#!/usr/bin/env bash

break_if_not_changed() {
  begin_function_flat
    if [[ ! "${needs_update:-}" ]]; then
      get_needs_update $cell_path || fail
    fi
    if [[ $needs_update == f ]]; then
      leave_loop=1
    fi
  end_function
  handle_return
}

pre_update() {
  begin_function

    update_successful= \
    something_changed=f \
    member_count=0 \
    cell_locks= \

    write_lock=t \
      timeout=$lock_timeout \
      cell_lock $cell_path || fail

    if [[ -v current_job_path ]]; then
      safe_link $current_job_path $running_job_path || fail
      defer "rm $running_job_path"
    fi

    touch $status_path/last-update-start || fail
    # this needs to be at the beginning of the update so other processes
    #   could potentially invalidate it, requiring another update
    touch $status_path/up-to-date || fail

    if [[ $reuse_existing_out == t && -f $status_path/last-good-update-end ]]; then
      # Don't allow cells to reuse old data when it is mid-modification and this update fails
      rm $status_path/last-good-update-end || fail
    fi

  end_function
  handle_return
}

create_downstream_links() {
  begin_function

    if [[ "${downstream_ref_path:-}" ]]; then
      local cell_path down_cell_path down_cell_name

      get_cell_path ${downstream_ref_path%/*} || fail
      down_cell_path=$cell_path

      get_cell_name $down_cell_path || fail
      down_cell_name=${cell_name%% *}

      local down_link=$down_path/$down_cell_name
      if [[ ! -e $down_link ]]; then
        if [[ ! -d $down_path ]]; then
          mkdir $down_path || fail
        fi
        safe_link $down_cell_path $down_link || fail
      else
        local link_target=$(readlink $down_link) || fail
        if [[ $link_target != $down_cell_path ]]; then
          log_fatal "Link conflict: A link already exists but doesn't point to the same place."
          log_fatal "  $link_target is expected to point to $down_cell_path"
        fi
      fi
    fi

  end_function
  handle_return
}

# inputs: 
#   up_dna
prep_upstream() {
  # down_fresh may be used by prep script to propagate freshness requirements to upstream
  down_fresh=$required_freshness

  # Don't inherit parent's freshness requirements, 
  #   only what upstream prep explicitly states
  # extra_dims includes dimensions that need to be promoted in upstream that don't
  #   exist in branch_dims
  fresh=$down_fresh required_freshness= default_freshness= extra_dims=

  local log_show_vars=^up_dna
  begin_function
    unset prep
    if [[ -f $up_dna/prep ]]; then
      log_debug "Executing upstream prep: $up_dna/prep"
      source $up_dna/prep || fail
      if ! type -t prep &>/dev/null; then
        log_fatal "$up_dna/prep must have a function named prep"
        fail1
      fi
      prep || fail
      setup_dep_defaults || fail
    fi
  end_function
  handle_return
}

update_upstream_prep() {

  local log_show_vars="^up_cyto"
  begin_function

    if [[ ! -d $cyto_up_path ]]; then
      mkdir $cyto_up_path || fail
    fi

    # This may be overridden by upstream prep file to customize how failure of this upstream is handled
    handle_upstream_result() {
      if [[ $update_successful == f ]]; then
        log_error "Failed to update upstream cell $up_dna"
      fi
    }

    if [[ -d $up_cyto ]]; then

      if [[ $previous_upstream_changed == t ]]; then
        log_debug "Previous upstream changed, removing cyto upstream"
        rm -r "$up_cyto" || fail
      fi

    fi

    if [[ ! -d $up_cyto ]]; then

      log_debug "Cyto upstream is missing, will need to update"
      mkdir $up_cyto || fail
      needs_update=t

    fi

    prep_upstream || fail

  end_function
  handle_return

}

# needs_update is guaranteed to be set after this completes successfully
update_upstream_choose() {
  begin_function

    if [[ -d $up_dna/cell ]]; then
      chosen=$up_dna/cell
    elif [[ -d $up_dna/choices ]]; then
      local choices=$(find1 $up_dna/choices -not -name ".*" | sort -g) || fail

      if [[ ! "$choices" ]]; then
        log_fatal "No choices defined for upstream $up_dna"
        fail1
      fi

      # are any already updated?
      local choice
      if [[ ! "$needs_update" ]]; then
        begin_for choice in $choices; doo

          get_needs_update $choice || fail
          if [[ "$needs_update" == f ]]; then
            chosen=$choice
            break
          fi

        end_for
      fi

      if [[ ! "$chosen" ]]; then
        chosen=${choices%% *}
        needs_update=t
      fi
    else
      log_fatal "Missing either cell or choices folder for dependency: $up_dna"
      fail1
    fi

    local log_show_vars=chosen
  end_function
  handle_return
}

update_upstream_get_locks() {
  local log_show_vars=^up_cyto
  begin_function

    local lock 
    local -r shared_lock_path=$up_cyto/chosen/.cyto/shared-locks
    if [[ -d $shared_lock_path ]]; then
      local shared_locks=$(find1 $shared_lock_path -not -name ".*" | sort -g) || fail
      begin_for lock in $shared_locks; doo
        write_lock=f \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for
    fi

    local -r exclusive_lock_path=$up_cyto/chosen/.cyto/exclusive-locks
    if [[ -d $exclusive_lock_path ]]; then
      local exclusive_locks=$(find1 $exclusive_lock_path -not -name ".*" | sort -g) || fail
      begin_for lock in $exclusive_locks; doo
        write_lock=t \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for
    fi

    # obtain lock from upstream cell
    write_lock=f \
      timeout=$lock_timeout \
      cell_lock $up_cyto/chosen || fail

  end_function
  handle_return
}

# inputs: 
#   upstream: a folder in .dna/up
update_upstream() {

  local required_freshness=$required_freshness fresh=$fresh \
    default_freshness=$default_freshness up_dna=$upstream

  if [[ -e $up_dna/.dna ]]; then
    log_fatal "update_upstream upstream field should be a path to a upstream spec, not a cell"
    fail1
  fi

  local log_show_vars=^up_dna 
  begin_function

    local up_part=${up_dna##*/}
    local up_cyto=$cyto_up_path/$up_part needs_update=

    update_upstream_prep || fail

    local chosen=
    update_upstream_choose || fail

    if [[ ! "$chosen" ]]; then
      log_fatal "chosen was not set."
      fail1
    fi

    if [[ ! -e $up_cyto/chosen ]]; then
      needs_update=t
    fi

    if [[ "${localize_dims:-}" ]]; then
      eval "$localize_dims"
    fi

    if [[ $needs_update == t ]]; then

      downstream_ref_path=$up_cyto \
        execute_command "$(realpath $chosen)" update || fail

      if [[ $something_changed == t ]]; then
        previous_upstream_changed=t
      fi

      handle_upstream_result || fail

      if [[ $update_successful == f ]]; then
        break
      fi

    fi
    
    update_upstream_get_locks || fail

  end_function
  handle_return
}

update_upstreams() {
  begin_function

    if [[ "$update_successful" == f ]]; then
      succeed
    fi

    update_successful=t
    touch $status_path/deps-up-to-date || fail

    if [[ -d "${dna_up_path:-}" ]]; then

      local previous_upstream_changed=f upstream upstreams

      upstreams=$(find1 $dna_up_path -not -name '.*' | sort -g) || fail
      begin_for upstream in $upstreams; doo
        update_upstream || fail
        if [[ $update_successful == f ]]; then
          break
        fi
      end_for

    fi

  end_function

  if failed || [[ $update_successful == f ]]; then
    rm $status_path/deps-up-to-date 
    update_successful=f
  fi

  handle_return
}

# given a cell, find the nearest seed searching it's ancestors
# returns: seed
find_seed() {
  local cell=$1
  begin_function_flat
    seed=
    begin_while [[ ! "$seed" ]]; doo
      if [[ -d $cell/.dna/sub ]]; then
        seed=$cell
      else
        local parent=${cell%/*}
        if [[ "${#parent}" -gt 1 && "$parent" != $cell ]]; then
          cell=$parent
        else
          break
        fi
      fi
    end_while
  end_function
  handle_return
}

link_dim_parts() {
  local from_path=$from_path to_path=$to_path
  begin_function_flat
    local contents=$(find1 $from_path -not -name '.*') || fail
    begin_for part in $contents; doo
      if [[ "$part" == */up \
         || "$part" == */down \
         || "$part" == */out \
         ]]; then
        continue
      elif [[ "$part" == */var \
           || "$part" == */fun \
           ]]; then
        contents=$(find1 $part -not -name '.*') || fail
        local folder=${part##*/} part2
        begin_for part2 in $contents; doo
          safe_link $(realpath $part2) $to_path/$folder/ || fail
        end_for
      else
        safe_link $(realpath $part) $to_path/ || fail
      fi
    end_for 
  end_function
  handle_return
}

create_sub_branch() {
  local log_show_vars=^sub_dna_path
  begin_function_flat

    mkdir $sub_var $sub_fun $sub_dim || fail

    echo "${super_dims[*]:1}" >$sub_var/leaf_dims || fail

    local dim
    begin_for dim in ${super_dims[*]:1}; doo
      local from_fun=$fun_path/${dim}_member_expand
      local to_fun=$sub_fun/${dim}_member_expand
      if [[ -e "$from_fun" ]]; then
        safe_link $(realpath $from_fun) $to_fun || fail
      else
        log_fatal "Missing ${dim}_member_expand which should be in $fun_path"
        fail1
      fi
    end_for

    local all_path=$dim_path/_all
    if [[ -d $all_path ]]; then
      from_path=$all_path to_path=$sub_dna_path link_dim_parts || fail
      safe_link $(realpath $all_path) $to_path/ || fail
    fi

    local leaf_path=$dim_path/_leaf
    if [[ -d $leaf_path ]]; then
      safe_link $(realpath $leaf_path) $sub_dim/ || fail
    fi

  end_function
  handle_return
}

create_sub_leaf() {
  local log_show_vars=^sub_dna_path
  begin_function_flat

    mkdir $sub_var $sub_fun || fail

    local all_path=$dna_path/dim/_all
    if [[ -d $all_path ]]; then
      from_path=$all_path to_path=$sub_dna_path link_dim_parts || fail
    fi

    local leaf_path=$dna_path/dim/_leaf
    if [[ -d $leaf_path ]]; then
      from_path=$leaf_path to_path=$sub_dna_path link_dim_parts || fail
    fi

  end_function
  handle_return
}

# returns seed_dna
find_seed_dna() {
  local seed=$1
  local parent=${seed%/*}
  local path_to_cell=$2
  begin_function_flat
    path_to_cell=${path_to_cell%.new}
    seed_dna=$seed/.dna/sub/$path_to_cell/.dna
    if [[ ! -e $seed_dna ]]; then
      seed_dna=
      if [[ -d $seed/.dna/sub ]]; then
        seed_dna=$seed/.dna/sub
        local path_array=( ${path_to_cell//\// } ) \
          failed=f
        begin_for path_part in "${path_array[@]}"; doo
          if [[ -d $seed_dna/$path_part ]]; then
            seed_dna+=/$path_part
          elif [[ -d $seed_dna/$wild_sub_path ]]; then
            seed_dna+=/$wild_sub_path
          else
            failed=t
            break
          fi
        end_for
        seed_dna+=/.dna
        if [[ $failed == t || ! -d $seed_dna ]]; then
          seed_dna=
        fi
      elif [[ ${#parent} -gt 1 ]]; then
        # recursive
        find_seed_dna $parent ${seed#$parent/}/$path_to_cell || fail
      fi
    fi
  end_function
  handle_return
}

append_dim_var_to_context() {
  local dim=$1
  begin_function_flat
    local ddim=d_$dim
    if [[ ! -v $ddim ]]; then
      log_fatal "Internal error: While trying to create a branch sub cell, required dim value $dim is missing."
      fail1
    fi
    local value=${!ddim}
    if [[ "$value" == $empty_member ]]; then
      value=
    fi
    echo "$value" >$sub_var/$dim || fail
  end_function
  handle_return
}

promote_dep_cell() {
  local log_show_vars=^from
  begin_function_flat

    local trunk_cell=
    local leaf_dims= last_cell_dims_loaded
    load_dims $trunk_cell || fail

    local dep_dim already_promoted_path=$from

    # We don't need to promote all dims in target, but only the dims in the source
    # e1 -> e1, not e1 -> e1/ods
    # only promote what is in source + provided by prep
    #   can't just promote because a var exists, only if it's actually used at that point

    begin_for dep_dim in ${leaf_dims[*]}; doo

      log_debug "Considering promotion of $dep_dim"

      # is this dim already promoted?
      if [[ $already_promoted_path == */.dim/* ]]; then
        already_promoted_path=${already_promoted_path%/.dim/*}
        log_debug "Already promoted: $dep_dim"
        continue
      fi

      local branch_dim found_branch_dim=f
      # upstream prep script can add extra_dims as needed
      # branch_dims here is the full set of dims for the subject cell, whereas 
      #   dims is the full set of dims for the upstream cell being promoted
      begin_for branch_dim in ${branch_dims[*]} ${extra_dims[*]}; doo
        if [[ $branch_dim == $dep_dim ]]; then
          log_debug "Found branch dim for $dep_dim"
          found_branch_dim=t
          break
        fi
      end_for

      local values=
      if [[ $found_branch_dim == f ]]; then
        # can't promote if dep dim doesn't exist on the branch 
        log_debug "Upstream dim not found in base branch dims: $dep_dim"
        if [[ $cell_is_leaf == t ]]; then
          if type -t ${dep_dim}_member_expand >/dev/null; then
            value= ${dep_dim}_member_expand 
            if [[ "$values" ]]; then
              log_debug "Found default for $dep_dim = $values"
            fi
          fi
          if [[ ! "$values" ]]; then
            log_fatal "Leaf cell was unable to resolve upstream dep to a leaf also. Missing dim $dep_dim"
            fail1
          fi
        else
          break
        fi
      fi

      local dep_dim_var=d_$dep_dim

      if [[ -v $dep_dim_var ]]; then
        values=${!dep_dim_var}
        if type -t ${dep_dim}_member_expand >/dev/null; then
          value=$values ${dep_dim}_member_expand
        fi
      fi

      values=( $values )

      if [[ "${#values[*]}" -gt 1 ]]; then
        log_fatal "Multiple values in dependency dims not yet supported (dim=$dep_dim)"
        fail1
      fi

      if [[ "${values:-}" ]]; then
        local sane_value
        get_sane_value "$values" || fail
        local old_from=$from
        from=$from/.dim/$sane_value
        log_debug "Promoted $dep_dim"
        if [[ ! -d $from ]]; then
          eval "$dep_dim_var=\"$values\""
          log_debug "Creating sub for $from"
          load_context_and_create_sub $old_from $from || fail
        fi
      else
        log_debug "Did not promote $dep_dim because no value is found for it yet"
        break
      fi

    end_for
    load_context || fail
  end_function
  handle_return
}

# from and to are paths to up/choices/{upstream} which must be a cell
migrate_cell() {
  local -r dep_link=$1 to=$2
  local from=$(realpath $dep_link) 
  local log_vars=from log_show_vars="^dep_link ^to"
  begin_function_flat

    if [[ "$from" == */.dna/sub/* ]]; then
      local fixed_from=${from//.dna\/sub\//}
      if [[ -d $fixed_from ]]; then
        rm $dep_link || fail
        safe_link $fixed_from $dep_link || fail
        from=$fixed_from
      else
        log_fatal "Dependencies must link to planted cells, not seeds: $from"
        fail1
      fi
    fi

    promote_dep_cell || fail
    safe_link $from $to || fail

  end_function
  handle_return
}

# from and to are paths to cells
migrate_dep2() {
  local from=$1 to=$2
  begin_function_flat

    if [[ -f $from || -f $from/.dna ]]; then
      safe_link $(realpath $from) $to || fail

    elif [[ -d $from/.dna ]]; then
      migrate_cell $from $to || fail

    elif [[ -d $from ]]; then
      log_fatal "Directory inside of dependency not supported yet"
      fail1
    
    fi

  end_function
  handle_return
}

# migrates a dependency given a .dna/up or .dna/leaf/up or .dna/down folder
migrate_dep() {
  local -r from=$1 to=$2

  local log_show_vars='^from ^to'
  begin_function_flat
    if [[ -d $from ]]; then

      if [[ ! -d $to ]]; then
        mkdir $to || fail
      fi

      local dep deps
      deps=$(find1 $from -type d -not -name '.*') || fail
      begin_for dep in $deps; doo

        local dep_name=${dep##*/}

        if [[ ! -d $to/$dep_name ]]; then
          mkdir $to/$dep_name || fail
        fi

        if [[ -f $dep/prep ]]; then
          safe_link $dep/prep $to/$dep_name/prep || fail
        fi

        if [[ -d $dep/cell ]]; then
          migrate_dep2 $dep/cell $to/$dep_name/cell || fail 
        elif [[ -d $dep/choices ]]; then
          local choice choices
          if [[ ! -d $to/$dep_name/choices ]]; then
            mkdir $to/$dep_name/choices || fail
          fi
          choices=$(find1 $dep/choices -not -name '.*') || fail
          begin_for choice in $choices; doo
            local choice_name=${choice##*/}
            if [[ ! -d "$choice" ]]; then
              log_fatal "Invalid config for $dep: $choice_name is not a folder"
              fail1
            fi
            migrate_dep2 $choice $to/$dep_name/choices/$choice_name || fail
          end_for
        else
          log_fatal "Dependency is missing choices or cell folder: $dep"
          fail1
        fi

      end_for

    fi
  end_function
  handle_return
}

migrate_out() {
  local from=$1
  local -r to=$2

  local log_show_vars='^from ^to'
  begin_function

    if [[ -d $from ]]; then
      local -r dim_var=d_${leaf_dims}
      local -r value=${!dim_var}
      local sane_value
      get_sane_value "$values" || fail
      from+=/$sane_value
      from=$(realpath $from)
      if [[ ! -d $from ]]; then
        log_fatal "dna out dim path is missing: $from"
        fail1
      fi
      safe_link $from $to || fail
    fi

  end_function
  handle_return
}

migrate_deps() {
  local log_show_vars='^dna_path ^sub_dna_path'
  begin_function_flat

    migrate_dep $dna_path/up $sub_dna_path/up || fail
    migrate_dep $dna_path/down $sub_dna_path/down || fail
    migrate_out $dna_path/out $sub_dna_path/out || fail

    if [[ $is_branch == t ]]; then
      mkdir -p $sub_dna_path/_leaf || fail
      migrate_dep $dim_path/_leaf/up $sub_dna_path/_leaf/up || fail
      migrate_dep $dim_path/_leaf/down $sub_dna_path/_leaf/down || fail
      migrate_out $dim_path/_leaf/out $sub_dna_path/_leaf/out || fail
    else
      migrate_dep $dim_path/_leaf/up $sub_dna_path/up || fail
      migrate_dep $dim_path/_leaf/down $sub_dna_path/down || fail
      migrate_out $dim_path/_leaf/out $sub_dna_path/out || fail
    fi

  end_function
  handle_return
}

create_sub_branch_or_leaf() {
  local seed=$seed cell=$cell 
  local log_vars=cell log_show_vars=short_cell
  begin_function_flat
    if [[ -d $cell ]]; then
      log_fatal "Cell already exists $cell"
      fail1
    fi
    mkdir -p $cell || fail
    if [[ "$seed" ]]; then
      local seed_dna
      find_seed_dna $seed ${cell#$seed/} || fail
    fi
    if [[ "$seed_dna" ]]; then
      safe_link $(realpath $seed_dna) $cell/ || fail
    else
      local branch_dims=( ${branch_dims[*]} )
      if (( branch_dim_count >= trunk_dim_count )); then
        log_fatal "Interal error: there are more branch dims than trunk dims defined for this cell: $cell_path"
        fail1
      fi
      branch_dims+=( ${trunk_dims[$branch_dim_count]} )
      
      local sub_dna_path=$cell/.dna 
      local sub_var=$sub_dna_path/var \
        sub_fun=$sub_dna_path/fun \
        sub_dim=$sub_dna_path/dim 

      mkdir $sub_dna_path || fail
      local -r super_dims=( ${leaf_dims[*]} ) || fail
      local -r super_dim_count=${#super_dims[*]}
      if [[ "$super_dims" ]]; then
        local is_branch=f
        if (( super_dim_count > 1 )); then
          is_branch=t
          create_sub_branch || fail
        else
          create_sub_leaf || fail
        fi
        append_dim_var_to_context ${super_dims[0]} || fail
        migrate_deps || fail
      fi
    fi
  end_function
  handle_return
}

create_sub_cell_with_seed() {
  # seed is allowed to be empty, meaning no seed exists at this location
  local seed=$1 sub_cell=$2

  local log_show_vars='^seed ^sub_cell'
  begin_function_flat

    if [[ "$sub_cell" =~ .dna ]]; then
      log_fatal "Internal error: Invalid sub_cell $sub_cell."
      log_fatal "We should not be creating a sub cell inside of a dna folder"
      fail1
    fi

    if [[ ! -d $sub_cell ]]; then

      local short_cell
      get_short_cell $sub_cell 
      log_debug "Creating sub cell $short_cell"

      if [[ -d $sub_cell.new ]]; then
        rm -rf $sub_cell.new || fail
      fi

      local parent=${sub_cell%/*}
      if [[ "$parent" == "$sub_cell" ]]; then
        log_fatal "Can't create sub cells in a cell without parents: $sub_cell"
        stack_trace
        fail1
      fi

      local parent_part=${parent##*/}
      if [[ "$parent_part" == .dim ]]; then
        seed=$seed \
          cell=$sub_cell.new \
          create_sub_branch_or_leaf || fail
      else
        mkdir -p $sub_cell.new || fail
        seed=${seed:-$parent}
        find_seed_dna $seed ${sub_cell#$seed/} || fail
        if [[ "$seed_dna" ]]; then
          safe_link $(realpath $seed_dna) $sub_cell.new/.dna || fail
        fi
      fi
      mv $sub_cell.new $sub_cell || fail
    
    fi

  end_function
  handle_return
}

create_sub_cell() {
  local sub_cell=$1
  find_seed $sub_cell || return 1
  create_sub_cell_with_seed $seed $sub_cell || return 1
  return 0
}

update_member() {
  local sane_value member_path \
    log_vars=member log_show_vars=member \
    downstream_ref_path=${downstream_ref_path:-}

  begin_function_flat

    get_sane_value "$member" || fail
    member_path=$cell_path/.dim/$sane_value
    if [[ ! -d $member_path ]]; then
      if [[ ! -d $cell_path/.dim ]]; then
        mkdir $cell_path/.dim || fail
      fi
      create_sub_cell $member_path || fail
    fi
    local needs_update=
    get_needs_update $member_path || return 1
    if [[ $needs_update == t ]]; then

      if (( member_count > 1 )); then
        log_debug "More than one member found ($member_count), not passing downstream_ref_path."
        downstream_ref_path=
      elif [[ "$downstream_ref_path" ]]; then
        log_debug "Only one member found, passing downstream_ref_path: $downstream_ref_path"
      fi
      execute_command $member_path update || fail

      if [[ $update_successful == f ]]; then
        error "Failed to update member cell $member"
        reply_to_caller "update_successful=f" || fail
      else 
        update_successful=
      fi
    fi

    if (( member_count == 1 )); then
      downstream_ref_path=
    fi

  end_function
  handle_return
}

update_members() {
  begin_function
    if [[ "${leaf_dims:-}" ]]; then
      par=t fork=f function=update_member for_each_member "${leaf_dims[0]}" || fail
      load_context || fail
    fi
  end_function
  handle_return
}

no_change_in_dirs() {
  local left=$1 right=$2
  if [[ -d $left ]]; then
    if [[ -d $right ]]; then
      local sub_full sub already_checked

      for sub_full in $(find1 $left -not -name .dna -not -name .cyto); do
        sub=${sub_full##*/}
        if ! no_change_in_dirs $left/$sub $right/$sub; then
          return 1
        fi
        already_checked+=" $sub"
      done
      already_checked+=' '

      for sub_full in $(find1 $right -not -name .dna -not -name .cyto); do
        sub=${sub_full##*/}
        if [[ "$already_checked" =~ \ $sub\  ]]; then
          continue
        fi
        if ! no_change_in_dirs $right/$sub $left/$sub; then
          return 1
        fi
      done

    else
      return 1
    fi
  elif [[ -f $left ]]; then
    if [[ -f $right ]]; then
      diff $left $right &>/dev/null
    else
      return 1
    fi
  else
    return 0
  fi
}

update_self_move_out_path() {
  begin_function_flat

    if [[ -e $out_path.old ]]; then
      rm -rf $out_path.old || fail
    fi

    if [[ -e $out_path/.dna ]]; then
      if [[ ! -e $out_path.new/.dna ]]; then
        mv $out_path/.dna $out_path.new/.dna || fail
      else
        log_fatal "Target .dna folder already exists, when it shouldn't"
        fail1
      fi
    fi

    if [[ -e $out_path/.cyto ]]; then
      if [[ ! -e $out_path.new/.cyto ]]; then
        mv $out_path/.cyto $out_path.new/.cyto || fail
      else
        log_fatal "Target .cyto folder already exists, when it shouldn't"
        fail1
      fi
    fi

    if [[ -d $out_path ]]; then
      mv $out_path $out_path.old || fail
    fi

    mv $out_path.new $out_path || fail
    something_changed=t

  end_function
  handle_return
}

update_self() {
  local log_vars='short_cell'
  begin_function_flat

    update_successful=
    can_retry=f

    if [[ $can_update == t ]]; then

      local reuse_existing_out=${reuse_existing_out:-f}

      local out_path=$cell_path
      if [[ $reuse_existing_out == f ]]; then
        out_path=$cell_path.new
        if [[ -d $out_path ]]; then
          rm -rf $out_path || fail
        fi
      else
        # allow update code to set this, since we can't compare when changes are made in place
        something_changed=
      fi
      if [[ ! -d $out_path ]]; then
        mkdir $out_path || fail
      fi

      tee_output_to_log || fail
      execute_op update || fail
      completion_time=$EPOCHSECONDS
      untee_output || fail

      update_successful=${update_successful:-f}

      if [[ $reuse_existing_out == f ]]; then
        out_path=$cell_path
        if [[ $update_successful == t ]]; then
          if no_change_in_dirs $out_path $out_path.new; then
            rm -rf $out_path.new || fail
          else
            update_self_move_out_path || fail
          fi
        fi
      else # $reuse_existing_out == t
        # if update code didn't set this, we must assume the worst
        if [[ ! "$something_changed" ]]; then
          something_changed=t
        fi
      fi

    fi

  end_function
  untee_output  # in case update failed and block was exited early
  handle_return
}

update_self_retry_loop() {
  begin_function

    ref_group=none
    delay=$retry_delay

    can_update=f
    find_op_or_function update || return 1
    if [[ "$found_op_function" || "$found_op" ]]; then
      can_update=t
    fi

    if [[ "$update_successful" ]]; then
      can_update=f
    fi

    local action=local_update
    if [[ $can_update == t ]]; then
      for ((retry=0; retry < retry_max; retry++)); do

        if [[ $retry -gt 0 ]]; then
          log_info "Waiting $delay seconds before trying again" 
          sleep $delay
          let 'delay *= retry_scale' || true
        fi

        local attempt_string=
        if (( retry_max > 1 )); then
          attempt_string=", attempt $((retry+1)) of $retry_max"
        fi
          
        log_debug "Executing local update of $short_cell$attempt_string" 

        update_self || fail

        [[ $can_retry == f || $update_successful == t ]] && break

      done
    fi

    update_successful=${update_successful:-t}

  end_function
  handle_return
}

check_results() {
  begin_function

    if [[ $can_update == t ]]; then
      if [[ $update_successful == t && $post_validate == t ]]; then
        log_debug "Post validating"
        local data_valid=f
        can_retry=f
        execute_op check || return 1
        if [[ $data_valid == f ]]; then
          log_warn "Data is not valid"
          update_successful=f
        else
          log_debug "Data is valid"
        fi
      fi
    else
      update_successful=t
    fi

  end_function
  handle_return
}

post_update() {
  local result_string
  begin_function

    completion_time=${completion_time:-$EPOCHSECONDS}
    if [[ $update_successful == t ]]; then
      result_string="successful"
    else
      result_string="failed"
      update_successful=f
    fi

    if [[ $pretend == f ]]; then

      if [[ $update_successful == t ]]; then
        touch -d @$completion_time $status_path/last-good-update-end || fail
        cp -a $status_path/last-update-start \
              $status_path/last-good-update-start || fail
        if [[ -v current_job_path ]]; then
          force=t safe_link $current_job_path $job_path/last-success || fail
        fi
        if [[ "${props:-}" ]]; then
          update_prop_hash || fail
        fi
        if [[ $something_changed == t ]]; then
          from_cell=$cell_path \
            propagate_change_to_downstream || fail
        fi
        if [[ "${downstream_ref_path:-}" ]]; then
          log_debug "Linking upstream cell to it's downstream cell cyto up folder"
          force=t safe_link $cell_path $downstream_ref_path/chosen || fail
        fi
      else
        touch -d @$completion_time $status_path/last-bad-update-end || fail
        force=t safe_link $current_job_path $job_path/last-failure || fail
        cp -a $status_path/last-update-start \
              $status_path/last-bad-update-start || fail
      fi

      if [[ $cell_is_leaf == t || $show_branches == t ]]; then
        log_info "Update $result_string. ($short_cell)"
      else
        log_debug "Update $result_string. ($short_cell)"
      fi

    else
      log_info "Pretend update $result_string."
    fi

    if [[ "${reply_file:-}" ]]; then
      echo "update_successful=${update_successful:-}" >>$reply_file || fail
    fi

    cell_unlock $cell_path || fail

    if [[ -v running_job_path ]]; then
      rm $running_job_path || fail
    fi

  end_function
  handle_return
}

# seed must not be empty here
create_sub_cells2() {
  begin_function_flat
    local seed=$1 relative_path=$2 sub_full sub 
    [[ "$relative_path" ]] && relative_path=/$relative_path
    local sub_path=$seed/.dna/sub$relative_path
    local subs=$(find1 $sub_path -not -name ".*" -not -name "$wild_sub_path" | sort -g) || fail
    begin_for sub_full in $subs; doo
      sub=${sub_full##*/}
      if [[ -f $sub_full ]]; then
        safe_link $(realpath $sub_full) $seed$relative_path/$sub || fail
      elif [[ -L $sub_full ]]; then
        cp $sub_full $seed$relative_path/$sub || fail
      elif [[ -d $sub_full ]]; then
        create_sub_cell_with_seed $seed $seed$relative_path/$sub || fail
        if [[ "$relative_path" ]]; then
          # recursive
          create_sub_cells2 $seed ${relative_path#/}/$sub || fail
        else
          # recursive
          create_sub_cells2 $seed $sub || fail
        fi
      fi
    end_for
  end_function
  handle_return
}

create_sub_cells() {
  begin_function_flat
    if [[ -f "$status_path/subs-up-to-date" ]]; then
      succeed
    fi
    if [[ -d "$sub_path" ]]; then
      create_sub_cells2 $cell_path '' || fail
    fi
    if [[ "$status_path" ]]; then
      touch $status_path/subs-up-to-date || fail
    fi
    succeed
  end_function
  handle_return
}

load_context_and_create_sub() {
  local parent_cell=$1 sub_cell=$2 cell_path
  local log_show_vars='^parent_cell ^sub_cell'
  begin_function
    cell_path=$parent_cell 
    load_context || fail
    # recursive
    create_sub_cell $sub_cell || fail
  end_function
  handle_return
}

is_leaf_cell() {
  local cell_path=$1
  [[ ! -d $cell_path/.dna/dim ]]
}

get_dep_member() {

  if [[ -f $dep_cell/.dna/context-before ]]; then
    source $dep_cell/.dna/context-before || return 1
  else
    log_fatal "Missing context-before in $dep_cell/.dna."
    log_fatal "Should have been generated by update of it's trunk."
    log_fatal "Maybe try to run a clean on it and update again."
    return 1
  fi

  if [[ ! -v $dep_dim ]]; then
    log_fatal "Missing member for $dep_dim."
    log_fatal "This should have been defined in $dep_cell/.dna/context-before"
    return 1
  fi

  dep_member=${!dep_dim}
  return 0
}

setup_cyto_out() {
  local from=$1 to=$2
  begin_function_flat
    local contents=$(find1 $from) || fail
    begin_for item in $contents; doo
      if [[ -d $item ]]; then
        local last_part=${item##*/}
        if [[ ! -d $to/$last_part ]]; then
          mkdir $to/$last_part || fail
        fi
        setup_cyto_out $from/$last_part $to/$last_part || fail
      elif [[ $item == *.safe ]]; then
        local target_file=${item##*/}
        target_file=${target_file%.safe}
        from=$item to=$to/$target_file decrypt_file_with_shared_key || fail
      else
        safe_link $item $to/ || fail
      fi
    end_for
  end_function
  handle_return
}

update() {
  begin_function_flat
    local leave_loop=0 needs_update= something_changed=f
    break_if_not_changed || fail
    if (( leave_loop > 0 )); then
      succeed
    fi
    pre_update || fail
    create_downstream_links || fail
    update_upstreams || fail
    if [[ $update_successful == t ]]; then
      update_successful=
      update_members || fail
      create_sub_cells || fail
      if [[ -d $cyto_path/out ]]; then
        setup_cyto_out $cyto_path/out $out_path || fail
      fi
      update_self_retry_loop || fail
      check_results || fail
    fi
    post_update || fail
  end_function
  handle_return
}

