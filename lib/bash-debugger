#!/bin/bash

type -t debugger_init >/dev/null && return 0
shopt -s expand_aliases   # make sure aliases are expanded even for non-interactive scripts

######################################################
# BASH Debugger
# At beginning of script you wish to debug: 
#   source this file. example: source /home/my_user/repos/bash-debugger
#   intialize debugger in your source: debugger_init
#   execute debug in the code where you wish to begin debugging.
# press '?' for list of commands while debugging
# If you want to get syntax highlighting working, install source-highlight
#   example for mac: brew install source-highlight
######################################################

if (( BASH_VERSINFO < 5 )); then
  echo "You must run this script with at least bash version 5." >&2
  echo "If you already have a correct version of bash in your path, you may need to put:" >&2
  echo "  #!/usr/bin/env bash" >&2
  echo "at the top of your script that you want debugged" >&2
  exit 1
fi

NL=$'\n'
TAB=$'\t'

   LIGHT_RED=$'\033[0;31m'
         RED=$'\033[1;31m'
 LIGHT_GREEN=$'\033[0;32m'
       GREEN=$'\033[1;32m'
LIGHT_YELLOW=$'\033[0;33m'
      YELLOW=$'\033[1;33m'
  LIGHT_BLUE=$'\033[0;34m'
        BLUE=$'\033[1;34m'
LIGHT_PURPLE=$'\033[0;35m'
      PURPLE=$'\033[1;35m'
  LIGHT_CYAN=$'\033[0;36m'
        CYAN=$'\033[1;36m'
 LIGHT_WHITE=$'\033[0;37m'
       WHITE=$'\033[1;37m'
 LIGHT_BLACK=$'\033[0;38m'
       BLACK=$'\033[1;38m'
       RESET=$'\033[0m'
  CLEAR_LINE=$'\033[2K\r'
       CLEAR=$'\033[2J'
CLEAR_SCREEN=$'\033[2J\r\033[H'
   CURSOR_UP=$'\033[1A'
     REVERSE=$'\033[7m'

original_cmd=${original_cmd:-"$0 $*"}
alias debug_once='[[ ! "${debug_once_triggered:-}" ]] && { debug_once_triggered=t; debug_start; }'

is_array() {
  local -n array=$1
  if [[ ! -v array[*] ]]; then
    return 1
  fi
  [[ ${array@a} == a ]]
}

side_log() {
  echo "$*" >>$side_log_file
}

debug_expansion_clean() {
  local line shortest= plusses code plus_length from=$1 show
  while read -rs line >&$fd_original_err || true; do
    if [[ "$line" =~ ^(\++)\ (.*) ]]; then
      plusses=${BASH_REMATCH[1]}
      code=${BASH_REMATCH[2]}
      plus_length=${#plusses}
      show=f

      if [[ ! "$shortest" ]]; then
        shortest=$((plus_length-1))
        show=t
      elif [[ $plus_length == $shortest || $debug_expansion -ge 2 ]]; then
        show=t
      fi

      if [[ $show == t ]]; then
        local new_plus=${plusses:$((shortest-1))}
        if [[ "$code" == "return 0" ]]; then
          :
        elif [[ "$code" != "set +x" \
           && "$code" != "set -x" \
           && "$code" != *"no_trace_depth"* \
           && "$code" != "break_out=f" \
           && "$code" != "debug_id_inc" \
           ]]; then
          echo "$new_plus $code"
        fi
      fi

    elif [[ "$line" ]]; then
      echo "$line"
    else
      break
    fi
  done < <(cat "$from")
  return 0
}

debug_output_reversed_line() {
  echo -n "$REVERSE" >&$fd_original_err
  local line=$(sed -E -n "${debug_line_num}p;${debug_line_num}q" "$raw_debug_path_to_source_file")
  local pad_size line_length=${#line}
  (( pad_size = COLUMNS - line_length ))
  echo -n "$line" >&$fd_original_err
  printf %${pad_size}s >&$fd_original_err
  echo "$RESET" >&$fd_original_err
}

debug_source_update() {
  debug_path_to_source_file=$raw_debug_path_to_source_file
  if [[ $debug_path_to_source_file == /dev/fd/* ]]; then
    debug_path_to_source_file=none
  fi

  if [[ $debug_full_path == t ]]; then
    debug_source_file=$debug_path_to_source_file
  else
    debug_source_file=${debug_path_to_source_file##*/}
  fi
}

debug_source_update_hl() {
  if [[ $debug_highlight == t && $debug_path_to_source_file != none ]]; then

    debug_path_to_source_file=$(cd "$debug_dir"; cd ${debug_path_to_source_file%/*}; pwd)/${debug_path_to_source_file##*/} || { debug_exit=t; exit 1; }
    local highlighted_source=$tmp_folder/debug_highlight/${debug_path_to_source_file#/}
    if [ ! -f "$highlighted_source" ]; then
      mkdir -p "${highlighted_source%/*}"
      #cat "$debug_path_to_source_file" | highlight -S shellscript -O ansi >"$highlighted_source"
      cat "$debug_path_to_source_file" | source-highlight -s bash -f esc >"$highlighted_source"
    fi
    debug_path_to_source_file=$highlighted_source

  fi
}

debug_source_line_update() {

  local i=$((debug_list_stack_pos))
  raw_debug_path_to_source_file=${saved_bash_source[$i]}

  if [[ ! "$raw_debug_path_to_source_file" ]]; then
    echo "Internal error: missing raw_debug_path_to_source_file" >&$fd_original_err
    echo "debug_list_stack_pos=$debug_list_stack_pos" >&$fd_original_err
    echo "Array saved_bash_source:" >&$fd_original_err
    show_array saved_bash_source
    debug_exit=t
    exit 1
  fi

  if (( debug_list_stack_pos > 0 )); then
    debug_line_num=${saved_bash_lineno[$((i - 1))]}
  else
    debug_line_num=$saved_lineno
  fi

  if [[ ! "$debug_line_num" ]]; then
    echo "Internal error: missing debug_line_num" >&$fd_original_err
    debug_exit=t
    exit 1
  fi

  debug_current_function=${saved_funcname[$i]:-}

  if [[ ! "$debug_current_function" ]]; then
    echo "Internal error: missing debug_current_function" >&$fd_original_err
    debug_exit=t
    exit 1
  fi

}

debug_display_source() {
  local skip_source_update=${skip_source_update:-f}

  if [[ $skip_source_update == f ]]; then
    debug_source_line_update
    debug_source_update
    debug_source_update_hl
  fi

  if [[ "$debug_path_to_source_file" == none ]]; then
    return 0
  fi
  local debug_start_line=$((debug_list_offset+debug_line_num))
  if (( debug_start_line < 1 )); then
    (( debug_list_offset += -debug_start_line + 1 ))
    debug_start_line=1
  fi
  local debug_end_line=$((debug_start_line+debug_list_window-1))

  if (( debug_start_line <= debug_line_num && debug_line_num <= debug_end_line )); then
    if (( debug_start_line < debug_line_num )); then
      sed -n "$debug_start_line,$((debug_line_num-1))p;$((debug_line_num-1))q" "$debug_path_to_source_file" >&$fd_original_err
    fi
    debug_output_reversed_line
    if (( debug_line_num < debug_end_line )); then
      sed -n "$((debug_line_num+1)),${debug_end_line}p;${debug_end_line}q" "$debug_path_to_source_file" >&$fd_original_err
    fi
  else
    sed -n "$debug_start_line,${debug_end_line}p;$((debug_end_line))q" "$debug_path_to_source_file" >&$fd_original_err
  fi
}

debug_load_state() {
  if [[ -f "$debug_state_file" && "${debug_needs_to_load_state:-t}" == t ]]; then
    [[ ${debug_debug:-f} == t ]] && echo "${CYAN}Loading state from $debug_state_file${RESET}" >&$fd_original_err
    debug_needs_to_load_state=f
    source "$debug_state_file" || return 1
  fi
  return 0
}

debug_save_state() {
  # We don't need to save the state if there are no parent shells to recall that state
  if [[ $BASH_SUBSHELL -gt 0 || ${force_save:-f} == t ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Saving debug_state_file${RESET}" >&$fd_original_err
    echo "
debug_buffered_commands='$debug_buffered_commands'
debug_condition='$debug_condition'
debug_condition_old='$debug_condition_old'
debug_display='$debug_display'
debug_exit='$debug_exit'
debug_expanded_search='$debug_expanded_search'
debug_expansion='$debug_expansion'
debug_expression='$debug_expression'
debug_follow_source='$debug_follow_source'
debug_function='$debug_function'
debug_function_old='$debug_function_old'
debug_highlight='$debug_highlight'
debug_ignore='$debug_ignore'
debug_immediate='$debug_immediate'
debug_line='$debug_line'
debug_line_old='$debug_line_old'
debug_max_depth='$debug_max_depth'
debug_original_tracefd='$debug_original_tracefd'
debug_prev_command='${debug_prev_command//\'/\'\"\'\"\'}'
debug_prev_function='$debug_prev_function'
debug_prev_line='$debug_prev_line'
debug_prev_source_file='$debug_prev_source_file'
debug_search='$debug_search'
debug_search_deep='$debug_search_deep'
debug_search_old='$debug_search_old'
debug_show_time='$debug_show_time'
debug_trace_time='$debug_trace_time'
debug_skip_ignore='$debug_skip_ignore'
debug_step_to_later_line='$debug_step_to_later_line'
debug_step_to_next_line='$debug_step_to_next_line'
debug_step_to_next_file='$debug_step_to_next_file'
debug_step_to_next_function='$debug_step_to_next_function'
debug_step_to_hi_function='$debug_step_to_hi_function'
debug_stepping='$debug_stepping'
debug_stop_at='$debug_stop_at'
debug_subshell='$debug_subshell'
debug_var_regex='$debug_var_regex'
debug_watch='$debug_watch'
PS4='$PS4'" >"$debug_state_file" || return 1
  fi
  return 0
}

# var must have trailing and leading spaces
remove_word_from_string() {
  local var_name=$1 remove_value=$2
  local -n var=$var_name
  if [[ -v var && "$var" == *" $remove_value "* ]]; then
    local left=${var% $remove_value *} \
      right=${var#* $remove_value }
    var="$left $right"
  fi
}

debug_ignore_remove() {
  local remove_functions="$*"
  for x in $remove_functions; do
    [[ ${debug_debug:-f} == t ]] && echo "${CYAN}debug_debug: Removing $x from debug_ignore${RESET}" >&$fd_original_err
    remove_word_from_string debug_ignore "$x"
  done
}

debug_display_command_expansion_status() {
  case $debug_expansion in
    0)
      echo "# Command expansion off" >&$fd_original_err
    ;;
    1)
      echo "# Command expansion basic" >&$fd_original_err
    ;;
    2)
      echo "# Command expansion deep" >&$fd_original_err
    ;;
    3)
      echo "# Command expansion unfiltered" >&$fd_original_err
    ;;
  esac
}

debug_output_stop() {
  if [[ $debug_recording_trace == t && -e $debug_out_path ]]; then
    debug_recording_trace=f
    BASH_XTRACEFD=$debug_original_tracefd
    eval "exec $fd_bash_trace>&-"
    if [[ -e $debug_out_path  ]]; then
      rm $debug_out_path
    fi
    [[ $debug_debug == t ]] && echo "${CYAN}debug_debug: Stopping debug output expansion${RESET}" >&$fd_original_err
  fi
}

debug_output_expansion() {
  if (( debug_expansion > 0 )); then
    if [[ -f "$debug_out_path" && ! "$debug_buffered_commands" ]]; then

      if (( debug_expansion > 2 )); then
        cat $debug_out_path >&$fd_original_err
      elif (( debug_expansion > 1 || debug_current_depth <= debug_max_depth )); then
        debug_expansion_clean $debug_out_path >&$fd_original_err
      fi

      debug_output_stop

    fi
  fi
}

# input:
#   new_bisect
# output:
#   new_command
debug_get_new_bisect() {
  new_command=$original_cmd
  local pre post
  if [[ "$new_command" =~ ^(.*)\ (debug_)?bisect=[^\ ]+(\ .*)?$ ]]; then
    pre=${BASH_REMATCH[1]}
    post=${BASH_REMATCH[3]}
    new_command="$pre$post"
  fi
  debug_bisect_min=${new_bisect%..*}
  debug_bisect_max=${new_bisect#*..}
  if (( debug_bisect_min == debug_bisect_max )); then
    new_command+=" debug=$((debug_bisect_max - 1))"
    echo "${YELLOW}Bisect complete, debugging just before issue occurs: ${RESET}$new_command" >&$fd_original_err
  else
    new_command+=" bisect=$new_bisect"
    echo "${CYAN}Starting next bisect: ${RESET}$new_command" >&$fd_original_err
  fi
}

debug_get_new_command() {
  new_command=$original_cmd
  local pre post
  if [[ "$new_command" =~ ^(.*)\ debug(_id)?=[^\ ]+(\ .*)?$ ]]; then
    pre=${BASH_REMATCH[1]}
    post=${BASH_REMATCH[3]}
    new_command="$pre$post"
  fi
  new_command+=" debug=$rewind_debug_id"
  echo "Starting over command: $new_command" >&$fd_original_err
}

debug_reset_stack_pos() {
  (( debug_list_offset = -debug_list_window / 2 + 1 ))
  debug_list_stack_pos=0
  debug_display_source
  debug_list_dir=forwards
  (( debug_list_offset += debug_list_window ))
}

debug_move_down_stack() {
  local index=$(( debug_list_stack_pos - 1 ))

  if (( index < 0 )); then

    echo "# Already at bottom of stack" >&$fd_original_err

  elif (( index == 0 )); then

    debug_reset_stack_pos

  else

    echo "# Move down the stack" >&$fd_original_err

    (( debug_list_stack_pos = index ))
    #local debug_id=
    #if [[ -v stack_debug_id[$index] ]]; then
    #  debug_id=${stack_debug_id[$index]}
    #fi

    local raw_stack_size=${#saved_bash_source[*]}
    (( debug_list_offset = -debug_list_window * 2 / 3 + 1 ))
    debug_source_line_update

    debug_display_source
    debug_list_dir=forwards
    (( debug_list_offset += debug_list_window ))

  fi
}

debug_move_up_stack() {
  local index=$(( debug_list_stack_pos + 1 ))

  if (( index >= stack_size )); then

    echo "# Already at top of stack" >&$fd_original_err

  else

    echo "# Move up the stack" >&$fd_original_err

    (( debug_list_stack_pos = index ))
    #local debug_id=
    #if [[ -v stack_debug_id[$index] ]]; then
    #  debug_id=${stack_debug_id[$index]}
    #fi
    
    local raw_stack_size=${#saved_bash_source[*]}
    (( debug_list_offset = -debug_list_window * 2 / 3 + 1 ))
    debug_source_line_update

    debug_display_source
    debug_list_dir=forwards
    (( debug_list_offset += debug_list_window ))

  fi
}

get_effective_debug_id() {

  if (( debug_list_stack_pos == 0 )); then
    effective_debug_id=$fork_debug_id
  else
    local i=$((stack_size - debug_list_stack_pos)) debug_id=
    if (( i >= stack_size )); then
      (( i = stack_size - 1 ))
    fi

    while [[ ! "$debug_id" ]]; do

      if [[ -v stack_debug_id[$i] ]]; then
        debug_id=${stack_debug_id[$i]}
        break
      fi

      (( i-- ))
      if (( i < 0 )); then
        break
      fi

    done

    if [[ "$debug_id" ]]; then
      effective_debug_id=$debug_id
    else
      effective_debug_id=1
    fi

  fi

}

debug_set_watch() {
  local new_watch=$1 add=f

  if [[ "$new_watch" == +* ]]; then
    new_watch=${new_watch#+}
    add=t
  fi

  if [[ $add == t ]]; then
    debug_watch+=" $new_watch"
  else
    debug_watch=$new_watch
  fi
}

stack_trace() {
  local start_frame=${start_frame:-2} stack_level=${stack_level:-0}

  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&$fd_original_err
  fi

  echo "Full call stack:" >&$fd_original_err
  stack_trace_inner | column -W4 -l4 -t >&$fd_original_err

  return 0
}

medium_stack_trace() {
  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&$fd_original_err
  fi

  if [[ "${stack_debug_id[*]}" ]]; then
    local start_frame=${start_frame:-1}

    if [ ${tracing_midline:-f} == t ]; then
      tracing_midline=f
      echo >&$fd_original_err
    fi

    echo "Medium call stack:" >&$fd_original_err
    stack_level=1 stack_trace_inner | column -W4 -l4 -t >&$fd_original_err
  else
    echo "No medium stack available." >&$fd_original_err
  fi
  return 0
}

high_stack_trace() {
  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&$fd_original_err
  fi

  if [[ "${cooked_stack[*]}" ]]; then
    local start_frame=${start_frame:-1}

    if [ ${tracing_midline:-f} == t ]; then
      tracing_midline=f
      echo >&$fd_original_err
    fi

    echo "High call stack:" >&$fd_original_err
    stack_level=2 stack_trace_inner | column -W4 -l4 -t >&$fd_original_err
  else
    echo "No high stack available." >&$fd_original_err
  fi
  return 0
}

stack_trace_inner() {
  local extra= debug_id= p n r l \
    stack_level=${stack_level:-0} count=${#FUNCNAME[*]} \
    before= after=

  echo "${WHITE}FUNCTION DEBUG_ID SOURCE DETAILS$RESET"
  for ((n = count - 1; n >= start_frame; n--)) ; do
    (( p = n - 1 ))
    (( r = count - n - 1 ))
    debug_id= extra= before= after=

    l=0
    if [[ -v stack_debug_id[$r] ]]; then
      debug_id=${stack_debug_id[$r]}
      l=1
    else
      debug_id=-
    fi

    if [[ -v cooked_stack[$r] ]]; then
      extra=${cooked_stack[$r]}
      l=2
      before=$WHITE
      after=$RESET
    else
      extra=
    fi

    if (( l >= stack_level )); then
      echo "$before${FUNCNAME[$n]:-(no func)} $debug_id ${BASH_SOURCE[$n]:-(no source)}:${BASH_LINENO[$p]:-(no line)}$after $extra"
    fi

  done

  return 0
}

debug_shell() {
  if [[ ! -v debugging ]]; then
    debugger_init || return 1
  fi
  local c
  echo "Debug shell started. " >&$fd_original_err
  echo "Use q to exit debug shell and resume execution of the script. " >&$fd_original_err
  echo "Use 'exit' to abort all further code execution. " >&$fd_original_err
  echo "You have access to the full execution environment (variables and functions). " >&$fd_original_err
  while true; do
    read -u $fd_original_in -e -p "debug ${CYAN}\$${RESET} " c >&$fd_original_err
    case $c in
      q|quit)
        echo "Leaving debug shell." >&$fd_original_err
        break
        ;;
      *)
        eval "$c" || { rc=$?; echo; echo "Command failed ($rc)"; }
        ;;
    esac
  done
}

debug_show_var() {
  local display_var=$1
  if [[ "$display_var" =~ ^[a-zA-Z_0-9]+$ ]]; then
    eval 'echo "$'$display_var'"' >&$fd_original_err 
  elif [[ "$display_var" == \** ]]; then
    eval "declare -p | grep \"${display_var#\*}\" | grep -Ev 'declare -a BASH_ARGV|declare -- _=|declare -- debug_display=|declare -n derive_fields=|declare -- display_var='" >&$fd_original_err
  elif [[ "${display_var:-}" == \$* ]]; then
    eval 'echo "'${display_var}'"' >&$fd_original_err
  elif [[ "${display_var:-}" ]]; then
    eval 'echo "[${!display_var}]"' >&$fd_original_err
  fi
}

debug_command_loop() {
  local debug_c no_follow_once=f

  debug_r=-1
  while [[ $debug_r == -1 ]]; do

    local current_source_line_without_comment=none
    if [[ $debug_path_to_source_file != none ]]; then
      current_source_line_without_comment=$(sed -E -n "${debug_line_num}p;${debug_line_num}q" "$raw_debug_path_to_source_file" \
        | sed -E 's/^ *(.*) *$/\1/' \
        | sed -E 's/#.*//'
        )
    fi
    if [[ $debug_follow_source == t && "$current_source_line_without_comment" && ! "$debug_buffered_commands" ]]; then
      if [[ $no_follow_once == t ]]; then
        no_follow_once=f
      else
        echo "$hbar_tilde" >&$fd_original_err
        (( debug_list_offset = -debug_list_window / 2 + 1 )) 
        debug_display_source
        debug_list_dir=forwards
        (( debug_list_offset += debug_list_window - 1 ))
      fi
    fi

    if [[ "$debug_watch" && ! "$debug_buffered_commands" ]]; then
      set +u
      local watch_var watch_output='+ ' value
      for watch_var in $debug_watch; do
        get_var_value $watch_var
        watch_output+="$watch_var=$value "
      done
      echo "$watch_output" >&$fd_original_err
    fi

    if [[ ! "$debug_buffered_commands" ]]; then
      local debug_prefix=
      if [[ $BASH_SUBSHELL -gt 0 ]]; then
        debug_prefix+="$YELLOW$BASH_SUBSHELL:$BASHPID "
      fi
      if [[ $debug_show_time == t && "$debug_start_ts" ]]; then
        local ts=${EPOCHREALTIME/./}
        local time_diff=$((ts-debug_start_ts))
        debug_prefix+="${LIGHT_WHITE}+$time_diff "
        debug_start_ts=
      fi
      if [[ "$fork_debug_id" ]]; then
        get_effective_debug_id
        debug_prefix+="${CYAN}debug_id=$effective_debug_id "
      fi
      if [[ $debug_source_file != none ]]; then
        echo -n "$debug_prefix$RED$debug_source_file:$debug_line_num" >&$fd_original_err
      fi
      echo -n " $GREEN$debug_current_function $RESET:" >&$fd_original_err
      echo -n " $debug_command " >&$fd_original_err
    fi

    debug_long_command=f
    local silent_command=f
    if [[ "$debug_buffered_commands" ]]; then
      debug_buffered_commands=${debug_buffered_commands##*( )}
      debug_c=${debug_buffered_commands%% *}
      debug_buffered_commands=${debug_buffered_commands#$debug_c}
      silent_command=t
    else
      read -rs -n1 -u $fd_original_in debug_c >&$fd_original_err 2>&1
      user_interacted=t
    fi

    if [[ "$debug_c" != l && "$debug_c" != L ]]; then
      debug_list_offset=0
      debug_list_dir=none
    fi

    BASH_REMATCH=( "${debug_rematch[@]}" )

    case "$debug_c" in
      a)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Name of array variable: " debug_array >&$fd_original_err
        if [[ "$debug_array" ]]; then
          show_array $debug_array
        fi
        no_follow_once=t
        ;;
      A)
        if [[ "${debug_array:-}" ]]; then
          echo "# Showing array $debug_array" >&$fd_original_err
          show_array $debug_array
          no_follow_once=t
        else
          echo "# No array var set, use 'a' command to choose" >&$fd_original_err
        fi
        ;;
      b)
        get_effective_debug_id
        local rewind_debug_id
        rewind_debug_id=$effective_debug_id
        echo "# Going back to debug_id=$rewind_debug_id..." >&$fd_original_err
        local new_command
        debug_get_new_command
        debug_restart_command=$new_command
        debug_exit=t
        debugging=
        exit 0
        ;;
      B)
        get_effective_debug_id
        local rewind_debug_id
        rewind_debug_id=$((effective_debug_id-1))
        echo "# Going back to debug_id=$rewind_debug_id..." >&$fd_original_err
        local new_command
        debug_get_new_command
        debug_restart_command=$new_command
        debug_exit=t
        debugging=
        exit 0
        ;;
      c)
        if [[ $debug_path_to_source_file == none ]]; then
          echo "# Source not available" >&$fd_original_err
        else
          echo "$NL" >&$fd_original_err
          debug_reset_stack_pos
          no_follow_once=t
        fi
        ;;
      C)
        echo "# Continuing..." >&$fd_original_err
        [[ "${fd_bash_trace:-}" ]] && eval "exec $fd_bash_trace>&-"
        debug_r=0
        debug_long_command=t
        debug_save_state
        debug_untrap=t
        ;;
      d)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Display: " debug_display >&$fd_original_err
        set +u
        debug_show_var "$debug_display" || fail
        no_follow_once=t
        ;;
      D)
        if [[ "${debug_display:-}" ]]; then
          echo "# Showing $debug_display" >&$fd_original_err
          debug_show_var "$debug_display" || fail
        else
          echo "# No previous display var." >&$fd_original_err
        fi
        no_follow_once=t
        ;;
      e)
        echo >&$fd_original_err
        read -u $fd_original_in -er -p "Eval: " debug_expression >&$fd_original_err
        #eval "$debug_saved_shell_options"
        eval "$debug_expression" >&$fd_original_err
        set +evTu +o pipefail
        no_follow_once=t
        ;;
      E)
        if [[ "$debug_expression" ]]; then
          echo "# Evaluating $debug_expression" >&$fd_original_err
          eval "$debug_expression" >&$fd_original_err
        else
          echo "# No previous expression to evaluate" >&$fd_original_err
        fi
        no_follow_once=t
        ;;
      /)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Deep Find: " debug_search >&$fd_original_err
        if [[ "${debug_search:-}" ]]; then
          if [[ "$debug_search" == ~* ]]; then
            # use unescaped to support regex if expression starts with ~
            debug_search=${debug_search#~}
          else
            debug_search=${debug_search//\\/\\\\}
            debug_search=${debug_search//\$/\\\$}
            debug_search=${debug_search//[/\\[}
          fi
          debug_search_old=$debug_search
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_stepping=f
          debug_save_state
        fi
        ;;
      f)
        if [[ "${debug_search_old:-}" ]]; then
          echo "# Repeating search for $debug_search_old" >&$fd_original_err
          debug_search=${debug_search_old:-}
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_stepping=f
          debug_save_state
        else
          echo "# No previous search." >&$fd_original_err
          no_follow_once=t
        fi
        ;;
      g)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Go until function: " debug_quick_function >&$fd_original_err
        if [[ "${debug_quick_function:-}" ]]; then
          debug_r=0
          debug_long_command=t
          debug_function_old=$debug_quick_function
          if [[ "${debug_quick_function:-}" == /* ]]; then
            debug_function=${debug_quick_function#/}
            debug_quick_function=
            debug_subshell=t
          else
            debug_untrap=t
          fi
          debug_save_state
        fi
        ;;
      G)
        if [[ "${debug_function_old:-}" ]]; then
          debug_quick_function=$debug_function_old
          echo "# Continuing until we reach function $debug_quick_function" >&$fd_original_err
          debug_r=0
          debug_long_command=t
          if [[ "${debug_quick_function:-}" == /* ]]; then
            debug_function=${debug_quick_function#/}
            debug_quick_function=
            debug_subshell=t
          else
            debug_untrap=t
          fi
          debug_save_state
        fi
        ;;
      h)
        if [[ $debug_highlight == t ]]; then
          echo "# Syntax highlighting is now off" >&$fd_original_err
          debug_path_to_source_file=$raw_debug_path_to_source_file
          debug_highlight=f
        else
          echo "# Syntax highlighting is now on" >&$fd_original_err
          # debug_path_to_source_file=$highlighted_source
          debug_highlight=t
        fi
        debug_save_state
        no_follow_once=t
        ;;
      i)
        echo "# Stepping in" >&$fd_original_err
        debug_r=0
        (( debug_max_depth += 10 ))
        debug_step_to_next_line=t
        debug_skip_ignore=t
        debug_subshell=t
        debug_save_state
        export -n debug
        ;;
      j)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Shallow Find: " debug_search >&$fd_original_err
        if [[ "${debug_search:-}" ]]; then
          if [[ "$debug_search" == ~* ]]; then
            # use unescaped to support regex if expression starts with ~
            debug_search=${debug_search#~}
          else
            debug_search=${debug_search//\\/\\\\}
            debug_search=${debug_search//\$/\\\$}
            debug_search=${debug_search//[/\\[}
          fi
          debug_search_old=$debug_search
          debug_search_deep=f
          debug_r=0
          debug_long_command=t
          debug_save_state
        fi
        ;;
      J)
        if [[ "${debug_search_old:-}" ]]; then
          echo "# Shallow find of $debug_search_old" >&$fd_original_err
          debug_search=${debug_search_old:-}
          debug_search_deep=f
          debug_r=0
          debug_long_command=t
          debug_save_state
        else
          echo "# No previous search" >&$fd_original_err
          no_follow_once=t
        fi
        ;;
#      k)
#        echo "# Skipping..." >&$fd_original_err
#        debug_r=1
#        debug_stepping=t
#        ;;
      l)
        if [[ $debug_path_to_source_file == none ]]; then
          echo "# Source not available" >&$fd_original_err
        else
          if [[ $debug_list_dir != none ]]; then
            echo -n "$CLEAR_LINE" >&$fd_original_err
            if [[ "$debug_watch" ]]; then
              echo -n "$CURSOR_UP$CLEAR_LINE" >&$fd_original_err
            fi
          fi

          [[ $debug_list_dir == none ]] && echo >&$fd_original_err
          [[ $debug_list_dir == backwards ]] && (( debug_list_offset += debug_list_window ))
          debug_display_source
          (( debug_list_offset += debug_list_window ))
          debug_list_dir=forwards
          no_follow_once=t
        fi
        ;;
      L)
        if [[ $debug_path_to_source_file == none ]]; then
          echo "# Source not available" >&$fd_original_err
        else
          echo -n "$CLEAR_SCREEN" >&$fd_original_err
          [[ $debug_list_dir == forwards ]] && (( debug_list_offset -= debug_list_window ))
          (( debug_list_offset -= debug_list_window * 15 / 10 ))
          debug_display_source
          debug_list_dir=backwards
          no_follow_once=t
        fi
        ;;
      n)
        echo "# Stepping over" >&$fd_original_err
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=t
        debug_subshell=t
        debug_save_state
        export -n debug
        ;;
      N)
        echo "# Stepping until next line is reached" >&$fd_original_err
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_later_line=t
        debug_long_command=t
        debug_save_state
        ;;
      o)
        if [[ $silent_command == f ]]; then
          echo "# Stepping out" >&$fd_original_err
        fi
        debug_max_depth=$((debug_current_depth-1))
        debug_r=0
        debug_long_command=t
        debug_stepping=t
        debug_save_state
        ;;
      p)
        echo >&$fd_original_err
        local fixed_command
        fixed_command=${debug_command}
        fixed_command=${fixed_command//\\/**BS**}
        fixed_command=${fixed_command//\\\$/\\\\\$}
        # temporarily hide this so we can keep $(( but transform $(
        fixed_command=${fixed_command//\$((/{{{}
        fixed_command=${fixed_command//\$(/\\\$(}
        # restore {{{ to $((
        fixed_command=${fixed_command//{{{/\$((}
        fixed_command=${fixed_command//\"/\\\"}
        fixed_command=${fixed_command//\*\*BS\*\*/\\}
        if [[ "${debug_saved_params:-}" ]]; then
          set "${debug_saved_params[@]}"
        fi
        set +u
        eval "echo \"$fixed_command\"" >&$fd_original_err
        set -u
        no_follow_once=t
        ;;
      P)
        echo >&$fd_original_err
        local fixed_command
        fixed_command=${debug_command}
        fixed_command=${fixed_command//\\/**BS**}
        fixed_command=${fixed_command//\\\$/\\\\\$}
        fixed_command=${fixed_command//\[\[ /~~dbo~~}
        fixed_command=${fixed_command// \]\]/~~dbc~~}
        fixed_command=${fixed_command//\[ /\$(\[ }
        fixed_command=${fixed_command// ]/ ] && echo true || echo false)}
        fixed_command=${fixed_command//~~dbo~~/\$(\[\[ }
        fixed_command=${fixed_command//~~dbc~~/ ]] \&\& echo true || echo false)}
        fixed_command=${fixed_command//\*\*BS\*\*/\\}
        eval "echo \"$fixed_command\"" >&$fd_original_err
        no_follow_once=t
        ;;
      q) 
        echo "# Quitting (debug state: $debug_state_file)" >&$fd_original_err
        force_save=t debug_save_state
        debug_exit=t
        debug_save_state
        if [[ "$reply_file" ]]; then
          echo "debugging=t" >$reply_file
        fi
        exit 0
        ;;
      r)
        echo "# Show low call stack" >&$fd_original_err
        start_frame=5 stack_trace
        no_follow_once=t
        ;;
      R)
        echo "# Rewinding..." >&$fd_original_err
        debug_rewind=t
        debug_stepping=t
        debug_r=0
        ;;
      s)
        echo "# Stepping over small" >&$fd_original_err
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=f
        debug_subshell=t
        debug_stepping=t
        debug_save_state
        ;;
      S)
        echo "# Stepping in small" >&$fd_original_err
        debug_r=0
        (( debug_max_depth += 10 ))
        debug_step_to_next_line=f
        debug_skip_ignore=t
        debug_subshell=t
        debug_stepping=t
        debug_save_state
        export -n debug
        ;;
      t)
        echo "# Show medium call stack" >&$fd_original_err
        medium_stack_trace
        no_follow_once=t
        ;;
      T)
        echo "# Show high call stack" >&$fd_original_err
        high_stack_trace
        no_follow_once=t
        ;;
      u)
        echo >&$fd_original_err
        local f
        read -u $fd_original_in -e -p "Unignore function: " f >&$fd_original_err
        if [[ "${f:-}" ]]; then
          debug_ignore_remove $f
        fi
        ;;
      U)
        echo "# Unignore all functions" >&$fd_original_err
        debug_ignore=
        no_follow_once=t
        ;;
      v)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Var regex: " debug_var_regex >&$fd_original_err
        if [[ "$debug_var_regex" ]]; then
          eval "declare -p | grep ' $debug_var_regex.*='" >&$fd_original_err 
        else
          eval "declare -p" >&$fd_original_err 
        fi
        no_follow_once=t
        ;;
      V)
        if [[ "$debug_var_regex" ]]; then
          echo "# Showing vars matching $debug_var_regex" >&$fd_original_err
          eval "declare -p | grep ' $debug_var_regex.*='" >&$fd_original_err 
        else
          echo "# Showing all vars" >&$fd_original_err
          eval "declare -p" >&$fd_original_err 
        fi
        no_follow_once=t
        ;;
      w)
        echo >&$fd_original_err
        local new_watch w
        read -u $fd_original_in -e -p "Watch: " new_watch >&$fd_original_err
        debug_set_watch "$new_watch"
        debug_save_state
        no_follow_once=t
        ;;
      x)
        echo >&$fd_original_err
        local v
        read -u $fd_original_in -e -p "Hex Display: " v >&$fd_original_err
        if [[ "$v" ]]; then
          eval 'echo -n "$'${v#\$}'" | xxd' >&$fd_original_err || true
        fi
        no_follow_once=t
        ;;
      z)
        echo >&$fd_original_err
        zombie_lap_summary
        no_follow_once=t
        ;;
      Z)
        if [[ $zombie_lap_detail == t ]]; then
          echo "# zombie_lap_detail=f" >&$fd_original_err
          zombie_lap_detail=f
        else
          echo "# zombie_lap_detail=t" >&$fd_original_err
          zombie_lap_detail=t
        fi
        ;;
      \!)
        echo "# resetting bind vars" >&$fd_original_err
        bind "$debug_bind_vars"
        ;;
      \()
        (( debug_expansion-- ))
        if (( debug_expansion < 0 )); then
          debug_expansion=0
        fi
        debug_display_command_expansion_status
        debug_save_state
        no_follow_once=t
        ;;
      \))
        if (( no_trace_depth > 0 )); then
          no_trace_depth=0
          echo "# Resetting no_trace_depth to 0" >&$fd_original_err
        else
          (( debug_expansion++ ))
          if (( debug_expansion > 3 )); then
            debug_expansion=3
          fi
          debug_display_command_expansion_status
        fi
        debug_save_state
        no_follow_once=t
        ;;
      -)
        debug_move_up_stack
        no_follow_once=t
        ;;
      _)
        debug_move_down_stack
        no_follow_once=t
        ;;
      =)
        echo "# Running until this line is reached again" >&$fd_original_err
        debug_stop_at="$raw_debug_path_to_source_file $debug_line_num"
        debug_r=0
        debug_long_command=t
        debug_subshell=t
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=f
        debug_save_state
        ;;
      \[)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Condition (brackets optional): " debug_condition >&$fd_original_err
        if [[ "${debug_condition:-}" ]]; then
          debug_condition_old=$debug_condition
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        fi
        ;;
      \{)
        if [[ "${debug_condition_old:-}" ]]; then
          echo "# Repeating search for $debug_condition_old" >&$fd_original_err
          debug_condition=${debug_condition_old:-}
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        else
          echo "# No previous condition." >&$fd_original_err
          no_follow_once=t
        fi
        ;;
      \])
        echo "# Running until a new function is reached" >&$fd_original_err
        (( debug_max_depth++ ))
        debug_step_to_next_function=t
        debug_subshell=t
        debug_r=0
        debug_save_state
        ;;
      \})
        echo "# Running until a new file is reached" >&$fd_original_err
        (( debug_max_depth++ ))
        debug_step_to_next_file=t
        debug_subshell=t
        debug_r=0
        debug_save_state
        ;;
      \\)
        echo "# Running until a high level function is reached" >&$fd_original_err
        (( debug_max_depth++ ))
        debug_r=0
        debug_long_command=t
        debug_step_to_hi_function=t
        debug_save_state
        debug_untrap=t
        ;;
      \|)
        if [[ $silent_command == f ]]; then
          echo "# Adding $debug_current_function to function ignore list" >&$fd_original_err
        fi
        debug_ignore+="$debug_current_function "
        debug_r=0
        debug_stepping=t
        debug_save_state
        ;;
      @)
        echo >&$fd_original_err
        echo "$raw_debug_path_to_source_file" >&$fd_original_err
        no_follow_once=t
        ;;
      \#)
        if [[ $debug_show_time == f ]]; then
          debug_show_time=t
          #PS4='$EPOCHREALTIME + '
          echo "# Enabled time stamps" >&$fd_original_err
        else
          debug_show_time=f
          #PS4='+ '
          echo "# Disabled time stamps" >&$fd_original_err
        fi
        debug_save_state
        no_follow_once=t
        ;;
      \$)
        echo "# Entering debug shell" >&$fd_original_err
        debug_shell
        no_follow_once=t
        ;;
      \%)
        if [[ $debug_trace_time == f ]]; then
          debug_trace_time=t
          echo "# Enabled time tracing" >&$fd_original_err
        else
          debug_trace_time=f
          echo "# Disabled time tracing" >&$fd_original_err
        fi
        debug_save_state
        no_follow_once=t
        ;;
      ^)
        if [[ $debug_follow_source == t ]]; then
          echo "# Follow source is now off" >&$fd_original_err
          debug_follow_source=f
        else
          echo "# Follow source is now on" >&$fd_original_err
          debug_follow_source=t
        fi
        debug_save_state
        ;;
      \>)
        if [[ $debug_expanded_search == t ]]; then
          echo "# Expanded search is now off" >&$fd_original_err
          debug_expanded_search=f
        else
          echo "# Expanded search is now on" >&$fd_original_err
          debug_expanded_search=t
        fi
        debug_save_state
        ;;
      \?)
        echo >&$fd_original_err
        echo >&$fd_original_err
        echo "a  display array" >&$fd_original_err
        echo "A  display previously shown array" >&$fd_original_err
        echo "b  restart command, going back to beginning of debug_id of current stack frame. (only works if the script running this is deterministic)" >&$fd_original_err
        echo "B  restart command, like b, but one debug_id earlier" >&$fd_original_err
        echo "c  list debug_list_window/2 lines of source code before and after current line" >&$fd_original_err
        echo "C  continue execution without stopping" >&$fd_original_err
        echo "d  display an expression with variables substituted" >&$fd_original_err
        echo "D  repeat last display command" >&$fd_original_err
        echo "e  evaluate an expression" >&$fd_original_err
        echo "E  repeat last eval expression command" >&$fd_original_err
        echo "f  repeat previous deep or shallow search" >&$fd_original_err
        echo "g  continue until the given function is reached" >&$fd_original_err
        echo "G  continue until the previously given function is reached" >&$fd_original_err
        echo "h  toggle syntax highlighting" >&$fd_original_err
        echo "i  next instruction, stepping into function calls" >&$fd_original_err
        echo "j  jump ahead: shallow substring find" >&$fd_original_err
        echo "J  repeat previous jump" >&$fd_original_err
#        echo "k  skip current command" >&$fd_original_err
        echo "l  list next debug_list_window (default 20) lines of source code" >&$fd_original_err
        echo "L  list previous debug_list_window (default 20) lines of source code" >&$fd_original_err
        echo "n  next line of code (even if it resolves to several different statements)," >&$fd_original_err
        echo "   not stepping into function calls" >&$fd_original_err
        echo "   WARNING: In the rare case that the debugger hangs after this command is run on a line of code, exit (control-c) and start over" >&$fd_original_err
        echo "   the debugging, except when you get to this line, press 's' to do a small step first, and then 'n' and usually it will work" >&$fd_original_err
        echo "N  continue executing until we reach a line later than the current line, completing loops if needed" >&$fd_original_err
        echo "o  step out from the current function" >&$fd_original_err
        echo "p  print variables in current line" >&$fd_original_err
        echo "P  print conditional test results of current line" >&$fd_original_err
        echo "q  quit: exit the program entirely" >&$fd_original_err
        echo "r  show full call stack" >&$fd_original_err
        echo "R  rewind: go back to the start of the last looping / try block" >&$fd_original_err
        echo "s  execute next small statement, even if multiple statements are on a line," >&$fd_original_err
        echo "   not stepping into function calls" >&$fd_original_err
        echo "s  execute next small statement, even if multiple statements are on a line," >&$fd_original_err
        echo "   stepping into function calls like the i command" >&$fd_original_err
        echo "t  show medium level call stack" >&$fd_original_err
        echo "T  show high level call stack" >&$fd_original_err
        echo "u  unignore: remove given function from ignore list" >&$fd_original_err
        echo "U  unignore all functions" >&$fd_original_err
        echo "v  dump vars matching a regex" >&$fd_original_err
        echo "V  repeat last v command" >&$fd_original_err
        echo "w  set or clear current watched expression. Expression can contain any string expression which can be given to echo as an argument." >&$fd_original_err
        echo "x  hex display of a variable" >&$fd_original_err
        echo "z  display zombie_lap_summary" >&$fd_original_err
        echo "Z  toggle zombie_lap_detail" >&$fd_original_err
        echo "!  reset tty / bind variables" >&$fd_original_err
        echo "@  show full path of file containing source being executed" >&$fd_original_err
        echo "#  add timestamps to each debug trace line" >&$fd_original_err
        echo "$  enter debug shell" >&$fd_original_err
        echo "%  toggle time tracing for debug steps" >&$fd_original_err
        echo "^  toggle source following (displays source context after every command)" >&$fd_original_err
        echo "(  reduce command expansion level. Command expansion shows what the shell previously executed" >&$fd_original_err
        echo ")  increase command expansion level. Will instead reset no_trace_depth if it is set." >&$fd_original_err
        echo "-  move up stack one position and show source" >&$fd_original_err
        echo "_  move down stack one position and show source" >&$fd_original_err
        echo "=  continue until the current line is reached again at the same stack depth" >&$fd_original_err
        echo "[  continue until a given [[ ]] or (( )) condition is met" >&$fd_original_err
        echo "]  continue until we reach a different function" >&$fd_original_err
        echo "}  continue until we reach a different file" >&$fd_original_err
        echo "\  continue until we reach a high level function (begin_function_hi)" >&$fd_original_err
        echo "|  add current function to jump ignore list, so using ] will not hit this function again" >&$fd_original_err
        echo ">  toggle expanded search mode, which enables searching on evaluated string expressions" >&$fd_original_err
        echo "/  continue until a line contains the substring given" >&$fd_original_err
        echo "   put a ~ at the beginning of the search string to do a regex search" >&$fd_original_err
        echo >&$fd_original_err
        no_follow_once=t
        ;;
      *)
        echo "# Unknown command" >&$fd_original_err
        echo "Press ? for a list of commands" >&$fd_original_err
        no_follow_once=t
        ;;
    esac
  done

  if [[ $debug_show_time == t ]]; then
    debug_start_ts=${EPOCHREALTIME/./}
  fi

  if [[ $debug_trace_time == t ]]; then
    trace_time=t
    timebox=debug_step timebox_open
  fi

}

debug_update_expansion() {
  if [[ $debug_recording_trace == f && debug_expansion -gt 0 ]]; then
    debug_recording_trace=t
    [[ $debug_debug == t ]] && echo "${CYAN}debug_debug: Starting debug output expansion${RESET}" >&$fd_original_err
    if [[ ! "${fd_bash_trace:-}" ]]; then
      exec {fd_bash_trace}>"$debug_out_path"
    else
      eval "exec ${fd_bash_trace}>\"$debug_out_path\""
    fi
    (( tracing_depth++ ))
    debug_original_tracefd=${BASH_XTRACEFD:-}
    BASH_XTRACEFD=$fd_bash_trace
  fi
}

debug_get_ok_to_debug() {
  if [[ $debug_immediate == t ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_immediate${RESET}" >&$fd_original_err
    ok_to_debug=t

  elif [[ -n "$debug_line" \
          && -z "$file_part" \
          && "$debug_line_num" -eq "$line_part" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_line${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_line_old=$debug_line
    debug_line=

  elif [[ -n "$debug_line" \
          && -n "$file_part" \
          && ( \
             "$debug_line_num" -eq "$line_part" \
             && "$debug_source_file" == "$file_part" \
             ) \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_line${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_line_old=$debug_line
    debug_line=

  elif [[ $debug_stepping == t \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_stepping${RESET}" >&$fd_original_err
    debug_stepping=f
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ "$debug_condition" ]]; then
    local condition=$debug_condition
    if [[ "$condition" != \[* && "$condition" != \(* ]]; then
      condition="[[ $condition ]]"
    fi
    condition+=" && ok_to_debug=t"
    eval "$condition"
    if [[ $ok_to_debug == t ]]; then
      debug_condition=
    fi

  elif [[ "$debug_function" \
          && $debug_function == $debug_current_function \
          || "$debug_search" \
          && $debug_search == $debug_current_function \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_function${RESET}" >&$fd_original_err
    if [[ "$debug_function" ]]; then
      debug_function_old=$debug_function
      debug_search_old=$debug_function
      debug_function=
    else
      debug_search_old=$debug_search
      debug_search=
    fi
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ "$debug_search" \
          && ( \
             $debug_search_deep == t \
             || $debug_current_depth -le $debug_max_depth \
             ) \
          && ( " $debug_command " =~ $debug_search \
             || " $expanded_command " =~ $debug_search \
             ) \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_search${RESET}" >&$fd_original_err
    debug_search=
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ $debug_step_to_next_line == t \
          && "$raw_debug_path_to_source_file $debug_line_num" != "$debug_last_location" \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_line${RESET}" >&$fd_original_err
    ok_to_debug=t

  elif [[ $debug_step_to_later_line == t \
          && "$debug_line_num" -gt "$debug_prev_line" \
          && $debug_current_function != none \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_later_line${RESET}" >&$fd_original_err
    debug_step_to_later_line=f
    ok_to_debug=t

  elif [[ "$debug_stop_at" \
          && "$raw_debug_path_to_source_file $debug_line_num" == "$debug_stop_at" \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_stop_at${RESET}" >&$fd_original_err
    debug_max_depth=$debug_current_depth
    debug_stop_at=
    ok_to_debug=t

  elif [[ $debug_step_to_next_function == t \
          && "$debug_current_function" != "$debug_prev_function" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_function${RESET}" >&$fd_original_err
    debug_step_to_next_function=f
    ok_to_debug=t

  elif [[ $debug_step_to_next_file == t \
          && "$debug_current_function" != "$debug_prev_function" \
          && "$debug_source_file" != "$debug_prev_source_file" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_file${RESET}" >&$fd_original_err
    debug_step_to_next_file=f
    ok_to_debug=t

  fi
}

maybe_enable_debug_tracing() {
  if (( debug_expansion > 0 
        && ${no_trace_depth:-0} <= 0 \
     )); then
    if [[ $debug_expansion == 1 \
          && $debug_current_depth -le $debug_max_depth \
          || $debug_expansion -ge 2 ]]; then
      debug_tracing=t
      [[ $debug_debug == t ]] && echo "${CYAN}debug_tracing=$debug_tracing${RESET}" >&$fd_original_err
      no_trace_depth=0
    fi
  fi
}

debug_show_extra_backlog() {
  if [[ "$debug_prev_command" =~ for\ (.*)\ in\  || "$debug_prev_command" =~ case\ \$(.*)\ in\  ]]; then
    local w=${BASH_REMATCH[1]}
    local w=${w#\$}
    eval "local s=\"+ \$w=\$$w\""
    echo "$s" >&$fd_original_err
  fi

  if [[ $debug_prev_command =~ ^\ *(\$?[a-zA-Z_0-9]+)\+?=\((.*)\) ]]; then
    local w=${BASH_REMATCH[1]}
    if [[ "$w" == \$* ]]; then
      w=${w#\$}
      w=${!w}
    fi
    local v=( ${BASH_REMATCH[2]} )
    if [[ "${#v[*]}" -gt 0 ]]; then
      eval "local s=\"+ \$w=( \${$w[*]} )\""
      echo "$s" >&$fd_original_err
    fi
  fi

  if [[ $debug_prev_command =~ ^\ *\(\(\ *([a-zA-Z_0-9]+)(--|\+\+|\ ?=.*)\ *\)\) ]]; then
    local w=${BASH_REMATCH[1]}
    eval "local s=\"+ \$w=\$$w\""
    echo "$s" >&$fd_original_err
  fi

  if [[ $debug_prev_command =~ (\[\[.*\]\]) && ! "$debug_buffered_commands" ]]; then
    local condition=${BASH_REMATCH[1]}
    eval "$condition && echo \"+ => true\" || echo \"+ => false\"" >&$fd_original_err
  fi

  if [[ $debug_prev_command =~ if\ (\(\(.*\)\))\;\ then && ! "$debug_buffered_commands" ]]; then
    local condition=${BASH_REMATCH[1]}
    eval "$condition && echo \"+ => true\" || echo \"+ => false\"" >&$fd_original_err
  fi

  if [[ "${debug_return_vars:-}" ]]; then
    local __var
    for __var in $debug_return_vars; do
      local -n __val=$__var
      if [[ -v __val ]]; then
        local __v=$__val
        if [[ "${__v:-}" ]] && is_array __val; then
          local -n __array=$__var
          local __i __count=${#__array[*]} __max=10 __short_mode=t __result=
          if (( __count < 10 )); then
            __max=$__count
          fi
          if (( ${#__array[0]} > 20 )); then
            __short_mode=f
          fi
          for ((__i = 0; __i < __max; __i++)); do
            __v=${__array[$__i]}
            shell_quote_var __v
            if (( ${#__v} < 20 )); then
              __result+=" $__v"
            else
              __short_mode=f
              echo "+ $__var[$__i]=$__v" >&$fd_original_err
            fi
          done
          if [[ $__short_mode == f ]]; then
            echo "+ $__var __count=$__count" >&$fd_original_err
          else
            echo "+ $__var[*]=( ${__result# } )" >&$fd_original_err
          fi
        else
          shell_quote_var __v
          echo "+ $__var=$__v" >&$fd_original_err
        fi
      fi
    done
    debug_return_vars=
  fi

}

debug_inner() {
  local saved_bash_source=( "${BASH_SOURCE[@]:2}" ) \
    saved_bash_lineno=( "${BASH_LINENO[@]:2}" ) \
    saved_funcname=( "${FUNCNAME[@]:2}" ) \

  local stack_size=${#saved_funcname[*]}

  if [[ $debug_trace_time == t ]]; then
    timebox_close
    trace_time=f
    trace_time_summarize
  fi

  if [[ $debug_skip_ignore == t ]]; then
    debug_skip_ignore=f
    if [[ "$debug_ignore" == *" $debug_current_function "* ]]; then
      debug_ignore_remove "$debug_current_function" 
    fi
  fi

  debug_last_location="$raw_debug_path_to_source_file $debug_line_num"
  debug_source_update_hl

  local backlog=
  if [[ $debug_path_to_source_file != none && "$debug_prev_function" == "$debug_current_function" && "$((debug_prev_line+1))" -lt "$debug_line_num" ]]; then
    local start_line=$((debug_prev_line+1))
    local end_line=$((debug_line_num-1))
    backlog=$(sed -n "$start_line,${end_line}p;${end_line}q" "$debug_path_to_source_file")
  fi

  debug_prev_line="$debug_line_num"
  debug_prev_function=$debug_current_function
  debug_prev_source_file=$debug_source_file
  debug_step_to_next_function=f
  debug_step_to_next_file=f
  debug_step_to_hi_function=f

  debug_show_extra_backlog

  local display_command=$debug_command
  local raw_display_command=$display_command
  if [[ $debug_step_to_next_line == t || $debug_long_command == t ]] \
     && [[ $debug_current_function != none ]] \
     && [[ $debug_path_to_source_file != none ]]; then
    display_command=$(sed -E -n "${debug_line_num}{s/^ *(.*)/\\1/;p;q;}" "$debug_path_to_source_file")
    raw_display_command=$(sed -E -n "${debug_line_num}{s/^ *(.*)/\\1/;p;q;}" "$raw_debug_path_to_source_file")
  fi

  debug_step_to_next_line=f
  debug_prev_command=$raw_display_command

  local user_interacted=f
  debug_command_loop
  if [[ $user_interacted == t ]]; then
    debug_immediate=f
  fi

  if [[ $debug_untrap == t ]]; then
    debug_tracing=f
    debug_expansion=0
    debugging=f
  fi

  [[ $debug_exit == t ]] && exit 0

  return 0
}

debug_trap() {
  debug_saved_shell_options_short=$-
  set +evTu +o pipefail

  debug_rematch=( "${BASH_REMATCH[@]}" )

  local saved_in saved_out saved_err
  : {saved_in}<&0 {saved_out}>&1 {saved_err}>&2
  : <&$fd_original_in >&$fd_original_out 2>&$fd_original_err

  local saved_lineno
  (( saved_lineno = debug_trap_first_line - 1 )) 

  if [[ "${debug_var:-}" ]]; then
    local v=${!debug_var}
    if [[ "${debug_var_old:-}" != "$v" ]]; then
      echo "${CYAN}debug_id=$fork_debug_id $debug_var=$v ${FUNCNAME[1]}$RESET" >&$fd_original_err
    fi
    debug_var_old=$v
  fi

  tracing_depth=0
  local debug_r=0

  if (( ${trace_debugger:-0} > 0 )); then 
    set -x
    BASH_XTRACEFD=2
    (( trace_debugger-- ))
  fi

  if [[ $debug_debug == t ]]; then
    log_debug_debug "debug_id=$fork_debug_id ${BASH_SOURCE[1]:-no_source}:$saved_lineno/${BASH_LINENO[1]:-no_line} ${FUNCNAME[1]:-no_func} ${BASH_COMMAND}" 
  fi

  local debug_path_to_source_file \
    raw_debug_path_to_source_file="${BASH_SOURCE[1]:-none}" \
    debug_line_num=$saved_lineno \
    debug_current_function=${FUNCNAME[1]:-none} \
    debug_command=${BASH_COMMAND} \
    debug_current_depth=${#FUNCNAME[*]} \
    IFS=' '$'\n'$'\t' \
    debug_full_path=${debug_full_path:-f} \
    debug_source_file \

  debug_tracing=f
  [[ $debug_debug == t ]] && echo "${CYAN}debug_tracing=$debug_tracing${RESET}" >&$fd_original_err
  local prev_debug_out_path=$debug_out_path
  debug_out_path=$tmp_folder/debug-out.$BASHPID
  if [[ "$prev_debug_out_path" != $debug_out_path && -v cleanup_on_exit ]]; then
    defer "rm $debug_out_path"
  fi
  debug_recording_trace=f

  if [[ "$debug_ignore" == *" $debug_current_function "* && $debug_skip_ignore == f ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Ignoring $debug_current_function${RESET}" >&$fd_original_err
    debug_output_stop
    return 0
  fi

  debug_load_state || return 1

  [[ $debug_exit == t ]] && exit 1

  debug_rewind=f

  debug_source_update

  local line_part=$debug_line file_part=
  if [[ "$debug_line" ]]; then
    if [[ $debug_line == *:* ]]; then
      line_part=${debug_line##*:}
      file_part=${debug_line%:*}
    fi
  fi

  local expanded_command= fixed_command=
  if [[ "$debug_search" ]]; then
    if [ "$debug_expanded_search" == t ]; then
      fixed_command=${debug_command}
      fixed_command=${fixed_command//\\/**BS**}
      fixed_command=${fixed_command//\\\$/\\\\\$}
      # temporarily hide this so we can keep $(( but transform $(
      fixed_command=${fixed_command//\$((/{{{}
      fixed_command=${fixed_command//\$(/\\\$(}
      # restore {{{ to $((
      fixed_command=${fixed_command//{{{/\$((}
      fixed_command=${fixed_command//\"/\\\"}
      fixed_command=${fixed_command//\*\*BS\*\*/\\}
      eval "expanded_command=\"$fixed_command\"" &>/dev/null || true
    fi
  fi

  local ok_to_debug=f
  debug_get_ok_to_debug

  debug_output_expansion

  if [[ $ok_to_debug == t ]]; then
    debug_inner
  else
    [[ $debug_debug == t ]] && echo "${CYAN}Not stopping.${RESET}" >&$fd_original_err
    debug_output_stop
  fi

  debug_update_expansion
  maybe_enable_debug_tracing
  debug_list_stack_pos=0

  [[ $debug_subshell == t ]] && set -T
  [[ $debug_saved_shell_options_short == *e* ]] && set -e
  [[ $debug_saved_shell_options_short == *u* ]] && set -u

  BASH_REMATCH=( "${debug_rematch[@]}" )
  : <&$saved_in >&$saved_out 2>&$saved_err
  return $debug_r
}

set_return_code() {
  if [[ $debug_tracing == t ]]; then
    set -x
  fi
  return $1
}

reserve_tmp_file() {
  local var=$1; shift
  local base=${1:-$var}; shift
  
  local internal_tmp_file=$(mktemp $tmp_folder/$base.$$.XXXXXX)
  eval "$var=$internal_tmp_file"
  eval "cleanup_on_exit+='rm ${internal_tmp_file} &>/dev/null || true;'"
}

show_array() {
  local -n array=$1
  local i size=${#array[*]}
  echo "size=$size" >&$fd_original_err
  for i in "${!array[@]}"; do
    echo "$i: ${array[$i]}" >&$fd_original_err
  done
}

debugger_init() {
  local first_run=${first_run:-t}
  # used by debugger, in case input or output is redirected from somewhere else during debugging
  if [[ ! -v fd_original_in ]]; then
    : {fd_original_in}<&0
    : {fd_original_out}>&1
    : {fd_original_err}>&2
    : {fd_original_trace}>&${fd_trace:-2}
  fi

  debug_output=${debug_output:-f}
  debug_ignore=${debug_ignore:-}
  tracing_depth=${tracing_depth:-0}
  tmp_folder=${tmp_folder:-/tmp}
  debug_state_file=$tmp_folder/debug-state-$$
  debug_id_current=0
  debugger_available=t
  debug_list_stack_pos=0
  debug_bisect_min=
  debug_bisect_max=
  fork_id_current=
  fork_debug_id=0

  if [[ "$first_run" == t ]]; then
    rm $tmp_folder/debug-* $tmp_folder/side-log-* &>/dev/null || true
  fi

  # used to debug complex debugger internal issues
  side_log_file=$tmp_folder/side-log-$$

  COLUMNS=${COLUMNS:-120}

  if [[ ! "${debug_highlight:-}" ]]; then
    if which source-highlight >/dev/null; then
      debug_highlight=t
    else
      debug_highlight=f
    fi
  fi

  if [[ $debug_highlight == t ]]; then
    if ! which source-highlight >/dev/null; then
      fatal "You set debug_highlight=t, but are missing the highlight command."
      fatal "You can use 'brew install highlight' to install it if you want."
      exit 1
    fi

    rm -rf $tmp_folder/debug_highlight &>/dev/null
    mkdir -p $tmp_folder/debug_highlight || exit 1
  fi

  debug_setup
}

log_debug_debug() {
  echo "${CYAN}debug_debug: $*$RESET" >&$fd_original_err
}

debug_start() {
  debug_buffered_commands=$*
  no_trace_depth=0
  parallel_execution=${p_par:-f}
  if [[ ! -v debugging ]]; then
    debugger_init || return 1
  fi
  if [[ $debugging == f ]]; then
    # export \
    debugging=t \
    debug=${debug:-} \
    debug_condition=${debug_condition:-} \
    debug_condition_old=${debug_condition_old:-} \
    debug_debug=${debug_debug:-f} \
    debug_dir=$PWD \
    debug_display=${debug_display:-none} \
    debug_exit=${debug_exit:-f} \
    debug_expanded_search=${debug_expanded_search:-f} \
    debug_expansion=${debug_expansion:-1} \
    debug_expression=${debug_expression:-echo none} \
    debug_expanded_search=${debug_expanded_search:-f} \
    debug_follow_source=${debug_follow_source:-t} \
    debug_function=${debug_function:-} \
    debug_function_old=${debug_function_old:-} \
    debug_id=${debug_id:-t} \
    debug_immediate=t \
    debug_last_location=${debug_last_location:-} \
    debug_line=${debug_line:-} \
    debug_line_old=${debug_line_old:-} \
    debug_list_dir=${debug_list_dir:-none} \
    debug_list_offset=${debug_list_offset:-0} \
    debug_list_stack_pos=${debug_list_stack_pos:-0} \
    debug_list_window=${debug_list_window:-20} \
    debug_long_command=${debug_long_command:-f} \
    debug_max_depth=${debug_max_depth:-999} \
    debug_original_tracefd=${debug_original_tracefd:-${BASH_XTRACEFD:-}} \
    debug_prev_command=${debug_prev_command:-none} \
    debug_prev_function=${debug_prev_function:-none} \
    debug_prev_line=${debug_prev_line:-0} \
    debug_search_old=${debug_search_old:-} \
    debug_show_time=${debug_show_time:-f} \
    debug_trace_time=${debug_trace_time:-f} \
    debug_prev_source_file=${debug_prev_source_file:-none} \
    debug_quick_function=${debug_quick_function:-} \
    debug_restart_command= \
    debug_rewind=${debug_rewind:-f} \
    debug_saved_params=${debug_saved_params:-} \
    debug_saved_shell_options=${debug_saved_shell_options:-} \
    debug_search=${debug_search:-} \
    debug_search_deep=${debug_search_deep:-t} \
    debug_skip_ignore=${debug_skip_ignore:-t} \
    debug_step_to_later_line=${debug_step_to_later_line:-f} \
    debug_step_to_next_file=${debug_step_to_next_file:-f} \
    debug_step_to_next_function=${debug_step_to_next_function:-f} \
    debug_step_to_hi_function=${debug_step_to_hi_function:-f} \
    debug_step_to_next_line=${debug_step_to_next_line:-f} \
    debug_stepping=${debug_stepping:-f} \
    debug_stop_at=${debug_stop_at:-} \
    debug_subshell=${debug_subshell:-f} \
    debug_untrap=f \
    debug_var=${debug_var:-} \
    debug_var_regex=${debug_var_regex:-} \
    new_debug_watch=${debug_watch:-${debug_var:-${trace_var:-}}} \

    debug_set_watch "$new_debug_watch"

    trap '
      set +x
      echo "PIPE signal was fired." >&$fd_original_err
      stack_trace
      BASH_XTRACEFD=
      debug_start
      ' PIPE
    shopt -s extdebug
    trap '
      set +x; debug_trap_first_line=${LINENO:-0} 
      debug_saved_params=( "$@" )
      debug_trap
      debug_rc=$?
      [[ $debug_untrap == t ]] && trap - DEBUG
      [[ $debug_rewind == t ]] && continue
      set_return_code $debug_rc
      ' DEBUG
  else
    debug_immediate=t
  fi
}

debug() {
  local function_to_debug=$*
  if [[ "$function_to_debug" ]]; then
    debug_start
    $function_to_debug
  else
    debug_start
  fi
}

debug_setup() {
  debugging=f

  if [[ "${debug_unignore:-}" ]]; then
    debug_ignore_remove "$debug_unignore"
  fi

  : ${debug_bisect:=${bisect:-}}
  if [[ "$debug_bisect" ]]; then
    if [[ "$debug_bisect" == *..* ]]; then
      debug_bisect_min=${debug_bisect%..*}
      debug_bisect_max=${debug_bisect#*..}
      if (( debug_bisect_max == debug_bisect_min )); then
        debug_id=$debug_bisect_max
        echo "  ${CYAN}Not bisecting since we are already at a single id${RESET}" >&$fd_original_err
      else
        debug_id=$(( (debug_bisect_max - debug_bisect_min) / 2 + debug_bisect_min ))
        echo "  ${CYAN}Will bisect $debug_bisect_min to $debug_bisect_max at $debug_id${RESET}" >&$fd_original_err
      fi
    else
      echo "Invalid bisect value. Must be a range with .. between, like 5..100" >&$fd_original_err
      exit 1
    fi
  fi

  debug=${debug:-f}
  if [[ $debug != f \
     || "${debug_search:-}" \
     || "${debug_search_deep:-}" \
     || "${debug_id:-}" && ! "${debug_at_log_id:-}" \
     || "${debug_var:-}" \
     || "${debug_function:-}" \
     || "${debug_quick_function:-}" \
     || "${debug_line:-}" ]]; then

    if [[ "$debug" && $debug != t && $debug != f ]]; then
      if [[ "$debug" == *:* ]]; then
        debug_line=$debug
      elif [[ "$debug" =~ ^[0-9\.]+$ ]]; then
        debug_id=$debug
      elif [[ "$debug" == =* ]]; then
        debug_search=${debug#=}
      elif [[ "$debug" == \? ]]; then
        debug_id_out=t
      else
        debug_quick_function=$debug
        debug_function_old=$debug_quick_function
      fi
      debug=f
    fi

    if [[ "${debug_search:-}" == =* ]]; then
      debug_search=${debug_search#=}
      debug_expanded_search=t
    fi

    if [[ "${debug_search:-}" ]]; then
      if [[ "$debug_search" == ~* ]]; then
        # use unescaped to support regex if expression starts with ~
        debug_search=${debug_search#\~}
      else
        debug_search=${debug_search//\\/\\\\}
        debug_search=${debug_search//\$/\\\$}
        debug_search=${debug_search//[/\\[}
      fi
      echo "  ${CYAN}Will debug when code is found to contain: $debug_search${RESET}" >&$fd_original_err
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
    fi

    if [[ "${debug_quick_function:-}" ]]; then
      echo "  ${CYAN}Will debug starting at function: $debug_quick_function${RESET}" >&$fd_original_err
      debug_id=t
    fi

    if [[ "${debug_function:-}" ]]; then
      echo "  ${CYAN}Will debug starting at function: $debug_function${RESET}" >&$fd_original_err
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
      if [[ "$debug_ignore" == *" $debug_function "* ]]; then
        local left_side=${debug_ignore% $debug_function *}
        local right_side=${debug_ignore#* $debug_function }
        debug_ignore=" $left_side $right_side "
      fi
    fi

    if [[ "${debug_line:-}" ]]; then
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
    fi

    if [[ "${debug_var:-}" ]]; then
      echo "  ${CYAN}Will debug var $debug_var" >&$fd_original_err
      debug_subshell=t
    fi

    if [[ "${debug_id:-}" ]]; then
      if [[ "$debug_id" != t ]]; then
        echo "  ${CYAN}Will debug starting at debug_id $debug_id or later${RESET}" >&$fd_original_err
      fi
      debug_subshell=t
    fi

    debug_search_old=${debug_search_old:-${debug_search:-}}

    if [[ $debug != t ]]; then
      debug_immediate=f
    fi

    if [[ ! "${debug_id:-}" ]]; then
      debug_start
    fi

  fi
}

