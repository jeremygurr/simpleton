#!/bin/bash

type -t debugger_init >/dev/null && return 0
shopt -s expand_aliases   # make sure aliases are expanded even for non-interactive scripts

######################################################
# BASH Debugger
# At beginning of script you wish to debug: 
#   source this file. example: source /home/my_user/repos/bash-debugger
#   execute debug in the code where you wish to begin debugging.
# press '?' for list of commands while debugging
# If you want to get syntax highlighting working, install source-highlight
#   example for mac: brew install source-highlight
######################################################

if [[ ${BASH_VERSINFO:-} -lt 5 ]]; then
  echo "You must run this script with at least bash version 5." >&2
  echo "If you already have a correct version of bash in your path, you may need to put:" >&2
  echo "  #!/usr/bin/env bash" >&2
  echo "at the top of your script that you want debugged" >&2
  exit 1
fi

NL=$'\n'
TAB=$'\t'

   LIGHT_RED=$'\033[0;31m'
         RED=$'\033[1;31m'
 LIGHT_GREEN=$'\033[0;32m'
       GREEN=$'\033[1;32m'
LIGHT_YELLOW=$'\033[0;33m'
      YELLOW=$'\033[1;33m'
  LIGHT_BLUE=$'\033[0;34m'
        BLUE=$'\033[1;34m'
LIGHT_PURPLE=$'\033[0;35m'
      PURPLE=$'\033[1;35m'
  LIGHT_CYAN=$'\033[0;36m'
        CYAN=$'\033[1;36m'
 LIGHT_WHITE=$'\033[0;37m'
       WHITE=$'\033[1;37m'
 LIGHT_BLACK=$'\033[0;38m'
       BLACK=$'\033[1;38m'
       RESET=$'\033[0m'
  CLEAR_LINE=$'\033[2K\r'
       CLEAR=$'\033[2J'
CLEAR_SCREEN=$'\033[2J\r\033[H'
   CURSOR_UP=$'\033[1A'
     REVERSE=$'\033[7m'

side_log() {
  echo "$*" >>$side_log_file
}

debug_expansion_clean() {
  local line shortest= plusses code plus_length from=$1
  while read -r line || true; do
    if [[ "$line" =~ ^(\++)\ (.*) ]]; then
      plusses=${BASH_REMATCH[1]}
      code=${BASH_REMATCH[2]}
      plus_length=${#plusses}
      if [[ ! "$shortest" ]]; then
        shortest=$((plus_length-1))
      elif [[ $plus_length == $shortest ]]; then
        if [[ "$code" != "set +x" && \
              "$code" != "set -x" ]]; then
          echo "+ $code"
        fi
      fi
    elif [[ "$line" ]]; then
      echo "$line"
    else
      break
    fi
  done < <(cat "$from")
  return 0
}

debug_output_reversed_line() {
  echo -n "$REVERSE" >&$fd_original_err
  local line=$(sed -E -n "${debug_line_num}p;${debug_line_num}q" "$raw_debug_path_to_source_file")
  local pad_size line_length=${#line}
  (( pad_size = COLUMNS - line_length ))
  echo -n "$line" >&$fd_original_err
  printf %${pad_size}s >&$fd_original_err
  echo "$RESET" >&$fd_original_err
}

debug_display_source() {
  raw_debug_path_to_source_file=${saved_bash_source[$debug_list_stack_pos]}
  if (( debug_list_stack_pos > 0 )); then
    debug_line_num=${saved_bash_lineno[$((debug_list_stack_pos-1))]}
  else
    debug_line_num=$saved_lineno
  fi
  debug_current_function=${saved_funcname[$debug_list_stack_pos]:-}

  debug_source_update
  if [[ "$debug_path_to_source_file" == none ]]; then
    return 0
  fi
  local debug_start_line=$((debug_list_offset+debug_line_num))
  if (( debug_start_line < 1 )); then
    (( debug_list_offset += -debug_start_line + 1 ))
    debug_start_line=1
  fi
  local debug_end_line=$((debug_start_line+debug_list_window-1))

  if (( debug_start_line <= debug_line_num && debug_line_num <= debug_end_line )); then
    if (( debug_start_line < debug_line_num )); then
      sed -n "$debug_start_line,$((debug_line_num-1))p;$((debug_line_num-1))q" "$debug_path_to_source_file" >&$fd_original_err
    fi
    debug_output_reversed_line
    if (( debug_line_num < debug_end_line )); then
      sed -n "$((debug_line_num+1)),${debug_end_line}p;${debug_end_line}q" "$debug_path_to_source_file" >&$fd_original_err
    fi
  else
    sed -n "$debug_start_line,${debug_end_line}p;$((debug_end_line))q" "$debug_path_to_source_file" >&$fd_original_err
  fi
}

debug_load_state() {
  if [[ -f "$debug_state_file" && "${debug_needs_to_load_state:-t}" == t ]]; then
    [[ ${debug_debug:-f} == t ]] && echo "${CYAN}Loading state from $debug_state_file${RESET}" >&$fd_original_err
    debug_needs_to_load_state=f
    source "$debug_state_file" || return 1
  fi
  return 0
}

debug_save_state() {
  # We don't need to save the state if there are no parent shells to recall that state
  if [[ $BASH_SUBSHELL -gt 0 || ${force_save:-f} == t ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Saving debug_state_file${RESET}" >&$fd_original_err
    echo "
debug_buffered_commands='$debug_buffered_commands'
debug_condition='$debug_condition'
debug_condition_old='$debug_condition_old'
debug_display='$debug_display'
debug_exit='$debug_exit'
debug_expanded_search='$debug_expanded_search'
debug_expansion='$debug_expansion'
debug_expression='$debug_expression'
debug_follow_source='$debug_follow_source'
debug_function='$debug_function'
debug_function_old='$debug_function_old'
debug_highlight='$debug_highlight'
debug_id_current='$debug_id_current'
debug_ignore='$debug_ignore'
debug_immediate='$debug_immediate'
debug_line='$debug_line'
debug_line_old='$debug_line_old'
debug_max_depth='$debug_max_depth'
debug_original_tracefd='$debug_original_tracefd'
debug_prev_command='${debug_prev_command//\'/\'\"\'\"\'}'
debug_prev_function='$debug_prev_function'
debug_prev_line='$debug_prev_line'
debug_prev_source_file='$debug_prev_source_file'
debug_search='$debug_search'
debug_search_deep='$debug_search_deep'
debug_search_old='$debug_search_old'
debug_skip_ignore='$debug_skip_ignore'
debug_step_to_later_line='$debug_step_to_later_line'
debug_step_to_next_line='$debug_step_to_next_line'
debug_step_to_next_file='$debug_step_to_next_file'
debug_step_to_next_function='$debug_step_to_next_function'
debug_stepping='$debug_stepping'
debug_stop_at='$debug_stop_at'
debug_subshell='$debug_subshell'
debug_watch='$debug_watch'
PS4='$PS4'" >"$debug_state_file" || return 1
  fi
  return 0
}

debug_ignore_remove() {
  local remove_functions="$*"
  for x in $remove_functions; do
    remove_from_string debug_ignore "$x"
  done
}

debug_source_update() {
  debug_path_to_source_file=$raw_debug_path_to_source_file
  if [[ $debug_path_to_source_file == /dev/fd/* ]]; then
    debug_path_to_source_file=none
  fi

  if [[ $debug_full_path == t ]]; then
    debug_source_file=$debug_path_to_source_file
  else
    debug_source_file=${debug_path_to_source_file##*/}
  fi

  if [[ $debug_highlight == t && $debug_path_to_source_file != none ]]; then

    debug_path_to_source_file=$(cd "$debug_dir"; cd ${debug_path_to_source_file%/*}; pwd)/${debug_path_to_source_file##*/}
    local highlighted_source=$tmp_folder/debug_highlight/${debug_path_to_source_file#/}
    if [ ! -f "$highlighted_source" ]; then
      mkdir -p "${highlighted_source%/*}"
      #cat "$debug_path_to_source_file" | highlight -S shellscript -O ansi >"$highlighted_source"
      cat "$debug_path_to_source_file" | source-highlight -s bash -f esc >"$highlighted_source"
    fi
    debug_path_to_source_file=$highlighted_source

  fi
}

debug_display_command_expansion_status() {
  case $debug_expansion in
    0)
      echo "# Command expansion off" >&$fd_original_err
    ;;
    1)
      echo "# Command expansion basic" >&$fd_original_err
    ;;
    2)
      echo "# Command expansion deep" >&$fd_original_err
    ;;
    3)
      echo "# Command expansion unfiltered" >&$fd_original_err
    ;;
  esac
}

debug_inner() {
  if [[ $debug_skip_ignore == t ]]; then
    debug_skip_ignore=f
    if [[ "$debug_ignore" == *" $debug_current_function "* ]]; then
      debug_ignore_remove "$debug_current_function" 
    fi
  fi

  debug_last_location="$raw_debug_path_to_source_file $debug_line_num"

  local backlog=
  if [[ $debug_path_to_source_file != none && "$debug_prev_function" == "$debug_current_function" && "$((debug_prev_line+1))" -lt "$debug_line_num" ]]; then
    local start_line=$((debug_prev_line+1))
    local end_line=$((debug_line_num-1))
    backlog=$(sed -n "$start_line,${end_line}p;${end_line}q" "$debug_path_to_source_file")
  fi

  debug_prev_line="$debug_line_num"
  debug_prev_function=$debug_current_function
  debug_prev_source_file=$debug_source_file
  debug_step_to_next_function=f
  debug_step_to_next_file=f

  if (( debug_expansion > 0 )); then
    if [[ -f "$debug_out_path" && ! "$debug_buffered_commands" ]]; then

      if (( debug_expansion > 2 )); then
        cat $debug_out_path >&$fd_original_err
      else
        debug_expansion_clean $debug_out_path >&$fd_original_err
      fi

      BASH_XTRACEFD=$debug_original_tracefd

      if [[ $debug_prev_command =~ for\ (.*)\ in\  || $debug_prev_command =~ case\ \$(.*)\ in\  ]]; then
        set +u
        local w=${BASH_REMATCH[1]}
        local w=${w#\$}
        eval "local s=\"+ \$w=\$$w\""
        echo "$s" >&$fd_original_err
        set -u
      fi

      # if [[ $debug_prev_command =~ ^([a-zA-Z_0-9]+)=\$\( ]]; then
      #   set +u
      #   local w=${BASH_REMATCH[1]}
      #   eval "local s=\"+ \$w=\${$w[*]}\""
      #   echo "$s" >&$fd_original_err
      #   set -u
      # fi

      if [[ $debug_prev_command =~ ^\ *(\$?[a-zA-Z_0-9]+)\+?=\((.*)\) ]]; then
        set +u
        local w=${BASH_REMATCH[1]}
        if [[ "$w" == \$* ]]; then
          w=${w#\$}
          w=${!w}
        fi
        local v=( ${BASH_REMATCH[2]} )
        if [[ "${#v[*]}" -gt 0 ]]; then
          eval "local s=\"+ \$w=( \${$w[*]} )\""
          echo "$s" >&$fd_original_err
        fi
        set -u
      fi

      if [[ $debug_prev_command =~ ^\ *\(\(\ *([a-zA-Z_0-9]+)(--|\+\+)\ *\)\) ]]; then
        set +u
        local w=${BASH_REMATCH[1]}
        eval "local s=\"+ \$w=\$$w\""
        echo "$s" >&$fd_original_err
        set -u
      fi

    fi
  elif [[ -f "$debug_out_path" ]]; then
    rm "$debug_out_path"
  fi

  if [[ $debug_prev_command =~ (\[\[.*\]\]) && ! "$debug_buffered_commands" ]]; then
    set +u
    local condition=${BASH_REMATCH[1]}
    eval "$condition && echo \"+ => true\" || echo \"+ => false\"" >&$fd_original_err
    set -u
  fi

  if [[ $debug_prev_command =~ if\ (\(\(.*\)\))\;\ then && ! "$debug_buffered_commands" ]]; then
    set +u
    local condition=${BASH_REMATCH[1]}
    eval "$condition && echo \"+ => true\" || echo \"+ => false\"" >&$fd_original_err
    set -u
  fi

  local display_command=$debug_command
  local raw_display_command=$display_command
  if [[ $debug_step_to_next_line == t || $debug_long_command == t ]] \
     && [[ $debug_current_function != none ]] \
     && [[ $debug_path_to_source_file != none ]]; then
    display_command=$(sed -E -n "${debug_line_num}{s/^ *(.*)/\\1/;p;q;}" "$debug_path_to_source_file")
    raw_display_command=$(sed -E -n "${debug_line_num}{s/^ *(.*)/\\1/;p;q;}" "$raw_debug_path_to_source_file")
  fi

  debug_step_to_next_line=f
  debug_prev_command=$raw_display_command
  debug_immediate=f

  local debug_c debug_array no_follow_once=f
  debug_r=-1
  while [[ $debug_r == -1 ]]; do

    # echo >&$fd_original_err

    local current_source_line_without_comment=none
    if [[ $debug_path_to_source_file != none ]]; then
      current_source_line_without_comment=$(sed -E -n "${debug_line_num}p;${debug_line_num}q" "$raw_debug_path_to_source_file" \
        | sed -E 's/^ *(.*) *$/\1/' \
        | sed -E 's/#.*//'
        )
    fi
    if [[ $debug_follow_source == t && "$current_source_line_without_comment" && ! "$debug_buffered_commands" ]]; then
      if [[ $no_follow_once == t ]]; then
        no_follow_once=f
      else
        echo "$hbar_tilde" >&$fd_original_err
        (( debug_list_offset = -debug_list_window / 2 + 1 )) 
        debug_display_source
        debug_list_dir=forwards
        (( debug_list_offset += debug_list_window - 1 ))
      fi
#    else
#      if [[ "$backlog" ]]; then
#        echo "$backlog"
#        backlog=
#      fi
    fi

    set +u
    if [[ "$debug_watch" && ! "$debug_buffered_commands" ]]; then
      eval "echo \"WATCHED: $debug_watch\"" >&$fd_original_err
    fi
    set -u

    if [[ ! "$debug_buffered_commands" ]]; then
      local prefix=
      if [[ $BASH_SUBSHELL -gt 0 ]]; then
        prefix+="$YELLOW$BASH_SUBSHELL:$BASHPID "
      fi
      if [[ "${omni_log_pos:-}" ]]; then
        local log_id=${omni_log_fork_id:-0}:$omni_log_pos
        prefix+="${CYAN}log_id=$log_id "
      fi
      if [[ "$debug_id" ]]; then
        prefix+="${CYAN}debug_id=$debug_id_current "
      fi
      if [[ $debug_source_file != none ]]; then
        echo -n "$prefix$RED$debug_source_file:$debug_line_num" >&$fd_original_err
      fi
      echo -n " $GREEN$debug_current_function $RESET:" >&$fd_original_err

      if [[ $debug_follow_source == t ]]; then
        echo -n " $debug_command " >&$fd_original_err
      else
        if [[ $debug_highlight == t ]]; then
          echo -n " $display_command " >&$fd_original_err
        else
          echo -n " $raw_display_command " >&$fd_original_err
        fi
      fi
    fi

    debug_long_command=f
    local silent_command=f
    if [[ "$debug_buffered_commands" ]]; then
      debug_buffered_commands=${debug_buffered_commands##*( )}
      debug_c=${debug_buffered_commands:0:1}
      debug_buffered_commands=${debug_buffered_commands:1}
      silent_command=t
    else
      read -rs -N1 -u $fd_original_in debug_c 
    fi

    if [[ "$debug_c" != l && "$debug_c" != L ]]; then
      debug_list_offset=0
      debug_list_dir=none
    fi

    BASH_REMATCH=( "${debug_rematch[@]}" )

    case "$debug_c" in
      a)
        echo >&$fd_original_err
        read -e -p "Name of array variable: " debug_array <&$fd_original_in >&$fd_original_err
        if [[ "$debug_array" ]]; then
          show_array $debug_array
        fi
        no_follow_once=t
        ;;
      C)
        echo "# Continuing..." >&$fd_original_err
        [[ "${fd_bash_trace:-}" ]] && eval "exec $fd_bash_trace>&-"
        debug_r=0
        debug_long_command=t
        debug_save_state
        trap - DEBUG
        set +x
        ;;
      c)
        if [[ $debug_path_to_source_file == none ]]; then
          echo "# Source not available" >&$fd_original_err
        else
          echo "$NL" >&$fd_original_err
          (( debug_list_offset = -debug_list_window / 2 + 1 ))
          debug_list_stack_pos=0
          debug_display_source
          debug_list_dir=forwards
          (( debug_list_offset += debug_list_window ))
          no_follow_once=t
        fi
        ;;
      d)
        echo >&$fd_original_err
        read -e -p "Display: " debug_display <&$fd_original_in >&$fd_original_err
        set +u
        if [[ "$debug_display" =~ ^[a-zA-Z_0-9]+$ ]]; then
          eval 'echo "$'$debug_display'"' >&$fd_original_err 
        else
          eval 'echo "'$debug_display'"' >&$fd_original_err 
        fi
        set -u
        no_follow_once=t
        ;;
      D)
        if [[ "$debug_display" ]]; then
          echo "# Showing $debug_display" >&$fd_original_err
          set +u
          eval 'echo "[${!debug_display}]"' >&$fd_original_err
          set -u
        else
          echo "# No previous display var." >&$fd_original_err
        fi
        no_follow_once=t
        ;;
      e)
        echo >&$fd_original_err
        read -er -p "Eval: " debug_expression <&$fd_original_in >&$fd_original_err
        #eval "$debug_saved_shell_options"
        set +u
        eval "$debug_expression" >&$fd_original_err
        set -u +evT +o pipefail
        no_follow_once=t
        ;;
      E)
        if [[ "$debug_expression" ]]; then
          echo "# Evaluating $debug_expression" >&$fd_original_err
          set +u
          eval "$debug_expression" >&$fd_original_err
          set -u
        else
          echo "# No previous expression to evaluate" >&$fd_original_err
        fi
        no_follow_once=t
        ;;
      /)
        echo >&$fd_original_err
        read -e -p "Deep Find: " debug_search <&$fd_original_in >&$fd_original_err
        if [[ "${debug_search:-}" ]]; then
          if [[ "$debug_search" == ~* ]]; then
            # use unescaped to support regex if expression starts with ~
            debug_search=${debug_search#~}
          else
            debug_search=${debug_search//\\/\\\\}
            debug_search=${debug_search//\$/\\\$}
            debug_search=${debug_search//[/\\[}
          fi
          debug_search_old=$debug_search
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        fi
        ;;
      f)
        if [[ "${debug_search_old:-}" ]]; then
          echo "# Repeating search for $debug_search_old" >&$fd_original_err
          debug_search=${debug_search_old:-}
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        else
          echo "# No previous search." >&$fd_original_err
          no_follow_once=t
        fi
        ;;
      g)
        echo >&$fd_original_err
        read -e -p "Go until function: " debug_quick_function <&$fd_original_in >&$fd_original_err
        if [[ "${debug_quick_function:-}" ]]; then
          debug_r=0
          debug_long_command=t
          debug_function_old=$debug_quick_function
          if [[ "${debug_quick_function:-}" == /* ]]; then
            debug_function=${debug_quick_function#/}
            debug_quick_function=
            debug_subshell=t
          else
            trap - DEBUG
            set +x
          fi
          debug_save_state
        fi
        ;;
      G)
        if [[ "${debug_function_old:-}" ]]; then
          debug_quick_function=$debug_function_old
          echo "# Continuing until we reach function $debug_quick_function" >&$fd_original_err
          debug_r=0
          debug_long_command=t
          if [[ "${debug_quick_function:-}" == /* ]]; then
            debug_function=${debug_quick_function#/}
            debug_quick_function=
            debug_subshell=t
          else
            trap - DEBUG
            set +x
          fi
          debug_save_state
        fi
        ;;
      h)
        if [[ $debug_highlight == t ]]; then
          echo "# Syntax highlighting is now off" >&$fd_original_err
          debug_path_to_source_file=$raw_debug_path_to_source_file
          debug_highlight=f
        else
          echo "# Syntax highlighting is now on" >&$fd_original_err
          # debug_path_to_source_file=$highlighted_source
          debug_highlight=t
        fi
        debug_save_state
        no_follow_once=t
        ;;
      i)
        echo "# Stepping in" >&$fd_original_err
        debug_r=0
        (( debug_max_depth += 10 ))
        debug_step_to_next_line=t
        debug_skip_ignore=t
        debug_subshell=t
        debug_save_state
        export -n debug
        ;;
      j)
        echo >&$fd_original_err
        read -e -p "Shallow Find: " debug_search <&$fd_original_in >&$fd_original_err
        if [[ "${debug_search:-}" ]]; then
          if [[ "$debug_search" == ~* ]]; then
            # use unescaped to support regex if expression starts with ~
            debug_search=${debug_search#~}
          else
            debug_search=${debug_search//\\/\\\\}
            debug_search=${debug_search//\$/\\\$}
            debug_search=${debug_search//[/\\[}
          fi
          debug_search_old=$debug_search
          debug_search_deep=f
          debug_r=0
          debug_long_command=t
          debug_save_state
        fi
        ;;
      J)
        if [[ "${debug_search_old:-}" ]]; then
          echo "# Shallow find of $debug_search_old" >&$fd_original_err
          debug_search=${debug_search_old:-}
          debug_search_deep=f
          debug_r=0
          debug_long_command=t
          debug_save_state
        else
          echo "# No previous search" >&$fd_original_err
          no_follow_once=t
        fi
        ;;
      k)
        echo "# Skipping..." >&$fd_original_err
        debug_r=1
        debug_stepping=t
        ;;
      l)
        if [[ $debug_path_to_source_file == none ]]; then
          echo "# Source not available" >&$fd_original_err
        else
          if [[ $debug_list_dir != none ]]; then
            echo -n "$CLEAR_LINE" >&$fd_original_err
            if [[ "$debug_watch" ]]; then
              echo -n "$CURSOR_UP$CLEAR_LINE" >&$fd_original_err
            fi
          fi

          [[ $debug_list_dir == none ]] && echo >&$fd_original_err
          [[ $debug_list_dir == backwards ]] && (( debug_list_offset += debug_list_window ))
          debug_display_source
          (( debug_list_offset += debug_list_window ))
          debug_list_dir=forwards
          no_follow_once=t
        fi
        ;;
      L)
        if [[ $debug_path_to_source_file == none ]]; then
          echo "# Source not available" >&$fd_original_err
        else
          echo -n "$CLEAR_SCREEN" >&$fd_original_err
          [[ $debug_list_dir == forwards ]] && (( debug_list_offset -= debug_list_window ))
          (( debug_list_offset -= debug_list_window * 15 / 10 ))
          debug_display_source
          debug_list_dir=backwards
          no_follow_once=t
        fi
        ;;
      n)
        echo "# Stepping over" >&$fd_original_err
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=t
        debug_subshell=t
        debug_save_state
        export -n debug
        ;;
      N)
        echo "# Stepping until next line is reached" >&$fd_original_err
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_later_line=t
        #debug_subshell=t
        debug_save_state
        ;;
      o)
        echo "# Stepping out" >&$fd_original_err
        debug_max_depth=$((debug_current_depth-1))
        debug_r=0
        debug_long_command=t
        debug_stepping=t
        debug_save_state
        ;;
      p)
        echo >&$fd_original_err
        local fixed_command
        fixed_command=${debug_command}
        fixed_command=${fixed_command//\\/**BS**}
        fixed_command=${fixed_command//\\\$/\\\\\$}
        # temporarily hide this so we can keep $(( but transform $(
        fixed_command=${fixed_command//\$((/{{{}
        fixed_command=${fixed_command//\$(/\\\$(}
        # restore {{{ to $((
        fixed_command=${fixed_command//{{{/\$((}
        fixed_command=${fixed_command//\"/\\\"}
        fixed_command=${fixed_command//\*\*BS\*\*/\\}
        set +u
        if [[ "${debug_saved_params}" ]]; then
          set "${debug_saved_params[@]}"
        fi
        eval "echo \"$fixed_command\"" >&$fd_original_err
        set -u
        no_follow_once=t
        ;;
      P)
        echo >&$fd_original_err
        local fixed_command
        fixed_command=${debug_command}
        fixed_command=${fixed_command//\\/**BS**}
        fixed_command=${fixed_command//\\\$/\\\\\$}
        fixed_command=${fixed_command//\[\[ /~~dbo~~}
        fixed_command=${fixed_command// \]\]/~~dbc~~}
        fixed_command=${fixed_command//\[ /\$(\[ }
        fixed_command=${fixed_command// ]/ ] && echo true || echo false)}
        fixed_command=${fixed_command//~~dbo~~/\$(\[\[ }
        fixed_command=${fixed_command//~~dbc~~/ ]] \&\& echo true || echo false)}
        fixed_command=${fixed_command//\*\*BS\*\*/\\}
        set +u
        eval "echo \"$fixed_command\"" >&$fd_original_err
        set -u
        no_follow_once=t
        ;;
      q) 
        echo "# Quitting (debug state: $debug_state_file)" >&$fd_original_err
        force_save=t debug_save_state
        debug_exit=t
        debug_save_state
        exit 0
        ;;
      R)
        echo "# Rewinding..." >&$fd_original_err
        debug_rewind=t
        debug_stepping=t
        debug_r=0
        ;;
      r)
        echo "# Show raw call stack" >&$fd_original_err
        start_frame=3 stack_trace
        no_follow_once=t
        ;;
      s)
        echo "# Stepping over small" >&$fd_original_err
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=f
        debug_subshell=t
        debug_stepping=t
        debug_save_state
        ;;
      t)
        echo "# Show warm call stack" >&$fd_original_err
        warm_stack_trace
        no_follow_once=t
        ;;
      T)
        echo "# Show cooked call stack" >&$fd_original_err
        cooked_stack_trace
        no_follow_once=t
        ;;
      u)
        echo >&$fd_original_err
        local f
        read -e -p "Unignore function: " f <&$fd_original_in >&$fd_original_err
        if [[ "${f:-}" ]]; then
          debug_ignore_remove $f
        fi
        ;;
      U)
        echo "# Unignore all functions" >&$fd_original_err
        debug_ignore=
        no_follow_once=t
        ;;
      w)
        echo >&$fd_original_err
        local new_watch
        read -e -p "Watch: " new_watch <&$fd_original_in >&$fd_original_err
        if [[ "$new_watch" == +* ]]; then
          debug_watch+=" ${new_watch#+}"
        else
          debug_watch=$new_watch
        fi
        debug_save_state
        no_follow_once=t
        ;;
      x)
        echo >&$fd_original_err
        local v
        read -e -p "Hex Display: " v <&$fd_original_in >&$fd_original_err
        set +u
        if [[ "$v" ]]; then
          eval 'echo -n "$'${v#\$}'" | xxd' >&$fd_original_err || true
        fi
        set -u
        no_follow_once=t
        ;;
      \()
        (( debug_expansion-- ))
        if (( debug_expansion < 0 )); then
          debug_expansion=0
        fi
        debug_display_command_expansion_status
        debug_save_state
        no_follow_once=t
        ;;
      \))
        if (( no_trace_depth > 0 )); then
          no_trace_depth=0
          echo "# Resetting no_trace_depth to 0" >&$fd_original_err
        else
          (( debug_expansion++ ))
          if (( debug_expansion > 3 )); then
            debug_expansion=3
          fi
          debug_display_command_expansion_status
        fi
        debug_save_state
        no_follow_once=t
        ;;
      -)
        if (( debug_list_stack_pos >= ${#saved_bash_lineno[*]} )); then
          echo "# Already at top of stack trace" >&$fd_original_err
        else
          echo >&$fd_original_err
          (( debug_list_offset = -debug_list_window * 2 / 3 + 1 ))
          (( debug_list_stack_pos++ )) 
          debug_display_source
          debug_list_dir=forwards
          (( debug_list_offset += debug_list_window ))
          no_follow_once=t
        fi
        ;;
      _)
        if (( debug_list_stack_pos == 0 )); then
          echo "# Already at bottom of stack trace" >&$fd_original_err
        else
          echo >&$fd_original_err
          (( debug_list_offset = -debug_list_window * 2 / 3 + 1 ))
          (( debug_list_stack_pos-- )) 
          debug_display_source
          debug_list_dir=forwards
          (( debug_list_offset += debug_list_window ))
          no_follow_once=t
        fi
        ;;
      =)
        echo "# Running until this line is reached again" >&$fd_original_err
        debug_stop_at="$raw_debug_path_to_source_file $debug_line_num"
        debug_r=0
        debug_long_command=t
        debug_subshell=t
        debug_step_to_next_line=f
        debug_save_state
        ;;
      \[)
        echo >&$fd_original_err
        read -e -p "Condition (brackets optional): " debug_condition <&$fd_original_in >&$fd_original_err
        if [[ "${debug_condition:-}" ]]; then
          debug_condition_old=$debug_condition
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        fi
        ;;
      \{)
        if [[ "${debug_condition_old:-}" ]]; then
          echo "# Repeating search for $debug_condition_old" >&$fd_original_err
          debug_condition=${debug_condition_old:-}
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        else
          echo "# No previous condition." >&$fd_original_err
          no_follow_once=t
        fi
        ;;
      \])
        echo "# Running until a new function is reached" >&$fd_original_err
        (( debug_max_depth++ ))
        debug_step_to_next_function=t
        debug_subshell=t
        debug_r=0
        debug_save_state
        ;;
      \})
        echo "# Running until a new file is reached" >&$fd_original_err
        (( debug_max_depth++ ))
        debug_step_to_next_file=t
        debug_subshell=t
        debug_r=0
        debug_save_state
        ;;
      \\)
        if [[ $silent_command == f ]]; then
          echo "# Adding $debug_current_function to function ignore list" >&$fd_original_err
        fi
        debug_ignore+="$debug_current_function "
        debug_r=0
        debug_stepping=t
        debug_save_state
        ;;
      @)
        echo >&$fd_original_err
        echo "$raw_debug_path_to_source_file" >&$fd_original_err
        no_follow_once=t
        ;;
      \#)
        if [[ "${#PS4}" -lt 5 ]]; then
          PS4='$EPOCHREALTIME\011+ '
          echo "# Enabled time tracing" >&$fd_original_err
        else
          PS4='+ '
          echo "# Disabled time tracing" >&$fd_original_err
        fi
        debug_save_state
        no_follow_once=t
        ;;
      \$)
        echo "# Entering debug shell" >&$fd_original_err
        set +u
        debug_shell
        set -u
        no_follow_once=t
        ;;
      ^)
        if [[ $debug_follow_source == t ]]; then
          echo "# Follow source is now off" >&$fd_original_err
          debug_follow_source=f
        else
          echo "# Follow source is now on" >&$fd_original_err
          debug_follow_source=t
        fi
        debug_save_state
        ;;
      \>)
        if [[ $debug_expanded_search == t ]]; then
          echo "# Expanded search is now off" >&$fd_original_err
          debug_expanded_search=f
        else
          echo "# Expanded search is now on" >&$fd_original_err
          debug_expanded_search=t
        fi
        debug_save_state
        ;;
      \?)
        echo >&$fd_original_err
        echo >&$fd_original_err
        echo "a  display array" >&$fd_original_err
        echo "c  list debug_list_window/2 lines of source code before and after current line" >&$fd_original_err
        echo "C  continue execution without stopping" >&$fd_original_err
        echo "d  display an expression with variables substituted" >&$fd_original_err
        echo "D  repeat last display command" >&$fd_original_err
        echo "e  evaluate an expression" >&$fd_original_err
        echo "E  repeat last eval expression command" >&$fd_original_err
        echo "f  repeat previous deep or shallow search" >&$fd_original_err
        echo "g  continue until the given function is reached" >&$fd_original_err
        echo "G  continue until the previously given function is reached" >&$fd_original_err
        echo "h  toggle syntax highlighting" >&$fd_original_err
        echo "i  next instruction, stepping into function calls" >&$fd_original_err
        echo "j  jump ahead: shallow substring find" >&$fd_original_err
        echo "J  repeat previous jump" >&$fd_original_err
        echo "k  skip current command" >&$fd_original_err
        echo "l  list next debug_list_window (default 20) lines of source code" >&$fd_original_err
        echo "L  list previous debug_list_window (default 20) lines of source code" >&$fd_original_err
        echo "n  next line of code (even if it resolves to several different statements)," >&$fd_original_err
        echo "   not stepping into function calls" >&$fd_original_err
        echo "   WARNING: In the rare case that the debugger hangs after this command is run on a line of code, exit (control-c) and start over" >&$fd_original_err
        echo "   the debugging, except when you get to this line, press 's' to do a small step first, and then 'n' and usually it will work" >&$fd_original_err
        echo "N  continue executing until we reach a line later than the current line, completing loops if needed" >&$fd_original_err
        echo "o  step out from the current function" >&$fd_original_err
        echo "p  print variables in current line" >&$fd_original_err
        echo "P  print conditional test results of current line" >&$fd_original_err
        echo "q  quit: exit the program entirely" >&$fd_original_err
        echo "r  show raw call stack" >&$fd_original_err
        echo "R  rewind: go back to the start of the last looping / try block" >&$fd_original_err
        echo "s  execute next small statement, even if multiple statements are on a line," >&$fd_original_err
        echo "   not stepping into function calls" >&$fd_original_err
        echo "t  show warm call stack" >&$fd_original_err
        echo "T  show cooked call stack" >&$fd_original_err
        echo "u  unignore: remove given function from ignore list" >&$fd_original_err
        echo "U  unignore all functions" >&$fd_original_err
        echo "w  set or clear current watched expression. Expression can contain any string expression which can be given to echo as an argument." >&$fd_original_err
        echo "x  hex display of a variable" >&$fd_original_err
        echo "#  add timestamps to each debug trace line" >&$fd_original_err
        echo "@  show full path of file containing source being executed" >&$fd_original_err
        echo "$  enter debug shell" >&$fd_original_err
        echo "^  toggle source following (displays source context after every command)" >&$fd_original_err
        echo "(  reduce command expansion level. Command expansion shows what the shell previously executed" >&$fd_original_err
        echo ")  increase command expansion level. Will instead reset no_trace_depth if it is set." >&$fd_original_err
        echo "-  move up stack one position and show source" >&$fd_original_err
        echo "_  move down stack one position and show source" >&$fd_original_err
        echo "=  continue until the current line is reached again" >&$fd_original_err
        echo "[  continue until a given [[ ]] or (( )) condition is met" >&$fd_original_err
        echo "]  continue until we reach a different function" >&$fd_original_err
        echo "}  continue until we reach a different file" >&$fd_original_err
        echo "\  add current function to jump ignore list, so using ] will not hit this function again" >&$fd_original_err
        echo ">  toggle expanded search mode, which enables searching on evaluated string expressions" >&$fd_original_err
        echo "/  continue until a line contains the substring given" >&$fd_original_err
        echo "   put a ~ at the beginning of the search string to do a regex search" >&$fd_original_err
        echo >&$fd_original_err
        no_follow_once=t
        ;;
      *)
        echo "# Unknown command" >&$fd_original_err
        echo "Press ? for a list of commands" >&$fd_original_err
        no_follow_once=t
        ;;
    esac
  done
}

debug_trap() {
  debug_saved_shell_options_short=$-
  set +xevT +o pipefail
  debug_rematch=( "${BASH_REMATCH[@]}" )
  local saved_bash_source=( "${BASH_SOURCE[@]:1}" ) \
    saved_bash_lineno=( "${BASH_LINENO[@]:1}" ) \
    saved_funcname=( "${FUNCNAME[@]:1}" ) \
    saved_lineno

  (( saved_lineno = debug_trap_first_line - 1 )) 

  tracing_depth=0
  local debug_r=0

  if (( ${trace_debugger:-0} > 0 )); then 
    set -x
    BASH_XTRACEFD=2
    (( trace_debugger-- ))
  fi

  if [[ $debug_debug == t ]]; then
    log_debug_debug "debug_id=$debug_id_current ${saved_bash_source[0]:-no_source}:$saved_lineno/${saved_bash_lineno[0]:-no_line} ${saved_funcname[0]:-no_func} ${BASH_COMMAND}" 
  fi

  local debug_path_to_source_file \
    raw_debug_path_to_source_file="${saved_bash_source[0]:-none}" \
    debug_line_num=$saved_lineno \
    debug_current_function=${saved_funcname[0]:-none} \
    debug_command=${BASH_COMMAND} \
    debug_current_depth=${#saved_funcname[*]}

  if [[ "$debug_ignore" == *" $debug_current_function "* && $debug_skip_ignore == f ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Ignoring $debug_current_function${RESET}" >&$fd_original_err
    return 0
  fi

  debug_load_state || return 1

  [[ $debug_exit == t ]] && exit 1

  if [[ "$debug_var" ]]; then
    set +u
    local v
    for v in ${debug_var}; do
      echo "${CYAN}debug_var: $v=${!v}${RESET}" >&$fd_original_err
    done
    set -u
  fi

  local IFS=$'\n'$'\t'" " \
    debug_full_path=${debug_full_path:-f} \
    debug_source_file \
    raw_debug_path_to_source_file

  debug_rewind=f

  debug_source_update

  local line_part=$debug_line file_part=
  if [[ "$debug_line" ]]; then
    if [[ $debug_line == *:* ]]; then
      line_part=${debug_line##*:}
      file_part=${debug_line%:*}
    fi
  fi

  local expanded_command= fixed_command=
  if [[ "$debug_search" ]]; then
    if [ "$debug_expanded_search" == t ]; then
      fixed_command=${debug_command}
      fixed_command=${fixed_command//\\/**BS**}
      fixed_command=${fixed_command//\\\$/\\\\\$}
      # temporarily hide this so we can keep $(( but transform $(
      fixed_command=${fixed_command//\$((/{{{}
      fixed_command=${fixed_command//\$(/\\\$(}
      # restore {{{ to $((
      fixed_command=${fixed_command//{{{/\$((}
      fixed_command=${fixed_command//\"/\\\"}
      fixed_command=${fixed_command//\*\*BS\*\*/\\}
      set +u
      eval "expanded_command=\"$fixed_command\"" &>/dev/null || true
      set -u
    fi
  fi

  local ok_to_debug=f

  if [[ $debug_immediate == t ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_immediate${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_immediate=f

  elif [[ -n "$debug_line" \
          && -z "$file_part" \
          && "$debug_line_num" -eq "$line_part" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_line${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_line_old=$debug_line
    debug_line=

  elif [[ -n "$debug_line" \
          && -n "$file_part" \
          && ( \
             "$debug_line_num" -eq "$line_part" \
             && "$debug_source_file" == "$file_part" \
             ) \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_line${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_line_old=$debug_line
    debug_line=

  elif [[ $debug_stepping == t \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_stepping${RESET}" >&$fd_original_err
    debug_stepping=f
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ "$debug_condition" ]]; then
    local condition=$debug_condition
    if [[ "$condition" != \[* && "$condition" != \(* ]]; then
      condition="[[ $condition ]]"
    fi
    condition+=" && ok_to_debug=t"
    eval "$condition"
    if [[ $ok_to_debug == t ]]; then
      debug_condition=
    fi

  elif [[ "$debug_function" \
          && $debug_function == $debug_current_function \
          || "$debug_search" \
          && $debug_search == $debug_current_function \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_function${RESET}" >&$fd_original_err
    if [[ "$debug_function" ]]; then
      debug_function_old=$debug_function
      debug_search_old=$debug_function
      debug_function=
    else
      debug_search_old=$debug_search
      debug_search=
    fi
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ "$debug_search" \
          && ( \
             $debug_search_deep == t \
             || $debug_current_depth -le $debug_max_depth \
             ) \
          && ( " $debug_command " =~ $debug_search \
             || " $expanded_command " =~ $debug_search \
             ) \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_search${RESET}" >&$fd_original_err
    debug_search=
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ $debug_step_to_next_line == t \
          && "$raw_debug_path_to_source_file $debug_line_num" != "$debug_last_location" \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_line${RESET}" >&$fd_original_err
    ok_to_debug=t

  elif [[ $debug_step_to_later_line == t \
          && "$debug_line_num" -gt "$debug_prev_line" \
          && $debug_current_function != none \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_later_line${RESET}" >&$fd_original_err
    debug_step_to_later_line=f
    ok_to_debug=t

  elif [[ "$debug_stop_at" \
          && "$raw_debug_path_to_source_file $debug_line_num" == "$debug_stop_at" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_stop_at${RESET}" >&$fd_original_err
    debug_max_depth=$debug_current_depth
    debug_stop_at=
    ok_to_debug=t

  elif [[ $debug_step_to_next_function == t \
          && "$debug_current_function" != "$debug_prev_function" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_function${RESET}" >&$fd_original_err
    debug_step_to_next_function=f
    ok_to_debug=t

  elif [[ $debug_step_to_next_file == t \
          && "$debug_current_function" != "$debug_prev_function" \
          && "$debug_source_file" != "$debug_prev_source_file" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_file${RESET}" >&$fd_original_err
    debug_step_to_next_file=f
    ok_to_debug=t

  fi

  local debug_out_path=$tmp_folder/debug-out.$BASHPID
  defer "rm $debug_out_path"

  if [[ $ok_to_debug == t ]]; then
    debug_inner
  else
    [[ $debug_debug == t ]] && echo "${CYAN}Not stopping.${RESET}" >&$fd_original_err
  fi

  debug_list_stack_pos=0
  if [[ $debug_expansion -gt 0 ]]; then
    exec {fd_bash_trace}>"$debug_out_path"
    (( tracing_depth++ ))
    debug_original_tracefd=${BASH_XTRACEFD:-}
    BASH_XTRACEFD=$fd_bash_trace
  fi

  [[ $debug_exit == t ]] && exit 0
  debug_tracing=f
  if [[ $debug_expansion -gt 0 
        && ${no_trace_depth:-0} -le 0 \
     ]]; then
    if [[ $debug_expansion == 1 \
          && " $debug_ignore " != *" $debug_prev_command "* \
          || $debug_expansion -gt 1 ]]; then
      debug_tracing=t
    fi
  fi

  [[ $debug_subshell == t ]] && set -T

  if [[ $debug_saved_shell_options_short == *e* ]]; then
    set -e
  fi

  BASH_REMATCH=( "${debug_rematch[@]}" )
  return $debug_r
}

set_return_code() {
  [[ $debug_tracing == t ]] && set -x
  return $1
}

reserve_tmp_file() {
  local var=$1; shift
  local base=${1:-$var}; shift
  
  local internal_tmp_file=$(mktemp $tmp_folder/$base.$$.XXXXXX)
  eval "$var=$internal_tmp_file"
  eval "cleanup_on_exit+='rm ${internal_tmp_file} &>/dev/null || true;'"
}

show_array() {
  local -n array=$1
  if [[ "${array:-}" ]]; then
    local i size=${#array[*]}
    echo "size=$size" >&$fd_original_err
    for ((i=0; i<size; i++)); do
      echo "$i: ${array[$i]}" >&$fd_original_err
    done
  fi
}

stack_trace() {
  local start_frame=${start_frame:-1}
  local count=${#FUNCNAME[*]}
  local p n

  if [ ${tracing_midline:-f} == t ]; then
    tracing_midline=f
    echo >&$fd_original_err
  fi

  echo "Raw call stack:" >&$fd_original_err
  for ((n = count - 1; n >= start_frame; n--)) ; do
    (( p = n - 1 ))
    echo "  ${BASH_SOURCE[$n]:-(no source)} ${FUNCNAME[$n]:-(no func)} ${BASH_LINENO[$p]:-(no line)}" >&$fd_original_err
  done
  return 0
}

warm_stack_trace() {
  if [[ -v warm_stack ]]; then
    echo "Warm call stack:" >&$fd_original_err
    local count=${#warm_stack[*]} n
    for ((n = 0; n < count; n++)); do
      echo " ${warm_stack[$n]}" >&$fd_original_err
    done
  else
    echo "No warm stack." >&$fd_original_err
  fi
  return 0
}

cooked_stack_trace() {
  if [[ -v cooked_stack ]]; then
    echo "Cooked call stack:" >&$fd_original_err
    local count=${#cooked_stack[*]} n
    for ((n = 0; n < count; n++)); do
      echo " ${cooked_stack[$n]}" >&$fd_original_err
    done
  else
    echo "No cooked stack." >&$fd_original_err
  fi
  return 0
}

alias debug_once='[[ ! "${debug_once_triggered:-}" ]] && { debug_once_triggered=t; debug_start; }'

debugger_init() {
  local first_run=${first_run:-t}
  # used by debugger, in case input or output is redirected from somewhere else during debugging
  if [[ ! -v fd_original_in ]]; then
    exec {fd_original_in}<&0
    exec {fd_original_out}>&1
    exec {fd_original_err}>&2
    exec {fd_original_trace}>&${fd_trace:-2}
  fi

  debug_output=${debug_output:-f}
  debug_ignore=${debug_ignore:-}
  tracing_depth=${tracing_depth:-0}
  tmp_folder=${tmp_folder:-/tmp}
  debug_state_file=$tmp_folder/debug-state-$$
  debug_id_current=0
  debugger_available=t

  if [[ "$first_run" == t ]]; then
    rm $tmp_folder/debug-* $tmp_folder/side-log-* &>/dev/null || true
  fi

  # used to debug complex debugger internal issues
  side_log_file=$tmp_folder/side-log-$$

  COLUMNS=${COLUMNS:-120}

  if [[ ! "${debug_highlight:-}" ]]; then
    if which source-highlight >/dev/null; then
      debug_highlight=t
    else
      debug_highlight=f
    fi
  fi

  if [[ $debug_highlight == t ]]; then
    if ! which source-highlight >/dev/null; then
      fatal "You set debug_highlight=t, but are missing the highlight command."
      fatal "You can use 'brew install highlight' to install it if you want."
      exit 1
    fi

    rm -rf $tmp_folder/debug_highlight &>/dev/null
    mkdir -p $tmp_folder/debug_highlight || exit 1
  fi

  debug_setup
}

log_debug_debug() {
  echo "${CYAN}debug_debug: $*$RESET" >&$fd_original_err
}

debug_start() {
  debug_buffered_commands=$*
  parallel_execution=${p_par:-f}
  if [[ ! -v debugging ]]; then
    debugger_init || return 1
  fi
  if [[ $debugging == f ]]; then
    export debugging=t \
      debug \
      debug_buffered_commands=${debug_buffered_commands:-} \
      debug_condition=${debug_condition:-} \
      debug_condition_old=${debug_condition_old:-} \
      debug_debug=${debug_debug:-f} \
      debug_dir=$PWD \
      debug_display=${debug_display:-none} \
      debug_exit=${debug_exit:-f} \
      debug_expanded_search=${debug_expanded_search:-f} \
      debug_expansion=${debug_expansion:-1} \
      debug_expression=${debug_expression:-echo none} \
      debug_expanded_search=${debug_expanded_search:-f} \
      debug_follow_source=${debug_follow_source:-t} \
      debug_function=${debug_function:-} \
      debug_function_old=${debug_function_old:-} \
      debug_id=${debug_id:-t} \
      debug_immediate=${debug_immediate:-t} \
      debug_last_location=${debug_last_location:-} \
      debug_line=${debug_line:-} \
      debug_line_old=${debug_line_old:-} \
      debug_list_dir=${debug_list_dir:-none} \
      debug_list_offset=${debug_list_offset:-0} \
      debug_list_stack_pos=${debug_list_stack_pos:-0} \
      debug_list_window=${debug_list_window:-20} \
      debug_long_command=${debug_long_command:-f} \
      debug_max_depth=${debug_max_depth:-999} \
      debug_original_tracefd=${debug_original_tracefd:-${BASH_XTRACEFD:-}} \
      debug_prev_command=${debug_prev_command:-none} \
      debug_prev_function=${debug_prev_function:-none} \
      debug_prev_line=${debug_prev_line:-0} \
      debug_search_old=${debug_search_old:-} \
      debug_prev_source_file=${debug_prev_source_file:-none} \
      debug_quick_function=${debug_quick_function:-} \
      debug_rewind=${debug_rewind:-f} \
      debug_saved_params=${debug_saved_params:-} \
      debug_saved_shell_options=${debug_saved_shell_options:-} \
      debug_search=${debug_search:-} \
      debug_search_deep=${debug_search_deep:-t} \
      debug_skip_ignore=${debug_skip_ignore:-t} \
      debug_step_to_later_line=${debug_step_to_later_line:-f} \
      debug_step_to_next_file=${debug_step_to_next_file:-f} \
      debug_step_to_next_function=${debug_step_to_next_function:-f} \
      debug_step_to_next_line=${debug_step_to_next_line:-f} \
      debug_stepping=${debug_stepping:-f} \
      debug_stop_at=${debug_stop_at:-} \
      debug_subshell=${debug_subshell:-f} \
      debug_var=${debug_var:-} \
      debug_watch=${debug_watch:-${trace_var:-}} \

    trap '
      set +x
      echo "PIPE signal was fired." >&$fd_original_err
      stack_trace
      BASH_XTRACEFD=
      debug_start
      ' PIPE
    shopt -s extdebug
    trap '
      set +x; debug_trap_first_line=${LINENO:-0} 
      debug_saved_params=( "$@" )
      debug_trap
      debug_rc=$?
      [[ $debug_rewind == t ]] && continue
      set_return_code $debug_rc
      ' DEBUG
  else
    debug_immediate=t
  fi
}

debug() {
  local function_to_debug=$*
  if [[ "$function_to_debug" ]]; then
    debug_start
    $function_to_debug
  else
    debug_start
  fi
}

debug_shell() {
  if [[ ! -v debugging ]]; then
    debugger_init || return 1
  fi
  local c
  echo "Debug shell started. " >&$fd_original_err
  echo "Use q to exit debug shell and resume execution of the script. " >&$fd_original_err
  echo "Use 'exit' to abort all further code execution. " >&$fd_original_err
  echo "You have access to the full execution environment (variables and functions). " >&$fd_original_err
  while true; do
    read -e -p "debug ${CYAN}\$${RESET} " c <&$fd_original_in >&$fd_original_err
    case $c in
      q|quit)
        echo "Leaving debug shell." >&$fd_original_err
        break
        ;;
      *)
        eval "$c" || { rc=$?; echo; echo "Command failed ($rc)"; }
        ;;
    esac
  done
}

debug_setup() {
  debugging=f

  if [[ "${debug_unignore:-}" ]]; then
    debug_ignore_remove "$debug_unignore"
  fi

  debug=${debug:-f}
  if [[ $debug != f \
     || "${debug_search:-}" \
     || "${debug_search_deep:-}" \
     || "${debug_id:-}" && ! "${debug_at_log_id:-}" \
     || "${debug_var:-}" \
     || "${debug_function:-}" \
     || "${debug_quick_function:-}" \
     || "${debug_line:-}" ]]; then

    if [[ "$debug" && $debug != t && $debug != f ]]; then
      if [[ "$debug" == *:* ]]; then
        debug_line=$debug
      elif [[ "$debug" =~ ^[0-9]+$ ]]; then
        debug_id=$debug
      elif [[ "$debug" == =* ]]; then
        debug_search=${debug#=}
      elif [[ "$debug" == \? ]]; then
        debug_id_out=t
        debug=f
      else
        debug_quick_function=$debug
        debug_function_old=$debug_quick_function
      fi
    fi

    if [[ "${debug_search:-}" == =* ]]; then
      debug_search=${debug_search#=}
      debug_expanded_search=t
    fi

    if [[ "${debug_search:-}" ]]; then
      if [[ "$debug_search" == ~* ]]; then
        # use unescaped to support regex if expression starts with ~
        debug_search=${debug_search#\~}
      else
        debug_search=${debug_search//\\/\\\\}
        debug_search=${debug_search//\$/\\\$}
        debug_search=${debug_search//[/\\[}
      fi
      echo "${CYAN}Will debug when code is found to contain: $debug_search${RESET}" >&$fd_original_err
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
    fi

    if [[ "${debug_quick_function:-}" ]]; then
      echo "${CYAN}Will debug starting at function: $debug_quick_function${RESET}" >&$fd_original_err
      debug_id=t
    fi

    if [[ "${debug_function:-}" ]]; then
      echo "${CYAN}Will debug starting at function: $debug_function${RESET}" >&$fd_original_err
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
      if [[ "$debug_ignore" == *" $debug_function "* ]]; then
        local left_side=${debug_ignore% $debug_function *}
        local right_side=${debug_ignore#* $debug_function }
        debug_ignore=" $left_side $right_side "
      fi
    fi

    if [[ "${debug_line:-}" ]]; then
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
    fi

    if [[ "${debug_var:-}" ]]; then
      echo "${CYAN}Will debug var $debug_var" >&$fd_original_err
      debug_subshell=t
    fi

    if [[ "${debug_id:-}" ]]; then
      if [[ "$debug_id" != t ]]; then
        echo "${CYAN}Will debug starting at debug_id $debug_id or later${RESET}" >&$fd_original_err
      fi
      debug_subshell=t
    fi

    debug_search_old=${debug_search_old:-${debug_search:-}}

    if [[ $debug != t ]]; then
      debug_immediate=f
    fi

    if [[ ! "${debug_id:-}" ]]; then
      debug_start
    fi

  fi
}

