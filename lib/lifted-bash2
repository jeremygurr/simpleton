#!/usr/bin/env bash

##########################################################
# BASH-LIFTED
# A bash library of functions to increase debugability of bash scripts.
# should not depend on anything other than bash 5+
##########################################################

# So it doesn't run twice even if it's sourced multiple times
type -t bash_lifted_init >/dev/null && return 0

declare -A trace_var_old trace_var_sub
debug_id_current=0

# this is empty, meaning we haven't forked yet. the top level process having a blank id
fork_id_current=    
fork_debug_id=0

# Run this near the top of scripts using this functionality, after the commandline parameters 
#   have been processed
bash_lifted_init() {
  autorepair_level=${autorepair_level:-${repair:-1}}

  log_var_entries_stack=()
  log_var_show_vars_stack=()

  trace_vars=${trace_vars:-${trace_var:-}}

  pause_at_functions=${pause_at_functions:-${pause_at_function:-}}
  pause_at_cells=${pause_at_cells:-${pause_at_cell:-}}
  pause_at_vars=${pause_at_vars:-${pause_at_var:-}}
  pause_at_debug_id=${pause_at_debug_id:-${pause_at_debug:-}}

  if [[ "${pause:-}" ]]; then
    if [[ "$pause" =~ / ]]; then
      if [[ ! "$pause_at_cells" ]]; then
        pause_at_cells=$pause
      fi
    elif [[ "$pause" =~ ^[0-9\.]+$ ]]; then
      if [[ ! "$pause_at_debug_id" ]]; then
        pause_at_debug_id=$pause
      fi
    elif [[ "$pause" =~ ^[a-zA-Z_0-9]+$ ]]; then
      if [[ ! "$pause_at_vars" ]]; then
        pause_at_vars=$pause
      fi
      if [[ ! "$pause_at_functions" ]]; then
        pause_at_functions=$pause
      fi
      if [[ ! "$pause_at_cells" ]]; then
        pause_at_cells=$pause
      fi
    elif [[ "$pause" =~ ^[a-zA-Z_0-9\^\ ]+$ ]]; then
      if [[ ! "$pause_at_vars" ]]; then
        pause_at_vars=$pause
      fi
    fi
  fi

  if [[ "$pause_at_vars" ]]; then
    trace_vars+=" $pause_at_vars"
  fi

  DEBUG_COLOR=$CYAN
  DIM_DEBUG_COLOR=$DIM_CYAN
  trace_structure=${trace_structure:-${trace_struct:-}}
  grip=${grip:-0}
  if [[ $grip == t ]]; then
    grip=1
  fi
  slow_down=${slow_down:-${slow:-}}
  if [[ $slow_down == t ]]; then
    slow_down=0.1
  fi
}

show_time_update() {
  if [[ "${show_time:-f}" == t && ${showed_something:-f} == f ]]; then
    new_time=${EPOCHREALTIME/./}
    if [[ "${show_time_prev:-}" ]]; then
      micro_time_diff $show_time_prev $new_time prefix
      prefix+=" "
    fi
    showed_something=t
    show_time_prev=$new_time
  fi
}

handle_user_interrupt() {
  local c silent=f prompt=${1:-Paused.}
  echo >&$fd_original_err
  while true; do
    if [[ $silent == t ]]; then
      read -u $fd_original_in -sr -N 1 c >&$fd_original_err
    else
      read -u $fd_original_in -sr -N 1 -p "${YELLOW}$prompt${RESET} (r)esume, (l)og level change, (d)ebug, (q)uit? " c >&$fd_original_err
    fi
    silent=f
    case "$c" in
      d)
        echo "debug" >&$fd_original_err
        debug_immediate=t
        unignore_this_function=f \
        debug_start n
      ;;
      l)
        echo "log level change" >&$fd_original_err
        local log=
        read -u $fd_original_in -e -p "New log level: " log >&$fd_original_err
        if [[ "$log" ]]; then
          if function_exists resolve_log_var; then
            resolve_log_var
          else
            log_level_filter=$log
          fi
          log_format=default
          log_level_filter_changed
          debug_log_level_filter=$log
          reply_to_caller "debug_log_level_filter=$debug_log_level_filter"
          echo "Log level changed to $log_level_filter" >&$fd_original_err
        else
          continue
        fi
      ;;
      q)
        echo "quit" >&$fd_original_err
        exit 100
      ;;
      r)
        echo "resume" >&$fd_original_err
        :
      ;;
      $NL)
        silent=t
        continue
      ;;
      *)
        echo "invalid key, try again" >&$fd_original_err
        continue
      ;;
    esac
    break
  done
}

show_trace_vars() {
  local indent=0 prefix= new_time

  if [[ ${show_debug_id:-f} == a ]]; then
    show_time_update
    echo -n " $prefix$DIM_DEBUG_COLOR$fork_debug_id$RESET" >&$fd_original_err
    showed_something=t
  fi

  if [[ $trace_structure == t && "${struct_type:-}" ]]; then
    show_time_update
    echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id$RESET ${struct_type:-}" >&$fd_original_err
    showed_something=t
  fi

  if [[ "${trace_fun:-}" ]]; then
    local fun
    for fun in $trace_fun; do
      if [[ "${struct_type:-}" == *" $fun" ]]; then
        show_time_update
        echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id ${struct_type:-}$RESET" >&$fd_original_err
        showed_something=t
      fi
    done
  fi

  stack_detail[$stack_pos]=
  if [[ "${log_show_vars:-}" ]]; then
    local var value show_vars
    for var in $log_show_vars; do
      value=
      local real_var=${var#^}
      real_var=${real_var#*=}
      get_var_value $real_var
      show_vars+="$real_var=$value "
    done
    stack_detail[$stack_pos]+="${show_vars% } "
  fi

  if [[ "${trace_vars:-}" ]]; then
    local var value
    for var in $trace_vars; do
      get_var_value $var
      local show_val=$value
      if [[ "${secret_vars:-}" && " ${secret_vars} " == *" $var "* ]]; then
        show_val='****'
      fi
      stack_detail[$stack_pos]+="$var=$show_val "
      if [[ -v trace_var_sub[$var] ]]; then
        if [[ "${trace_var_sub[$var]}" != "$value" ]]; then
          show_time_update
          echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id ${YELLOW}$var=$show_val$RESET" >&$fd_original_err
          showed_something=t
          if [[ " $pause_at_vars " == *" $var "* ]]; then
            handle_user_interrupt "Var changed: $var."
          fi
        fi
        unset trace_var_sub[$var]
        trace_var_old[$var]=$value
      elif [[ "${trace_var_old[$var]:-}" != "$value" || ${trace_var_always:-f} == t ]]; then
        if [[ $fork_debug_id != 1 || "$value" != '(unset)' ]]; then
          show_time_update
          echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id $var=$show_val$RESET" >&$fd_original_err
          showed_something=t
          if [[ " $pause_at_vars " == *" $var "* ]]; then
            handle_user_interrupt "Var changed: $var."
          fi
        fi
        unset trace_var_sub[$var]
        trace_var_old[$var]=$value
      fi
    done
  fi
  if [[ "${trace_condition:-}" ]]; then
    local result
    set +u
    eval "if $trace_condition; then result=t; else result=f; fi"
    set -u
    if [[ "${trace_var_old:-}" != "$result" ]]; then
      show_time_update
      echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id $trace_condition=$result$RESET" >&$fd_original_err
      showed_something=t
      trace_var_old=$result
    fi
  fi
  if [[ "${trace_expression:-}" ]]; then
    local result
    set +u
    eval "result=$trace_expression"
    set -u
    if [[ "${trace_var_old:-}" != "$result" ]]; then
      show_time_update
      echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id expression=$result$RESET" >&$fd_original_err
      showed_something=t
      trace_var_old=$result
    fi
  fi
  stack_detail[$stack_pos]="${stack_detail[$stack_pos]% }"
}

reached_debug_id() {
  local r1 r2 p1 p2 i=0
  OIFS=$IFS
  IFS=. r1=( $fork_debug_id ) r2=( $1 )
  IFS=$OIFS
  while true; do
    p1=${r1[$i]:-} p2=${r2[$i]:-}
    (( i++ ))
    if [[ "$p1" ]]; then
      if [[ "$p2" ]]; then
        if (( p1 < p2 )); then
          return 1
        elif (( p1 > p2 )); then
          return 0
        fi
      else
        return 0
      fi
    else
      if [[ "$p2" ]]; then
        return 1
      else
        return 0
      fi
    fi
  done
}

# ALSO IN: CellOp
debug_id_inc() {
  (( no_trace_depth++ ))
  (( debug_id_current++ ))
  local showed_something=f 

  fork_debug_id=$debug_id_current
  if [[ "$fork_id_current" ]]; then
    fork_debug_id=$fork_id_current.$fork_debug_id
  fi

  if read -u $fd_original_in -t 0; then
    local c
    read -u $fd_original_in -sr -N 1 c
    if [[ "$c" == "$NL" ]]; then
      handle_user_interrupt
    fi
  fi
  show_trace_vars

  if [[ "$slow_down" ]]; then
    sleep $slow_down
  fi

  if [[ "${struct_type:-}" && "${pause_at_functions:-}" \
     && " $pause_at_functions " == *" ${FUNCNAME[1]} "* ]]; then
    handle_user_interrupt "Reached ${struct_type:-}."
  fi

  if [[ "${pause_at_debug_id:-}" ]] && reached_debug_id $pause_at_debug_id; then
    handle_user_interrupt "Reached ${pause_at_debug_id:-}."
  elif [[ "${debug_id:-}" && $debug_id != t ]] && reached_debug_id $debug_id; then
    if [[ "${debug_bisect_min:-}" ]]; then
      local response new_bisect
      if [[ "${bisect_test:-}" ]]; then
        eval "$bisect_test"
      fi
      prompt_ynq "${NL}Debug bisect: Did the problem happen?" response
      case $response in
        y)
          new_bisect=${debug_bisect_min}..${debug_id}
        ;;
        n)
          new_bisect=$(( debug_id + 1 ))..${debug_bisect_max}
        ;;
        q)
          exit 1
        ;;
      esac
      debug_get_new_bisect
      debug_restart_command=$new_command debug_exit=t debugging=
      exit 100
    else
      debug_id=t
      debug_immediate=t
      unignore_this_function=f \
      debug_start n
    fi
  elif [[ "${debug_quick_function:-}" && $debug_quick_function == ${FUNCNAME[1]} ]]; then
    #debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_function_old=$debug_quick_function
    debug_quick_function=
    debug_immediate=t
    unignore_this_function=f \
    debug_start n
  fi

  if [[ "${debug_quick_stop_less_than_depth:-}" ]] && \
     (( ${#FUNCNAME[*]} <= debug_quick_stop_less_than_depth )); then
    debug_quick_stop_less_than_depth=
    debug_immediate=t
    unignore_this_function=f \
    debug_start n
  fi

  (( no_trace_depth-- ))
}

trace_time_summarize() {
  eval "exec $trace_time_fd>&-"
  trace_time_fd=

  if [[ ! "$trace_time_log" ]]; then
    echo "Internal error: Missing trace_time_log" >&$fd_original_err
    return 1
  fi

  echo "$NL$hbar_equals" >&$fd_original_err
  echo "trace_time summary by function instance in chronological order:$NL" >&$fd_original_err
  { echo "duration(µs) function id_start id_end"; 
    awk '
    /^[0-9]/ { 
      x=$3; gsub("\\.", " ", x)
      y=x
      gsub("[^ ]", "", y)
      result=($1 " " $2 " " $3 " " $4 " " x)
      for(i=6-length(y); i>1; i--) {
        result=(result " 0")
      }
      print result
    }
    ' $trace_time_log | sort -n -k5 -k6 -k7 -k8 -k9 -k10 \
    | awk '{ print $1, $2, $3, $4 }' \
    | field=0 format_number_stream \
    | field=4 format_number_stream;
  } | column -t >&$fd_original_err

#  echo "$NL$hbar_equals"
#  echo "trace_time summary by function instance sorted by name:$NL"
#  { echo "duration(µs) function id_start id_end"; sort -k2 $trace_time_log } \
#    | field=0 format_number_stream | field=4 format_number_stream | column -t 
#
#  echo "$NL$hbar_equals"
#  echo "trace_time summary by function instance sorted by time:$NL"
#  { echo "duration(µs) function id_start id_end"; sort -n $trace_time_log } \
#    | field=0 format_number_stream | field=4 format_number_stream | column -t 

  echo "$NL$hbar_equals" >&$fd_original_err
  echo "trace_time summary by function sorted by time:$NL" >&$fd_original_err
  { echo "duration(µs) function executions"; sort -k2 $trace_time_log \
    | awk '
  BEGIN {
    prev=""
  }
  prev != $2 {
    if ( prev != "" && total > 0 ) print total " " prev " x" count
    prev=$2
    total=0
    count=0
  }
  {
    total+=$1
    count+=1
  }
  END {
    if ( prev != "" && total > 0 ) print total " " prev " x" count
  }
  ' | sort -n | field=0 format_number_stream; } \
  | column -t >&$fd_original_err

}

: ${trace_time:=f}

alias timebox_open='
  (( no_trace_depth++ ))
  timebox_stack+=( $timebox )
  trace_time_open
  (( no_trace_depth-- ))
'

alias timebox_close='
  (( no_trace_depth++ ))
  trace_time_close
  unset timebox_stack[-1]
  timebox=${timebox_stack[-1]}
  (( no_trace_depth-- ))
'

alias trace_time_open='
  if [[ $trace_time == t ]]; then
    if [[ ! ${trace_time_fd:-} ]]; then
      : ${trace_time_log:=/tmp/trace_time.log}
      [[ -e $trace_time_log ]] && rm $trace_time_log
      exec {trace_time_fd}<>$trace_time_log
    fi
    trace_time_start=${EPOCHREALTIME/./}
    trace_time_start_debug_id=$fork_debug_id
  fi
'

alias trace_time_close='
  if [[ $trace_time == t && "${trace_time_fd:-}" ]]; then
    trace_time_stop=${EPOCHREALTIME/./}
    (( time_dur = trace_time_stop - trace_time_start ))
    echo "$time_dur $timebox $trace_time_start_debug_id $fork_debug_id" >&$trace_time_fd
  fi
'

# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
alias begin_function_hi='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=2 repair_attempted=f current_function=${function_override:-$FUNCNAME} function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
  write_to_log_and_save 
  (( log_depth_current++ ))
  trace_time_open
  struct_type="start of $current_function" debug_id_inc
  log_vars= log_show_vars=
  stack_debug_id[$stack_pos]=$fork_debug_id
  stack_high_level[$stack_pos]=1
  while true; do
  if [[ ${debug_step_to_hi_function:-f} == t || ${debug_step_to_mid_function:-f} == t ]]; then
    debug_id=t
    debug_immediate=t
    local unignore_this_function=f
    debug_start n
  fi
  (( no_trace_depth-- ))
'

# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
alias begin_function='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=1 repair_attempted=f current_function=${function_override:-$FUNCNAME} function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
  trace_time_open
  struct_type="start of $current_function" debug_id_inc
  log_vars= log_show_vars=
  stack_debug_id[$stack_pos]=$fork_debug_id
  while true; do
  if [[ ${debug_step_to_mid_function:-f} == t ]]; then
    debug_id=t
    debug_immediate=t
    local unignore_this_function=f
    debug_start n
  fi
  (( no_trace_depth-- ))
'
  
# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
# This one switches between a low level and a mid level function, based on the grip variable
# grip=0 is default, where these functions will be low level
# grip=1 makes these functions mid level
alias begin_function_grip='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=0 repair_attempted=f current_function=${function_override:-$FUNCNAME} function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
  if (( grip > 0 )); then
    function_level=1
    trace_time_open
    struct_type="start of $current_function" debug_id_inc
    log_vars= log_show_vars=
    stack_debug_id[$stack_pos]=$fork_debug_id
  fi
  while true; do
  if (( grip > 0 )); then
    if [[ ${debug_step_to_mid_function:-f} == t ]]; then
      debug_id=t
      debug_immediate=t
      local unignore_this_function=f
      debug_start n
    fi
  fi
  (( no_trace_depth-- ))
'
  
# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
alias begin_function_lo='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=0 repair_attempted=f function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur log_show_vars= log_vars=
  while true; do
  (( no_trace_depth-- ))
'

alias end_function='
  (( no_trace_depth++ ))
  break
  done
  local log_return_vars=
  if (( function_level > 0 )); then
    stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
    struct_type="end of $current_function" debug_id_inc
    unset stack_debug_id[$stack_pos] stack_detail[$stack_pos] stack_high_level[$stack_pos]
  fi
  (( no_trace_depth-- ))
'

alias handle_return='
  (( no_trace_depth++ ))
  case ${function_level:-0} in
    2)
      timebox=$FUNCNAME
      trace_time_close
      load_log_vars_and_write_to_log
      (( log_depth_current-- ))
    ;;
    1)
      timebox=$FUNCNAME
      trace_time_close
    ;;
    0)
      if (( no_trace_depth-- <= 1 )); then 
        no_trace_depth=1
      fi
    ;;
  esac
  debug_return_vars=${log_return_vars:-}
  (( no_trace_depth-- ))
  return ${return_value:-0}
'

alias begin_while='break_out=f; while'
alias   begin_for='break_out=f; for'
alias  begin_loop='break_out=f; while true'
alias   end_while='done; debug_id_inc; [[ $break_out == t ]] && break'
alias     end_for='done; debug_id_inc; [[ $break_out == t ]] && break'
alias    end_loop='done; debug_id_inc; [[ $break_out == t ]] && break'

# end_while or end_for or end_loop should usually be used instead of this.
# This is helpful though if the done part needs to be separated from the break part
alias maybe_break='[[ $break_out == t ]] && break'

alias handle_exit='exit $return_value'

# to avoid bash syntax parsing problems, and provide a hook for loop beginning
alias         doo=do

#  instead of this, just put a fence at beginning of loop if an extra debug step is needed
#alias         doo='do debug_id_inc;'

# This performs the same debug_id advancement that begin_function and others do,
#   except unlike begin_function this may be placed anywhere within a function,
#   providing a stopping point for debugging of larger blocks of code that otherwise
#   can't be split up.
alias fence='debug_id_inc; log_show_vars='
alias fence_grip='(( grip > 0 )) && debug_id_inc; log_show_vars='

# used after a direct command which may fail: cd /somewhere || fail
alias fail='{ return_value=$?; (( return_value < 100 )) && attempt_autorepair $FUNCNAME && { repair_attempted=t; continue; }; break_out=t; break; }'
alias fail_later='{ return_value=$?; break_out=t; }'
alias fail_later1='{ return_value=1; break_out=t; }'

# used as a standalone command triggering the failed state and exiting the block
alias fail1='{ return_value=1; attempt_autorepair $FUNCNAME && { repair_attempted=t; continue; }; break_out=t; break; }'
alias fail2='{ return_value=2; attempt_autorepair $FUNCNAME && { repair_attempted=t; continue; }; break_out=t; break; }'
alias succeed='{ return_value=100; break_out=t; break; }'

# used to check if something failed: failed && break
alias failed='(( return_value > 0 && return_value < 100 ))'
alias abort='{ return_value=0; break_out=t; break; }'
alias succeeded='(( return_value == 0 || return_value >= 100 ))'
alias handle_break='[[ $break_out == t ]] && break'

attempt_autorepair() {
  local repair_successful=f func_name=$1

  if [[ "${debug_quick_function:-}" == fail ]]; then
    debug_immediate=t
    debug_start
  fi

  if [[ $autorepair_level > 0 && ${repair_attempted:-f} == f ]] \
    && declare -pf repair_$func_name &>/dev/null
    then
    log_debug "Attempting auto-repair of $func_name"
    repair_$func_name

    if [[ $repair_successful == t ]]; then
      log_debug "Autorepair of $func_name successful."
      return_value=0 break_out=f
    else
      log_debug "Autorepair of $func_name failed."
    fi

  fi

  [[ $repair_successful == t ]]
}

#!/bin/bash

type -t bash_lib_loaded >/dev/null && return 0
bash_lib_loaded=t

set -u +Hm -o pipefail
shopt -s expand_aliases extglob dotglob globstar huponexit

umask 0077  # to make created files readable only by the user by default

if [[ ! -v fd_original_in ]]; then
  exec {fd_original_in}<&0
  exec {fd_original_out}>&1
  exec {fd_original_err}>&2
  exec {fd_original_trace}>&${fd_trace:-2}
fi

# use this to make vars local which are computed by another function call
alias local_vars='[[ "${to_local_vars:-}" ]] && eval "local $to_local_vars"'

# some parts of bash require a statement, but in some cases there's nothing to be
# done, so this serves as a clear indication that nothing needs to be done, and yet
# satisfies the requirement that a statement be there. 
alias nothing=':;'

# some required defaults
export tmp_folder="${tmp_folder:-/tmp}"
export EDITOR=${EDITOR:-vim}

export tracing_depth=${tracing_depth:-0}
export no_trace_depth=${no_trace_depth:-0}

alias start_tracing='(( tracing_depth++ == 0 )) && set -x'
alias stop_tracing='(( --tracing_depth <= 0 )) && { set +x; tracing_depth=0; }'

# used in if condition to be more clear.
# instead of:
#   if ! diff $f1 $f2; then ...
# write:
#   if are_different $f1 $f2; then ...
alias files_are_different='! diff >/dev/null'
alias files_are_same='diff >/dev/null'

NL=$'\n'
CR=$'\r'
TAB=$'\t'
ESC=$'\e'
DQ='"'
SQ="'"

     DIM_RED=$'\033[0;31m'
         RED=$'\033[1;31m'
   DIM_GREEN=$'\033[0;32m'
       GREEN=$'\033[1;32m'
  DIM_YELLOW=$'\033[0;33m'
      YELLOW=$'\033[1;33m'
    DIM_BLUE=$'\033[0;34m'
        BLUE=$'\033[1;34m'
  DIM_PURPLE=$'\033[0;35m'
      PURPLE=$'\033[1;35m'
    DIM_CYAN=$'\033[0;36m'
        CYAN=$'\033[1;36m'
   DIM_WHITE=$'\033[0;37m'
       WHITE=$'\033[1;37m'
   DIM_BLACK=$'\033[0;38m'
       BLACK=$'\033[1;38m'
       RESET=$'\033[0m'
  CLEAR_LINE=$'\033[2K\r'
       CLEAR=$'\033[2J'
CLEAR_SCREEN=$'\033[2J\r\033[H'
   CURSOR_UP=$'\033[1A'
     REVERSE=$'\033[7m'
   HIGHLIGHT=$'\033[1;37m'

COL0=$'\n\e[A\e[0G'     COL5=$'\n\e[A\e[5G'     COL10=$'\n\e[A\e[10G'
COL15=$'\n\e[A\e[15G'   COL20=$'\n\e[A\e[20G'   COL25=$'\n\e[A\e[25G'
COL30=$'\n\e[A\e[30G'   COL35=$'\n\e[A\e[35G'   COL40=$'\n\e[A\e[40G'
COL45=$'\n\e[A\e[45G'   COL50=$'\n\e[A\e[50G'   COL55=$'\n\e[A\e[55G'
COL60=$'\n\e[A\e[60G'   COL65=$'\n\e[A\e[65G'   COL70=$'\n\e[A\e[70G'
COL75=$'\n\e[A\e[75G'   COL80=$'\n\e[A\e[80G'   COL85=$'\n\e[A\e[85G'
COL90=$'\n\e[A\e[90G'   COL95=$'\n\e[A\e[95G'   COL100=$'\n\e[A\e[100G'
COL110=$'\n\e[A\e[110G' COL120=$'\n\e[A\e[120G' COL130=$'\n\e[A\e[130G'
COL140=$'\n\e[A\e[140G' COL150=$'\n\e[A\e[150G' COL160=$'\n\e[A\e[160G'
COL170=$'\n\e[A\e[170G' COL180=$'\n\e[A\e[180G' COL190=$'\n\e[A\e[190G'
COL200=$'\n\e[A\e[200G'

eval "printf -v hbar_tilde '%.s~' {1..${COLUMNS:-40}}"
eval "printf -v hbar_equals '%.s=' {1..${COLUMNS:-40}}"
eval "printf -v hbar_minus '%.s-' {1..${COLUMNS:-40}}"

get_var_value() {
  local var_name=$1 val_name=${2:-value}
  if [[ "$var_name" =~ ^[0-9]+ ]]; then
    eval "$val_name=\$$var_name"
  else
    local -n _var=$var_name _val=${2:-value} || return 1
    _val='(unbound)'
    if is_array _var; then
      if [[ "${_var:-}" ]] && (( ${#_var[*]} > 20 )); then
        _val="( ${_var[*]:0:20} ... )"
      else
        _val="( ${_var[*]:-} )"
      fi
    elif is_set _var; then
      local c=0 k v
      _val="( "
      for k in "${!_var[@]}"; do
        v=${_var[$k]}
        if [[ "${v:-}" ]]; then
          _val+="$k=$v "
        else
          _val+="$k=(empty) "
        fi
        (( c++ ))
        if (( c > 20 )); then
          _val+="... "
          break
        fi
      done
      _val+=")"
    elif [[ -v _var ]]; then
      _val=$_var
      newlines=preserved quotes=single shell_quote_var _val
    else
      _val='(unset)'
    fi
  fi
}

micros_to_minute() {
  local -n _t=$1
  (( _t = _t / 1000000 / 60 ))
}

# input:
#   $1   path to file with wildcard in it
# output:
#   returns true (0) if at least one file exists matching the pattern
wild_file_exists() {
  local pattern=$1
  [[ "$pattern" != *'*'* ]]
}

progress_bar_start() {
  local new_progress_bar_size=$1 front_load=${front_load:-3} below_log=${below_log:-verbose}
  if ! log_level_at_least $below_log && [[ "${trace_structure:-f}" == f ]]; then
    progress_bar_total=${progress_bar_total:-0}
    progress_bar_nesting=${progress_bar_nesting:-0}
    progress_bar_front_load=${progress_bar_front_load:-$front_load}
    (( progress_bar_total += new_progress_bar_size ))
    (( progress_bar_nesting++ ))
    progress_bar_start_time=${progress_bar_start_time:-${EPOCHREALTIME/./}}
    progress_bar_current=0
    
    if (( progress_bar_total > 2 )); then
      echo -n "0% complete" >&$fd_original_err
#    else
#      echo -n "..." >&$fd_original_err
    fi
  fi
}

progress_bar_next() {
  local amount_to_add=${1:-1} percentage
  if (( ${progress_bar_nesting:-0} > 0 )); then
    (( progress_bar_current += amount_to_add ))
    if (( progress_bar_total > 2 )); then
      (( percentage = 100 * progress_bar_current / progress_bar_total ))
      local time_taken_micro total_micro remaining_micro extra= remaining_min current_time=${EPOCHREALTIME/./}
      (( time_taken_micro = current_time - progress_bar_start_time ))
      (( total_micro = time_taken_micro * progress_bar_total / progress_bar_current ))
      (( remaining_micro = total_micro - time_taken_micro ))

      remaining_min=$remaining_micro
      (( percentage < 25 )) && (( remaining_min *= progress_bar_front_load ))
      micros_to_minute remaining_min
      if (( remaining_min > 0 )); then
        extra=" ($remaining_min minute(s) left)"
      fi

      if [[ "${progress_bar_last_percentage:-}" != $percentage ]]; then
        echo -n "$CLEAR_LINE" >&$fd_original_err
        echo -n "...$percentage% complete$extra" >&$fd_original_err
      fi
      progress_bar_last_percentage=$percentage
    else # too few total items in progress bar to show %
      local out
      eval "printf -v out '%.s.' {1..$amount_to_add}"
      echo -n "$out"
    fi
  fi
}

progress_bar_nudge() {
  local output_char=${1:-.}
  if (( ${progress_bar_nesting:-0} > 0 )); then
    echo -n "$output_char" >&$fd_original_err
  fi
}

progress_bar_stop() {
  if (( ${progress_bar_nesting:-0} > 0 )); then
    (( progress_bar_nesting-- ))
    if (( progress_bar_nesting == 0 )); then
      local time_taken current_time=${EPOCHREALTIME/./}
      (( time_taken = current_time - progress_bar_start_time ))
      micros_to_minute time_taken
      if (( time_taken > 0 )); then
        echo "...Completed in $time_taken minutes." >&$fd_original_err
      else
        echo -n "${CLEAR_LINE}" >&$fd_original_err
      fi
      unset progress_bar_total progress_bar_nesting \
            progress_bar_front_load progress_bar_start_time \
            progress_bar_current
    fi
  fi
}

# input:
#   $1   previous timestamp (in microseconds, as from EPOCHREALTIME
#   $2   next timestamp
#   $3   var name to write result to, writes time in seconds with .
micro_time_diff() {
  local before=$1 after=$2
  local -n to_var=$3
  local diff=$((after-before)) p1 p2
  diff="000000$diff"
  p1=${diff%%??????}
  p2=${diff#$p1}
  p1=${p1##*(0)}
  to_var="${p1:-0}.$p2"
}

remove_empty_parents() {
  local dir=$1 contents recursive=${recursive:-f}
  contents=( $(find1 "$dir") ) || return 1
  if (( ${#contents[*]} == 0 )); then
    rm -r $dir || return 1
    if [[ $recursive == t && "$dir" == /*/*/* ]]; then
      remove_empty_parents "${dir%/*}" || return 1
    fi
  fi
}

valid_var_name() { 
  [[ "$1" =~ [a-zA-Z0-9_]+ ]]
}

# used for temporary logging to debug issues. Uses of this should be removed before
#   committing changes. 
zombie() {
  local s=${BASH_SOURCE[1]:-(no source)} \
    f=${FUNCNAME[1]:-(no func)}
  s=${s##*/}
  echo "$CYAN$EPOCHREALTIME debug_id=${fork_debug_id:-} $f $s:${BASH_LINENO[0]} $*$RESET" >&$fd_original_err
}

zombie_lap_reset() {
  zombie_lap_total=0
  unset zombie_lap_time
  declare -Ag zombie_lap_time
  unset zombie_lap_count
  declare -Ag zombie_lap_count
}

# used for temporary debugging of performance issues
# will aggregate time spent between each lap and show percentages and totals
# calls to this should be removed before committing code
# usage: zombie_lap "message..."
zombie_lap() {
  local current=$* ts=${EPOCHREALTIME/./} diff=0 p p1 p2 m

  if [[ "${zombie_lap_prev:-}" ]]; then
    m="$zombie_lap_prev -> $current"
  else
    m=$current
  fi
  zombie_lap_prev=$current

  if [[ "${zombie_lap_last_ts:-}" ]]; then
    (( diff = ts - zombie_lap_last_ts ))
  else
    zombie_lap_reset
  fi

  zombie_lap_last_ts=$ts
  : ${zombie_lap_time[$m]:=0} ${zombie_lap_count[$m]:=0} \
    ${zombie_lap_detail:=f} ${zombie_lap_max_diff:=10000000}
  local extra=

  if (( diff > 0 )); then
    if (( diff < $zombie_lap_max_diff )); then
      (( zombie_lap_time[$m] += diff ))
      (( zombie_lap_count[$m] += 1 ))
      (( zombie_lap_total += diff ))
      if [[ $zombie_lap_detail == f ]]; then
        return 0
      fi
      (( percent = zombie_lap_time[$m] * 10000 / zombie_lap_total ))
      percent="00$percent"
      p1=${percent%??}
      p2=${percent#$p1}
      p1=${p1##*(0)}
      percent="${p1:-0}.$p2"
      extra="[diff=$diff sum=${zombie_lap_time[$m]} $percent%] "
    else
      extra="[exceeded zombie_lap_max_diff $diff > $zombie_lap_max_diff] "
    fi
  fi

  if [[ $zombie_lap_detail == t ]]; then
    echo "$CYAN$EPOCHREALTIME zombie_lap: $extra$m$RESET" >&2
  fi
}

zombie_lap_summary() {
  local key val count percent p1 p2
  echo "TIME${TAB}PERCENT${TAB}COUNT${TAB}NAME" >&2
  for key in "${!zombie_lap_time[@]}"; do
    val=${zombie_lap_time[$key]}
    count=${zombie_lap_count[$key]}
    if [[ "$val" && "$val" -gt 0 ]]; then
      (( percent = val * 10000 / zombie_lap_total ))
      percent="00$percent"
      p1=${percent%??}
      p2=${percent#$p1}
      p1=${p1##*(0)}
      percent="${p1:-0}.$p2"
      echo "$val$TAB$percent%$TAB$count$TAB$key"
    fi
  done | sort -gr >&2
  echo "Total: $zombie_lap_total" >&2
}

# calls to this should be converted to normal evals before committing code
zombie_eval() {
  local s=${BASH_SOURCE[1]:-(no func)}
  s=${s##*/}
  echo "$CYAN$EPOCHREALTIME $s:${BASH_LINENO[0]} $*$RESET" >&2
  eval "$*"
}

array_contains() {
  local -n __array=$1
  local look_for=$2 i found=f
  for (( i = 0; i < ${#__array[*]}; i++ )); do
    if [[ ${__array[$i]} == "$look_for" ]]; then
      found=t
      break
    fi
  done
  [[ $found == t ]]
}

dedup_array() {
  local -n from=$1 to=$2
  local -A already_copied
  local e
  for e in "${from[@]}"; do
    if [[ ! "${already_copied[$e]:-}" ]]; then
      to+=( "$e" )
      already_copied["$e"]=1
    fi
  done
}

# does not work if members of array contain newlines
sort_array() {
  local -n _v=$1
  local v OIFS=$IFS
  IFS=$NL
  _v=( $(
  for v in "${_v[@]}"; do
    echo "$v"
  done | sort) )
  IFS=$OIFS
}

intersect() {
  local -n _old_values=$1 _new_values=$2 _intersected=$3
  local v
  for v in "${!_old_values[@]}"; do
    if [[ -v _new_values[$v] ]]; then
      _intersected[$v]=1
    fi
  done
  debug_return_vars=$3
}

clear_set() {
  local -n _x=$1
  local v
  for v in "${!_x[@]}"; do
    unset _x[$v]
  done
}

# will NOT wipe out what's already in target var
add_to_set() {
  local -n _from=$1 _to=$2
  local v
  for v in "${!_from[@]}"; do
    _to[$v]=1
  done
  debug_return_vars=$2
}

# will NOT wipe out what's already in target var
add_to_map() {
  local -n _from=$1 _to=$2
  local v
  for v in "${!_from[@]}"; do
    _to[$v]=${_from[$v]}
  done
  debug_return_vars=$2
}

# inputs:
#   $1   name of variable containing string to add
#   $2   name of variable to add string to
add_to_string_if_missing() {
  local -n element=$1 target_string=$2
  if [[ ! -v target_string ]]; then
    target_string=
  fi
  if [[ " $target_string " != *" $element "* ]]; then
    if [[ "${target_string:-}" ]]; then
      target_string+=" $element"
    else
      target_string+="$element"
    fi
  fi
  debug_return_vars=$2
}

# variable should be checked to see if it is set first
is_array() {
  local -n _array=$1
  local rc
  set +u
  [[ ${_array@a} == a ]]; rc=$?
  set -u
  return $rc
}

# variable should be checked to see if it is set first
is_set() {
  local -n _set=$1
  local rc
  set +u
  [[ ${_set@a} == A ]]; rc=$?
  set -u
  return $rc
}

split_to_array() {
  local -n from_var=$1;
  local -n to_var=${2:-$1}
  local separator=${separator:-$'\n'}
  local IFS=$separator
  to_var=( $from_var )
}

array_to_string() {
  local -n _from_array=$1 _to_string=$2
  local v
  _to_string="( "
  for v in "${_from_array[@]}"; do
    quotes=single shell_quote_var v
    _to_string+="$v "
  done
  _to_string+=")"
}

string_to_array() {
  local -n _from_string=$1 _to_array=$2
  local from=$_from_string part
  local separator=${separator:-${sep:-' '}}
  _to_array=()
  while [[ "$from" == *"$separator"* ]]; do
    part=${from%%$separator*}
    _to_array+=( "$part" )
    from=${from#$part$separator}
  done
  if [[ "$from" ]]; then
    _to_array+=( "$from" )
  fi
}

string_to_set() {
  local -n _from_string=$1 _to_set=$2
  local v
  for v in ${_from_string}; do
    _to_set[$v]=1
  done
  debug_return_vars=$2
}

# WILL wipe out target var, and replace with source
copy_set() {
  clear_set $2
  add_to_set $1 $2
}

# WILL wipe out target var, and replace with source
copy_map() {
  clear_set $2
  add_to_map $1 $2
}

# inputs:
#   $1   var name which is a set (associative array) to read from
#   $2   var name which is an array to write the keys of the set to
keys_to_array() {
  local -n key_set=$1 out_array=$2
  if [[ -v key_set[*] ]]; then
    if (( ${#key_set[*]} > 0 )); then
      out_array=( "${!key_set[@]}" )
    fi
  else
    out_array=()
  fi
  debug_return_vars=$2
}

get_value_from_table() {
  local -n data=${table_var}_data fields=${table_var}_fields
  local field=$field row=${row:-0} offset i field_count=${#fields[*]} data_count=${#data[*]}

  value=
  (( offset = field_count * row ))
  for (( i = 0; i < field_count; i++ )); do
    if [[ ${fields[$i]} == $field ]]; then
      value=${data[$(( offset + i ))]}
      break
    fi
  done
}

# get input from the user to select from a given set of possibilities and assign
# the result to the given variable.
# usage: choose {prompt string} {var} {choices...}
# prompt string: prompt to show user
# var: variable to assign choice to
# choices: space separated list of options
choose() {
  local prompt=$1; shift
  local var_name=$1; shift
  local -n var=$var_name
  
  if (( $# > 0 )); then
    local PS3=$prompt
    select var; do break; done
    if [[ "$var" ]]; then
      return 0
    else
      return 1
    fi
  else
    if [[ "${secret_vars:-}" && " $secret_vars " == *\ $var_name\ * ]]; then
      read -sr -p "$prompt" $var_name >&2 || return 1
      echo "********" >&2
    else
      read -r -p "$prompt" $var_name >&2 || return 1
    fi
  fi
  return 0
}

out_wrap() {
  local message="$@" indent=${indent:-0} pad
  trim_ws message
  message=${message//$NL/}
  message=${message//+( )/ }
  printf -v pad %${indent}s
  echo "$message" | fold -s -w $((COLUMNS-1)) | sed "s/^/$pad/"
}

# primitive logging functions. If using omni-logger, you should use log_info, etc instead
out() {
  local indent=${indent:-0} pad
  printf -v pad %${indent}s
  echo "$@" | sed "s/^/$pad/"
}

# primitive logging functions. If using omni-logger, you should use log_info, etc instead
out_no_nl() {
  local message="$*" indent=${indent:-0} pad
  printf -v pad %${indent}s
  echo -n "$message" | sed "s/^/$pad/"
}

# primitive logging functions. If using omni-logger, you should use log_fatal, etc instead
err() {
  #echo "$RED$*$RESET" >&2
  echo "$*" >&$fd_original_err
}

# primitive logging functions. If using omni-logger, you should use log_warn, etc instead
warn() {
  echo "$YELLOW$*$RESET" >&2
}

# indents an input stream by the given number of spaces (defaults to 2 spaces)
indent() {
  local amount=${1:-2} pad
  printf -v pad %${amount}s
  sed "s/^/$pad/"
}

function_exists() {
  declare -pf $1 &>/dev/null
}

execute_if_exists() {
  local function_name=$1 full_command=$*
  if declare -pf $function_name &>/dev/null; then
    $full_command || return 1
  fi
  return 0
}

ansi_filter_stream() {
  local line
  local IFS=
  while read -r line || [[ "$line" ]]; do
    printf '%s\n' "${line//$ESC[\[(]*([0-9;])[@-n]/}"
  done
}

ansi_filter_var() {
  local -n var=$1
  var="${var//$ESC[\[(]*([0-9;])[@-n]/}"
  var="${var//$ESC[?????l/}"
}

plural() {
  local count=$1 word=$2
  if [[ $count -eq 1 ]]; then
    echo "$count $word"
  else
    echo "$count ${word}s"
  fi
}

find1() {
  if [[ ! -d "${1:-}" ]]; then
    echo "find1: directory missing: ${1:-}" >&$fd_original_err
    return 1
  fi
  local path=$1; shift
  find -L "$path" -mindepth 1 -maxdepth 1 "$@"
  return 0
}

hydrate_template() {
  if [[ "$line" =~ \$ ]]; then
    line="${line//\"/\\\"}"
    eval "echo \"$line\"" || return 1
  else
    echo "$line"
  fi
}

# prompt_ynsq {message} {var to save result into}
# Allows: (y)es (n)o (q)uit
prompt_ynq() {
  local message=$1 var=$2
  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&2
  fi

  while true; do
    read -s -n 1 -p "${GREEN:-}$message${RESET:-} (y/n/q) " $var >&2
    case ${!var} in
      y)
        echo "Yes" >&2  
        ;;
      n)
        echo "No" >&2 
        ;;
      q)
        echo "Quit" >&2 
        ;;
      *)
        err "Pick one of: (y)es (n)o (q)uit"
        continue
        ;;
    esac
    break
  done
}

# should pass in a single command or a { } block of commands
# will run this command after script terminates (whether successfully or in error)
defer() {
  if [[ "${cleanup_on_exit:-}" != *"$1"* ]]; then
    eval "cleanup_on_exit+='$1 &>/dev/null;'"
  fi
}

undefer() {
  local command=$1
  cleanup_on_exit=${cleanup_on_exit/"$command &>/dev/null;"/}
  eval "$command"
}

# usage: random {p=number of possibilities}
#   sets r={random number between 0 and p-1}
#   it will be fairly evenly distributed below about 1000, but will become more biased as it gets higher
random() {
  local p=$1
  r=$((RANDOM % p))
}

# usage: random_sleep {min} {max}
#   will sleep for a random interval between min and max
random_sleep() {
  local min=$1; shift
  local max=$1
  random $((max-min))
  sleep $((min+r))
}

escape_regex_single() {
  local -n internal_var=$1
  internal_var=${internal_var//\"/\\\"}
  internal_var=${internal_var// /\\ }
  internal_var=${internal_var//\(/\\\(}
  internal_var=${internal_var//)/\\)}
  internal_var=${internal_var//\?/\\\?}
  internal_var=${internal_var//\$/\\\$}
}

escape_regex() {
  local -n var=$1
  local trim=${trim:-f} var_array

  if [[ $trim == t ]]; then
    var_array=$var
    var=
    split_to_array var_array
    local i e size=${#var_array[*]}
    for (( i = 0; i < size; i++ )); do
      e=${var_array[$i]}
      e=${e##*( )}
      e=${e%%*( )}
      escape_regex_single e
      var+=$e
      if (( i < size - 1 )); then
        var+=$NL
      fi
    done
  else
    escape_regex_single var
  fi
}

literal_to_regex() {
  local -n var=$1
  var=${var//\\/\\\\}
  var=${var//\$/\\\$}
  var=${var//^/\\^}
  var=${var//\[/\\\[}
  var=${var//\]/\\\]}
  var=${var//./\\.}
}

shell_quote_var() {
  local var_name=$1
  local -n var=$var_name
  local quotes=${quotes:-single} # can be single, double, or dollar
  local newlines=${newlines:-preserved} # can be escaped or preserved
  local quote_empty=${quote_empty:-t}

  if [[ ! -v var ]]; then
    log_fatal "shell_quote_var called on unset var: $1"
    return 1
  fi

  if [[ "$var" =~ \<|\>|\(|\)|\"|\'|\\|\ |\$|$NL ]]; then
    if [[ $quotes == single ]]; then
      var=${var//\'/\'\"\'\"\'}
      var="'$var'"
    elif [[ $quotes == dollar ]]; then
      var=${var//\'/\\x27}
      var=${var//$NL/\\n}
      var="\$'$var'"
    else
      var=${var//\\/\\\\}
      var=${var//\"/\\\"}
      var=${var//\$/\\\$}
      var="$DQ$var$DQ"
    fi
  elif [[ ! "$var" && $quote_empty == t ]]; then
    if [[ $quotes == single ]]; then
      var="''"
    elif [[ $quotes == dollar ]]; then
      var="\$''"
    else
      var='""'
    fi
  fi

  if [[ "$newlines" == escaped ]]; then
    var=${var//$NL/\\n}
  fi

  return 0
}

dir_is_empty() {
  local content=( "$1"/* )
  [[ ! -e $content ]]
}

# will remove duplicate whitespace and trim leading and trailing
# do not use for large strings, it is too inefficient
compress_ws() {
  local -n v=$1
  v=${v//+([ $NL$TAB])/ }
  v=${v##*([ $NL$TAB])}
  v=${v%%*([ $NL$TAB])}
}

# usage: trim_ws {var name}
# will remove trailing and leading whitespace
trim_ws() {
  local -n x=$1
  if (( ${#x} > 1000 )); then
    x=$(echo -n "$x" | awk '
      BEGIN { after_first_line = 1 }
      NR == 1 { sub("^ +", "") }
      after_first_line == 1 { print line }
      { line = $0 }
      END { sub(" +$", "", line); if (NR > 0) print line }')
  else
    x=${x##*([$NL $TAB])}
    x=${x%%*([$NL $TAB])}
  fi
}

# usage: echo -e "\n\n blah  \n\n" | trim_stream_nl
# will trim empty lines from beginning and end of given string
# will leave exactly one trailing newline at the end
trim_stream_nl() {
  local block
  read -r -d '' block
  block=${block##*($NL)}
  block=${block%%*($NL)}
  echo "$block"
}

# usage: echo " blah   " | trim
# will trim whitespace from beginning and end of each line in the given input
trim_stream() {
  sed -E -e 's/^[[:space:]]+//' -e 's/[[:space:]]+$//' | grep -v '^$'
}

declare -A apad_size apad_min apad_max
# append a string to another string + padding according to the class of item being added
# Usage: apad {base var name} [{class of append string} {append string}]...
# The base var will be directly appended to with the append string and maybe padding
# You should include spaces in the append string itself if you want to guarantee a minimum
#   amount of space.
# You may define explicit min/maxes for various classes by adding entries to the apad_min and
#   apad_max maps, and can setup initial sizes with the apad_size map
apad() {
  local -n base=$1; shift
  local class append append_size class_size class_min class_max pad pad_size
  while (( $# > 1 )); do

    class=$1 append=$2; shift 2
    append_size=${#append}

    if [[ ! -v apad_min[$class] ]]; then
      apad_min[$class]=0
    fi
    class_min=${apad_min[$class]}

    if [[ ! -v apad_size[$class] ]]; then
      apad_size[$class]=$class_min
    fi
    class_size=${apad_size[$class]}

    if [[ ! -v apad_max[$class] ]]; then
      apad_max[$class]=1000
    fi
    class_max=${apad_max[$class]} 

    if (( append_size > class_size && class_size < class_max )); then
      apad_size[$class]=$append_size
      if (( class_size > class_max )); then
        apad_size[$class]=$class_max
      fi
    fi

    pad_size=0
    if (( class_size > append_size )); then
      (( pad_size = class_size - append_size ))
    fi

    base+=$append

    if (( pad_size > 0 )); then
      printf -v pad %${pad_size}s
      base+=$pad
    fi

  done
}

# Usage: apad_calc [{class of append string} {append string}]...
# similar to apad, except that it doesn't write to a var, it only calculates boundaries
apad_calc() {
  local class append append_size class_size class_min class_max pad pad_size
  while (( $# > 1 )); do

    class=$1 append=$2; shift 2
    append_size=${#append}

    if [[ ! -v apad_min[$class] ]]; then
      apad_min[$class]=0
    fi
    class_min=${apad_min[$class]}

    if [[ ! -v apad_size[$class] ]]; then
      apad_size[$class]=$class_min
    fi
    class_size=${apad_size[$class]}

    if [[ ! -v apad_max[$class] ]]; then
      apad_max[$class]=1000
    fi
    class_max=${apad_max[$class]} 

    if (( append_size > class_size && class_size < class_max )); then
      apad_size[$class]=$append_size
      if (( class_size > class_max )); then
        apad_size[$class]=$class_max
      fi
    fi

  done
}

# For debugging: shows the current apad padding information
apad_info() {
  local k
  for k in "${!apad_size[@]}"; do
    echo "$k: size=${apad_size[$k]} min=${apad_min[$k]} max=${apad_max[$k]}"
  done
}

upper_first_char() {
  local string=$1
  local first=${string:0:1}
  first=$(echo -n "$first" | tr '[:lower:]' '[:upper:]')
  echo -n "$first${string:1}"
}

# usage: convert_to_seconds {from time period} {to var name}
convert_to_seconds() {
  local from=$1
  local -n _to=$2
  case "$from" in
    *s)
      _to=${from%s}
    ;;
    *m)
      _to=$((${from%m}*60))
    ;;
    *h)
      _to=$((${from%h}*60*60))
    ;;
    *d)
      _to=$((${from%d}*24*60*60))
    ;;
    *w)
      _to=$((${from%w}*7*24*60*60))
    ;;
    *y)
      _to=$((${from%y}*365*24*60*60))
    ;;
    *)
      if [[ "$from" =~ ^[0-9]+$ ]]; then
        # default to seconds
        _to=$from
      else
        log_fatal "Unknown time format, use something like: 4h, 3d, 5m"
        return 1
      fi
    ;;
  esac
  return 0
}

# usage: convert_to_seconds {from seconds} {to var name}
convert_from_seconds() {
  local from=$1
  local -n _to=$2
  if (( from < 120 )); then
    _to=${from}s
  elif (( from < 120 * 60 )); then
    _to=$(( from / 60 ))m
  elif (( from < 48 * 60 * 60 )); then
    _to=$(( from / 60 / 60 ))h
  else
    _to=$(( from / 60 / 60 / 24 ))d
  fi
}

get_overlap() {
  local i
  result=
  for ((i=0; i<${#1}; i++)); do
    [[ "${1:$i:1}" != "${2:$i:1}" ]] && break
    result+=${1:$i:1}
  done
}

# inputs: 
#   from    directory to link to target
#   to      target to link to
#   timeout how long to wait in miliseconds
# if timeout is not given, then attempt will immediately fail if it can not get the lock right away
#   otherwise it will keep trying until the timeout is reached or the lock is obtained.
link_lock() {
  local from=$from
  local to=$to
  local timeout=${timeout:-}
  local pid_file=${pid_file:-$to/pid}

  local log_vars='from to timeout'
  begin_function_hi

    if [[ ! -e "$from" ]]; then
      log_fatal "$from doesn't exist, can't link lock it"
      fail1
    fi
    
    if [[ -L "$to" ]]; then

      log_debug "Lock link exists already: $to"
      local pid=

      if [[ -f "$pid_file" ]]; then
        pid=$(<"$pid_file")
        if [[ "$pid" == $$ ]]; then
          log_debug "This process already owns the lock, so we are done."
          abort
        fi
      fi

      # check to see if the process is still running
      if [[ ! "$pid" ]] || ! ps $pid &>/dev/null; then
        rm "$to" || fail
        log_debug "Removed stale lock: $to with pid: $pid"
      fi

    elif [[ -e "$to" ]]; then
      log_fatal "$to already exists and it's not a link. Can't obtain lock."
      fail1
    fi

    local parent=${to%/*}
    if [[ ! -d "$parent" ]]; then
      log_fatal "Target of link lock isn't in a folder ($to)"
      fail1
    fi

    local timeleft
    let timeleft=timeout
    local delay=250
    local success=f
    begin_while true; doo
      ln -sn "$from" "$to" &>/dev/null && success=t
      if [[ $success == t ]]; then
        echo $$ >"$pid_file" || fail
        break
      fi

      if [ ! "$timeout" ]; then
        break
      fi

      local seconds_to_wait=$(dc -e "2 k $delay 1000 / p")
      log_debug "Failed to obtain lock. Waiting $seconds_to_wait seconds before trying again."
      sleep $seconds_to_wait
      timeleft=$((timeleft-delay))

      let delay*=2
      if (( delay > 10000 )); then
        delay=10000
      fi

      if (( timeleft <= 0 )); then
        log_warn "Timeout reached. Couldn't obtain the lock in time."
        break
      fi

    end_while

    if [[ $success == f ]]; then
      log_debug "Failed to obtain lock."
      fail1
    fi

    defer "rm '$pid_file' '$to' &>/dev/null"

    # lock obtained
    log_debug "Succeeded in obtaining lock."

  end_function
  handle_return
}

link_unlock() {
  local to=$to
  local pid_file=${pid_file:-$to/pid}

  if [[ -f "$pid_file" ]]; then
    rm "$pid_file" || return 1
  fi

  if [[ -L "$to" ]]; then
    rm "$to" || return 1
  elif [[ -e "$to" ]]; then
    log_fatal "$to is not a link, can't unlock it"
    return 1
  fi

  return 0
}

# inputs: folder_to_lock timeout pid_file
# if timeout is not given, then attempt will immediately fail if it can't get the lock right away
#   otherwise it will keep trying until the timeout is reached or the lock is obtained.
folder_lock() {
  local folder_to_lock=${folder_to_lock}
  local timeout=${timeout:-$lock_timeout}
  local pid_file=${pid_file:-$folder_to_lock/pid}
  local remove_folder_when_unlocked=${remove_folder_when_unlocked:-f}

  local log_vars='folder_to_lock timeout'
  begin_function_hi

    if [[ -d "$folder_to_lock" ]]; then

      log_debug "Lock folder exists already: $folder_to_lock"
      local pid=

      if [[ -f "$pid_file" ]]; then
        pid=$(<"$pid_file")
        if [[ "$pid" == $$ ]]; then
          log_debug "This process already owns the lock, so we are done."
          abort
        fi
      fi

      # check to see if the process is still running
      if [[ ! "$pid" ]] || ! ps $pid &>/dev/null; then
        rm -rf "$folder_to_lock" || fail
        log_debug "Removed stale lock: $folder_to_lock with pid: $pid"
      fi

    fi

    local timeleft
    let timeleft=timeout*1000
    local delay=250
    local success=f
    local parent=${folder_to_lock%/*}
    if [[ -d "$parent" ]]; then
      begin_while true; doo
        mkdir "$folder_to_lock" &>/dev/null && success=t
        if [[ $success == t ]]; then
          echo $$ >"$pid_file" || fail
          break
        fi

        if [ ! "$timeout" ]; then
          break
        fi

        local seconds_to_wait=$(dc -e "2 k $delay 1000 / p")
        log_debug "Failed to obtain lock. Waiting $seconds_to_wait seconds before trying again."
        sleep $seconds_to_wait
        timeleft=$((timeleft-delay))
        let delay*=2
        if [ "$timeleft" -le 0 ]; then
          log_warn "Timeout reached. Couldn't obtain the lock in time."
          break
        fi
      end_while
    else
      log_fatal "Attempting to obtain a folder lock when it's parent doesn't exist: $parent"
      fail1
    fi

    if [[ $success == f ]]; then
      log_debug "Failed to obtain lock."
      fail1
    fi

    if [[ $remove_folder_when_unlocked == t ]]; then
      defer "rm -r '$pid_file' '$folder_to_lock' &>/dev/null"
    fi

    log_debug "Succeeded in obtaining lock."

  end_function
  handle_return
}

folder_is_locked() {
  local folder_to_lock=$folder_to_lock
  local pid_file=${pid_file:-$folder_to_lock/pid}
  local is_locked=f
  if [[ -d "$folder_to_lock" ]]; then
    if [[ -f "$pid_file" ]]; then
      pid=$(<"$pid_file")
      if [[ "$pid" ]] && ps $pid &>/dev/null; then
        is_locked=t
      fi
    fi
  fi
  [[ "$is_locked" == t ]]
}

# inputs: folder_to_unlock pid_file
folder_unlock() {
  local folder_to_unlock=$folder_to_unlock
  local pid_file=${pid_file:-$folder_to_unlock/pid}
  local remove_folder_when_unlocked=${remove_folder_when_unlocked:-f}

  if [[ ! "$folder_to_unlock" ]]; then
    log_fatal "Usage: folder_to_unlock=... folder_unlock "
    return 1
  fi

  if [[ -d "$folder_to_unlock" && $remove_folder_when_unlocked == t ]]; then
    rm -r "$folder_to_unlock" || return 1
  fi

  if [[ -f "$pid_file" ]]; then
    rm "$pid_file" || return 1
  fi

  return 0
}

fd_read_lock() {
  local lock_path=$lock_path timeout=$timeout
  if [[ ! -d "${lock_path%/*}" ]]; then
    log_fatal "Bad lock path: $lock_path. It must either exist, or point to a file in a folder that exists."
    return 1
  fi
  if [[ ! -e "$lock_path" ]]; then
    touch "$lock_path" || return 1
  fi
  exec {lock_fd}<>$lock_path
  #zombie "Locking $lock_path write_lock=f timeout=$timeout fd=$lock_fd"
  flock -s -w $timeout $lock_fd || {
    log_fatal "Failed to get read lock for $lock_path within $timeout seconds"
    return 1
    }
}

fd_write_lock() {
  local lock_path=$lock_path timeout=$timeout
  if [[ ! -d "${lock_path%/*}" ]]; then
    log_fatal "Bad lock path: $lock_path. It must either exist, or point to a file in a folder that exists."
    return 1
  fi
  if [[ ! -e "$lock_path" ]]; then
    touch "$lock_path" || return 1
  fi
  exec {lock_fd}<>$lock_path
  flock -e -w $timeout $lock_fd || {
    log_fatal "Failed to get write lock for $lock_path within $timeout seconds"
    return 1
    }
}

fd_unlock() {
  flock -u $lock_fd
}

get_next_fd() {
  next_fd=$(ls -1 /proc/self/fd | tail -n1)
  let next_fd++
}

is_dir_empty() {
  eval "local contents=( $1/* )"
  local first=${contents[0]}
  [[ "${first%\*}" != "$first" ]]
}

pretend_filter=
case "${pretend:-}" in
  a|'')
    pretend=ask
  ;;
  f|t|ask)
  ;;
  *)
    pretend_filter=$pretend
    pretend=f
  ;;
esac

maybe() {
  local command_to_execute="$*"
  local execute

  case $pretend in
    f)
      execute=t
    ;;
    t)
      echo "Pretending: $command_to_execute" >&2
      execute=f
    ;;
    ask)
      local response
      echo "Will execute: $command_to_execute" >&2
      sleep 0.5
      read -p 'Are you sure? [yes/no/All/None/quit] ' -s -n1 response >&2
      case $response in
        y)
          echo "yes" >&2
          execute=t
        ;;
        A)
          echo "all" >&2
          pretend=f
          execute=t
        ;;
        N)
          echo "none" >&2
          pretend=t
          execute=f
        ;;
        q)
          echo "quit" >&2
          exit 1
        ;;
        *)
          echo "no" >&2
          execute=f
        ;;
      esac
    ;;
    *)
      log_fatal "Invalid pretend setting: $pretend. Must be one of: t f ask"
      return 1
    ;;
  esac

  if [[ $execute == t ]]; then
    log_info "Executing: $command_to_execute"
    eval "$command_to_execute" || return $?
  fi

  return 0
}

min() {
  result=$1
  if [[ $1 == inf || $2 -lt $1 ]]; then
    result=$2
  fi
}

max() {
  result=$1
  if [[ $2 == inf || $2 -gt $1 ]]; then
    result=$2
  fi
}

# input: $1 (name of array variable which was already populated 
#   with string values)
enum() {
  local i count array=$1 var
  eval "count=\${#$array[*]}"
  for ((i=0; i < count; i++)); do
    eval "var=\${$array[$i]}"
    eval "$var=$i"
  done
}

safe_link() {
  local from_all="$*" from to \
    force=${force:-f} \
    from_must_exist=${from_must_exist:-t} \
    ignore_existing=${ignore_existing:-f} \

  to=${from_all##* }
  from_all=${from_all% $to}

  local log_show_vars="^from_all ^to" log_vars="force from_must_exist"
  begin_function

    # log_debug "Linking $from_all to $to"

    if [[ "$to" == "$from_all" ]]; then
      log_fatal "Invalid parameters for safe_link: $*"
      fail1
    fi

    if [[ $to != */ ]]; then
      if [[ -L $to ]]; then
        rm "$to" || fail
      elif [[ -e $to ]]; then
        if [[ $ignore_existing == t ]]; then
          abort
        fi
        log_fatal "safe_link: target already exists: $to. If you want to make a link inside of this folder, make the target $to/ instead."
        fail1
      fi
    fi

    local files parent extra
    begin_for from in $from_all; doo

      if [[ "$from" == */\* || "$from" == *!* ]]; then
        extra= parent=${from%/*}
        if [[ "$from" == *!* ]]; then
          extra=${from##*/}
          extra=${extra#!}
          extra=${extra#(}
          extra=${extra%)}
          extra=" -not -name \"$extra\""
        fi
        files=$(find1 $parent -not -name ".*" $extra) || fail
        if [[ "$files" ]]; then
          safe_link $files $to || fail
        fi
        continue
      fi

      if [[ $from_must_exist == t && ! -e "$from" ]]; then
        log_fatal "Internal error: Source of link doesn't exist: $from"
        fail1
      fi

      local to_parent=${to%/*}
      local full_to=$to
      if [[ $to == */ ]]; then
        full_to+=${from##*/}
      fi

      if [[ ! -d "$to_parent" ]]; then
        log_fatal "Missing target folder for link: $to_parent"
      fi

      if [[ $force == t ]]; then
        ln -sfn "$from" "$full_to" || fail
      else
        if [[ -e "$full_to" ]]; then
          if [[ $ignore_existing ]]; then
            continue
          else
            log_fatal "Target of link operation already exists: $full_to"
            fail1
          fi
        fi
        ln -sn "$from" "$full_to" || fail
      fi

    end_for

  end_function
  debug_return_vars='from_all to'
  handle_return
}

# inputs:
#   $1               optional message to display at pause prompt
# outputs:
#   pause_response   contains key pressed (which is usually ignored)
pause() {
  if function_exists handle_user_interrupt; then
    handle_user_interrupt "Paused. "
  else
    local extra=
    if [[ "${fork_debug_id:-}" ]]; then
      extra=" at $fork_debug_id"
    fi
    echo >&$fd_original_err
    read -sp "$WHITE** PAUSED$extra ** ${1:-Press any key}$RESET" -n 1 pause_response >&$fd_original_err || true
    echo >&$fd_original_err
    echo >&$fd_original_err
  fi
}

# inputs:
#   $1               optional message to display at pause prompt
pause_qd() {
  local extra=
  if [[ "${fork_debug_id:-}" ]]; then
    extra=" at $fork_debug_id"
  fi
  local pause_response
  echo >&$fd_original_err
  read -sp "$WHITE** PAUSED$extra ** ${1:-} Press q to quit, D to debug here or any other key to continue.$RESET" -n 1 pause_response >&$fd_original_err || true
  echo >&$fd_original_err
  case $pause_response in 
    D)
      debug_stepping=t
      debug_start o
    ;;
    q)
      echo "Quitting..." >&$fd_original_err
      debug_exit=1 debugging=t
      if [[ "$reply_file" ]]; then
        echo "debugging=t" >$reply_file
      fi
      exit 1
    ;;
  esac
  echo >&$fd_original_err
  return 0
}

# resolves relative paths but does not resolve symlinks
# should run in a subprocess so dir change doesn't affect caller
# normal usage: x=$(unrealpath "$some_path")
unrealpath() {
  local p=$PWD x=$1
  shift
  local flags=$*
  if [[ "$x" != /* ]]; then
    x="$p/$x"
  fi
  realpath $flags "$x" || {
    log_fatal "Internal error: could not resolve $x"
    return 1 
    }
  return 0
}

# inputs: 
#   $1: var       name of var to add to
#   $2: add_value
# var will have trailing and leading spaces
add_word_to_string() {
  local var_name=$1 add_value=$2
  local -n var=$1
  if [[ -v var ]]; then
    if [[ "$var" != *" $add_value "* ]]; then
      var+="$add_value "
    fi
  else
    var=" $add_value "
  fi
}

# var must have trailing and leading spaces
remove_word_from_string() {
  local -n var=$1
  local remove_value=$2
  var=" $var "
  if [[ -v var && " $var " == *" $remove_value "* ]]; then
    local left=${var%%+( )$remove_value *} \
      right=${var##* $remove_value+( )}
    if [[ "$left" ]]; then
      if [[ "$right" ]]; then
        var="${left##+( )} ${right%%+( )}"
      else
        var="${left##+( )}"
      fi
    else
      if [[ "$right" ]]; then
        var="${right%%+( )}"
      else
        var=
      fi
    fi
  fi
}

# inputs:
#   $1    name of array
#   $2    element to remove
# will remove any elements that match, but those indexes will be removed also
remove_array_element() {
  local -n array=$1
  local element=$2 i
  for (( i = 0; i < ${#array[*]}; i++ )); do
    if [[ "${array[$i]}" == "$element" ]]; then
      unset array[$i]
    fi
  done
}

show_array() {
  local -n _array=$1
  local i size char_array=f

  set +u
  size=${#_array[*]}
  set -u

  echo "size=$size" >&$fd_original_err
  for i in "${!_array[@]}"; do
    if [[ ! -v _array[$i] ]]; then
      echo "$i: << MISSING >>" >&$fd_original_err
    else
      echo "$i: ${_array[$i]:-}" >&$fd_original_err
    fi
  done
}

rcp() {
  local shell="ssh"
  if [ "${port:-}" ]; then
      shell="ssh -p $port"
  fi
  RSYNC_RSH="$shell" rsync -a --append --inplace --partial --progress "$@"
}

# usage: convert_time_to_timestamp {time}
#   time can be something like this:
#   -10m
#   now
#   -30h@d      30 hours ago rounded to the previous day
#   2 weeks ago
#   25 Dec      the next time 25 Dec happens
#   2025/1/5 08:34:20
# output:
#   timestamp
convert_time_to_timestamp() {
  local time=$1
  local rounding_unit=s rounding_multiple=1 offset=0
  if [[ "$time" =~ @([0-9]*)([smhdwMy])$ ]]; then
    local o=${BASH_REMATCH[1]} u=${BASH_REMATCH[2]}
    if [[ "$o" ]]; then
      rounding_multiple=$o
    fi
    rounding_unit=$u
    time=${time%${BASH_REMATCH[0]}}
  fi

  if [[ "$time" =~ ^-([0-9]+)([smhdwMy])$ ]]; then
    local o=${BASH_REMATCH[1]} u=${BASH_REMATCH[2]}
    case $u in
      s)
        time="now - $o seconds"
      ;;
      m)
        time="now - $o minutes"
      ;;
      h)
        time="now - $o hours"
      ;;
      d)
        time="now - $o days"
      ;;
      w)
        time="now - $o weeks"
      ;;
      M)
        time="now - $o months"
      ;;
      y)
        time="now - $o years"
      ;;
      *)
        log_fatal "Invalid time unit: $u in $time"
        return 1
      ;;
    esac
  fi

  if [[ "$time" =~ ^[0-9]+$ ]]; then
    timestamp=$time
  else
    local d
    d=$(date -d "$time" +%s) || {
      log_fatal "Invalid time format: $time"
      return 1
    }
    timestamp=$d
  fi

  if [[ $rounding_unit != s || $rounding_multiple != 1 ]]; then
    local y M d h m s
    read y M d h m s < <(date -d @$timestamp +'%Y %m %d %H %M %S')
    case $rounding_unit in
      s)
        (( s = s / $rounding_multiple * $rounding_multiple ))
      ;;
      m)
        if (( rounding_multiple > 1 )); then
          (( m = m / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
      ;;
      h)
        if (( rounding_multiple > 1 )); then
          (( h = h / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
      ;;
      h)
        if (( rounding_multiple > 1 )); then
          (( h = h / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
      ;;
      d)
        if (( rounding_multiple > 1 )); then
          (( d = d / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
        h=0
      ;;
      M)
        if (( rounding_multiple > 1 )); then
          (( M = M / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
        h=0
        d=1
      ;;
      y)
        if (( rounding_multiple > 1 )); then
          (( y = y / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
        h=0
        d=1
        M=1
      ;;
      *)
        log_fatal "Internal error in time conversion. Bad rounding unit: $rounding_unit"
        return 1
      ;;
    esac
    timestamp=$(date -d "$y/$M/$d $h:$m:$s" +%s) || return 1
  fi
}

# calculate the difference between two timestamps
# input: 
#   $1      start time
#   $2      end time
# output:
#   result  {end time} - {start time}
ts_diff() {
  local start=$1 end=$2
  result=$(dc -e "6k $end $start - p")
  #start=${start//./} end=${end//./}
  # (( result = end - start ))
  # local ipart=${result%??????}
  # result=${ipart}.${result#ipart}
}

debug_timer_start() {
  debug_counter_count=${debug_counter_count:-0}
  if (( debug_counter_count++ )); then nothing fi
  reply_to_caller "debug_counter_count=$debug_counter_count"
  debug_timer_start=$EPOCHREALTIME
  #echo "DEBUG TIMER $debug_counter_count started" >&$fd_original_err
}

debug_timer_end() {
  local result
  ts_diff $debug_timer_start $EPOCHREALTIME
  echo "DEBUG TIMER $debug_counter_count ended: $result" >&$fd_original_err
}

debug_counter() {
  debug_counter_count=${debug_counter_count:-0}
  if (( debug_counter_count++ )); then nothing fi
  reply_to_caller "debug_counter_count=$debug_counter_count"
  echo "DEBUG COUNTER: $debug_counter_count" >&$fd_original_err
}

# usage: cat {some file} | format_number_stream
# will format all numbers found in the stream
format_number_stream() {
  local field=${field:-all}
  if [[ $field == all ]]; then
    perl -wpe '1 while s/(\d+)(\d\d\d)/$1,$2/;'
  else
    perl -ae '1 while $F['$field'] =~ s/(\d+)(\d\d\d)/$1,$2/; print join(" ",@F) . "\n";'
  fi
}

# inputs:
#   $1    form
#   $2    var name
format_var() {
  local form=$1 var_name=$2
  local -n _value=$var_name
  case $form in
    number)
      local int=${_value%%.*}
      local frac=${_value#$int} 
      local i c=0
      _value=
      for (( i = ${#int} - 1; i >= 0; i-- )); do
        (( c++ )) || true
        _value=${int:$i:1}$_value
        if (( c % 3 == 0 )); then
          _value=,$_value
        fi
      done
      _value=${_value#,}
    ;;
    *)
      # unknown form, do nothing
      :
    ;;
  esac
}

# input:
#   pid   process to check for
# output:
#   process_running  boolean
check_process() {
  if ps $pid &>/dev/null; then
    log_debug "Process $pid exists"
    process_running=t
  else
    log_debug "Process $pid doesn't exist"
    process_running=f
  fi
}

# make sure we clean up after ourselves whether we've launched a background job or allocated resources
# this needs to be run again whenever forking to a subprocess
setup_exit_trap() {
  failure_handler_state_file=$tmp_folder/failure-state-$$
  failure_handler_already_dumped_stack=f
  trap '
    rc=$?
    #echo "EXIT TRAP $BASHPID, BASH_SUBSHELL=$BASH_SUBSHELL" >&$fd_original_err
    if [[ ${debug_on_exit:-} == t ]]; then
      exiting=t
      debug_start
    fi
    if (( rc > 0 && rc < 100 )); then
      if [[ -e $failure_handler_state_file ]]; then
        source $failure_handler_state_file &>/dev/null
        if (( BASH_SUBSHELL == 0 )); then
          rm $failure_handler_state_file &>/dev/null
        fi
      fi
      if [[ $failure_handler_already_dumped_stack == f ]]; then
        if [[ $trace_time == t ]]; then
          trace_time_summarize
        fi
        extra=
        #if [[ ${show_debug_id:-f} != f ]]; then
        if [[ "${fork_debug_id:-}" ]]; then
          extra=" ${DEBUG_COLOR}debug_id=$fork_debug_id$RESET"
        fi
        echo "$extra ${RED}Exited with failure code $rc"
        #if log_level_at_least debug; then
        #  stack_trace
        #fi
        echo "failure_handler_already_dumped_stack=t" >>$failure_handler_state_file
      fi
    fi
    trap - DEBUG ERR EXIT RETURN QUIT &>/dev/null
    #echo "Cleaning up: $cleanup_on_exit" >&$fd_original_err
    eval "${cleanup_on_exit:-}" &>/dev/null
    if (( rc > 0 )); then
      jobs="$(jobs -p)"
      #echo "Killing jobs $jobs" >&$fd_original_err
      if [[ "$jobs" ]]; then
        { kill $jobs; } 2>/dev/null || true
      fi
    fi
    set +TeuExv
    #echo "debug_restart_command=$debug_restart_command" >&$fd_original_err
    if [[ "${debug_restart_command:-}" ]]; then
      if [[ $BASH_SUBSHELL == 0 ]]; then
        eval "exec $debug_restart_command"
      else
        quotes=single shell_quote_var debug_restart_command
        #echo "Passing up debug_restart_command=$debug_restart_command" >&$fd_original_err
        reply_to_caller "debug_restart_command=$debug_restart_command"
      fi
    fi
    ' EXIT

  # trap '
  #   zombie "ERR $BASH_COMMAND"
  #   trap - DEBUG ERR EXIT RETURN QUIT &>/dev/null
  #   set +TeuExv
  #   if [[ ${debug_on_err:-} == t ]]; then
  #     debug_start
  #     echo "Debugging..."
  #   fi
  #   ' ERR

  # trap '
  #   zombie "HUP $BASH_COMMAND"
  #   ' HUP

  # trap '
  #   zombie "ILL $BASH_COMMAND"
  #   ' ILL

  # trap '
  #   zombie "TRAP $BASH_COMMAND"
  #   ' TRAP

  # trap '
  #   zombie "TERM $BASH_COMMAND"
  #   ' TERM

  # trap '
  #   zombie "ALRM $BASH_COMMAND"
  #   ' ALRM

  # trap '
  #   zombie "SEGV $BASH_COMMAND"
  #   ' SEGV

  # trap '
  #   zombie "USR1 $BASH_COMMAND"
  #   ' USR1

  # trap '
  #   zombie "KILL $BASH_COMMAND"
  #   ' KILL

  # trap '
  #   zombie "FPE $BASH_COMMAND"
  #   ' FPE

  # trap '
  #   zombie "BUS $BASH_COMMAND"
  #   ' BUS

  # trap '
  #   zombie "ABRT $BASH_COMMAND"
  #   ' ABRT

  # trap '
  #   zombie "QUIT $BASH_COMMAND"
  #   ' QUIT
  # trap '
  #   zombie "RETURN $BASH_COMMAND"
  #   f=( "${FUNCNAME[@]:1}" )
  #   show_array f
  #   ' RETURN
}
setup_exit_trap

#!/bin/bash

# default for tracing messages is to go to stderr, but that can easily be overridden
exec {fd_trace}>&2

set -u
shopt -s expand_aliases      # make sure aliases are expanded even for non-interactive scripts
shopt -s extglob

umask 0077  # to make created files readable only by the user by default

parameter_questions=() 

parameters_to_env() {
  local term OIFS k v update_original_cmd=${update_original_cmd:=t}
  real_params=( )
  if [[ $update_original_cmd == t ]]; then
    original_cmd=$0
  fi

  for term; do

    if [[ $update_original_cmd == t ]]; then
      if [[ "$term" == *[\ \$]* ]]; then
        if [[ "$term" =~ ^([a-zA-Z0-9_]+)=(.*)$ ]]; then
          original_cmd+=" ${BASH_REMATCH[1]}='${BASH_REMATCH[2]}'"
        else
          original_cmd+=" \"$term\""
        fi
      else
        original_cmd+=" $term"
      fi
    fi

    if [[ "$term" =~ ^([a-zA-Z0-9_]+)=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      if [[ "$v" == __ ]]; then
        read -p "$k=" -rs v || return 1
        echo '************'
      elif [[ "$v" == _ ]]; then
        read -p "$k=" -r v || return 1
      elif [[ "$v" == \? ]]; then
        parameter_questions+=( $k )
        v=
      elif [[ "$v" == \?\? ]]; then
        parameter_questions+=( $k )
        (( command_detail++ ))
        v=
      fi
      k=${k,,}
      eval "$k='$v'"
      eval "p_$k='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "$k='$v'"
        eval "p_$k='$v'"
      fi
    elif [[ "$term" =~ ^([a-zA-Z0-9_]+)\+=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      k=${k,,}
      eval "${k}_append='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "${k}_append='$v'"
      fi
    elif [[ "$term" =~ ^([a-zA-Z0-9_]+)\^=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      k=${k,,}
      eval "${k}_prepend='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "${k}_prepend='$v'"
      fi
    elif [[ "$term" =~ ^([a-zA-Z0-9_]+)-=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      k=${k,,}
      eval "${k}_remove='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "${k}_remove='$v'"
      fi
    else
      real_params+=( "$term" )
    fi
  done
}

# usage: required_function {function(s) to check...}
# fails if the function doesn't exist
required_function() {
  local i
  for i ; do
    if ! type -t $i &>/dev/null; then
      echo "Missing function: $i" >&2
      exit 1
    fi
  done
}

# usage: optional_var {variable} {default}
# fails if any variable doesn't exist
optional_var() {
  local v="$2"
  v="${v//\"/\\\"}"
  eval "export $1=\${$1:-$v}"
}

# usage: require_var {variable(s) to check...}
# fails if any variable doesn't exist
require_var() {
  local i
  for i; do
    [[ -v $i ]] || {
      echo "Required variable is not defined: $i" >&2
      if type -t stack_trace &>/dev/null; then
        stack_trace
      fi
      exit 1
    }
    #eval "export $i"
  done
}

# usage: require_var {variable(s) to check...}
# fails if none of the variables exist
require_var_any() {
  local i found inputs
  for i ; do
    inputs="$inputs $i"
    declare -p $i &>/dev/null && found=t
    #eval "export $i"
  done
  if [ ! "${found:-}" ]; then
    echo "Missing required var. At least one of these must be defined:$inputs" >&2
    exit 1
  fi
  return 0
}

# usage: require_var_or_ask {var name} {question if missing}
require_var_or_ask() {
  local v new_value var_name="$1"
  shift
  local description="$1"

  v=`eval echo "$"$var_name`
  while true; do
    if [ -z "$v" ]; then
      v=`eval echo "$"{#$var_name[*]}`
      if [ "$v" == "0" ]; then
        IFS= read -ep "${description}? ${var_name}=" new_value
        if [ "$new_value" ]; then
          eval "var_name=\"${new_value}\""
          break
        else
          echo "You must enter a valid value to continue."
        fi
      fi
    else
      break
    fi
  done
}

# usage: require_command {command_name} [{hint}]
require_command() {
  local command_name=$1; shift
  local hint=$1

  if ! which $command_name &>/dev/null; then
    echo "Couldn't find required command $command_name on your path." >&2
    [ "$hint" ] && echo "Possible solution: $hint" >&2
    exit 1
  fi

  return 0
}

# Make sure that Control-C exits this script, even if running a subcommand which doesn't handle Control-C properly.
trap '
  trap - INT # restore default INT handler
  kill -s INT "$$"
' INT

#!/bin/bash

type -t omni_log_init >/dev/null && return 0

# if logging_to_file is set, trace output will be sent to this file

# when a function which gets forked into it's own process is run, need to do this:
# f() {
#   change_log_file
#   begin_function_hi
#   end_function
#   handle_return
# }

resolve_log_var() {
  case $log in
    o|f|e|w|i|v|t|a)
      log_level_filter=$log
      ;;
    off|fatal|error|warn|info|verbose|trace|all)
      log_level_filter=$log
      ;;
    d|debug)
      log_level_filter=debug
      #show_debug_id=${show_debug_id:-t}
      ;;
    d2|debug2)
      log_level_filter=debug
      show_debug_id=a
      ;;
    file)
      # default behavior
      ;;
    out)
      log_to_out=t
      log_level_filter=warn
      if [[ "$log_format" == default ]]; then
        log_format='$level_color$message$RESET'
      fi
      ;;
    both)
      log_to_file=t
      log_to_out=t
      ;;
    id)
      show_debug_id=${show_debug_id:-t}
      ;;
    id2)
      show_debug_id=a
      ;;
  esac
  case $log_level_filter in
    n)
      log_level_filter=none
    ;;
    f)
      log_level_filter=fatal
    ;;
    e)
      log_level_filter=error
    ;;
    w)
      log_level_filter=warn
    ;;
    i)
      log_level_filter=info
    ;;
    v)
      log_level_filter=verbose
    ;;
    d)
      log_level_filter=debug
    ;;
    t)
      log_level_filter=trace
    ;;
    a)
      log_level_filter=all
    ;;
  esac
}

log_level_filter_changed() {

  case $log_level_filter in
    none)
      log_format=
    ;;
    fatal|error|warn|info|verbose)
      if [[ "$log_format" == default ]]; then
        log_format='$level_color$message$RESET'
      fi
    ;;
    debug)
      if [[ "$log_format" == default ]]; then
        log_format='$level_color$message$RESET'
      fi
    ;;
    trace|all)
      if [[ "$log_format" == default ]]; then
        log_format='$level_color$action$COL25$function$COL50$log_vars$message$RESET'
      fi
    ;;
    *)
      log_fatal "Invalid log_level value. Must be one of: none, error, warn, info, verbose, debug, trace"
      exit 1
    ;;
  esac

  case $log_format in
    tiny)
      log_format='$level_color$message$RESET'
    ;;
    short)
      log_format='$level_color$action$COL15$function$COL45$log_vars$message$RESET'
    ;;
    compact)
      log_format='$level_color$action$function$log_vars$message$RESET'
    ;;
  esac

  if [[ $show_debug_id == t || $show_debug_id == a ]]; then
    log_format='$debug_id$level_color$message$RESET'
  fi

}

omni_log_init() {
  begin_function
    local command="$*"  
    omni_log_job_id=0 omni_log_fork_id=

    if [[ "${debugger_available:-f}" == t ]]; then
      debug_at_log_id=
      if [[ "${log_id:-}" ]]; then
        echo "${CYAN}Will debug starting at log_id $log_id or later${RESET}" >&2
        debug_at_log_id=$log_id
      fi
    fi

    first_log_file= \
    first_log=t \
    log_depth_current=0 \
    omni_log_pos=0 \
    trace_vars=${trace_vars:-${trace_var:-}} \
    log=${log:-} \
    log_to_file=t \
    log_to_out=f \
    log_action_filter=${log_action:-} \
    log_depth_filter=${log_depth:-} \
    log_function_filter=${log_function:-} \
    log_level_filter=${log_level:-info} \
    log_format=${log_format:-default} \
    show_debug_id=${show_debug_id:-${show_id:-f}} \
    cooked_stack=( ${cooked_stack[*]:-} ) \
    log_ansi=${log_ansi:-${ansi:-t}} \

    declare -gA trace_var_value

    resolve_log_var || fail
    log_level_filter_changed

    var_stack=( ) \
      var_stack2=( ) \
      logging_to_file= \
      log_vars= \
      log_show_vars= 
  end_function
  handle_return
}

hide_secrets() {
  local -n text=$1
  local secret_var 
  for secret_var in ${secret_vars:-}; do
    local -n secret=$secret_var
    if [[ "${secret:-}" && "$secret" != $empty_member ]]; then
      text=${text//$secret/****}
    fi
  done
}

save_log_vars() {
  local entry entries= var value quoted_value
  for var in ${log_vars:-} ${log_show_vars:-}; do
    value=
    var=${var#^}
    var=${var##*=}
    if [[ -v $var && "${!var:-}" ]]; then
      value=${!var}
      shell_quote_var value
    fi
    entries+=" $var=$value"
  done
  entries=${entries# }
  hide_secrets entries
  log_var_entries_stack+=( "$entries" ) 
  log_var_show_vars_stack+=( "$log_show_vars" ) 
}

snapshot_source_location_locals="log_function log_source_file log_source_line"
snapshot_source_location() {
  local offset=${offset:-1} offset1= offset2=
  (( 
    offset1 = offset + 1
  , offset2 = offset + 2
  , log_source_line = BASH_LINENO[offset]
  , log_source_line2 = BASH_LINENO[offset1]
  )) 
  log_function=${FUNCNAME[$offset1]}
  log_source_file=${BASH_SOURCE[$offset1]}
  log_source_file2=${BASH_SOURCE[$offset2]}
  log_stack_index=$(( ${#FUNCNAME[*]} - offset2 ))
}

auto_shorten() {
  local -n shorten_var=$1
  local extra length
  if [[ "$shorten_var" =~ /.*/.*/.*/.*/ ]]; then
    extra=${shorten_var%/*/*/*/*}
    shorten_var=${shorten_var#$extra/}
  fi

  length="${#shorten_var}"
  if (( length > 80 )); then
    shorten_var=${shorten_var:0:78}..
  fi
}

write_to_log_process_vars() {
  begin_function_lo

    local var var_name value added=
    for var in $trace_vars $show_vars2 $log_vars $log_return_vars; do

      if [[ $var == *=* ]]; then
        var_name=${var%%=*}
        var=${var#*=}
      else
        var_name=$var
      fi

      if [[ "$var" == ^* ]]; then
        var=${var#^}
        var_name=${var_name#^}
      fi

      get_var_value $var

      local quoted_value=$value
      shell_quote_var quoted_value

      if [[ "$added" != *"$var"* ]]; then
        if [[ "$trace_vars" == *"$var"* ]]; then

          #if [[ "$value" != "${trace_var_value[$var]:-}" ]]; then
          #  trace_vars+="$CYAN"
          #fi

          trace_vars+=" $var_name=$quoted_value"

          if [[ "$value" != "${trace_var_value[$var]:-}" ]]; then
            #trace_vars+="$RESET"
            trace_var_value[$var]=$value
          fi

        else
          if [[ "$value" ]]; then
            new_vars+=" $var_name=$quoted_value"
          fi
        fi
        added+=" $var "
      fi

    done
    trace_vars=${trace_vars% }

    if [[ "$show_vars2" ]]; then
      local new_show_vars=
      for var in $show_vars2; do
        if [[ $var == *=* ]]; then
          var_name=${var%%=*}
        else
          var_name=$var
        fi
        new_show_vars+=" $var_name"
      done
      show_vars2=${new_show_vars# }
    fi

    if [[ "${secret_vars:-}" ]]; then
      hide_secrets new_vars
      hide_secrets trace_vars
    fi

  end_function
  handle_return
}

write_to_log_log_var() {
  local quoted
  to_log="= ts=$time pid=$pid fork_id=$fork_id_current debug_id=$fork_debug_id log_id=$log_id log_level=$level"

  if [[ "$action" ]]; then
    local quoted=$action
    shell_quote_var quoted
    to_log+=" log_action=$quoted"
  fi
  if [[ ! "${log_function:-}" ]]; then
    offset=2 snapshot_source_location
  fi
  function=$log_function
  if [[ "${log_function:-}" ]]; then
    to_log+=" log_function=$log_function"
  fi
  if [[ "${log_source_file:-}" ]]; then
    to_log+=" log_source=$log_source_file:$log_source_line log_source_caller=$log_source_file2:$log_source_line2"
  fi
  if [[ "${show_vars2:-}" ]]; then
    quoted=$show_vars2
    shell_quote_var quoted
    to_log+=" log_show_vars=$quoted"
  fi
  to_log+="$new_vars$trace_vars"
  #if [[ "${trace_vars:-}" ]]; then
  #  quoted=$trace_vars
  #  shell_quote_var quoted
  #  to_log+=" trace_vars=$quoted"
  #fi
  local quoted=${message:-}
  if [[ "$message" ]]; then
    shell_quote_var quoted
    to_log+=" log_message=$quoted"
  fi
  return 0
}

write_to_log_update_cooked() {
  local show_vars= var v value
  for var in $show_vars2; do
    value=
    local real_var=${var#^}
    get_var_value $real_var
    shell_quote_var value
    #if [[ -v $real_var ]]; then
    #  v=${!real_var}
    #  if [[ "$var" == ^* ]]; then
    #    auto_shorten v
    #  fi
    #  get_var_value v
    #  shell_quote_var value
    #fi
    show_vars+="$var=$value "
  done
  case $action in
    call)
      local s="$show_vars$trace_vars"
      if [[ "${secret_vars:-}" ]]; then
        hide_secrets s
      fi
      s=${s%%*( )}
      s=${s##*( )}
      s=${s// *( )/ }
      cooked_stack[$log_stack_index]="$s"
    ;;
    return*)
      if [[ -v cooked_stack[$log_stack_index] ]]; then
        unset cooked_stack[$log_stack_index]
      fi
    ;;
  esac
  return 0
}

log_level_at_least() {
  local level=$1
  local level_num=${log_level_num_map[$level]} \
    log_level_num=${log_level_num_map[$log_level_filter]}
  (( log_level_num >= level_num ))
}

write_to_log_console_out() {
  local out_line=
  if [[ $log_to_out == t ]]; then
    out_line="$to_log"
    echo "$out_line" >&2
  else

    local hide=t

    if log_level_at_least $level; then
      hide=f
    fi

    if [[ "$log_action_filter" && ! $action =~ $log_action_filter ]]; then
      hide=t
    fi

    if [[ "$log_function_filter" && ! $function =~ $log_function_filter ]]; then
      hide=t
    fi

    if [[ "$log_depth_filter" && $log_depth_current -gt $log_depth_filter ]]; then
      hide=t
    fi

    local level_color=${log_level_color_map[$level]}
    if [[ $log_ansi == f ]]; then
      level_color=
    fi

    local function=" $function" \
      action=" $action" \
      message=" $message" \
      log_vars="$new_vars" \
      time=" $time" \
      pid=" pid=$pid" \
      log_id=" log_id=$log_id" \
      debug_id=" ${DIM_DEBUG_COLOR}debug_id=$fork_debug_id${RESET}" \
      prefix= \
      showed_something=f \

    if [[ ${strong_log:-f} == t ]]; then
      debug_id=" ${DEBUG_COLOR}debug_id=$fork_debug_id${RESET}"
    fi

    eval "local to_terminal=\"$log_format\""
    out_line="$to_terminal"

    show_time_update

    if [[ ${show_depth:-f} == t ]]; then
      prefix+=" depth=$log_stack_index"
    fi

    if [[ $hide == f ]]; then
      echo " ${prefix# }${out_line# }" >&2
    fi
  fi
  return 0
}

# Can be called safely whether or not a log file has been set up
write_to_log() {
  pause_tee
  begin_function_lo

    local level=$1 action=${2:-${1:-}} message=${3:-} \
      new_vars= trace_vars= show_vars2=${log_show_vars:-} \
      log_vars=${log_vars:-} log_return_vars=${log_return_vars:-} \

    : ${omni_log_pos:=0}
    (( omni_log_pos++ )) || true

    if [[ ${log_ansi:-t} == f ]]; then
      local RESET= COL15= COL45= COL60= COL90= CYAN= YELLOW= RED= DIM_DEBUG_COLOR= DEBUG_COLOR= GREEN=
    fi

    if [[ "${secret_vars:-}" ]]; then
      hide_secrets message
    fi

    write_to_log_process_vars || fail

    : ${omni_log_fork_id:=0}
    local time="$EPOCHREALTIME" \
      pid="$BASHPID" \
      to_log= \
      function= log_function=${log_function:-} \
      log_source_file=${log_source_file:-} \
      log_source_line=${log_source_line:-} \
      log_id=$omni_log_fork_id:$omni_log_pos

    write_to_log_log_var

    : ${log_to_file:=f} ${log_to_out:=t}
    if [[ ${disable_log:-f} == f && $log_to_file == t && "${logging_to_file:-}" ]]; then
      echo "$NL$to_log" >>$logging_to_file || fail
    fi

    write_to_log_update_cooked || fail
    write_to_log_console_out || fail

  end_function
  unpause_tee
  handle_return
}

write_to_log_and_save() {
  local $snapshot_source_location_locals
  offset=1 snapshot_source_location
  write_to_log trace call || return 1
  save_log_vars || return 1
}

load_log_vars_and_write_to_log() {
  begin_function_lo
    local \
      var value entry log_vars= \
      entries=${log_var_entries_stack[-1]} \
      _log_show_vars=${log_var_show_vars_stack[-1]} \

    eval "entries=( ${entries} )"

    for entry in "${entries[@]}"; do
      var=${entry%%=*}
      value=${entry#*=}

      shell_quote_var value
      log_vars+=" $var"
      eval "local $var=$value"
    done
    log_vars=${log_vars# }

    local $snapshot_source_location_locals
    offset=1 snapshot_source_location
    unset log_var_entries_stack[-1] log_var_show_vars_stack[-1]
    log_show_vars=$_log_show_vars \
      write_to_log trace "return($return_value)" || fail
  end_function
  handle_return
}

# Usage:
#   new_log_file=... change_log_file  point to new log file
#   new_log_file= change_log_file     stop logging
# should also include previous_fork_id
change_log_file() {
  begin_function

    local new_log_file=$new_log_file old_log_file \
      log_function=${log_function:-${FUNCNAME[1]}} \
      previous_fork_id=${previous_fork_id:-0} \
      resume_existing_log=${resume_existing_log:-f}

    local $snapshot_source_location_locals
    offset=2 snapshot_source_location

    if [[ "${logging_to_file:-}" == "$new_log_file" || ${disable_log:-f} == t ]]; then
      abort
    fi

    if [[ "${logging_to_file:-}" ]]; then
      if [[ "$new_log_file" ]]; then
        omni_log_fork_id=$previous_fork_id log_vars=new_log_file write_to_log trace log_to || fail
      else
        omni_log_fork_id=$previous_fork_id write_to_log trace log_close || fail
      fi
    fi

    if [[ "$new_log_file" ]]; then
      #log_debug "Logging to $new_log_file"
      old_log_file=${logging_to_file:-}
      logging_to_file=$new_log_file
      omni_log_pos=0

      if [[ -f $logging_to_file && $resume_existing_log == f ]]; then
        log_fatal "Log file already exists: $logging_to_file"
        fail1
      fi

      if [[ "$old_log_file" ]]; then
        log_vars=old_log_file write_to_log trace log_from || fail
      fi

    fi

  end_function
  handle_return
}

log_quick() {
  begin_function_lo
    local m=
    if [[ $show_debug_id != f ]]; then
      if [[ "${strong_log:-}" == t ]]; then
        m="${DEBUG_COLOR}"
      else
        m="${DIM_DEBUG_COLOR}"
      fi
      m+="debug_id=$fork_debug_id$RESET "
    fi
    if [[ "${strong_log:-}" == t ]]; then
      m+="$HIGHLIGHT$*$RESET"
    else
      m+="$*"
    fi
    if [[ "${secret_vars:-}" ]]; then
      hide_secrets m
    fi
    local prefix= showed_something=f
    show_time_update
    echo " $prefix$m" >&$fd_original_err
  end_function
  handle_return
}

log_trace() {
  if log_level_at_least trace; then
    log_quick "$*"
  fi
  #local $snapshot_source_location_locals
  #offset=1 snapshot_source_location
  #write_to_log trace "${action:-}" "$*" || fail
}

log_debug() {
  if log_level_at_least debug; then
    log_quick "$*"
  fi
  #begin_function_lo
  #  local $snapshot_source_location_locals
  #  offset=1 snapshot_source_location
  #  write_to_log debug "${action:-}" "$*" || fail
  #end_function
  #handle_return
}

log_verbose() {
  if log_level_at_least verbose; then
    log_quick "$*"
  fi
  #begin_function_lo
  #  local $snapshot_source_location_locals
  #  offset=1 snapshot_source_location
  #  write_to_log verbose "${action:-}" "$*" || fail
  #end_function
  #handle_return
}

log_info() {
  begin_function_lo
    local $snapshot_source_location_locals
    offset=1 snapshot_source_location
    write_to_log info "${action:-}" "$*" || fail
  end_function
  handle_return
}

log_warn() {
  begin_function_lo
    local $snapshot_source_location_locals
    offset=1 snapshot_source_location
    write_to_log warn "${action:-}" "$*" || fail
  end_function
  handle_return
}

log_error() {
  begin_function_lo
    local $snapshot_source_location_locals
    offset=1 snapshot_source_location
    write_to_log error "${action:-}" "$*" || fail
  end_function
  handle_return
}

log_fatal() {
  begin_function
    local $snapshot_source_location_locals
    offset=1 snapshot_source_location
    write_to_log fatal "${action:-}" "$*" || fail
    #if log_level_at_least debug; then
    #  stack_trace
    #fi
  end_function
  handle_return
}

alias incomplete='echo "Not implemented yet." >&2; start_frame=1 stack_trace; fail1'

log_and_run() {

  local prefix= command=$* \
    out_to_file=${out_to_file:-} \
    err_to_file=${err_to_file:-}

  if [[ $pretend == t ]]; then
    prefix="PRETEND: "
  fi

  local $snapshot_source_location_locals
  offset=1 snapshot_source_location

  if [[ "$out_to_file" ]]; then
    command+=" >>$out_to_file"
  fi

  if [[ "$err_to_file" ]]; then
    command+=" 2>>$err_to_file"
  fi

  write_to_log debug command "$prefix$command" || fail

  if [[ $pretend != t ]]; then
    eval "$command" || return 1
    if [[ "${!:-}" ]]; then
      pid=$!
    fi
  fi

  return 0
}

declare -A log_level_num_map=( 
  [off]=0
  [fatal]=1 
  [error]=2 
  [warn]=3 
  [info]=4 
  [verbose]=5 
  [debug]=6 
  [trace]=7 
  [all]=8
  )

declare -A log_level_color_map=( 
  [all]= 
  [trace]= 
  [debug]= 
  [verbose]= 
  [info]=
  [warn]=$YELLOW
  [error]=$RED 
  [fatal]=$RED 
  [off]=
  )

