#!/bin/bash

[[ ${walk_lib_loaded:-f} == t ]] && return 0
walk_lib_loaded=t

walk_split_choice() {
  local remainder
  key=${choice%% *}
  code=${choice#$key }
  code=${code%% *}
  remainder=${choice##$key $code }
  if [[ "$remainder" != "$choice" ]]; then
    message=$remainder
  else
    message=$code
  fi
}

walk_menu() {
  local choice key code message prompt=${prompt:-Choose:}

  for choice in "${choices[@]}"; do
    walk_split_choice
    if [[ "$key" != ? ]]; then
      key=/
    fi
    echo "$key  $message"
  done

  local input

  response=
  if [[ "$walk_filter" ]]; then
    echo "${CYAN}Current filter:${RESET} $walk_filter"
  fi
  read -sp "$prompt" -n1 input || return 1
  if [[ $clear_screen == t ]]; then
    echo -n "$CLEAR_SCREEN$prompt"
  fi
  for choice in "${choices[@]}" "${hidden_choices[@]}"; do
    walk_split_choice
    if [[ $key == $input || $key == enter && $input == '' ]]; then
      response=$code
      #walk_filter=
      break
    fi
  done
  if [[ "$response" ]]; then
    echo "${message%% *}"
  else
    echo
  fi

}
 
walk_add_choice() {
  local hidden=${hidden:-f} key=$1 
  shift 1
  local remaining=$*
  local code=${remaining%% *}
  if [[ ! "${code_set[$code]:-}" ]]; then
    if [[ $hidden == f ]]; then
      choices+=( "$key $remaining" )
    else
      hidden_choices+=( "$key $remaining" )
    fi
    code_set[$code]=1
  fi
}

walk_add_dirs() {
  local dirs d extra current_selection=$1
  dirs=$(find -L $current_selection -mindepth 1 -maxdepth 1 -type d -not -name ".*" | sort -g) || return 1
  if [[ "$dirs" ]]; then
    for d in $dirs; do
      extra=
      if [[ -L $d ]]; then
        local r=$(realpath $d)
        r=${r#/work/*/}
        extra+=" -> $r"
      fi
      if [[ -f $d/.member ]]; then
        local member="$(<$d/.member)"
        if (( ${#member} > 60 )); then
          extra+=" ${member:0:60}..."
        else
          extra+=" ${member}"
        fi
      fi
      if [[ "${walk_filter:-}" && "${d##*/}$extra" != *"$walk_filter"* ]]; then
        continue
      fi
      walk_add_choice "$i" "${d#./}" "${d##*/}$extra"
      (( i++ ))
    done
  fi
}

walk_init() {
  show_selection() { :; }
  adjust_choices() { :; }
  handle_walk_responses() { :; }
}

walk_execute() {
  begin_function
    local current_selection=$1 \
      hidden_choices choices \
      choice path i real_stack=() \
      walk_filter= \
      prompt=${prompt:-Choose: } \
      clear_screen=${clear_screen:-t} \

    local -A code_set
    if [[ $clear_screen == t ]]; then
      echo -n "$CLEAR_SCREEN"
    fi
    begin_while true; doo

      show_selection || fail

      code_set=()
      hidden_choices=(
        "enter accept"
        "q quit"
        "? help"
        "/ filter"
        )
      choices=()
      local i=1
      adjust_choices || fail

      walk_menu || break
      if [[ "$response" == help ]]; then
        echo "Press one of the characters in the menu to select one of the choices, enter or space to accept the choice, or q to quit/abort this command."
        echo "You can also use / to enter a filter to narrow down results."
        echo "Using / again after a filter is applied will remove the filter."
        if [[ "${hidden_choices:-}" ]]; then
          echo "${NL}Hidden commands:"
          local h
          for h in "${hidden_choices[@]}"; do
            echo "  $h"
          done | column -t
        fi
      elif [[ "$response" == quit ]]; then
        return 1
      elif [[ "$response" == accept ]]; then
        break
      elif [[ "$response" == filter ]]; then
        if [[ "$walk_filter" ]]; then
          echo "Removed filter."
          walk_filter=
        else
          read -p "New filter: " walk_filter
        fi
      else
        local invalid_response=f
        handle_walk_responses || fail
        if [[ $invalid_response == t ]]; then
          echo "Invalid selection, try again."
          continue
        fi
        if [[ $response == accept ]]; then
          break
        fi
      fi

    end_while
    result=$current_selection
  end_function
  handle_return
}

