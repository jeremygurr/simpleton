#!/bin/bash

#[[ ${walk_lib_loaded:-f} == t ]] && return 0
walk_lib_loaded=t

walk_get_choice() {
  local i=$1
  key=${choices[$i]}
  response=${choices[$((i+1))]}
  message=${choices[$((i+2))]}
}

walk_get_hidden_choice() {
  local i=$1
  key=${hidden_choices[$i]}
  response=${hidden_choices[$((i+1))]}
  message=${hidden_choices[$((i+2))]}
}

walk_menu() {

  local prompt=${prompt:-Choose:} \
    i choice key message 

  for (( i = 0; i < ${#choices[*]}; i+=3 )); do
    walk_get_choice $i
    if [[ "$key" != ? ]]; then
      key=/
    fi
    echo "$key  $message"
  done

  local input found=f

  if [[ "$walk_filter" ]]; then
    echo "${CYAN}Current filter:${RESET} $walk_filter"
  fi
  read -sp "$prompt" -n1 input || return 1

  if [[ $clear_screen == t ]]; then
    echo -n "$CLEAR_SCREEN$prompt"
  fi

  for (( i = 0; i < ${#choices[*]}; i+=3 )); do
    walk_get_choice $i
    if [[ $key == $input || $key == enter && $input == '' ]]; then
      #walk_filter=
      found=t
      break
    fi
  done

  if [[ $found == f ]]; then
    for (( i = 0; i < ${#hidden_choices[*]}; i+=3 )); do
      walk_get_hidden_choice $i
      if [[ $key == $input || $key == enter && $input == '' ]]; then
        #walk_filter=
        found=t
        break
      fi
    done
  fi

  if [[ $found == t ]]; then
    echo "$message"
  else
    echo
  fi

}
 
walk_add_choice() {
  local hidden=${hidden:-f} key=$1 response=$2 message=$3
  if [[ $hidden == f ]]; then
    choices+=( "$key" "$response" "$message" )
  else
    hidden_choices+=( "$key" "$response" "$message" )
  fi
}

walk_add_dirs() {
  local dirs d extra current_selection=$1
  dirs=$(find -L $current_selection -mindepth 1 -maxdepth 1 -type d -not -name ".*" | sort -g) || return 1
  if [[ "$dirs" ]]; then
    for d in $dirs; do
      extra=
      if [[ -L $d ]]; then
        local r=$(realpath $d)
        r=${r#/work/*/}
        extra+=" -> $r"
      fi
      if [[ -f $d/.member ]]; then
        local member="$(<$d/.member)"
        if (( ${#member} > 60 )); then
          extra+=" ${member:0:60}..."
        else
          extra+=" ${member}"
        fi
      fi
      if [[ "${walk_filter:-}" && "${d##*/}$extra" != *"$walk_filter"* ]]; then
        continue
      fi
      walk_add_choice "$i" "${d#./}" "${d##*/}$extra"
      (( i++ ))
    done
  fi
}

walk_init() {
  show_selection() { :; }
  adjust_choices() { :; }
  handle_walk_responses() { :; }
}

walk_execute() {
  begin_function
    local current_selection=$1 \
      hidden_choices choices \
      choice path i real_stack=() \
      walk_filter= \
      prompt=${prompt:-Choose: } \
      clear_screen=${clear_screen:-t} \

    if [[ $clear_screen == t ]]; then
      echo -n "$CLEAR_SCREEN"
    fi
    begin_while true; doo

      show_selection || fail

      hidden_choices=(
        "enter accept"
        "q quit"
        "? help"
        "/ filter"
        )
      choices=()
      local i=1
      adjust_choices || fail

      walk_menu || break
      if [[ "$response" == help ]]; then
        echo "Press one of the characters in the menu to select one of the choices, enter or space to accept the choice, or q to quit/abort this command."
        echo "You can also use / to enter a filter to narrow down results."
        echo "Using / again after a filter is applied will remove the filter."
        if [[ "${hidden_choices:-}" ]]; then
          echo "${NL}Hidden commands:"
          local h
          for (( i = 0; i < ${#hidden_choices[*]}; i+=3 )); do
            walk_get_hidden_choice $i
            echo "  $key $message"
          done | column -t
        fi
      elif [[ "$response" == quit ]]; then
        return 1
      elif [[ "$response" == accept ]]; then
        break
      elif [[ "$response" == filter ]]; then
        if [[ "$walk_filter" ]]; then
          echo "Removed filter."
          walk_filter=
        else
          read -p "New filter: " walk_filter
        fi
      else
        local invalid_response=f
        handle_walk_responses || fail
        if [[ $invalid_response == t ]]; then
          echo "Invalid selection, try again."
          continue
        fi
        if [[ $response == accept ]]; then
          break
        fi
      fi

    end_while
    result=$current_selection
  end_function
  handle_return
}

