#!/bin/bash

type -t make_cyto >/dev/null && return 0

# don't let other users read any files written by these scripts
umask 0077

readonly failed_but_can_retry=2 skip=2 somethings_wrong=1 everythings_fine=0

parallel_default=t 
[[ $debug == t ]] && parallel_default=f
parallel_execution=${parallel_execution:-${par:-$parallel_default}}

make_cyto() {
local stem=$1
begin_function
  if [[ ! -d $stem/.dna ]]; then
    err "$stem is not a stem cell"
    fail1
  fi
  mkdir -p $stem/.cyto/command || fail
  mkdir -p $stem/.cyto/lib || fail
  inherit_lib $stem $stem || fail
end_function
handle_return
}

inherit_lib() {
local stem_from=$1 stem_to=$2
local parent=${stem_from%/*}
begin_function
  if [[ "${#parent}" -gt 1 ]]; then
    inherit_lib $parent $stem_to || fail
  fi
  if [[ -d $stem_from/.dna ]]; then
    local lib
    if [[ -d $stem_from/.dna/lib ]]; then
      inherit_lib_folder $stem_from/.dna/lib $stem_to/.cyto/lib || fail
    fi
    if [[ -d $stem_from/.dna/command ]]; then
      inherit_lib_folder $stem_from/.dna/command $stem_to/.cyto/command || fail
    fi
  fi
end_function
handle_return
}

inherit_lib_folder() {
local from=$1 to=$2
begin_function
  local folder_name=${from##*/}
  mkdir -p $to/$folder_name
  local lib
  to=$to/$folder_name
  begin_for lib in $(find1 -not -name '.*' $from); doo
    if [[ -f $lib ]]; then
      local source_path=${lib%/*} target_file=${lib##*/} base prefix
      if [[ ! $target_file =~ ([0-9]+)-(.*) ]]; then
        prefix=000
        base=$target_file
        found=( $(find1 $to -regex '[0-9]+-'$base'$' | sort -g) ) || fail
        if [[ "$found" ]]; then
          target_file=$found
          if [[ "${#found[*]}" -gt 1 ]]; then
            warn "Found more than one match for $lib in $to. Will use $target_file."
          fi
        fi
      fi
      ln -sf $lib $to/$target_file || fail
    elif [[ -d $lib ]]; then
      inherit_lib_folder $lib $to/$folder_name || fail
    fi
  end_for
end_function
handle_return
}

execute_command() {
local stem=$1 command=$2
vars='stem command'; begin_function
  local command_path=$stem/.cyto/command/$command
  if [[ -e $command_path ]]; then
    execute_command_step $command_path || fail
  fi
end_function
handle_return
}

# executes a step of the folder language
# folder language
#   {stem}                update the given stem with the current coordinates
#   choose-{n}-{name}     multi-path, stopping after {n} choices are successful. {name} is optional
#   each-{var}-in-{vars}  loop over {vars} storing current value in {var}
#                         can be file or folder
#   each-{var}            loop over {vars} (adds 's' to index var)
#   {file}.go             execute go code
#                         should define a single method named after the file which will be executed
#   {file}.py             execute python script
#   {file}.js             execute js code
#   {file}.java           execute java code
#   {file}.bash           execute bash code
#   {folder}              go through each item in folder and execute according to folder language
execute_command_step() {
local step=$1
vars=step; begin_function
  local step_name=${step##*/} prefix=

  if [[ $target_file =~ ([0-9]+)-(.*) ]]; then
    prefix=${BASH_REMATCH[1]}
    base=${BASH_REMATCH[2]}
  fi
  
  if [[ ! "$prefix" ]]; then
    succeed # only execute steps that have a numeric prefix
  fi

  if [[ -d $step/.dna ]]; then
    # recursive
    execute_command $step update || fail
  elif [[ -d $step ]]; then
    if [[ $base =~ ^choose-.* ]]; then
      # TODO ...
      incomplete
    elif [[ $base =~ ^serial-each-.* ]]; then
      serial=t execute_command_step_each || fail
    elif [[ $base =~ ^each-.* ]]; then
      serial=f execute_command_step_each || fail
    else
      execute_command_step_plain_folder $step || fail
    fi
  elif [[ -f $step ]]; then
    execute_command_step_file $step || fail
  else 
    err "I don't know how to process this step: $step"
    fail1
  fi
end_function
handle_return
}

execute_command_step_file() {
begin_function_flat
  case $step in
    *.py)
      err "Python steps not implemented yet"
      fail1
    ;;
    *.js)
      err "JavaScript steps not implemented yet"
      fail1
    ;;
    *.go)
      err "GoLang steps not implemented yet"
      fail1
    ;;
    *.java)
      err "Java steps not implemented yet"
      fail1
    ;;
    *.bash)
      source $step || fail
      local function_name=${step%.bash}
      function_name=${function_name##*/}
      local function_exists=`type -t $function_name &>/dev/null && echo true`
      if [[ "$function_exists" ]]; then
        $function_name || fail
      else
        err "Step $step requires that a function named $function_name be defined in that file."
        fail1
      fi
    ;;
    *)
      err "Unknown file format for $step. Can't execute."
      fail1
    ;;
  esac
end_function_flat
handle_return
}

execute_command_step_each() {
local serial=$serial
begin_function_flat
  local ref ref_group
  if [[ $base =~ each-([^-]+)-in-([^-]+) ]]; then
    ref=${BASH_REMATCH[1]}
    ref_group=${BASH_REMATCH[2]}
  elif [[ $base =~ each-([^-]+) ]]; then
    ref=${BASH_REMATCH[1]}
    ref_group=${ref}s
  fi
  if [[ ! -v $ref_group ]]; then
    err "var doesn't exist: $ref_group"
    fail1
  fi
  local v a
  eval "a=( \"$ref_group[@]}\" )"

  local parallel=f processes=
  if [[ "${#a[*]}" -gt 1 ]]; then
    if [[ "$parallel_execution" == t && $serial == f ]]; then
      parallel=t
      wait_for_low_load || fail
    fi
  fi

  begin_for v in "${a[@]}"; doo
    let "$ref=\$v"
    if [[ $parallel == t ]]; then
      execute_command_step_plain_folder $step &
      processes+=" $!"
    else
      execute_command_step_plain_folder $step || fail
    fi
  end_for

  wait_for_sub_processes || fail

end_function_flat
handle_return
}

# may be run in a subshell
execute_command_step_plain_folder() {
local step=$1
begin_function_flat

  change_log_file || fail

  local contents=$(find1 -not -name ".*" $step | sort -g) || fail
  local files i=0 file_index
  if [[ ! "$contents" ]] && succeed

  begin_loop

    files=( ${contents[$i]} )
    if [[ $files =~ ([0-9]+)-.* ]]; then
      file_index=${BASH_REMATCH[1]}
      # does next file have same index?
    else
      file_index=-1
    fi

    # gather all files with the same index
    local next_file_index=$file_index next_file n=$i
    begin_loop
      let n++ || true
      [[ $n -gt ${#contents[*]} ]] && break
      next_file=${contents[$n]}
      if [[ $next_file =~ ([0-9]+)-.* ]]; then
        next_file_index=${BASH_REMATCH[1]}
      else
        next_file_index=-1
      fi
      if [[ $next_file_index -eq $file_index ]]; then
        files+=( $next_file )
        let i++ || true
      else
        break
      fi
    end_loop

    local parallel=f
    if [[ "${#files[*]}" -gt 1 ]]; then
      if [[ "$parallel_execution" == t ]]; then
        parallel=t
        wait_for_low_load || fail
      fi
    fi

    begin_for step in "${files[@]}"; doo
      if [[ $parallel == t ]]; then
        # recursive
        execute_command_step $step &
        processes+=" $!"
      else
        # recursive
        execute_command_step $step || fail
      fi
    end_for

    wait_for_sub_processes || fail

    let i++ || true
    [[ $i -gt ${#contents[*]} ]] && break

  end_loop

end_function_flat
handle_return
}

# input: $* = batch values in dim order
# output: batch_node = string path to batch from batch path
get_batch_node() {
local v i=0 d
batch_node=
for v in "$@"; do
  d=${batch_dims[$i]}
  get_sane_value "$v"
  v=$sane_value
  batch_node+=/dim/$d/$v
  let i++ || true
done
}

# input: $* = batch values in dim order
# output: batch_id = string batch id
get_batch_id() {
local v
batch_id=
for v in "$@"; do
  get_sane_value "$v"
  v=$sane_value
  batch_id+=_$v
done
batch_id=${batch_id#_}
}

get_stem_path() {
local subject=$1
stem_path=
if [[ -d $subject/.cyto || -d $subject/.dna ]]; then
  stem_path=$subject
else
  subject=${subject%/*}
  if [[ "$subject" =~ / ]]; then
    get_stem_path $subject
  fi
fi
}

handle_secure_edit() {
begin_function

  local unsafe_file=${file%.safe}
  local new_unsafe_file=$tmp_path/$unsafe_file.new
  local old_unsafe_file=$tmp_path/$unsafe_file.old

  if [[ -f $new_unsafe_file ]]; then
    err "$new_unsafe_file already exists, delete that first if you want to edit $file"
    fail1
  fi

  defer "rm $new_unsafe_file"
  defer "rm $old_unsafe_file"

  if [[ -f $old_file ]]; then
    from=$old_file to=$old_unsafe_file decrypt_file || fail
    cp $old_unsafe_file $new_unsafe_file || fail
  fi

  if [[ "$content" ]]; then
    echo "$content" >$new_unsafe_file || fail
  else
    $EDITOR $new_unsafe_file || fail
  fi

  if [[ -f $old_unsafe_file ]]; then
    if files_are_different $old_unsafe_file $new_unsafe_file >/dev/null; then
      changed=t
    else
      trace $log_trace "No change"
      rm $new_unsafe_file || fail
    fi
  else
    changed=t
  fi

  if [[ $changed == t ]]; then
    from=$new_unsafe_file to=$new_file encrypt_file || fail
    mv $new_file $old_file || fail
    update_modify_times "${new_file%/*}" "${current_cube}" || fail
  fi

end_function
handle_return
}

handle_insecure_edit() {
begin_function

  if [[ -f $old_file ]]; then
    cp $old_file $new_file || fail 
  fi

  if [[ "$content" ]]; then
    echo "$content" | trim_nl >$new_file || fail
  else
    $EDITOR $new_file || fail
  fi

  if [[ -f $old_file ]]; then
    if files_are_different $old_file $new_file >/dev/null; then
      changed=t
    else
      trace 0 "No change"
      rm $new_file || fail
    fi
  else
    changed=t
  fi

  if [[ $changed == t ]]; then
    mv $new_file $old_file || fail
    update_modify_times "${new_file%/*}" "$cube_path" || fail
  fi

end_function
handle_return
}

# input must be a folder
setup_cube_path_vars() {
begin_function_flat

  if [[ ! "${top_path:-}" ]]; then
    get_top_path "$subject" || fail
  fi

  cube_path=$(realpath $1) \
    dna_path=$cube_path/.dna \
    cube_cyto_path=$cube_path/.cyto \
    short_cube=${cube_path#$top_path}

  if [[ ! -d $dna_path ]]; then

    cube_type=constant
    dna_path=

  else

    if [[ -d $dna_path/key ]]; then
      key_path=$dna_path/key
    else
      key_path=
    fi

  fi

  cube_up_path=$dna_path/up
  if [[ ! -d $cube_up_path ]]; then
    cube_up_path=
  fi

  cube_down_path=$cube_cyto_path/down
  if [[ ! -d $cube_down_path ]]; then
    cube_down_path=
  fi

  # context can override these as needed
  # should be a relative path
  in_path=${in_path:-}
  out_path=${out_path:-}

  if [[ "$in_path" ]]; then
    if [[ "$in_path" == . ]]; then
      cube_in_path=$cube_path
    else
      cube_in_path=$cube_path/$in_path
    fi
  fi

  if [[ "$out_path" ]]; then
    if [[ "$out_path" == . ]]; then
      cube_out_path=$cube_path
    else
      cube_out_path=$cube_path/$out_path
    fi
  fi

  cube_status_path=$cube_cyto_path/status
  if [[ ! -d $cube_status_path ]]; then
    cube_status_path=
  fi

  cube_lock_path=$cube_cyto_path/lock
  if [[ ! -d $cube_lock_path ]]; then
    cube_lock_path=
  fi

  cube_log_path=$cube_cyto_path/log
  if [[ ! -d $cube_log_path ]]; then
    cube_log_path=
  fi

  cube_debug_path=$cube_cyto_path/debug
  if [[ ! -d $cube_debug_path ]]; then
    cube_debug_path=
  fi

  req_path=$cube_cyto_path/req
  if [[ ! -d $req_path ]]; then
    req_path=
  fi

  # if there are dims, this will be overridden in setup_batch_path_vars
  batch_path=$cube_cyto_path/batch

end_function_flat
handle_return
}

get_top_path() {
local subject=$1
subject=${subject%%/.dna*}
subject=${subject%%/.cyto*}
local parent=${subject%/*}
if [[ -d $parent/.dna ]]; then
  if [[ ! -d $parent/.cyto ]]; then
    init_cube $parent || return 1
  fi
  # recursive
  get_top_path $parent || return 1
else
  top_path=$parent/
fi
return 0
}

# This is run if cube hasn't been initialized = missing .cyto folder
# Context should be loaded before this is run
init_cube() {
local subject=$1
begin_function_flat
  cube_cyto_path=$subject/.cyto
  mkdir $cube_cyto_path || fail
  local feature
  cube_lock_path=
  if [[ "${cube_features:-}" ]]; then
    begin_for feature in "${cube_features[@]}"; doo
      case $feature in
        req)
          mkdir -p $cube_cyto_path/$feature/new || fail
        ;;
        log)
          mkdir -p $cube_cyto_path/$feature || fail
        ;;
        *)
          err "Unknown feature $feature"
          fail1
        ;;
      esac
    end_for
  fi
  if [[ -d $subject/.dna ]]; then
    mkdir $cube_cyto_path/batch \
          $cube_cyto_path/status || fail
  fi
end_function_flat
handle_return
}

# should be run before spawn update function
init_context() {

  # default_fresh:
  #   inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
  #   1w means refresh if it's older than a week.
  # high_volume_cell:
  #   does the cell have thousands of cells or more? If so we will use another folder level
  # ignore_fresh:
  #   whether freshness is used to determine if a cell needs to be updated
  # cell_storage:
  #   contains pairs of var_name/default values used to store data in this cell
  # shuffle_chance:
  #   chance out of 1000 of not following the computed strategy order
  # min_pause:
  #   number of ms to wait between cycles
  #   this number doubles each time there is nothing to do, until it reaches max_pause
  # cube_type:
  #   can be: constant info change
  #   constant means it just holds a fixed value that never changes
  #   info means it only fetches information 
  #   change means that it applies a change

  batch_dims= \
  cell_dims= \
  in_path= \
  in_paths= \
  out_path= \
  out_paths= \
  cube_in_path= \
  cube_out_path= \
  batch_in_path= \
  batch_out_path= \
  default_fresh=inf \
  require_fresh_greater_than= \
  retry_max=1 \
  retry_delay=1 \
  retry_scale=2 \
  cell_expiration= \
  high_volume_cell=f \
  ignore_fresh=f \
  default_strategies=crl \
  cell_storage=() \
  shuffle_chance=100 \
  force_update=${p_force_update:-f} \
  lock_timeout=${lock_timeout:-30} \
  prevalidate=f \
  postvalidate=f \
  generators=gen_copy \
  min_pause=250 \
  current_pause=250 \
  cube_type=info \
  max_pause=60000 \
  top_path=${top_path:-}

  # override this if there are parameter requirements that must be met before attempting to update the cell
  are_batch_params_valid() {
    return 0
  }

  # override this if there are some batch id combinations which are not valid even when
  # composed of valid dim members
  # returns 0 if it's not a valid combination of members
  skip_batch() {
    return 1
  }

  # this may be overridden to provide a custom cooldown calculation
  get_cooldown_delay() {
    [[ -z "${cooldown_delay:-}" ]] && cooldown_delay=1
    let cooldown_delay*=2
  }

  # override this function to implement custom update logic
  unset execute_update

}

# batch_id should be figured out before this, 
#   although it may be empty if no dims in this batch
#   each element should be expanded and validated beforehand
setup_batch_path_vars() {
begin_function_flat

  require_var cube_path cube_cyto_path

  # batch id is quite different than batch path, given new structure: .cyto/dim/env/e1...
  batch_path=$cube_cyto_path/batch
  batch_dna_path=$dna_path/batch
  batch_id=only
  batch_value_path=

  if [[ "${batch_values:-}" ]]; then
    local i d v
    batch_id=
    for ((i=0; i < ${#batch_values[*]}; i++)); do

      d=${batch_dims[$i]}
      if [[ ! "$d" ]]; then
        err "Invalid cube config: batch_values array has more elements than the number of batch_dims"
        fail1
      fi
      if [[ ! "$d" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
        err "Invalid cube config: Bad dim name: $d"
        fail1
      fi

      get_sane_value "${batch_values[$i]}" || fail
      v=$sane_value

      local dim_part=/dim/$d/$v
      batch_path+=$dim_part
      batch_id+=${v}_
      batch_value_path+=/$v

    done
    batch_id=${batch_id%_}
  fi

  if [[ ! -d $batch_path ]]; then
    mkdir -p $batch_path || fail
  fi

  update_batch_value_file || fail

  if [[ "$cube_lock_path" ]]; then
    # Will be created when a lock on this batch is obtained
    batch_lock_path=$batch_path/lock
  else
    batch_lock_path=
  fi

  if [[ "$cube_status_path" ]]; then
    batch_status_path=$batch_path/status
    if [[ ! -d $batch_status_path ]]; then
      mkdir -p $batch_status_path || fail
    fi
  else
    batch_status_path=
  fi

  batch_tmp_path=$batch_path/tmp
  if [[ ! -d $batch_tmp_path ]]; then
    mkdir -p $batch_tmp_path || fail
  fi

  if [[ "$cube_log_path" ]]; then
    batch_log_path=$batch_path/log
    mkdir -p $batch_log_path || fail
  else
    batch_log_path=
  fi

  if [[ "$cube_debug_path" ]]; then
    batch_debug_path=$batch_path/debug
    mkdir -p $batch_debug_path || fail
  else
    batch_debug_path=
  fi

  if [[ "$cube_up_path" ]]; then
    batch_up_path=$batch_path/up
    # Don't create the up path here, but instead allow it to be created 
    #   inside of batch_update -> batch_setup_up
  else
    batch_up_path=
  fi

  if [[ "$cube_down_path" ]]; then
    batch_down_path=$batch_path/down
    # Created on demand
  else
    batch_down_path=
  fi

  if [[ "$in_path" ]]; then
    if [[ "$in_path" == . ]]; then
      batch_in_path=$cube_path$batch_value_path
    else
      batch_in_path=$cube_in_path$batch_value_path
    fi
    mkdir -p $batch_in_path || fail
  else
    batch_in_path=
  fi

  if [[ "$out_path" ]]; then
    if [[ "$out_path" == . ]]; then
      batch_out_path=$cube_path$batch_value_path
    else
      batch_out_path=$cube_out_path$batch_value_path
    fi
    mkdir -p $batch_out_path || fail
  else
    batch_out_path=
  fi

end_function_flat
handle_return
}

get_cube() {
cube_path=$1
[[ ${#cube_path} -lt 3 ]] && return 1
[[ -d $cube_path/.dna ]] && return 0
[[ -d $cube_path/.cyto ]] && return 0
get_cube ${cube_path%/*} || return 1
return 0
}

setup_tmp_path() {
if [[ ! "$tmp_path" ]]; then
  err "Missing tmp_path. Maybe you needed to run setup_cube_path_vars first"
  return 1
fi
if [[ ! -d $tmp_path ]]; then
  mkdir -p $tmp_path || return 1
fi
return 0
}

# params: $1 (subject)
# output: workspace
get_workspace() {
local subject=$1
workspace=
while [[ ${#subject} -gt 1 && $subject =~ / ]]; do
  if [[ "$subject" == "$top_path"/* ]]; then
    workspace=$subject
    break
  fi
  subject=${subject%/*}
done
[[ "$workspace" ]]
}

get_tmp_path() {
local current_cube=$1
if [[ -d $current_cube/tmp ]]; then
  tmp_path=$current_cube/tmp
elif [[ -d ~/tmp ]]; then
  tmp_path=~/tmp
else
  tmp_path=/tmp
fi
return 0
}

# inputs: from to tmp_path current_cube
# will write output to file at $to
decrypt_file() {

local from=$from
local to=$to
local tmp_path=$tmp_path
local key_path=$key_path
local user_private_key=${user_private_key:-~/.ssh/id_rsa}

trace $log_trace "Decrypting $from to $to"
begin_function

  if [[ ! -f "$user_private_key" ]]; then
    err "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
    err "You may create one using: ssh-keygen -mPEM"
    fail1
  fi

  if [[ ! "$tmp_path" ]]; then
    err "tmp_path must be set to a directory before calling decrypt_file."
    fail1
  fi

  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || fail
  fi

  if [[ ! -d "$key_path" ]]; then
    err "key_path must be set before calling decrypt_file"
    fail1
  fi

  if [[ ! -d $key_path ]]; then
    mkdir $key_path || fail
  fi

  if [[ ! -f "$key_path/key.$USER" ]]; then
    err "You don't have a key for this cube ($USER). Ask someone who does to add you. Existing keys:" 
    find -L $key_path -name "key.*" >&2
    fail1
  fi

  # extract the main key
  if ! openssl pkeyutl -decrypt -inkey $user_private_key -in "$key_path/key.$USER" -out $tmp_path/main; then
    err "Failed to decrypt main key." 
    fail1
  fi
  defer "rm $tmp_path/main"

  # decrypt the secret file
  if ! openssl enc -aes256 -pbkdf2 -in $from -out $to -d -pass file:$tmp_path/main; then 
    err "Failed to decrypt secret file." 
    fail1
  fi

end_function
handle_return

}

encrypt_file() {

local from=$from
local to=$to
local tmp_path=$tmp_path
local key_path=$key_path
local user_private_key=${user_private_key:-~/.ssh/id_rsa}

trace $log_trace "Encrypting $from to $to"
begin_function

  if [[ ! -f "$user_private_key" ]]; then
    err "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
    err "You may create one using: ssh-keygen -mPEM"
    fail1
  fi

  if [[ ! "$tmp_path" ]]; then
    err "tmp_path must be set to a directory before calling decrypt_file."
    fail1
  fi

  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || fail
  fi

  if [[ ! -d "$key_path" ]]; then
    err "key_path must be set before calling decrypt_file"
    fail1
  fi

  if [[ ! -d $key_path ]]; then
    mkdir $key_path || fail
  fi

  if [[ ! -f "$key_path/key.$USER" ]]; then

    local key_count=$(find -L $key_path -mindepth 1 -maxdepth 1 -name 'key.*' -type f | wc -l)

    if [[ $key_count -gt 0 ]]; then

      err "You don't have a key for this cube ($USER). Ask someone who does to add you. Existing keys:" 
      find -L $key_path -name "key.*" >&2
      fail1

    else

      trace $log_info "There are no keys for this cube yet. Will create a new key."

      # create a new main key
      if ! openssl rand -base64 40 >$tmp_path/main; then
        err "Failed to generate new main key."
        fail1
      fi
      defer "rm $tmp_path/main"

      # create a compatible public key from the user's private key
      if ! openssl pkey -in $user_private_key -out $tmp_path/public -pubout; then 
        err "Failed to convert private key to public key."
        fail1
      fi

      # encrypt main key with given user key
      if ! openssl pkeyutl -encrypt -pubin -inkey $tmp_path/public -in $tmp_path/main -out $key_path/key.$USER; then
        err "Failed to encrypt main key."
        fail1
      fi

    fi
  else 
    # extract the main key
    if ! openssl pkeyutl -decrypt -inkey $user_private_key -in $key_path/key.$USER -out $tmp_path/main; then
      err "Failed to decrypt main key." 
      fail1
    fi

    defer "rm $tmp_path/main"
  fi
    
  # encrypt the file with main key
  if ! openssl enc -aes256 -pbkdf2 -in $from -out $to -pass file:$tmp_path/main; then
    err "Failed to create new secret file."
    fail1
  fi

end_function
handle_return

}

# dim vars and functions should be set before this is called
# will construct batch_values array with current set of values of the
#   batch dims, which can be used in branch or leaf functions
for_each_batch() {

local leaf_function=${leaf_function:-} \
  branch_function=${branch_function:-} \
  batch_values=( ) \
  multi_batch=${multi_batch:-f} \
  multi_cell=${multi_cell:-f} \
  remaining_batch_dims=( "$@" ) 

if [[ "${remaining_batch_dims:-}" ]]; then
  local finished=f
  batch_pivot "${remaining_batch_dims[@]}" || return 1
else
  if [[ "$leaf_function" ]]; then
    $leaf_function || return 1
  fi
  if [[ "$branch_function" ]]; then
    $branch_function || return 1
  fi
fi
}

# check if the dim exists before calling this
# other inputs: function
# *sometimes* runs as a subshell
batch_pivot() {

local -r remaining_batch_dims=( "$@" ) 
local -r dim=$remaining_batch_dims
local values=() \
  batch_values=( "${batch_values[@]}" ) \
  processes= 

begin_function_flat

  expand_values || fail
  batch_pivot_values || fail

end_function_flat
handle_return

}

# input: values (array)
batch_pivot_values() {
begin_function_flat

  local parallel=f \
        go_deeper=t 
  if [[ "${#values[*]}" -gt 1 ]]; then
    multi_batch=t
    if [[ "$parallel_execution" == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi
  fi

  local value sane_value processes= 

  batch_values+=( only )

  begin_for value in "${values[@]}"; doo

    eval "local $dim='$value' d_$dim='$value'"
    batch_values[-1]=$value

    if [[ "$branch_function" ]]; then
      $branch_function || fail
    fi

    if [[ $finished == t ]]; then
      break
    fi

    if [[ ${#remaining_batch_dims[*]} -gt 1 
       && $go_deeper == t
       ]]; then

      if [[ $parallel == t ]]; then
        # recursive
        batch_pivot "${remaining_batch_dims[@]:1}" &
        processes+=" $!"
      else
        # recursive
        batch_pivot "${remaining_batch_dims[@]:1}" || fail
      fi

    else

      if [[ "$leaf_function" ]]; then
        if [[ $parallel == t ]]; then
          $leaf_function &
          processes+=" $!"
        else
          $leaf_function || fail
        fi
      fi

    fi

  end_for

  wait_for_sub_processes || fail

end_function_flat
handle_return
}

get_sane_value() {
local -r value=$1
if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
  sane_value=$value
else
  hash=$(echo "$value" | cksum -a md5 | awk '{ print $4 }')
  sane_value=${hash:0:8}
fi
return 0
}

# input: parallel processes
wait_for_sub_processes() {
if [[ "$processes" ]]; then
  trace $log_info "Waiting for sub processes to complete"
  local process last_err_code= last_failed_process= rc
  for process in $processes; do
    trace $log_trace "Waiting for process $process"
    wait $process &>/dev/null; rc=$?
    if [[ $rc -gt 0 && $rc -lt 127 ]]; then
      if [[ ! "$last_err_code" ]]; then
        last_err_code=$rc
        last_failed_process=$process
      else
        trace $log_warn "Subprocess $process failed to terminate successfully"
        return 1
      fi
    fi
  done
  if [[ "$last_err_code" ]]; then
    if [[ "$last_err_code" == 1 ]]; then
      trace $log_warn "Subprocess $last_failed_process failed to terminate successfully"
      return 1
    fi
    return $last_err_code
  fi
  processes=
fi
return 0
}

wait_for_low_load() {
local cell_max_load=${cell_max_load:-10}
local cell_load_wait_timeout=${cell_load_wait_timeout:-600}
local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
if [[ $current_load -gt $cell_max_load ]]; then
  trace $log_warn "Load average is too high ($current_load > $cell_max_load)," \
    "waiting until things cool down first."
  local time_waited=0
  while [[ $current_load -gt $cell_max_load ]]; do
    current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
    sleep 5; let time_waited+=5
    if [[ "$cell_load_wait_timeout" -gt 0 && $time_waited -ge $cell_load_wait_timeout ]]; then
      err "Timed out waiting for cpu load to be low enough. Aborting"
      return 1
    fi
  done
fi
return 0
}

is_cube() {
[[ -d "$1/.dna" ]]
}

is_inside_of_cube() {
local c=$1
if [[ $c == "$top_path"/* ]]; then
  while [[ $c == "$top_path"/* ]]; do
    if [[ -d $c/.dna ]]; then
      return 0
    fi
    c=${c%/*}
  done
else
  while [[ $c == /*/* ]]; do
    if [[ -d $c/.dna ]]; then
      return 0
    fi
    c=${c%/*}
  done
fi
return 1
}

