#!/bin/bash
# depends on lib/bash-lib being sourced first to provide needed aliases

[[ -v cell_lib_loaded ]] && return 0
cell_lib_loaded=t

cell_lib_init() {
  # don't let other users read any files written by these scripts
  umask 0077

  empty_member=_ 
  execute_inner=${execute_inner:-${dig:-m}}

  handle_special_vars trace_vars
  handle_special_vars pause_at_vars

  : ${risk_tolerance:=${risk:-0}}
  case "$risk_tolerance" in
    l*)
      risk_tolerance=0
      ;;
    m*)
      risk_tolerance=1
      ;;
    h*)
      risk_tolerance=2
      ;;
    v*)
      risk_tolerance=3
      ;;
    [0-9])
      risk_tolerance=${risk_tolerance:-${risk}}
      ;;
    *)
      log_fatal "Unknown risk level: $risk. Should be one of: low medium high very_high (or 0 1 2 3). Defaults to low."
      fail1
      ;;
  esac

  tee_files=( )
  paused_tee_file=

  parallel_default=f 
  [[ ${debug:-f} == t ]] && parallel_default=f
  parallel_execution=${parallel_execution:-${par:-$parallel_default}}

  # used to detect upstream circular dependencies
  # not currently implemented for some reason, will probably add later
  downstream_cell_stack=( ) 

  disable_log=${disable_log:-}

  command_aliases=()
  command_alias_command=()

  trace_dims=${trace_dims:-${trace_dim:-}}
}

handle_special_vars() {
  local -n vars=$1
  local t new_vars=
  for t in $vars; do
    if [[ $t == ^* ]]; then
      t=${t#^}
      new_vars+="p_$t p_${t}s d_$t d_${t}s s_$t s_${t}s "
    else
      new_vars+="$t "
    fi
  done
  vars=${new_vars% }
}

# allocates a unique file optionally based on a given name in the cell tmp_path
# returns tmp_file set to the full path of the file
get_tmp_file() {
  local base=${1:-tmp}
  if [[ ! -e $tmp_path ]]; then
    mkdir $tmp_path || return 1
  fi
  tmp_file=$(mktemp $tmp_path/$base.$$.XXXXXX) || return 1
  defer "rm $tmp_file"
  return 0
}

# Will update a single row of coordinate data
# inputs:
#   current_row
#   coord_type
#   d_*          dimensions to update coordinates with
set_coordinate_data() {
  local current_row=${current_row:-0}
  begin_function
    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      starting_index i field \

    (( starting_index = current_row * c_fields_count ))

    for (( i = starting_index; i < starting_index + c_fields_count; i++ )); do
      field=${c_fields[$i]}
      local -n ddim=d_${field}
      if [[ "${ddim:-}" ]]; then
        c_data[$i]=$ddim
      else
        c_data[$i]=''
      fi
    done

  end_function
  handle_return
}

write_to_context() {
  local context_type=${context_type:-} new_type=$1 context_file=${context_file:-}
  local -n _content=$2
  begin_function_lo
    if [[ "$context_type" || "$context_file" ]]; then
      if [[ ! "$context_file" ]]; then
        context_file=$context_path-$context_type.new
      fi

      last_type=${last_type:-var}
      if [[ $last_type == fun || $new_type == fun ]]; then
        echo >>$context_file || fail
      fi
      trim_ws _content
      echo "${_content}" >>$context_file || fail
      last_type=$new_type
      eval "$_content" || {
        if [[ "${var_full_path:-}" ]]; then
          log_fatal "Invalid dna file: $var_full_path"
        else
          log_fatal "Invalid dna file. Contents:"
          log_fatal "$_content"
        fi
        fail1
      }
    fi
  end_function
  handle_return
}

# inputs:
#   either context_type or context_file
#   $*    vars to write to context file
write_vars_to_context() {
  local vars_to_write=$* ignore_missing=${ignore_missing:-f}
  begin_function_lo
    local var val quoted_val
    for var in $vars_to_write; do
      local -n val=$var
      local is_set=f
      if is_set val; then
        set_to_string val quoted_val
        is_set=t
      elif is_array val; then
        array_to_string val quoted_val
      elif [[ $ignore_missing == t && ! -v $var ]]; then
        continue
      else
        local quoted_val=${val:-}
        shell_quote_var quoted_val
      fi
      local content="$var=$quoted_val"
      if [[ $is_set == t ]]; then
        content="declare -Ag $content"
      fi
      write_to_context var content || fail
    done; maybe_break
  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_fun_to_code() {
  local full_path=$1 content name=$2
  begin_function_lo
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" =~ ^[a-zA-Z_]+\(\) ]]; then
      code="$content"
    else
      #  can't indent the code because it may contain multiline strings, which this would corrupt
      #content=$(echo -n "$content" | sed 's/^/    /')
      level=_lo
      if [[ $name == update_op ]]; then
        level=
      fi
      code="$name() {
begin_function$level
$content
end_function
handle_return
}"
    fi

  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_var_to_code() {
  local full_path=$1 name=$2 content append=f
  begin_function_lo

    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    if [[ "$content" != [\"\']* ]]; then
      shell_quote_var content
    fi

    if [[ $append == t ]]; then
      append_vars[$name]=1
      code="$name+=$content"
    else
      code="$name=$content"
    fi

  end_function
  handle_return
}

# will skip empty / whitespace lines
load_arr_to_code() {
  begin_function_lo

    local full_path=$1 content name=$2 append=f
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    code="$name"
    if [[ $append == t ]]; then
      append_vars[$name]=1
      code+="+=("
    else
      code+="=("
    fi

    while IFS= read -r line || [[ "$line" ]]; do
      trim_ws line
      if [[ "$line" ]]; then
        if [[ "$line" != [\"\']* ]]; then
          shell_quote_var line
        fi
        code+=" $line" || fail
      fi
    done < <(echo -n "$content")

    code+=" )"

  end_function
  handle_return
}

# inputs:
#   table     name of table variable prefix
#   ignore_unknown_dims
# outputs:
#   ${table}_index_${field}   map of field value to spaced array of row indexes
make_table_index() {

  local table=$table ignore_unknown_dims=${ignore_unknown_dims:-f}
  begin_function
    local row_index \
      field_index \
      data_offset \
      field \
      value \
      values \
      row_count \

    local -n table_fields=${table}_fields \
      table_data=${table}_data \

    if [[ ! -v table_fields ]]; then
      log_fatal "Internal error: Table not defined: $table"
      fail1
    fi

    local \
      field_count=${#table_fields[*]} \
      data_count=${#table_data[*]} \

    if (( field_count == 0 )); then
      log_warn "Internal warning: make_table_index called on a table with no fields."
      succeed
    fi

    (( row_count = data_count / field_count ))

    begin_for (( field_index = 0; field_index < field_count; field_index++ )); doo

      field=${table_fields[$field_index]}

      if [[ -v all_dims[$field] ]]; then

        local -n index=${table}_index_${field}

        unset index
        eval "declare -gA ${table}_index_${field}=()"

        begin_for (( row_index = 0; row_index < row_count; row_index++ )); doo

          (( data_offset = row_index * field_count + field_index ))
          value=${table_data[$data_offset]}

          values=()

          dim=$field \
          ignore_problems=t \
          expand_dim || fail

          for value in "${values[@]}"; do
            index[$value]+="$row_index "
          done

        end_for

      elif [[ $ignore_unknown_dims == f ]]; then
        log_fatal "Unknown dim found in derive table $table: $field"
        fail1
      fi

    end_for

  end_function
  handle_return
}

# inputs:
#   name
load_derive_table_keys() {
  begin_function

    local -n table_fields=derive_table_${name}_fields \
      table_data=derive_table_${name}_data \
      key_fields=derive_table_${name}_key_fields \

    local field_count=${#table_fields[*]} \
      data_count=${#table_data[*]} \
      field_index field row_count \

    (( row_count = data_count / field_count ))

    for (( field_index = 0; field_index < field_count; field_index++ )); do

      field=${table_fields[$field_index]}

      local -n index=derive_table_${name}_index_${field}

      if [[ ! "${index[*]:-}" ]]; then
        log_warn "Internal error: index missing from derive_table ${name} field ${field}"
        continue
      fi

      local card=${#index[*]}
      if (( card == row_count )); then
        local -n key_tables=dim_${field}_key_tables

        key_tables+="$name "
        key_fields+="$field "
      fi

      #local -n card_table=dim_${field}_card_table

      #if [[ -v card_table ]]; then
      #  local -n old_index=derive_table_${card_table}_index_${field}
      #  local old_card=${#old_index[*]}
      #  if (( card > old_card )); then
      #    card_table=$name
      #  fi
      #else
      #  card_table=$name
      #fi

      local -n dim_derive_tables=dim_${field}_derive_tables
      if [[ ! "${dim_derive_tables:-}" || " ${dim_derive_tables[*]} " != *" $name "* ]]; then
        dim_derive_tables+=( $name )
      fi

    done

    write_vars_to_context derive_table_${name}_key_fields || fail

  end_function
  handle_return
}

init_context() {
  begin_function

    # required_freshness:
    #   inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
    #   1w means refresh if it's older than a week.
    # shuffle_chance:
    #   chance out of 1000 of not following the computed strategy order
    # min_pause:
    #   number of ms to wait between cycles
    #   this number doubles each time there is nothing to do, until it reaches max_pause
    # reuse_existing_out:
    #   if set to t: 
    #   new output folder won't be created when updating, but the existing one will be used
    #   should set to true when creating a new output folder would be expensive
    #   these cells must detect for themselves whether a change has happened in an
    #     update and set something_changed=t accordingly. 

    # need to make sure that expand functions don't bleed into sub command execution

    unset -n ${!dim_*} \
      ${!derive_table*} \
      ${!derive_function*} \
      ${!branch_coordinate_*} \
      ${!leaf_coordinate_*} \
      ${!sub_coordinate_*} \
      ${!tree_coordinate_*} \
      ${!i_*} \
      ${!validator*} \

    unset ${!dim_*} \
      ${!derive_table*} \
      ${!derive_function*} \
      ${!branch_coordinate_*} \
      ${!leaf_coordinate_*} \
      ${!sub_coordinate_*} \
      ${!tree_coordinate_*} \
      ${!i_*} \
      ${!validator*} \

    declare -Ag all_dims=() \
      dim_shorts=() \
      required_dims=() \

    auto_loads=() \
    cell_expiration= \
    cell_is_leaf= \
    cell_is_outdated=t \
    cell_is_trunk= \
    check_op_var=f \
    child_dims=() \
    control_props=() \
    control_props_expanded=() \
    current_pause=250 \
    data_props=() \
    data_props_expanded=() \
    default_anchor_dims= \
    default_freshness= \
    default_strategies=crl \
    derive_caches= \
    dim_caches= \
    dim_max_distance=${dim_max_distance:-50} \
    dim_parameters= \
    implicit_dims=() \
    key_path= \
    localize_dims= \
    localize_reverse_dims= \
    lock_timeout=2 \
    max_attempts=1 \
    max_pause=60000 \
    min_pause=250 \
    optional_dims= \
    out_file= \
    out_path= \
    post_validate=t \
    pre_validate=t \
    prev_branch_info_cell= \
    refresh_less_than=${refresh_less_than:-1} \
    related_dims_expanded=() \
    retry_delay=1 \
    retry_delay_max=10 \
    retry_scale=2 \
    reuse_existing_out=t \
    shuffle_chance=100 \
    sub_dims=() \
    sub_dims_expanded=() \
    support_dims_expanded=() \
    support_dims_one_expanded=() \
    trunk_dims=() \
    trunk_dims_expanded=() \
    up=() \
    update_cost=1 \
    update_risk=3 \

    unset \
      check_op \
      update_op \
      get_op \
      aggregate_op \

    context_path=$cyto_path/context \
    context_path=$cyto_path/context \
    down_path=$cyto_path/down \
    job_path=$cyto_path/job \
    req_path=$cyto_path/req \
    status_path=$cyto_path/status \
    tmp_path=$cyto_path/tmp \
    up_path=$cyto_path/up \
    up_chosen_path=$cyto_path/up-chosen \
    reactor_path=$cyto_path/reactors \
    validator_path=$cyto_path/validator \

    lock_path=$context_path \
    replay_path=$job_path/pipe_replay \

  end_function
  handle_return
}

setup_cell_paths() {
  dna_path=$cell_path/.dna
  cyto_path=$cell_path/.cyto
  init_context
}

branch_local_vars='branch_dims branch_members branch_hashes branch_dim_count trunk_cell short_cell prev_branch_info_cell'
load_branch_info() {
  local cell_path=${1:-$cell_path}

  begin_function

    if [[ "${prev_branch_info_cell:-}" == $cell_path ]]; then
      # already loaded
      abort
    fi
    prev_branch_info_cell=$cell_path

    branch_dims=() \
    branch_members=() \
    branch_hashes=() \

    local c=$cell_path p d m
    while [[ $c == *:* ]]; do
      p=${c##*/}
      if [[ $p == *:* ]]; then

        dim=${p%%:*}

        if [[ " ${branch_dims[*]} " == *" $dim "* ]]; then
          log_fatal "Duplicate branch dim found: $dim in $cell_path"
          fail1
        fi

        branch_dims=( $dim ${branch_dims[*]} )

        m=${p#*:}
        branch_hashes=( $m ${branch_hashes[*]} )

        local member_var_path=$c/.member
        if [[ -f $member_var_path ]]; then
          IFS= read -r -d '' m <$member_var_path
        fi
        branch_members=( "$m" "${branch_members[@]}" )

        local -n ddim=d_$dim idim=i_$dim
        ddim=$m
        idim=$m

      fi
      c=${c%/*}
    done

    trunk_cell=$c
    branch_dim_count=${#branch_dims[*]}

    if (( branch_dim_count > 0 )); then
      cell_is_trunk=f
    else
      cell_is_trunk=t
    fi

    if [[ "${branch_dims:-}" ]]; then
      log_debug "Branch dims found: ${branch_dims[*]}"
    fi

    local x y dim_string= 
    if [[ "${branch_hashes:-}" ]]; then
      dim_string="${branch_hashes[*]}"
      dim_string=:${dim_string// /\/}
    fi
    local short_trunk=${trunk_cell#/*/*/}

  end_function
  handle_return
}

execute_command_prep() {
  begin_function

    get_short_cell
    load_branch_info || fail

    trunk_changed=f
    if [[ $trunk_cell != "${previous_trunk:-}" ]]; then
      trunk_changed=t
      previous_trunk=$trunk_cell
    fi

    setup_cell_paths

    if [[ ${during_validation:-f} == t ]]; then
      cell_is_used_for_validation=t
    else
      cell_is_used_for_validation=f
    fi

    unset default_anchor_dims
    if [[ $top_level_command == f ]]; then
      anchor_dims=
    fi

  end_function
  handle_return
}

# inputs:
#   $1    cell_path   should be real path
#   $2... commands
execute_commands() {
  local cell_path=$1; shift
  local cell_commands=( $* ) cell_command
  local log_show_vars='^cell_path cell_commands'
  begin_function

    if [[ "$pause_at_cells" ]]; then
      local pac
      for pac in $pause_at_cells; do
        if [[ "$cell_path" == *"$pac"* ]]; then
          handle_user_interrupt "Cell reached (execute_command): $pac."
        fi
      done
    fi

    local top_level_command=${top_level_command_next:-t}

    # so top_level_command is set to t throughout this function, yet if it's called again, it will
    #   be set to f
    top_level_command_next=f

    eval "local $branch_local_vars" || fail
    local previous_trunk=${previous_trunk:-}
    execute_command_prep || fail

    begin_for cell_command in ${cell_commands[*]}; doo

      local original_cell_command=$cell_command
      substitute_command_alias || fail
      init_command_vars || fail

      if [[ -e $cell_command_path.info ]]; then
        source $cell_command_path.info || fail
        handle_questions || fail
      else
        log_warn "Missing file $cell_command_path.info"
      fi

      if [[ ! -d $cell_path/.dna && $command_requires_cell == t ]]; then

        if [[ $top_level_command == t ]]; then
          log_warn "Skipping $cell_path because it is not a cell"
        else
          log_verbose "Skipping $cell_path because it is not a cell"
        fi

      else

        if [[ -e $cell_command_path ]]; then
          source $cell_command_path || fail
        else
          log_fatal "Internal error: Missing $cell_command command in $cell_command_path"
          fail1
        fi

        validate_command_parameters || fail
        execute_command $cell_path $cell_command || fail

        if [[ $command_modifies_context == t \
           || $command_modifies_upstream == t ]]; then
          # make sure cell rebuilds context next time it's updated
          if [[ -e $context_path ]]; then
            rm $context_path* || fail
          fi
        fi

        if [[ $command_modifies_upstream == t ]]; then
          if [[ -e $up_path ]]; then
            rm -rf $up_path || fail
          fi
          if [[ -e $validator_path ]]; then
            rm -rf $validator_path || fail
          fi
          if [[ -e $up_chosen_path ]]; then
            rm -rf $up_chosen_path || fail
          fi
        fi

      fi

    end_for

  end_function
  handle_return
}

load_dna_contents_update_cell() {
  local file=$1 original_cell_path=$cell_path cell_path work_path
  begin_function

    local bottom_cell cell_path parent=${file%/*}
    if [[ ! -d "$parent" ]]; then
      ignore_nonexistent=t plant_seed $parent || fail
      cell_path=$work_path
    else
      get_bottom_cell $parent
      if [[ ! "$bottom_cell" ]]; then
        log_fatal "Could not find cell for $file"
        fail1
      fi
      cell_path=$bottom_cell
    fi
    local short_cell
    get_short_cell

    if [[ " ${command_history:-}" == *" update $short_cell "* ]]; then
      # can't update a cell we are already updating
      abort
    fi

    needs_update= \
    fork execute_commands "$cell_path" update || fail

    if [[ ! -f "$file" ]]; then
      log_fatal "Cell $short_cell did not produce file at $file as required by dna of $original_cell_path"
      fail1
    fi

  end_function
  handle_return
}

# this duplicates code from write_dna_tab_to_context on purpose for performance reasons
# inputs:
#   $1     full path to tab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
load_dna_tab() {

  begin_function_lo
    local full_path=$1 name=$2

    # must not indent data in case it's a multi-line string
    eval "$(
    awk '
    NR == 1 { print "'$name'_fields=( " $0 " )"; print "'$name'_data=(" }
    NR > 1 { print $0 }
    END { print ")" }
    ' $full_path
    )" || fail

  end_function
  handle_return
}

# this duplicates code from write_dna_vtab_to_context on purpose for performance reasons
# inputs:
#   $1     full path to vtab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
load_dna_vtab() {

  begin_function_lo
    local full_path=$1 name=$2

    local -n fields=${name}_fields data=${name}_data

    fields=( $(awk '{ print $1 }' $full_path) ) || fail
    local field_count=${#fields[*]}
    eval "local array=( $(<$full_path) )" || fail

    local row_offset col_offset data_index array_index current_field_index=0 \
      col_count=$(( ${#array[*]} / field_count )) \

    for (( row_offset = 0; row_offset < ${#array[*]}; row_offset += col_count )); do
      if [[ "${array[$row_offset]}" != ${fields[$current_field_index]} ]]; then
        log_fatal "Bad data in file $full_path around line $current_field_index"
        fail1
      fi

      for (( col_offset = 1; col_offset < col_count; col_offset++ )); do
        (( array_index = row_offset + col_offset )) || true
        (( data_index = ( col_offset - 1 ) * field_count + current_field_index ))
        data[$data_index]=${array[$array_index]}
      done

      (( current_field_index++ )) || true
    done; maybe_break

  end_function
  handle_return
}

# Will load the given derive table if not already loaded
# Will not load indexes (those should have already been loaded from the table cache)
# Will not calculate cardinality or key fields
load_derive_table() {
  local name=$1
  begin_function

  local -n derive_table_data=derive_table_${name}_data

  if [[ ! -v derive_table_data ]]; then

    log_debug "Loading derive table $name"
    local -n dtp=derive_table_${name}_path

    if [[ ! -v dtp ]]; then
      log_fatal "Internal error: Missing derive table path for $name."
      fail1
    fi

    if [[ -L $dtp && ! -f $dtp ]]; then
      log_fatal "Broken link: $dtp"
      fail1
    fi

    local type=${dtp##*.}
    if [[ $type == tab ]]; then
      load_dna_tab $dtp derive_table_$name || fail
    else
      load_dna_vtab $dtp derive_table_$name || fail
    fi

  fi

  end_function
  handle_return
}

# inputs:
#   name        name of derive table
#   cache_path
# outputs:
#   dim_*_derive_from
tab_get_derive_from() {
  begin_function

    local -n derive_table_fields=derive_table_${name}_fields \
      derive_table_data=derive_table_${name}_data \
      key_fields=derive_table_${name}_key_fields \

    local field_count=${#derive_table_fields[*]} \
      data_count=${#derive_table_data[*]} \
      row_count index_card \
      other_fields \
      field_index field \
      key_field \
      other_field \
      other_field \
      other_index \
      other_index_card \
      join \
      join2 \
      is_key \

    (( row_count = data_count / field_count ))

    for (( field_index = 0; field_index < field_count; field_index++ )); do
      field=${derive_table_fields[$field_index]}

      local -n index=derive_table_${name}_index_$field \
        derive_from=dim_${field}_derived_from \

      index_card=${#index[*]}
      if (( index_card == row_count )); then
        join=one-
        is_key=t
      else
        join=many-
        is_key=f
      fi

      other_fields="${derive_table_fields[*]}"
      remove_word_from_string other_fields $field

      join2=to-many
      for other_field in $other_fields; do
        if [[ " $key_fields " == *" $other_field "* ]]; then
          join2=to-one
          break
        fi
      done

      derive_from+=( "$name.tab $join$join2 $other_fields" )

    done

  end_function
  handle_return
}

# not handling failure here for performance reasons
# should be nearly impossible to fail at this point anyway
maybe_write_newline_to_context() {
  local new_type=$1
  last_type=${last_type:-none}
  if [[ $last_type != none ]]; then
    if [[ $last_type == fun || $new_type == fun \
       || $last_type == tab || $new_type == tab \
       ]]; then
      echo >>$context_path-$context_type.new
    fi
  fi
  last_type=$new_type
}

# inputs:
#   $1            full path to vtab file. It is assumed existence check has already happened.
#   $2            target var to store data in (includes prefix)
#   context_type
#   context_file
write_dna_vtab_to_context() {

  begin_function_lo
    local full_path=$1 name=$2

    load_dna_vtab $full_path $name
    local array_assignment

    make_array_assignment ${name}_fields || fail
    write_to_context var array_assignment || fail

    if [[ $name == *_derive ]]; then
      eval "$array_assignment" || fail
    fi

    make_array_assignment ${name}_data || fail
    write_to_context var array_assignment || fail

  end_function
  handle_return
}

# inputs:
#   $1            full path to tab file. It is assumed existence check has already happened.
#   $2            target var to store data in (includes prefix)
#   context_file
write_dna_tab_to_context() {

  begin_function_lo
    local full_path=$1 name=$2

    maybe_write_newline_to_context tab
    local content
    content=$(
      awk '
      NR == 1 { print "'$name'_fields=( " $0 " )"; print "'$name'_data=(" }
      NR > 1 { print "  " $0 }
      END { print ")" }
      ' $full_path
    ) || fail

    echo "$content" >>$context_file || fail

  end_function
  handle_return
}

# usage: split_ordinal {from_var} {ordinal_part_var} {base_part_var}
split_ordinal() {
  local -n _f=$1 _o=$2 _b=$3
  if [[ $_f =~ ^([0-9]+)-([^/]*)$ ]]; then
    _o=${BASH_REMATCH[1]}
    _b=${BASH_REMATCH[2]}
  else
    _o=9999
    _b=$_f
  fi
  debug_return_vars="$2 $3"
}

# usage: get_simple_name {from var} {ordinal var} {to var}
extract_simple_name() {
  local to_var=$3
  local -n _from=$1 _ord=$2 _to=$to_var
  split_ordinal _from _ord _to
  debug_return_vars=$to_var
}

# usage: get_simple_name {from array} {to array}
extract_simple_name_across_array() {
  local -n _from=$1 _to=$2
  local o i f t
  for (( i = 0; i < ${#_from[*]}; i++ )); do
    f=${_from[$i]}
    extract_simple_name f o t
    _to[$i]=$t
  done
  return 0
}

auto_load_tab_vars() {
  local var_name=$var_name
  begin_function
    local -n fields=${var_name}_fields data=${var_name}_data

    local field_count=${#fields[*]} \
      data_count=${#data[*]} \
      field i expression \

    if (( data_count == field_count )); then
      for (( i = 0; i < data_count; i++ )); do
        field=${fields[$i]}
        value=${data[$i]}
        shell_quote_var value
        expression="$prefix$field=$value"
        eval "$expression" || {
          log_fail "Internal error evaluating tab expression: $expression"
          fail1
          }
      done
    fi
  end_function
  handle_return
}

# inputs:
#   $1                  full path to dna file
#   prefix              optional prefix
#   context_type        if empty, only loads the variable, if set, records to context
#   context_file
#   auto_load_tab_vars  if set to 't', and a table is loaded with only one row, the fields of that row get loaded as variables also
load_dna_item() {
  begin_function
    local var_full_path=$1 prefix=${prefix:-} \
      suffix= \
      file_name \
      context_file=${context_file:-} \
      context_type=${context_type:-} \
      auto_load_tab_vars=${auto_load_tab_vars:-f} \

    if [[ ! "$context_file" && $context_type ]]; then
      context_file=$context_path-$context_type.new
    fi

    last_type=${last_type:-var}

    file_name=${var_full_path##*/}
    if [[ $file_name == *.* ]]; then
      suffix=${file_name##*.}
      file_name=${file_name%.*}
    fi

    local var_name o code= load_type=var is_auto=f
    extract_simple_name file_name o var_name

    #if [[ $var_name == auto-* ]]; then
    #  is_auto=t
    #  var_name=${var_name#auto-}
    #fi

    #if [[ $is_auto == t ]]; then
    #  auto_loads+=( $var_name.$suffix )
    #fi

    var_name=${var_name//-/_}
    var_name=$prefix$var_name

    case "$suffix" in
      var)
        load_var_to_code $var_full_path $var_name || fail
      ;;
      arr)
        load_arr_to_code $var_full_path $var_name || fail
      ;;
      fun)
        load_fun_to_code $var_full_path $var_name || fail
        load_type=fun
      ;;
      tab)
        if [[ "${context_type:-}" ]]; then
          write_dna_tab_to_context $var_full_path $var_name || fail
        else
          load_dna_tab $var_full_path $var_name || fail
          if [[ $auto_load_tab_vars == t ]]; then
            auto_load_tab_vars || fail
          fi
        fi
      ;;
      vtab)
        if [[ "${context_type:-}" ]]; then
          write_dna_vtab_to_context $var_full_path $var_name || fail
        else
          load_dna_vtab $var_full_path $var_name || fail
          if [[ $auto_load_tab_vars == t ]]; then
            auto_load_tab_vars || fail
          fi
        fi
      ;;
      *)
        if [[ $ignore_unknown == f ]]; then
          log_fatal "Unknown dna object: $item."
          fail1
        fi
      ;;
    esac

    if [[ "$code" ]]; then
      if [[ "${context_type:-}${context_file:-}" ]]; then
        write_to_context $load_type code || fail
      else
        eval "$code" || fail
      fi
    fi

  end_function
  handle_return
}

make_array_assignment() {
  local arr_name=$1 append=${append:-f}
  local -n arr=${2:-$1}
  begin_function_lo
    if [[ $append == t ]]; then
      array_assignment="$arr_name+=("
    else
      array_assignment="$arr_name=("
    fi
    local v
    for v in "${arr[@]}"; do
      shell_quote_var v
      array_assignment+=" $v"
    done
    array_assignment+=" )"
  end_function
  debug_return_vars=array_assignment
  handle_return
}

# finds the nearest ancestor of the given path which has .dna in it
# will set bottom_cell, which will be empty if no cell cells are found
get_bottom_cell() {
  local subject=$1
  bottom_cell=
  if [[ $subject == /seed/* ]]; then
    log_fatal "Called get_bottom_cell on a seed path"
    return 1
  fi
  while [[ -d "$subject" && "$subject" == /*/* ]]; do
    if [[ -e $subject/.dna ]]; then
      bottom_cell=$subject
      break
    fi
    subject=${subject%/*}
  done
  debug_return_vars=bottom_cell
  return 0
}

build_context_expand_find_members() {
  begin_function

    local branch other_found=f member_paths
    member_paths=$(find1 $seed_path -name "$dim:*" -type d | sort -g) || fail

    for branch in $member_paths; do
      m=${branch##*/*:}
      if [[ $m == all ]]; then
        log_fatal "Should not have an all as a dim member: $branch"
        fail1
      elif [[ $m == _other ]]; then
        other_found=t
      else
        local member_var_path=$branch/.member
        if [[ -f $member_var_path ]]; then
          m=$(<$member_var_path) || fail
        fi
        members+=( "$m" )
      fi
    done; maybe_break

  end_function
  handle_return
}

build_context_expand_handle_default() {
  begin_function_lo

    local -n default=dim_${dim}_default

    if [[ -v default ]]; then

      code+="
    '')
      values=( \"$default\" )
    ;;"

    elif function_exists dim_${dim}_default_function; then

      code+="
    '')
    "
      code+="$(echo "dim_${dim}_default_function" | indent 2)"
      code+="
    ;;"

    else

      code+="
    '')
      problem=\"Missing required parameter: $dim\"
    ;;"

    fi
  end_function
  handle_return
}

build_context_expand_handle_aliases() {
  begin_function_lo
    local a_line first remaining
    for a_line in "${aliases[@]}"; do
      first=${a_line%% *}
      remaining=${a_line#* }
      code+="
    $first)
      _out=( $remaining )
    ;;"
    done
  end_function
  handle_return
}

get_all_values_from_derive_table() {
  local derive_table=$1 output_var=$2
  local -n __out=$output_var \
    index=derive_table_${derive_table}_index_$dim \

  __out=( "${!index[@]}" )
}

value_exists_in_derive_table() {
  local derive_table=$1 value=$2
  local -n index=derive_table_${derive_table}_index_$dim
  [[ -v index["$value"] ]]
}

build_context_expand_members_known() {
  local quoted_members= members_with_pipes=${members[*]} need_quotes=f m
  for m in "${members[@]}"; do
    quoted_members+="\"$m\" "
    if [[ $m == *\ * ]]; then
      need_quotes=t
    fi
  done

  if [[ $need_quotes == f ]]; then
    quoted_members="${members[*]}"
  fi

  local members_with_pipes=${members_with_pipes// /\|}

  code+="
  all)
    _out=( $quoted_members )
  ;;
  $members_with_pipes)
    _out=( \$_in )
  ;;
  *)
    problem=\"Invalid $dim: \$_in\"
  ;;
esac
}"
}

build_context_expand_members() {
  code+="
  all)
    local -n members=dim_${dim}_members
    if [[ -v members ]]; then
      _out=( \"\${members[@]}\" )
    else
      problem=\"Can't use all value for a dynamic dim\"
    fi
  ;;
  *)
    local -n members=dim_${dim}_members \
      member_type=dim_${dim}_member_type \

    if [[ -v members ]] && array_contains members \$_in; then
      _out=( \"\$_in\" )
    elif [[ ! -v member_type || \$member_type == dynamic ]]; then
      _out=( \"\$_in\" )
    else
      problem=\"Invalid dim member for $dim: \$_in\"
    fi
  ;;
esac
}"
}

# inputs:
#   dim
# outputs:
#   code
build_context_expand() {
  begin_function

    local fun

    local -n aliases=dim_${dim}_aliases

    code="dim_${dim}_expand() {
  local -n _in=\${1:-value} _out=\${2:-values}
  problem=
  case \"\$_in\" in"

    build_context_expand_handle_default || fail

    if [[ -v aliases ]]; then
      build_context_expand_handle_aliases || fail
    fi

    build_context_expand_members || fail

    write_to_context fun code || fail

  end_function
  handle_return
}

# inputs:
#   table
#   context_file      path to target file
write_index_to_context() {
  begin_function

    local value field_index data_offset row_index field

    local -n c_data=${table}_data \
      c_fields=${table}_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    for (( field_index = 0; field_index < c_fields_count; field_index++ )); do

      field=${c_fields[$field_index]}
      local -n table_index=${table}_index_${field}
      if [[ ! "${!table_index[*]}" ]]; then
        log_fatal "Internal error: Missing index ${table}_index_${field}"
        fail1
      fi

      echo "declare -Ag ${table}_index_${field}=(" >>$context_file || fail

      local k v
      for k in "${!table_index[@]}"; do
        v=${table_index[$k]}
        echo "  ['$k']='${v% }'" >>$context_file || fail
      done

      echo ")$NL" >>$context_file || fail

    done

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more sub coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_shell_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    echo "${coord_type}_coordinate_fields=( ${c_fields[*]} )" >$target_file || fail
    echo "${coord_type}_coordinate_data=(" >>$target_file || fail

    local line=
    for (( row_index = 0; row_index < c_rows; row_index++ )); do

      line="  "

      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        fi
      done

      echo "${line% }" >>$target_file || fail

    done

    echo ")$NL" >>$target_file || fail


    table=${coord_type}_coordinate \
    context_file=$target_file \
    write_index_to_context || fail

  end_function
  handle_return
}

display_coordinates_vertical() {
  begin_function
    for (( row_index = 0; row_index < c_rows; row_index++ )); do
      echo "$hbar_minus" >&$fd_original_err
      echo "ROW $row_index" >&$fd_original_err
      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          echo "${field^^}: $value" >&$fd_original_err
        fi
      done
    done
  end_function
  handle_return
}

display_coordinates_horizontal() {
  begin_function
    local line=

    for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
      field=${c_fields[$field_index]}
      if [[ " $skip_dims " != *" $field "* ]]; then
        apad line $field "${field^^}  "
      fi
    done
    echo "$line" >&$fd_original_err || fail

    for (( row_index = 0; row_index < c_rows; row_index++ )); do
      line=
      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          apad line $field "$value  "
        fi
      done

      echo "$line" >&$fd_original_err || fail
    done
  end_function
  handle_return
}

# displays $coord_type coords to the user, skipping dims specified in skip_dims
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
display_coordinates() {
  local coord_type=$coord_type skip_dims=${skip_dims:-}
  begin_function

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "No $coord_type coordinates found"
      fail1
    fi

    apad_clear
    for (( row_index = 0; row_index < c_rows; row_index++ )); do
      line=
      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          apad_calc $field "$value  "
        fi
      done
    done

    local max_row_width=0 col_size
    for col_size in ${apad_size[*]}; do
      (( max_row_width += col_size ))
    done

    if (( max_row_width > ${COLUMNS:-120} )) \
    || [[ "${out_form:-${form:-}}" == l* ]]; then
      display_coordinates_vertical || fail
    else
      display_coordinates_horizontal || fail
    fi

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_tab_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    local line=

    for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
      field=${c_fields[$field_index]}
      if [[ " $skip_dims " != *" $field "* ]]; then
        line+="$field "
      fi
    done
    echo "${line% }" >>$target_file || fail

    for (( row_index = 0; row_index < c_rows; row_index++ )); do
      line=
      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        fi
      done

      echo "${line% }" >>$target_file || fail
    done

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more sub coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_vtab_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    local line

    for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
      field=${c_fields[$field_index]}
      line=
      if [[ " $skip_dims " != *" $field "* ]]; then
        line+="$field "
        for (( row_index = 0; row_index < c_rows; row_index++ )); do
          (( data_offset = row_index * c_fields_count + field_index ))
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        done
      fi
      echo "${line% }" >>$target_file || fail
    done; maybe_break

  end_function
  handle_return
}

# initialized coordinates with a table to speed up coordinate calculation
#   of all possibilities
# won't work if coordinates already has data
# inputs:
#   coord_type: which coordinates to load
#   seed_table: defaults to auto, which will just choose the largest available table
seed_coordinates() {
  local seed_table=${seed_table:-auto} \
    coord_type=$coord_type \
    add_implicit_dims=${add_implicit_dims:-f} \
    fill_in_the_blanks=${fill_in_the_blanks:-f} \

  begin_function
    local -n coordinate_data=${coord_type}_coordinate_data \
      coordinate_fields=${coord_type}_coordinate_fields \

    local coordinate_fields_count=0 \
      coordinate_count=0 \
      coordinate_rows=0 \

    log_debug "Seeding $coord_type coordinates with seed table $seed_table"
    seed_coordinates_prep || fail

    local -n seed_fields=${seed_table}_fields \
             seed_data=${seed_table}_data \

    if [[ ! -v seed_fields ]]; then
      log_fatal "Invalid seed table: $seed_table"
      fail1
    fi

    local seed_field_count=${#seed_fields[*]} \
          seed_data_count=${#seed_data[*]} \
          total_coord_rows_added=0 \

    local seed_table_rows=$(( seed_data_count / seed_field_count ))

    target_form=tree \
    setup_coord_fields || fail
    if [[ $add_implicit_dims == t ]]; then
      local f p
      for f in ${seed_fields[*]}; do
        if ! array_contains coordinate_fields $f; then
          coordinate_fields+=( $f )
          (( coordinate_fields_count++ ))
          all_dims[$f]=1
          get_plural $f p
          localize_dims+=" d_$f d_$p"
        fi
      done
    fi

    if (( coordinate_fields_count <= 1 )); then
      log_debug "Too few fields found ($coordinate_fields_count) to generate useful $coord_type seed coords"
      abort
    fi

    local row_index field_index seed_field seed_data_index \
      new_coordinate_data=() \

    local -n \
      field_count=seed_field_count \
      table_fields=seed_fields \
      table_data=seed_data \

    begin_for (( row_index = 0; row_index < seed_table_rows; row_index++ )); doo
      seed_coordinates_handle_row || fail
    end_for

    coordinate_data=( "${new_coordinate_data[@]}" )
    (( coordinate_count = ${#coordinate_data[*]} ))
    (( coordinate_rows = coordinate_count / coordinate_fields_count ))

    if (( coordinate_rows > 1 )); then
      calc_coordinates_dedup || fail
    fi

  end_function
  handle_return
}

# Adds the branch coords (from existing dims) to the given table file
append_coords_to_file() {
  local from=$1 to=$2 coord_type=$coord_type fill_in_the_blanks=${fill_in_the_blanks:-f}
  begin_function
    log_debug "Appending $coord_type coordinates to $to from $from"
    local old_table type=${to##*.}

    case $type in
      tab)
        load_dna_tab $from old_table || fail
      ;;
      vtab)
        load_dna_vtab $from old_table || fail
      ;;
      *)
        log_fatal "Invalid file type for append_coords_to_file: $type"
        fail1
      ;;
    esac

    seed_table=old_table \
    add_implicit_dims=t \
    seed_coordinates || fail

    if [[ -e $to ]]; then
      rm $to || fail
    fi

    case $type in
      tab)
        write_coordinates_to_tab_file $to || fail
      ;;
      vtab)
        write_coordinates_to_vtab_file $to || fail
      ;;
    esac

  end_function
  handle_return
}

get_plural() {
  local dim=$1
  local target_var=${2:-plural}
  local -n target=$target_var
  if [[ $dim == *s ]]; then
    target=${dim}es
  elif [[ $dim == *y && ! $dim =~ [aeiou]y$ ]]; then
    target=${dim%y}ies
  else
    target=${dim}s
  fi
  debug_return_vars=$target_var
  return 0
}

# inputs:
#   table                  variable name containing the table, without _fields or _data
#   row_index              defaults to 0
#   target_dim_var_type    one of: sdims ddims sdim ddim
# will load nothing if the given row_index doesn't exist in the given table
convert_table_to_dims() {
  local table=$table row_index=${row_index:-0} \
    target_dim_var_type=$target_dim_var_type \

  begin_function

    local field fields field_index values=() count field_count data_offset

    local -n c_fields=${table}_fields \
             c_data=${table}_data \

    if [[ ! -v c_fields ]]; then
      log_warn "Internal warning: convert_table_to_dims run on table with no fields"
      abort
    fi

    local c_fields_count=${#c_fields[*]} \

    local c_data_count=0
    if [[ -v c_data ]]; then
      c_data_count=${#c_data[*]}
    fi

    if (( c_data_count >= c_fields_count * (row_index + 1) )); then

      local value
      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        field=${c_fields[$field_index]}

        get_plural $field fields

        local -n sdim=s_$field sdims=s_$fields ddim=d_$field ddims=d_$fields

        (( data_offset = c_fields_count * row_index + field_index ))
        value=${c_data[$data_offset]}

        if [[ "$value" ]]; then

          if [[ "$value" == $empty_member ]]; then
            value=
          fi

          case $target_dim_var_type in 
            sdims)
              sdims=$value
              unset sdim ddim ddims
            ;;
            ddims)
              ddims=$value
              unset sdim sdims ddim
            ;;
            sdim)
              sdim=$value
              unset sdims ddim ddims
            ;;
            ddim)
              ddim=$value
              unset sdim sdims ddims
            ;;
            *)
              log_fatal "Invalid target_dim_var_type: $target_dim_var_type"
              fail1
            ;;
          esac

        fi

      done; maybe_break

    fi

  end_function
  handle_return
}

# input: 
#   dim
#   $1               name of input var
#   $2               name of output var
#   ignore_problems
# output: values 
expand_dim() {
  local in_var=${1:-value} out_var=${2:-values} \
    ignore_problems=${ignore_problems:-f} \

  begin_function_lo

    if [[ "${!in_var:-}" && "${!in_var}" != \? ]]; then

      if ! function_exists dim_${dim}_expand; then
        log_fatal "Missing expand function for $dim"
        fail1
      fi

      local problem
      dim_${dim}_expand $in_var $out_var || fail
      if [[ "${problem:-}" ]]; then
        if [[ $ignore_problems == t ]]; then
          local -n out=$out_var in=$in_var
          out=( "$in" )
        else
          log_fatal "$problem"
          fail1
        fi
      fi

    fi

  end_function
  handle_return
}

# inputs:
#   $1           array var name which contains the members
#   dim_var      dim being expanded
# outputs:
#   new_values   array of expanded members
expand_dim_members() {
  local -n _members=$1
  local members=( "${_members[@]}" )
  local value values
  new_values=()
  for value in "${members[@]}"; do
    dim=$dim_var \
    expand_dim value values || return 1
    if [[ "$values" ]]; then
      new_values+=( "${values[@]}" )
    fi
  done
}

# inputs:
#   $*      list of dims to expand
# expands aliases for the known dims array
# collapses singular and plural dims into plural dims
# should only be used after prep_dims, which means 
#   all dims should be stored in sdim/sdims or ddim/ddims
#   plural dims should always be arrays, not space separated
# ddim is expanded form of sdim, and takes priority over sdim
# this function will generate ddim/ddims where they are not already set based on sdim/sdims
# this function guaranteeds ddims will be set for all known dims
# ddims will be an array after this function
expand_dims() {
  local to_expand=$*
  begin_function_lo

    local dim_var dim_var plural
    for dim_var in $to_expand; do

      local dims_var
      get_plural $dim_var dims_var
      local -n \
        sdim=s_$dim_var sdims=s_$dims_var \
        ddim=d_$dim_var ddims=d_$dims_var \

      if [[ ! "${ddim:-}" && ! "${ddims:-}" && \
            ( "${sdim:-}" || "${sdims:-}" ) ]]; then

        #log_debug "Expanding dim $dim_var"

        local members single=t
        if [[ "${sdims:-}" ]]; then
          members=( "${sdims[@]}" )
          single=f
        else
          members=( "$sdim" )
        fi

        local value new_values
        expand_dim_members members || fail

        if [[ $single == t ]]; then
          if (( ${#new_values[*]} > 1 )); then
            log_fatal "Too many values for $dim_var: ${new_values[*]}"
            fail1
          fi
        fi

        if (( ${#new_values[*]} == 1 )); then
          ddim=${new_values}
          unset ddims sdim sdims
        else
          ddims=( "${new_values[@]}" )
          unset ddim sdim sdims
        fi

      elif [[ ! "${ddims:-}" ]]; then
        if [[ "${ddim:-}" ]]; then
          unset ddims sdim sdims
        else
          unset ddims ddim sdim sdims
        fi
      fi

    done

  end_function
  handle_return
}

extract_from_derive_table_find_row_indexes() {

  begin_function

    local row_indexes \
      row_index_count \
      column_index \
      field \

    local -A new_matching_rows

    for (( column_index = 0; column_index < field_count; column_index++ )); do
      field=${derive_fields[$column_index]}
      if [[ " $ignore_dims " == *" $field "* ]]; then
        continue
      fi
      local -n dt_index=${full_table}_index_${field}
      if [[ $field == $dim ]]; then
        output_dim_index=$column_index
        local -n member_type=dim_${dim}_member_type
        if [[ $member_type == static ]]; then
          local -n members=dim_${dim}_members
          local member_count=${#members[*]}
          if (( ${#dt_index[*]} != member_count )); then
            complete_table=f
            break
          fi
        fi
      else
        local -n ddim=d_$field
        if [[ "${ddim:-}" ]]; then

          if [[ ! -v dt_index ]]; then
            clear_set new_matching_rows

            if [[ -v dt_index[$ddim] ]]; then
              row_indexes=( ${dt_index[$ddim]} )
              array_to_set row_indexes new_matching_rows
            else
              # table is incomplete for this dim, meaning
              # it doesn't contain all possible values for it
              # so we can't use this table for deriving
              complete_table=f
              log_debug "No rows exist in $full_table for $field = $ddim"
              break
            fi

            if [[ -v dt_index[all] ]]; then
              row_indexes=( ${dt_index[all]} )
              array_to_set row_indexes new_matching_rows
            fi

            intersect_with_all matching_rows new_matching_rows matching_rows

            if (( ${#matching_rows[*]} == 0 )); then
              # Accoridng to the index, no values exist in this table which match the known dim value
              log_debug "Couldn't find any rows in $full_table which match all existing dims (last checked: $field = $ddim)"
              value_set=()
              abort
            fi
          fi

        else # ddim not defined for this field
          #can_derive=f
          #abort

          # let's allow derivation even if we are missing some fields
          :
        fi
      fi
    done

  end_function
  handle_return
}

extract_from_derive_table_check_row() {
  begin_function

    local field value column_index
    for (( column_index = 0; column_index < field_count; column_index++ )); do

      field=${derive_fields[$column_index]}
      value=${derive_data[$((data_index + column_index))]}

      log_show_vars='field value'

      if [[ $field == $dim ]]; then

        if [[ "$value" != all && ${#value_set[*]} -gt 0 && ! "${value_set[$value]:-}" ]]; then
          # don't need to check this row if value isn't in the list of choices
          everything_matches=f
          break
        fi

        if [[ "$value" ]]; then
          row_result=$value
        else
          row_result=$empty_member
        fi

        if [[ $validate_rows == f ]]; then
          break
        fi

      elif [[ " $ignore_dims " != *" $field "* && $validate_rows == t ]]; then

        local -n ddim=d_$field

        if [[ "${ddim:-}" ]]; then
          if [[ "$ddim" != "$value" && "$value" != all && "$ddim" != all ]]; then
            #log_debug "Row doesn't match because dim $field = $ddim but table shows $value"
            everything_matches=f
          fi
        else # ddim not set
          if [[ $strict_matching == t && "$value" && "$value" != all ]]; then
            #log_debug "Row doesn't match because $field is not set"
            everything_matches=f
            break
          fi
        fi

        if [[ $everything_matches == f && -v all_dims[$field] ]]; then
          local expanded_values
          dim=$field expand_dim value expanded_values || fail
          if array_contains expanded_values $ddim; then
            everything_matches=t
          fi
        fi

        if [[ $everything_matches == f ]]; then
          break
        fi

      fi

    done

  end_function
  handle_return
}

# if derive table is incomplete, will not change value_set
# inputs:
#   derive_table            name of var of derive table
#   full_table              auto generated if derive_table is given
#   value_set               starting value set, defaults to all
#   dim
#   ignore_dims
# outputs:
#   value_set               the var out_set points to will contain a set of all matches
extract_from_derive_table() {
  local derive_table=${derive_table:-} full_table=${full_table:-}

  begin_function
      
    rows_matched=0
    local ignore_dims=${ignore_dims:-}

    if [[ ! "$full_table" ]]; then
      if [[ "$derive_table" ]]; then
        full_table=derive_table_${derive_table}
      else
        log_fatal "Internal error: either derive_table or full_table must be specified."
        fail1
      fi
    fi

    local -n derive_fields=${full_table}_fields \
             derive_data=${full_table}_data \

    if [[ ! -v derive_data ]]; then
      log_fatal "Missing derive table data for $full_table"
      fail1
    fi

    local field_count=${#derive_fields[*]} \
      data_count=${#derive_data[*]} \
      data_index \
      value= row_result everything_matches \
      invalid=f \
      row_index \
      output_dim_index \

    local -n index=${full_table}_index_${dim} \
      dim_members=dim_${dim}_members \
      member_type=dim_${dim}_member_type \

    local row_count=$(( data_count / field_count )) \
      complete_table=t \

    local -A matching_rows=() new_value_set=()
    matching_rows[all]=1

    extract_from_derive_table_find_row_indexes
    maybe_break

    if [[ $complete_table == t ]]; then
      if [[ -v matching_rows[all] ]]; then
        add_to_set index new_value_set
      else
        for value in "${!index[@]}"; do
          local row_indexes=${index[$value]}
          for row_index in $row_indexes; do
            if [[ -v matching_rows[$row_index] ]]; then
              new_value_set[$value]=1
            fi
          done
        done
      fi

      rows_matched=${#new_value_set[*]}

      if [[ ! "${value_set[*]}" ]]; then
        add_to_set new_value_set value_set
      else
        intersect_with_all value_set new_value_set value_set
      fi
    fi

    debug_return_vars=value_set
  end_function
  handle_return
}

fetch_column_from_table() {

  local table_var=$table_var field=$field
  local -n table_data=${table_var}_data \
    table_fields=${table_var}_fields \

  local field_count=${#table_fields[*]} \
    data_count=${#table_data[*]} \
    data_index \
    value= field \
    found=f \

  for (( data_index = 0; data_index < field_count; data_index++ )); do
    if [[ ${table_fields[$data_index]} == $field ]]; then
      found=t
      break
    fi
  done

  if [[ $found == f ]]; then
    log_fatal "Internal error: Table $table_var doesn't contain field $field"
    return 1
  fi

  for (( ; data_index < data_count; data_index += field_count )); do
    values+=( "${table_data[$data_index]}" )
  done

  return 0

}

narrow_dim_fun() {
  begin_function
    local derived_from_dim all_dims_are_set=t
    local f_name=derive_function_$derive_fun
    local action=check values=() can_derive=f target_dim=$dim
    $f_name || fail
    if [[ $can_derive == t ]]; then
      action=derive
      derive_found=t
      $f_name || fail
      local -A new_values=()

      local field i value
      for (( i = 0; i < ${#fields[*]}; i++ )); do
        field=${fields[$i]}
        if [[ $field == $dim ]]; then
          value=${values[$i]}
          if [[ "$value" ]]; then
            new_values[$value]=1
          fi
          break
        fi
      done
      intersect_with_all new_values value_set value_set
    fi
  end_function
  handle_return
}

# inputs:
#   dim          
#   result_var   name of array variable containing members
# outputs:
#   (result_var) array variable
#   derive_found
narrow_dim() {
  local dim=$dim result_var=$result_var
  local -n result=$result_var
  begin_function
    log_debug "Narrowing down $dim"
    local -n derived_from=dim_${dim}_derived_from

    local row type target row_array \
      original_count=${#result[*]} new_count \
      original_first=${result:-} \

    local -A value_set=()
    array_to_set result value_set

    begin_for derived_from_row in "${derived_from[@]}"; doo
      row_array=( $derived_from_row )
      target=$row_array
      type=${target##*.}
      case $type in
        fun)
          local derive_fun=${target%.*}
          narrow_dim_fun || fail
        ;;
        tab)
          local derive_table=${target%.*}
          derive_found=t
          extract_from_derive_table || fail
        ;;
        *)
          log_fatal "Unknown derived_from type: $type"
          fail1
        ;;
      esac
      if (( ${#value_set[*]} == 0 )); then
        break
      fi
    end_for

    set_to_array value_set result
    if (( ${#result[*]} > 1 )); then
      sort_array result
    fi

    new_count=${#result[*]}
    if [[ $new_count != $original_count || "$original_first" != $result ]]; then
      local from=$original_count
      if [[ "$original_first" == all ]]; then
        from=all
      fi
      log_debug "Narrowed down $dim from $from to $new_count"
    fi

  end_function
  handle_return
}

# inputs:
#   dim 
#   from_dim        optional, will only look for ways to derive 'dim' from 'from_dim'
#   deriving        list of dims we are in the process of deriving, to avoid infinite loops
#   skip_dims       should be set to blank when starting. Is use to avoid failing to derive the same
#                   dim multiple times.
# output:
#   values          array of members
#   derive_found    whether a derive function or derive table exists for the given dim
attempt_derive() {

  local from_dim=${from_dim:-} \
    old_values_string=${old_values_string:-} \
    stop_after_first_match=${stop_after_first_match:-f} \
    deriving=${deriving:-} \
    derive_deep=${derive_deep:-t} \
    derive_exactly_one=${derive_exactly_one:-t} \

  log_show_vars='dim from_dim'
  begin_function

    local -n derived_from=dim_${dim}_derived_from
    values=( all )

    if [[ " $deriving " == *" $dim "* || -v derive_tried[$dim] ]]; then
      abort
    fi
    deriving+="$dim "
    derive_tried[$dim]=1
    derive_found=f

    if [[ "${derived_from:-}" ]]; then
      result_var=values \
      narrow_dim || fail
    fi

    if [[ $values == all ]]; then
      values=()
    fi

    if [[ $derive_exactly_one == t && ${#values[*]} -gt 1 ]]; then
      log_debug "Derive of $dim failed, too many possibilities"
      values=()
    elif [[ ! "${values:-}" ]]; then
      log_debug "Derive of $dim failed, no possibilities found"
    else
      log_debug "Derive of $dim successful: ${values[*]:0:30}"
    fi

  end_function
  handle_return
}

alias localize='[[ "${localize_dims:-}" ]] && eval "local -I $localize_dims"'

fetch_values_from_coordinates2_row() {
  begin_function_lo

    localize

    table=${coord_type}_coordinate \
    target_dim_var_type=ddim \
    convert_table_to_dims || fail

    local -n ddim=d_$dim
    if [[ -v ddim ]]; then
      new_values[$ddim]=1
    else
      #local -A derive_tried=()
      #value_found=f
      #skip_dims= \
      #attempt_derive || fail

      #if [[ $value_found == t ]]; then
      #  local value
      #  for value in "${values[@]}"; do
      #    new_values[$value]=1
      #  done
      #else
        log_fatal "Could not extract dim $dim from ${coord_type}_coordinate table at row $row_index"
        fail1
      #fi
    fi

  end_function
  handle_return
}

fetch_values_from_coordinates2() {
  begin_function
    
    local -n table_data=${table_var}_data
    local data_count=${#table_data[*]} \
      field_count=${#table_fields[*]} \

    local -A new_values=()

    local row_count=$(( data_count / field_count ))
    for (( row_index = 0; row_index < row_count; row_index++ )); do
      fetch_values_from_coordinates2_row || fail
    done

    values=( "${!new_values[@]}" )
    sort_array values

  end_function
  handle_return
}

# inputs:
#   dim
#   coord_type
# outputs:
#   values      array of dim members
fetch_values_from_coordinates() {
  local coord_type=$coord_type
  begin_function
    values=()
    local table_var=${coord_type}_coordinate
    local -n table_fields=${table_var}_fields

    if [[ " ${table_fields[*]} " == *" $dim "* ]]; then
      field=$dim \
      fetch_column_from_table || fail
    else
      fetch_values_from_coordinates2 || fail
    fi

    if [[ "${values:-}" != *"$NL"* ]]; then
      sort_array values
    fi

    if [[ "${values[*]:-}" ]]; then
      log_debug "$dim fetched from coordinates: ${values[*]}"
    else
      log_debug "Failed to fetch $dim from coordinates"
    fi
  end_function
  handle_return
}

prep_dims() {
  begin_function

    local dim_var dims_var
    for dim_var in ${!all_dims[*]}; do

      get_plural $dim_var dims_var

      # p_dims are what the user sets when putting parameters on the commandline (without the p_), or explicitly set in environemnt (with the p_)
      # i_dims are set in the dna and are a permanent feature of the cell and can't be overridden by the user
      # s_dims are taken from p and i dims, and may contain members which are aliases or groups of other dims
      # d_dims are the final form of dim, after the s_dims have been expanded
      local -n \
        ddim=d_$dim_var ddims=d_$dims_var \
        sdim=s_$dim_var sdims=s_$dims_var \
        pdim=p_$dim_var pdims=p_$dims_var \
        idim=i_$dim_var idims=i_$dims_var \

      if [[ "${ddim:-}" || "${ddims:-}" ]]; then
        unset pdim pdims sdim sdims
        #  we need dims to have a non blank value to represent explicit emptiness (missing_member)
        #[[ "${ddim:-}" == $empty_member ]] && ddim=
        #[[ "${ddims:-}" == $empty_member ]] && ddims=()
      else

        if [[ $dim_var == *_* && ! "${pdim:-}" && ! "${pdims:-}" ]]; then

          local shorter_dim=$dim_var shorter_dims

          while [[ $shorter_dim == *_* ]]; do

            shorter_dim=${shorter_dim#*_}
            get_plural $shorter_dim shorter_dims

            if [[ ! -v dim_shorts[$shorter_dim] ]]; then
              log_fatal "Internal error: dim_short[$shorter_dim] doesn't exist, and it should have already been set in build_dim_info"
              fail1
            fi

            local -n short_pdim=p_$shorter_dim \
              short_pdims=p_$shorter_dims \

            if [[ "${short_pdim:-}${short_pdims:-}" ]]; then

              if [[ ${dim_shorts[$shorter_dim]} == *' '* ]]; then
                log_fatal "Ambiguous dim: $dim_var. This could refer to any of: ${dim_shorts[$shorter_dim]}. Choose one specifically when setting this dim."
                fail1
              fi

              if [[ ${dim_shorts[$shorter_dim]} == $dim_var ]]; then
                if [[ "${short_pdim:-}" ]]; then
                  pdim=$short_pdim
                  break
                elif [[ "${short_pdims:-}" ]]; then
                  pdims=( "${short_pdims[@]}" )
                  break
                fi
              fi

            fi

          done
        fi

        # We do not support pulling from simple dim here
        # If we want to set an dim in env vars, it must be set with p_dim form
        sdim=${sdim:-${idim:-${pdim:-}}}

        if [[ ! "${sdims:-}" ]]; then
          if [[ "${idims:-}" ]]; then
            sdims=( "${idims[@]}" )
          elif [[ "${pdims:-}" ]]; then
            # Multiple members that have spaces inside are not supported
            # Only single member dims can be used if the value requires spaces or special characters
            sdims=( $pdims )
          else
            sdims=()
          fi
        fi

        # from here on out only sdims and ddims should be used
        # sdims may contain shortcuts, ddims are always expanded (never shortcuts)
        unset pdim pdims

        # idims are needed when calculating seed coordinates
        # unset i_$dim_var i_$dims_var

        [[ "${sdim:-}" == $empty_member ]] && sdim=
        [[ "${sdims:-}" == $empty_member ]] && sdims=()

      fi

      local -n is_optional=dim_${dim_var}_is_optional
      if [[ ${is_optional:-} == t && " $optional_dims " != *" $dim_var "* ]]; then
        optional_dims+=" $dim_var"
        optional_dims=${optional_dims# }
      fi

    done

  end_function
  handle_return
}

# child dims are anchor dims which have not yet been converted into branch dims
# they are dims which will form sub cells, and need to be expanded
load_child_dims() {
  begin_function
    local i

    if [[ ! "${child_dims:-}" ]]; then
      child_dims=()
      local trunk_dim_count=${#trunk_dims_expanded[*]}
      if [[ ! "${anchor_dims:-}" ]]; then
        for (( i = branch_dim_count; i < trunk_dim_count; i++ )); do
          child_dims+=( ${trunk_dims_expanded[$i]} )
        done
      else
        local anchor_dim branch_dim leftovers=" $anchor_dims "
        
        for branch_dim in ${branch_dims[*]}; do
          remove_word_from_string leftovers $branch_dim
        done

        begin_for anchor_dim in $anchor_dims; doo
          if [[ " ${trunk_dims_expanded[*]} ${support_dims_expanded[*]} " != *" $anchor_dim "* ]]; then
            log_fatal "Invalid anchor_dim: $anchor_dim. It does not exist in the list of possible leaf nodes: ${trunk_dims_expanded[*]} ${support_dims_expanded[*]}"
            fail1
          fi
        end_for
        
        child_dims=( $leftovers )
      fi

      child_dim_count=${#child_dims[*]}

      if (( child_dim_count > 0 )); then
        cell_is_leaf=f
      else
        cell_is_leaf=t
      fi
    fi

    current_branch_dim=
    if [[ "${child_dims[0]:-}" ]]; then
      current_branch_dim=${child_dims[0]}
    fi

  end_function
  handle_return
}

# inputs:
#   target_dims               which dims to connect trunk dims to via support dims
#   related_dims_expanded
#   shortest_path_to_dim
# outputs:
#   support_dims_expanded
get_support_dims() {
  begin_function

    local related_dim
    local -A support_dims_set

    begin_for related_dim in ${related_dims_expanded[*]}; doo
      
      if [[ " $target_dims " == *" $related_dim "* ]]; then
        #  not sure if this is needed
        #if [[ $type == *-to-one ]]; then
        #  support_dims_one_expanded+=( $dim )
        #fi
        local d
        for d in ${shortest_path_to_dim[$related_dim]}; do
          if ! array_contains trunk_dims_expanded $d; then
            support_dims_set[$d]=1
          fi
        done
        if [[ " ${trunk_dims_expanded[*]} " != *" $related_dim "* ]]; then
          support_dims_set[$related_dim]=1
        fi
      fi

    end_for

    support_dims_expanded=( ${!support_dims_set[*]} )
    sort_array support_dims_expanded
    #sort_array support_dims_one_expanded
    if [[ "${support_dims_expanded:-}" ]]; then
      log_debug "Found support dims: ${support_dims_expanded[*]}"
    else
      log_debug "No support dims needed"
    fi

  end_function
  handle_return
}

add_required_dims() {
  local dims=$* dim
  for dim in $dims; do
    if [[ " $optional_dims " != *" $dim "* ]]; then
      required_dims[$dim]=1
    fi
  done
}

setup_dims() {
  begin_function

    calc_anchor_dims || fail
    prep_dims || fail

    get_dim_parameters || fail

    local target_dims="${trunk_dims_expanded[*]} $dim_parameters $anchor_dims"

    get_support_dims || fail

    load_child_dims || fail
    if [[ $cell_is_leaf == t ]]; then
      expand_dims ${sub_dims_expanded[*]:-} ${control_props_expanded[*]:-} ${data_props_expanded[*]:-} || fail
      load_implicit_dims || fail
      add_required_dims ${sub_dims_expanded[*]:-} ${control_props_expanded[*]:-} ${data_props_expanded[*]:-} || fail
    else
      expand_dims ${trunk_dims_expanded[*]:-} ${support_dims_expanded[*]:-} || fail
      add_required_dims ${trunk_dims_expanded[*]:-} || fail
    fi

    if (( ${#required_dims[*]} > 0 )); then
      log_debug "Required dims: ${!required_dims[*]}"
    else
      log_debug "No dims required"
    fi

  end_function
  handle_return
}

# should make sure load_branch_info was run before calling this
# inputs: 
#   $1  work path to target folder, which may be a cell or a folder of a cell
#   $2  target var to save seed path to, defaults to seed_path
# outputs: seed_path work_path
find_seed_path() {
  local d s=$1 i h dim dim_count
  local -n target=${2:-seed_path} 
  begin_function
    target=

    s=/seed${s#/work}

    while [[ ! -d $s && $s == *:* ]]; do
      s=${s%/*}
    done

    if [[ ${ignore_nonexistent:-f} == t ]]; then
      while [[ ! -d $s && $s == */*/*/* ]]; do
        s=${s%/*}
      done
    fi

    if [[ ! -d $s ]]; then
      log_fatal "Couldn't find seed for $s"
      fail1
    fi

    work_path=/work${s#/seed}

    # go through each seed folder and find matching dim
    local found_branch=t dim_folder
    while [[ $found_branch == t ]]; do
      
      found_branch=f
      dim_folder=$(find1 $s -name "*:*" -type d | head -n1) || fail
      if [[ "$dim_folder" ]]; then

        local seed_dim=${dim_folder##*/}
        seed_dim=${seed_dim%%:*}

        for (( i = 0; i < branch_dim_count; i++ )); do

          dim=${branch_dims[$i]}
          if [[ $dim == $seed_dim ]]; then
            h=${branch_hashes[$i]}
            if [[ -d $s/$dim:$h ]]; then
              s+=/$dim:$h
              found_branch=t
            elif [[ -d $s/$dim:_other ]]; then
              s+=/$dim:_other
              found_branch=t
            fi
            break
          fi

        done

      fi

    done

  end_function

  if [[ "$s" && -d $s ]]; then
    target=$s
  fi

  local log_return_vars='target work_path'
  handle_return
}

get_short_cell() {
  short_cell=${cell_path#/work/*/}
  debug_return_vars=short_cell
}

init_command_vars() {
  cell_command_path=$path_to_commands/$cell_command \
    command_allows_logs=f \
    command_requires_cell=f \
    command_requires_resolved_dims=f \
    command_modifies_context=f \
    command_modifies_upstream=f
}

# Inputs:
#   $1    cell_path   should be real path
#   $2    command
execute_command() {
  local cell_path=$1 cell_command=$2 \
    log_show_vars='short_cell cell_command'
  begin_function_hi

    case $cell_command in
      dim-*|up-*)
        if [[ $cell_path == /seed/* ]]; then
          cell_path=/work${cell_path#/seed}
        fi
      ;;
      *)
        if [[ $cell_path != /work* ]]; then
          log_fatal "You must run this command from within the workspace (any subfolder of /work)"
          fail1
        fi
      ;;
    esac

    local parent_string=
    if [[ "${parent_cell:-}" ]]; then
      parent_string=" (from $parent_cell)"
    fi
    strong_log=t log_verbose "Executing cell command: $short_cell $cell_command$parent_string"

    local parent_cell=$short_cell

    if [[ $command_requires_cell == t ]]; then
      if [[ ! -e "$cell_path" ]]; then
        plant_seed $cell_path || {
          log_fatal "Not a cell: $cell_path"
          fail1
        }
      fi

      if [[ ! -e $cell_path/.dna ]]; then
        log_fatal "Invalid cell: $cell_path"
        fail1
      fi
    fi

    #  replacing logs with a simpler and faster mechanism
    #if [[ $command_allows_logs == t ]]; then
    #  disable_log=f
    #else
      disable_log=t
    #fi

    if [[ $disable_log == t ]]; then
      #log_debug "Logging disabled."
      background_log=$cell_path/background
    else
      execute_command_log_prep || fail
    fi

    if [[ $disable_log == f ]]; then
      : ${omni_log_fork_child:=0}
      (( omni_log_fork_child++ ))
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    local omni_log_fork_parent=${omni_log_fork_parent:-}-${omni_log_fork_child:-1} \
      omni_log_fork_child=0
    omni_log_fork_parent=${omni_log_fork_parent#-}

    if [[ " ${command_history:-}" == *" $cell_command $short_cell "* ]]; then
      log_fatal "Circular dependency found: arrived at $cell_command $short_cell a second time."
      fail1
    fi

    local command_history=${command_history:-}
    command_history+="$cell_command $short_cell "

    local cell_command_function=${cell_command//-/_}_command
    if function_exists $cell_command_function; then
      $cell_command_function || fail
    else
      log_fatal "Missing command function $cell_command_function which should be in $cell_command_path"
      fail1
    fi

    if [[ $disable_log == f ]]; then
      cell_close_log_file || fail
    fi

  end_function

  if failed; then
    log_fatal "Failed while executing command: $cell_command in folder $cell_path"
  fi
  handle_return
}

substitute_command_alias() {
  begin_function
    local alias_command parameters
    for (( i = 0; i < ${#command_aliases[*]}; i++ )); do
      if [[ "${command_aliases[$i]}" == "$cell_command" ]]; then
        alias_command=${command_alias_command[$i]}
        cell_command=${alias_command%% *}
        parameters=${alias_command#$cell_command }
        update_original_cmd=f parameters_to_env $parameters
        abort
      fi
    done
  end_function
  handle_return
}

# inputs:
#   $1        start_path
#   dim
# outputs:
#   dim_path    will not be set if it's not found
get_dim_path() {

  local start_path=$1 lib_dim_path

  lib_dim_path=$start_path/.lib/dim
  if [[ -d $lib_dim_path/$dim ]]; then
    dim_path=$lib_dim_path/$dim
  elif [[ $start_path == /*/*/* ]]; then
    get_dim_path ${start_path%/*}
  fi

}

# inputs:
#   $1      dim path
# 
build_dim_info_single() {
  local log_show_vars=dim_path \
    dim_path=$1 dim

  begin_function

    local dims dim=${dim_path##*/}

    if [[ -v all_dims[$dim] ]]; then
      log_fatal "Dim $dim has already been built"
      fail1
    fi

    all_dims[$dim]=1

    if [[ ! "$dim" =~ ^[a-zA-Z0-9][a-zA-Z0-9_]+$ ]]; then
      log_fatal "Invalid dim name: $dim. Dims must consist of alphanumeric characters or underscores."
      fail1
    fi

    get_plural $dim dims

    prefix=dim_${dim}_ \
    load_dna_contents $dim_path || fail

    local -n is_secret=dim_${dim}_is_secret
    if [[ -v is_secret && $is_secret == t ]]; then
      add_word_to_string secret_vars "$dim $dims s_$dim s_$dims d_$dim d_$dims"
    fi

    local -n members=dim_${dim}_members

    local shorter_dim=$dim shorter_dims

    dim_shorts[$dim]=$dim
    while [[ $shorter_dim == *_* ]]; do

      shorter_dim=${shorter_dim#*_}
      get_plural $shorter_dim shorter_dims
      if [[ ! -v dim_shorts[$shorter_dim] ]]; then
        dim_shorts[$shorter_dim]=$dim
      else
        # Allow exact dim name to override all abbreviations
        if [[ "${dim_shorts[$shorter_dim]}" != $shorter_dim ]]; then
          dim_shorts[$shorter_dim]+=" $dim"
        fi
      fi

    done

    if ! function_exists expand_function; then
      build_context_expand || fail
    fi

  end_function
  handle_return
}

dim_set_in_parameter() {
  local long_dim=$1 dim=${2:-$1}
  local -n pdim=p_$dim

  if [[ -v pdim && ${dim_shorts[$dim]} == $long_dim ]]; then
    return 0
  fi

  if [[ $dim == *_* ]]; then
    dim_set_in_parameter $long_dim ${dim#*_} || return 1
  else
    return 1
  fi

  return 0
}

# inputs:
#   dim
#   dim_derived_from
#   next_level_row
build_context_support_dims_find_related() {
  local log_show_vars=dim

  begin_function

    local row object type
    begin_for row in "${dim_derived_from[@]}"; doo
      local row_array=( $row )
      object=${row_array[0]}
      type=${row_array[1]}

      local canopy=${row_array[*]:2} \
        up_dim \
        new_shortest \
        old_shortest \

      begin_for up_dim in $canopy; doo

        new_shortest=( $next_level_row )

        local replace_shortest=t
        if [[ -v shortest_path_to_dim[$up_dim] ]]; then
          old_shortest=( ${shortest_path_to_dim[$up_dim]} )
          if (( ${#new_shortest[*]} >= ${#old_shortest[*]} )); then
            replace_shortest=f
          fi
        fi

        if [[ $replace_shortest == t ]]; then
          shortest_path_to_dim[$up_dim]=${new_shortest[*]}
        fi

        if [[ ! -v tried[$up_dim] ]]; then

          log_debug "Found reference to derived dim $up_dim (from $dim via $object)"

          if [[ ! -v all_dims[$up_dim] ]]; then
            log_fatal "Missing dim $up_dim"
            fail1
          fi

          local new_next_level_row=$next_level_row d
          for d in $canopy; do
            if [[ " $new_next_level_row " != *" $d "* && $d != $up_dim ]]; then
              new_next_level_row+=" $d"
            fi
          done
          new_next_level_row+=" $up_dim"

          tried[$up_dim]=1 \
          related_dims_set[$up_dim]=1 \
          next_level_dims[$new_next_level_row]=1 \

        fi

      end_for
    end_for

  end_function
  handle_return
}

build_context_related_dims() {
  begin_function

    local dim dim_parents next_level_row support_dim_depth=0 down_dim
      anchors=${anchor_dims:-${default_anchor_dims:-}}

    local -A related_dims_set=() \
      support_dims_set=() \
      shortest_path_to_dim=() \
      tried=() \
      next_level_dims=() \
      current_level_dims=() \
      target_dims=() \

    array_to_set trunk_dims_expanded    target_dims
    array_to_set sub_dims_expanded      target_dims
    array_to_set control_props_expanded target_dims
    array_to_set data_props_expanded    target_dims

    begin_for dim in ${!target_dims[*]}; doo
      if [[ ! -v tried[$dim] ]]; then
        tried[$dim]=1
        next_level_dims[$dim]=1
      fi
    end_for

    begin_while (( ${#next_level_dims[*]} > 0 )); doo
      current_level_dims=()
      add_to_set next_level_dims current_level_dims
      next_level_dims=()
      begin_for next_level_row in "${!current_level_dims[@]}"; doo
        dim=${next_level_row##* }
        dim_parents=${next_level_row% *}
        if [[ "$dim" == "$dim_parents" ]]; then
          dim_parents=
        fi
        local -n dim_derived_from=dim_${dim}_derived_from
        if [[ -v dim_derived_from ]]; then
          log_debug "Finding related dims of $dim"
          build_context_support_dims_find_related || fail
        fi
      end_for
    end_while

    fence

    related_dims_expanded=( ${!related_dims_set[*]} )
    sort_array related_dims_expanded

    if [[ "${related_dims_expanded:-}" ]]; then
      log_debug "Related dims found: $related_dims_expanded"
    fi

    write_vars_to_context related_dims_expanded shortest_path_to_dim || fail

  end_function
  handle_return
}

get_dim_parameters() {
  dim_parameters=
  for related_dim in ${related_dims_expanded[*]}; do
    if dim_set_in_parameter $related_dim; then
      dim_parameters+="$related_dim "
    fi
  done
}

build_dim_info_expand_group() {
  local dim=$1
  begin_function

    local dim_path=
    get_dim_path $cell_path || fail

    if [[ ! "$dim_path" ]]; then
      log_fatal "Could not find dim $dim of $dim_type"
      fail1
    fi

    local dim_folders dim_folder
    dim_folders=$(find1 $dim_path | sort -g) || fail

    for dim_folder in $dim_folders; do
      local dim=${dim_folder##*/}
      dim=${dim##+([0-9])-}
      if [[ $dim == _* ]]; then
        build_dim_info_expand_group $dim || fail
      else
        expanded_array+=( $dim )
      fi
    done

  end_function
  handle_return
}

build_dim_info() {
  begin_function

    local dim dim_type
    localize_dims=
    localize_reverse_dims=

    begin_for dim_type in trunk_dims sub_dims control_props data_props; doo

      local -n dim_array=${dim_type} expanded_array=${dim_type}_expanded
      expanded_array=()

      begin_for dim in "${dim_array[@]}"; doo

        if [[ "$dim" == *" "* ]]; then
          log_fatal "Dim ($dim) has spaces in it's name. Most likely multiple dims are defined in a single line of an .arr file in dna. Each dim should be on separate lines."
          fail1
        fi

        if [[ $dim == _* ]]; then
          build_dim_info_expand_group $dim || fail
        else

          if [[ ! "$dim" =~ ^[a-zA-Z0-9_]+$ ]]; then
            log_fatal "Invalid dim name: [$dim] in $dim_type"
            fail1
          fi

          if [[ $dim == d_* ]]; then
            log_fatal "Dims should not be named with d_ prefix: $dim in $dim_type"
            fail1
          fi

          expanded_array+=( $dim )

        fi

      end_for

      write_vars_to_context ${dim_type}_expanded || fail

    end_for

    build_context_related_dims || fail

    local dim dims
    for dim_type in trunk_dims related_dims sub_dims control_props data_props; do

      local -n dim_array=${dim_type}_expanded

      for dim in "${dim_array[@]}"; do

        local -n dt=dim_${dim}_type
        dt=$dim_type

        get_plural $dim dims
        localize_dims+=" d_$dim d_$dims"
        localize_reverse_dims+=" $dim=\${d_$dim:-} $dims=( \"\${d_$dims[@]:-}\" )"
        write_vars_to_context dim_${dim}_type || fail

      done

    done

    write_vars_to_context localize_dims localize_reverse_dims || fail

  end_function
  handle_return
}

load_dna_contents_handle_dir() {
  begin_function_lo
    if [[ "$current_var" && $item_var != _* ]]; then
      array_content+=( "$item_name" )
      if [[ -L $item || -d $item ]]; then
        result="${current_var}_${item_var}_path=$real_path"
        write_to_context var result || fail
      fi
      array_ord+=( $ord )
    fi

    if [[ ! -d $real_path/.dna ]]; then

      local new_pass_thru=f

      if [[ $item_var != _* ]]; then
        new_prefix+=${item_var}_
      else
        new_pass_thru=t
      fi

      # recursive
      prefix=$new_prefix pass_thru=$new_pass_thru load_dna_contents $item || fail

    fi
  end_function
  handle_return
}
 
# if context_type is not set, then no context will be written
# inputs:
#   $1                  folder to load dna objects from
#   prefix              prefix to append all var names with
#   recursive           whether to descend into sub dirs
#   ignore_unknown      if set to 'f', then unknown dna objects will throw an error
#   context_type        which context file to write the variable to. If empty, no context file will be written
#   auto_load_tab_vars  if set to 't', and a table is loaded with only one row, the fields of that row get loaded as variables also
load_dna_contents() {
  local folder=$1 prefix=${prefix:-} \
    pass_thru=${pass_thru:-f} recursive=${recursive:-t} \
    ignore_unknown=${ignore_unknown:-f} \
    context_type=${context_type:-} \
    auto_load_tab_vars=${auto_load_tab_vars:-f} \

  begin_function

    local items new_items
    items=$(find1 $folder -not -name '.*' -not -name root | sort -g) || fail

    local current_var=${prefix%_} ord item_name item_var= result 
    if [[ $pass_thru == f ]]; then
      local array_content=( )
      local -n array_ord=${current_var}_ord
    fi
    current_var=${current_var//-/_}

    begin_for item in $items; doo

      item_name=${item##*/}

      local dna_prefix=f
      if [[ "$item_name" == dna-* ]]; then
        dna_prefix=t
        item_name=${item_name#dna-}
      fi

      if [[ "$item_name" == *:* && $item != */.dna/* ]]; then
        local filter filters=${item_name%:*}
        for filter in ${filters//:/ }; do
          if [[ $cell_path != */"$filter"/* && $cell_path != */"$filter" ]]; then
            continue 2
          fi
        done
        item_name=${item_name##*:}
      fi

      extract_simple_name item_name ord item_name
      item_var=${item_name//-/_}
      item_var=${item_var%%,*}
      item_var=${item_var%%:*}

      local new_prefix= 
      if [[ "$current_var" && $dna_prefix == f ]]; then
        new_prefix=${current_var}_
      fi

      local real_path=$(realpath -m $item)

      if [[ -d $item ]]; then
        if [[ $recursive == t ]]; then
          load_dna_contents_handle_dir || fail
        fi
      elif [[ -f $item ]]; then
        prefix=$new_prefix load_dna_item $item || fail
      elif [[ -L $item ]]; then
        log_fatal "Broken link in dna: $item"
        fail1
      fi

    end_for

    if [[ "$current_var" && "${array_content:-}" && $pass_thru == f ]]; then
      local append=f
      local -n v=$current_var
      [[ "${v:-}" ]] && append=t
      make_array_assignment $current_var array_content || fail
      write_to_context var array_assignment || fail
    fi

  end_function
  handle_return
}

build_context_reactors() {
  begin_function_lo
    reactor_groups=
    local ord
    for ord in ${reactors_ord[*]:-}; do
      reactor_groups+="$ord "
    done
    reactor_groups=( $(echo "${reactor_groups% }" | sed 's/ /\n/g' | sort -gu) )
    write_vars_to_context reactor_groups || fail
  end_function
  handle_return
}

load_parent_context() {
  local path=$1
  begin_function
    if [[ "$path" == /*/*/* ]]; then
      load_parent_context ${path%/*}
    fi
    local root_path=$path/.root
    if [[ -e $root_path ]]; then
      log_debug "Appending parent trunk context ${path#/*/*/}"
      echo "$NL# FROM $root_path" >>$context_path-$context_type.new || fail
      if [[ -d $root_path ]]; then
        load_dna_contents $root_path || fail
      elif [[ -f $root_path ]]; then
        cat $root_path >>$context_path-$context_type.new || fail
      fi
    fi
  end_function
  handle_return
}

# Unused now?
build_dim_expand_functions() {
  begin_function
    local dim
    for dim in ${!all_dims[*]}; do
      local -n expand_function=dim_${dim}_expand
      if ! function_exists expand_function; then
        build_context_expand || fail
      fi
    done; maybe_break
  end_function
  handle_return
}

build_context_trunk_dna() {
  local log_vars=cell_path log_show_vars=short_cell
  begin_function

    local item_name last_part dna_full_item suffix context_type=trunk
    local -A append_vars

    if [[ -d $dna_path ]]; then

      auto_loads=()

      if [[ "$cell_path" == */*/* ]]; then
        load_parent_context ${cell_path%/*} || fail
      fi

      echo "$NL# FROM $dna_path" >>$context_path-$context_type.new || fail
      prefix= load_dna_contents $dna_path || fail

      write_vars_to_context auto_loads || fail

      if [[ ! "${default_anchor_dims:-}" ]]; then
        default_anchor_dims="${trunk_dims_expanded[*]:-}"
        write_vars_to_context default_anchor_dims || fail
      fi

      mv $context_path-$context_type.new $context_path-$context_type.new2 || fail
      echo "#!/usr/env bash" >$context_path-$context_type.new || fail
      local v
      for v in ${!append_vars[*]}; do
        echo "$v=" >>$context_path-$context_type.new || fail
      done

      cat $context_path-$context_type.new2 >>$context_path-$context_type.new || fail
      rm $context_path-$context_type.new2 || fail

      build_context_reactors || fail

    elif [[ -f $dna_path ]]; then
      safe_link $dna_path $context_path-$context_type.new || fail
      source $dna_path || fail
    else
      log_vars=dna_path log_fatal "Internal error: dna not found"
      fail1
    fi

  end_function
  handle_return
}

# inputs:
#   name
#   derive_path
#   cache_path
make_derive_cache_handle_table() {
  begin_function

    local -n dtp=derive_table_${name}_path
    dtp=$derive_path

    load_derive_table $name || fail
    derive_tables+=( $name )

    write_vars_to_context \
      derive_table_${name}_path \
      derive_table_${name}_fields \
      derive_table_${name}_data \
      || fail

    table=derive_table_${name} \
    make_table_index || fail

    table=derive_table_${name} \
    write_index_to_context $cache_path.new || fail

    fence

    load_derive_table_keys || fail

    tab_get_derive_from || fail

  end_function
  handle_return
}

make_derive_cache_handle_function() {
  begin_function

    load_fun_to_code $derive_path derive_function_$name || fail
    eval "$code" || fail
    derive_functions+=( $name )
    write_to_context fun code || fail

    local keys=() fields=()

    action=info \
    derive_function_$name || fail

    local field is_key other_fields
    for field in ${fields[*]}; do

      if [[ " ${keys[*]} " == *" $field "* ]]; then
        is_key=t
      else
        is_key=f
      fi

      local -n derive_from=dim_${field}_derived_from \
        key_functions=dim_${field}_key_functions \

      if [[ $is_key == t ]]; then

        other_fields=( ${fields[*]} )
        remove_array_element other_fields $field
        derive_from+=( "$name.fun ${other_fields[*]}" )
        key_functions+=( $name )

      else
        derive_from+=( "$name.fun ${keys[*]}" )
      fi

    done

  end_function
  handle_return
}

# inputs:
#   lib_dt_path
#   cache_path
make_derive_cache() {
  begin_function

    log_debug "Generating derive cache for $lib_dt_path"
    deriving_dims=t

    if [[ -f $cache_path.new ]]; then
      rm $cache_path.new || fail
    fi

    local context_file=$cache_path.new \
      type files \

    begin_for type in fun tab; doo

      if [[ $type == fun ]]; then
        files=$(find -L $lib_dt_path \( -type f -or -type l \) -not -name '.*' -name '*.fun' | sort -g) || fail
      else
        files=$(find -L $lib_dt_path \( -type f -or -type l \) -not -name '.*' -name '*.*tab' | sort -g) || fail
      fi

      local name code derive_path
      begin_for derive_path in $files; doo
        name=${derive_path##*/}
        name=${name%.*}
        name=${name#derive_}
        if [[ $type == fun ]]; then
          make_derive_cache_handle_function || fail
        else
          make_derive_cache_handle_table || fail
        fi
      end_for
    end_for

    write_vars_to_context derive_tables derive_functions || fail

    local dim
    for dim in ${!all_dims[*]}; do

      ignore_missing=t \
      write_vars_to_context \
        dim_${dim}_key_tables \
        dim_${dim}_key_functions \
        dim_${dim}_derived_from \
        || fail

#        dim_${dim}_card_table \

      local -n member_type=dim_${dim}_member_type \
        dim_members=dim_${dim}_members \
        dim_derive_tables=dim_${dim}_derive_tables \

      if [[ ! -v dim_members ]]; then
        calc_missing_members || fail
      fi

      case ${member_type:-unset} in
        static|dynamic)
          :
        ;;
        unset)
          if [[ "${dim_members:-}" || "${dim_derive_tables:-}" ]]; then
            member_type=static
          else
            member_type=dynamic
          fi
        ;;
        *)
          log_fatal "Invalid value for member_type: $member_type defined for dim $dim"
          fail1
        ;;
      esac

      write_vars_to_context dim_${dim}_member_type || fail
       
    done

    if [[ -f $cache_path.new ]]; then
      mv $cache_path.new $cache_path || fail
    fi
    unset deriving_dims

  end_function
  handle_return
}
 
load_derive_caches() {
  local work_path=$1
  begin_function

    if [[ $work_path == /*/*/* ]]; then
      load_derive_caches ${work_path%/*} || fail
    fi

    local lib_dt_path=$work_path/.lib/derive

    if [[ -d $lib_dt_path ]]; then

      local dt files links link type is_generated \
        cache_path=$work_path/.lib/derive-cache \
        real_path real_path_parent \

      derive_caches+="$cache_path "

      if [[ ! -f $cache_path ]]; then
        fork make_derive_cache || fail
      fi

      source $cache_path || fail

    fi

  end_function
  handle_return
}

# inputs:
#   derive_tables
# outputs:
#   refine_tables
build_refine_tables() {
  begin_function

    local dim dt dts

    for dim in ${!all_dims[*]}; do

      local -n refine_tables=dim_${dim}_refine_tables \
        dts=dim_${dim}_derive_tables \
        members=dim_${dim}_members \

      if [[ -v dts && -v members ]]; then

        refine_tables=()
        local member_count=${#members[*]}

        for dt in $dts; do
          local -n index=derive_table_${dt}_index_$dim
          if (( ${#index[*]} == member_count )); then
            refine_tables+=( $dt )
          fi
        done

        if [[ "${refine_tables:-}" ]]; then
          log_debug "Refine tables found for $dim: ${refine_tables[*]}"
        fi

        write_vars_to_context dim_${dim}_refine_tables || fail

      fi

    done

  end_function
  handle_return
}

# inputs:
#   dim
calc_missing_members() {
  begin_function

    local members_array 
    log_debug "Calculating missing dim members for $dim"

    local -n dts=dim_${dim}_derive_tables

    local -A found_members=()

    local dt v
    if [[ -v dts ]]; then

      local -n members=dim_${dim}_members
      members=()

      for dt in $dts; do
        local -n index=derive_table_${dt}_index_$dim
        for v in ${!index[*]}; do
          found_members[$v]=1
        done
      done
      members=( "${!found_members[@]}" )
      sort_array members

      log_debug "Found ${#found_members[*]} members for $dim"

      if [[ ! "${found_members[*]}" ]]; then
        log_fatal "No members were found for this dim $dim. Check the derive tables or explicitly make a members list in the dim folder."
        fail1
      fi

      write_vars_to_context dim_${dim}_members || fail

    else
      log_debug "No derive tables found for $dim, and no explicit members are defined, so it must be a dynamic dim"
    fi

  end_function
  handle_return
}

build_context_trunk() {
  begin_function

    local context_type=trunk last_type=var

    log_debug "Building trunk context for $short_cell"

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    build_context_trunk_dna || fail

    if [[ "${trunk_dims[0]:-}${sub_dims[0]:-}${control_props[0]:-}${data_props[0]:-}" ]]; then

      local dims_missing_members=

      write_vars_to_context derive_tables derive_functions derive_caches || fail

      build_dim_info || fail

      if [[ "$dims_missing_members" ]]; then
        calc_missing_members || fail
      fi

      build_refine_tables || fail

    fi

    if [[ ! -d $status_path ]]; then
      mkdir -p $status_path || fail
    fi

    get_key_path || fail
    write_vars_to_context key_path || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

build_context_branch() {
  begin_function

    local context_type=branch last_type=var
    log_debug "Building branch context for $short_cell"

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    local dim assignment member i members_string=
    begin_for ((i = 0; i < branch_dim_count; i++)); doo
      dim=${branch_dims[$i]}
      member=${branch_members[$i]}
      shell_quote_var member
      assignment="d_$dim=$member"
      members_string+="$member "
      write_to_context var assignment || fail
    end_for

    local content="
branch_dims=( ${branch_dims[*]} )
branch_dim_count=$branch_dim_count
branch_members=( ${members_string% } )
branch_hashes=( ${branch_hashes[*]} )
cell_is_leaf=$cell_is_leaf
"
    write_to_context var content || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

seed_coordinates_prep() {
  begin_function
    if (( ${coordinate_count:-0} > 0 )); then
      log_fatal "Coordinates already have data, can't seed them."
      fail1
    fi

    if [[ $seed_table == auto ]]; then
      local derive_table biggest_table= biggest_size=0
      for derive_table in ${derive_tables[*]}; do
        local -n derive_fields=derive_table_${derive_table}_fields \
                 derive_data=derive_table_${derive_table}_data \

        local size=${#derive_data[*]}
        if (( size > biggest_size )); then
          biggest_size=$size
          biggest_table=$derive_table
        fi
      done

      seed_table=$biggest_table

    fi

    if [[ ! "$seed_table" ]]; then
      log_fatal "Missing seed_table"
      fail1
    fi
  end_function
  handle_return
}

check_table_field() {
  local field=$1 expected_value=$expected_value value=${2:-} values=${3:-} fields

  is_valid=t
  if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
    return 0 # this one always matches
  fi

  if [[ ! "$value" || ! "$values" ]]; then

    get_plural $field fields
    local -n ddim=d_$field \
             ddims=d_$fields \
             pdim=p_$field \
             pdims=p_$fields \

    if [[ ! "$value" ]]; then
      value=${ddim:-${pdim:-}}
    fi
      
    if [[ ! "$values" ]]; then
      values=( "${ddims[@]:-${pdims:-}}" )
    fi

  fi
      
  if [[ "${values:-${value}}" == *"*"* ]]; then
    if [[ "$expected_value" != ${values:-${value}} ]]; then
      is_valid=f
    fi
  elif [[ "$value" && "$value" != all && "$value" != $empty_member \
       && "$value" != "$expected_value" ]]; then
    is_valid=f
  elif [[ "$values" && "$values" != all && "$values" != $empty_member \
       && " $values " != *" $expected_value "* ]]; then
    local v
    is_valid=f
    for v in "${values[@]}"; do
      if [[ "$v" == "$expected_value" ]]; then
        is_valid=t
        break
      fi
    done
  fi
  
  return 0
}

# inputs:
#   table_fields       
#   table_data
#   offset       (optional) offset into data structure where row starts
#   row_index    (optional) which row to select from the table
# either offset or row must be set
# outputs:
#   is_valid 
check_table_row() {
  local offset=${offset:-} row_index=${row_index:-} field_count=${#table_fields[*]}
  begin_function
    local f t
    if [[ ! "$offset" ]]; then
      (( offset = row_index * field_count ))
    fi
    is_valid=t
    for (( f = 0; f < field_count; f++ )); do

      log_show_vars=f

      local field=${table_fields[$f]}
      (( t = offset + f ))
      local expected_value=${table_data[$t]}

      if [[ -v all_dims[$field] ]]; then
        check_table_field $field
      fi

      if [[ $is_valid == f ]]; then
        break
      fi

    done
  end_function
  handle_return
}

# Will add a row to new_coordinate_data based on current ddim values and coordinate_fields
# Should only be called when the row is known to be valid
# inputs:
#   coordinate_fields
#   coordinate_fields_count
#   ignore_missing            (optional)
#   validate_row              (optional)
# outputs:
#   new_coordinate_data
#   total_coord_rows_added
#   row_is_valid
calc_coordinates_add_row() {
  local ignore_missing=${ignore_missing:-f}
  begin_function_lo

    local i new_coords=()
    for (( i = 0; i < coordinate_fields_count; i++ )); do
      local dim_var=${coordinate_fields[$i]}
      local -n dim_value=d_$dim_var
      if [[ ! "${dim_value:-}" ]]; then
        if [[ $ignore_missing == f ]]; then
          log_fatal "Missing dim: $dim_var"
          fail1
        fi
        new_coords+=( "" )
      else
        new_coords+=( "$dim_value" )
      fi
    done

    new_coordinate_data+=( "${new_coords[@]}" )
    log_debug "${coord_type}_coordinate_data+=( ${new_coords[*]} )"
    progress_bar_nudge +
    (( total_coord_rows_added++ ))

  end_function
  handle_return
}

setup_coord_fields() {
  begin_function

    local short_coord_type=${coord_type%_seed}

    case $short_coord_type in
      branch)
        #coordinate_fields=( ${trunk_dims_expanded[*]:-} ${support_dims_one_expanded[*]:-} )
        # don't need to do deep derive if we are already include support dims, which come
        #   from a deep derive analysis
        #derive_deep=f

        if [[ $target_form == seed ]]; then
          coordinate_fields=( ${trunk_dims_expanded[*]:-} )
        else
          coordinate_fields=( ${trunk_dims_expanded[*]:-} ${support_dims_expanded[*]:-} )
        fi
      ;;
      leaf)
        coordinate_fields=( ${control_props_expanded[*]:-} ${data_props_expanded[*]:-} )
      ;;
      sub)
        coordinate_fields=( ${sub_dims_expanded[*]:-} )
      ;;
      tree)
        coordinate_fields=( ${trunk_dims_expanded[*]:-} ${support_dims_expanded[*]:-} ${sub_dims_expanded[*]:-} )
        # don't need to do deep derive if we are already include support dims, which come
        #   from a deep derive analysis
        derive_deep=f

        #if [[ $target_form == seed ]]; then
        #  coordinate_fields=( ${trunk_dims_expanded[*]:-} ${support_dims_expanded[*]:-} ${sub_dims_expanded[*]:-} )
        #else
        #  coordinate_fields=( ${trunk_dims_expanded[*]:-} ${sub_dims_expanded[*]:-} )
        #fi
      ;;
      *)
        log_fatal "Internal error: invalid coord_type=$coord_type"
        fail1
      ;;
    esac

    if [[ $target_form == seed ]]; then

      local new_fields=() dim

      for dim in ${coordinate_fields[*]}; do
        local -n member_type=dim_${dim}_member_type

        if [[ ! -v member_type ]]; then
          log_fatal "internal error: Missing member_type for dim $dim. Might need to clean the dim cache with a 'cell clean' command."
          fail1
        fi

        if [[ $member_type == static ]]; then
          new_fields+=( $dim )
        fi
      done

      coordinate_fields=( ${new_fields[*]} )

    fi

    coordinate_fields_count=${#coordinate_fields[*]}

  end_function
  handle_return
}

load_implicit_dims() {
  begin_function_lo
    local d
    implicit_dims=()
    if [[ -e $out_path/output.tab ]]; then
      for d in $(head -n1 $out_path/output.tab); do
        if [[ ! " ${trunk_dims_expanded[*]} ${sub_dims_expanded[*]} " == *" $d "* ]]; then
          implicit_dims+=( $d )
          all_dims[$d]=1
        fi
      done
    fi
  end_function
  handle_return
}

# inputs
#   dim    dim to output
#   var    var name containing value of dim
#   $1     message to output
show_trace_dim_message() {
  local var=$var dim=$dim message="$1"
  get_var_value $var
  local show_val=$value
  if [[ "${secret_vars:-}" && " ${secret_vars} " == *" $var "* ]]; then
    show_val='****'
  fi
  echo " ${DIM_DEBUG_COLOR}debug_id=$fork_debug_id $dim=$show_val$RESET $message" >&$fd_original_err
}

attempt_derive_from_function() {
  local function_name=$function_name
  if function_exists dim_${dim}_$function_name; then
    # This should be set to t in the derive function if requirements are met

    dim_${dim}_$function_name || return 1
    if [[ " $trace_dims " == *" $dim "* && "$values" ]]; then
      var=values \
      show_trace_dim_message "Derived from derive function: dim_${dim}_$function_name"
    fi
  fi
  return 0
}

# input:
#   dim
#   dim_type
#   $1        target var name
# output:
#   values    array of dim members
read_dim() {
  local -n target=$1
  begin_function_lo
    local -n is_secret=dim_${dim}_is_secret
    while true; do
      if [[ "${is_secret:-f}" == t ]]; then
        read -u $fd_original_in -p "(? for more info) $dim=" -rs values >&$fd_original_err || fail
        echo '************' >&$fd_original_err
      else
        read -u $fd_original_in -p "(? for more info) $dim=" -r values >&$fd_original_err || fail
      fi
      if [[ "$values" == \?* ]]; then
        command_detail=1 show_dimension $dim || fail
      else
        local problem=
        dim_var=$dim expand_dim_members values || fail
        if [[ "$problem" ]]; then
          echo "$problem" >&$fd_original_err
        else
          # value is valid
          if [[ "${new_values[*]}" != "$values" ]]; then
            echo "Expanded to: ${new_values[*]}" >&$fd_original_err || fail
            values=( "${new_values[@]}" )
          fi
          break
        fi
      fi
    done
  end_function
  handle_return
}

# inputs:
#   dim
# outputs:
#   values    array, may contain $empty_member
attempt_default() {
  local dim=$dim
  begin_function

    local problem
    local -n dim_type=dim_${dim}_type

    values=()

    if function_exists dim_${dim}_default; then
      dim_${dim}_default || fail

      if [[ " $trace_dims " == *" $dim "* && "${values:-}" ]]; then
        var=values \
        show_trace_dim_message "Default value taken from default function: dim_${dim}_default"
      fi

    fi

    if [[ ! "${values:-}" ]] && function_exists dim_${dim}_expand; then
      value= dim_${dim}_expand || fail
      already_expanded=t

      if [[ " $trace_dims " == *" $dim "* && "${values:-}" ]]; then
        if [[ -v dim_${dim}_default ]]; then
          var=values \
          show_trace_dim_message "Default value taken from default value: dim_${dim}_default"
        else
          var=values \
          show_trace_dim_message "Default value taken from expand function: dim_${dim}_expand"
        fi
      fi

    fi

    if [[ "${values:-}" == ask ]]; then
      read_dim values || fail
      already_expanded=t
    fi

    if [[ ! "${values:-}" ]]; then

      if [[ ! -v required_dims[$dim] ]]; then
        values=( $empty_member )
        needs_narrowing=f
      fi
      already_expanded=t

    fi

  end_function
  handle_return
}

calc_coordinates_row_end() {
  begin_function

    local unknown_dim new_unknown_dims=
    for unknown_dim in $unknown_dims; do
      if [[ -v required_dims[$unknown_dim] ]]; then
        new_unknown_dims+="$unknown_dim "
      fi
    done
    unknown_dims=${new_unknown_dims% }

    if [[ "${unknown_dims:-}" ]]; then
      log_debug "Skipped row because of unresolvable dims: $unknown_dims"
      problem_message="Could not resolve dims: $unknown_dims"
    else
      ignore_missing=t \
      calc_coordinates_add_row || fail
      problem_message=
    fi

  end_function
  handle_return
}

calc_coordinates_dedup_output_rows() {
  local row_id
  for ((row_id = 0; row_id < coordinate_rows; row_id++ )); do
    (( row_start = row_id * coordinate_fields_count ))
    echo "${coordinate_data[*]:$row_start:$coordinate_fields_count} $row_id"
  done
}

# will remove duplicate coordinates
# inputs:
#   coordinate_rows
#   coordinate_data
#   coordinate_fields_count
calc_coordinates_dedup() {
  begin_function

    local prev_row_count=$coordinate_rows \
      sorted_row_ids row_id row_start \
      prev_coordinate_data=( "${coordinate_data[@]}" ) \

    sorted_row_ids=$(calc_coordinates_dedup_output_rows | tee /tmp/out | sort | sed -E 's/^(.*) ([0-9]+)$/\2 \1/' | tee /tmp/out2 | uniq -f 1 | awk '{print $1}')
    coordinate_data=()
    for row_id in $sorted_row_ids; do
      (( row_start = row_id * coordinate_fields_count ))
      coordinate_data+=( "${prev_coordinate_data[@]:$row_start:$coordinate_fields_count}" )
    done

    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))
    if (( coordinate_rows != prev_row_count )); then
      log_debug "Coord dedup reduced rows: $prev_row_count -> $coordinate_rows"
    fi
    
  end_function
  handle_return
}

# inputs:
#   dim            Dim of the member being checked. can't be empty
#   single_member  The member to be checked, if there is only one. may be empty
#   multi_member   The name of array var containing members to be checked, if more than one.  may be empty
#   target_member  what to check against. can't be empty
# outputs:
#   returns 0 if there are conflicts
member_conflicts() {
  if [[ "$single_member" ]]; then
    if [[ "$single_member" != "$target_member" && "$target_member" != all && "$single_member" != all ]]; then
      return 0
    fi
  elif [[ "$multi_member" ]]; then
    local -n members=$multi_member
    if [[ "${members:-}" ]]; then

      local found=f new_values v
      dim_var=$dim expand_dim_members $multi_member || return 0

      for v in "${new_values[@]}"; do
        if [[ "$v" == "$target_member" || "$target_member" == all || "$v" == all ]]; then
          found=t
          break
        fi
      done

      if [[ $found == f ]]; then
        return 0
      fi

    fi
  fi
  return 1
}

# inputs:
#   derive_table
#   dim
#   member
set_table_cross_dims_single() {
  local member=$member dim=$dim derive_table=$derive_table
  begin_function
    local -n derive_fields=derive_table_${derive_table}_fields \
             derive_data=derive_table_${derive_table}_data \

    local field_count=${#derive_fields[*]} \
      data_count=${#derive_data[*]} \
      row_index data_index=0 column_index \
      value= field \

    local row_count=$((data_count / field_count))

    local -n dt_index=derive_table_${derive_table}_index_${dim}
    if [[ -v dt_index[$member] ]]; then
      row_index=( ${dt_index[$member]} )
      if (( ${#row_index[*]} > 1 )); then
        log_fatal "Too many rows found in derive table matching cross dim: $row_index"
        fail1
      fi

      for (( column_index = 0; column_index < field_count; column_index++ )); do
        field=${derive_fields[$column_index]}
        local fields
        get_plural $field fields
        if [[ $field != $dim && -v all_dims[$field] ]]; then
          (( data_index = row_index * field_count + column_index ))
          value=${derive_data[$data_index]}
          local -n field_dim=d_$field
          if dim=$field \
             single_member="${field_dim:-}" \
             multi_member=d_$fields \
             target_member="$value" \
             member_conflicts; then
            conflict="$field = $value"
            break
          else
            if [[ "$value" && "$value" != all \
               && ! -v cross_dims_tried[$field] ]]; then
              log_debug "Cross dim set: $field=$value"
              field_dim=$value
              validated_dims+=" $field"
              cross_dims_tried[$field]=1

              # recursive
              dim=$field \
              member=$value \
              set_cross_dims || fail

            fi
          fi
        fi
      done
    else
      log_debug "Member ($member) doesn't exist in derive table ($derive_table)"
      conflict='(missing from table)'
    fi

  end_function
  handle_return
}

# inputs:
#   derive_fun
#   dim
set_function_cross_dims_single() {

  begin_function

    local action=derive fields=() values=() i field value
    derive_function_$derive_fun || fail

    begin_for (( i = 0; i < ${#fields[*]}; i++ )); doo

      field=${fields[$i]}

      if [[ ! -v values[$i] ]]; then
        log_fatal "Missing value for field $field in derive function $derive_fun"
        fail1
      fi

      value=${values[$i]}

      local -n ddim=d_${field}

      if [[ "${ddim:-}" ]] \
         && dim=$field \
         single_member="$value" \
         target_member="${ddim:-}" \
         member_conflicts; then
        conflict=$field
        break
      else
        if [[ "$value" && "$value" != all \
           && ! -v cross_dims_tried[$field] ]]; then
          log_debug "Cross dim set: $field=$value"
          ddim=$value
          validated_dims+=" $field"
          cross_dims_tried[$field]=1

          # recursive
          dim=$field \
          member=$value \
          set_cross_dims || fail

        fi
      fi

    end_for

  end_function
  handle_return
}

# input: 
#   dim
#   member
#   key_functions
#   key_tables
# output:
#   {dims}
#   conflict
set_cross_dims_internal() {
  local member=${member}
  begin_function

    if [[ "${key_functions:-}" ]]; then
      local derive_fun

      begin_for derive_fun in $key_functions; doo
        set_function_cross_dims_single || fail
      end_for
    fi

    if [[ "${key_tables:-}" ]]; then
      local derive_table

      begin_for derive_table in $key_tables; doo
        set_table_cross_dims_single || fail
      end_for
    fi

  end_function
  handle_return
}

# input: 
#   dim
#   member
# output:
#   {dims}
#   conflict
set_cross_dims() {
  begin_function

    conflict=
    local -n key_tables=dim_${dim}_key_tables \
      key_functions=dim_${dim}_key_functions \

    set_cross_dims_internal || fail

  end_function
  handle_return
}

# input:
#   $1   name of dim
# output:
#   derive_tables_loaded
load_related_derive_tables() {
  local dim=$1
  begin_function_lo
    local -n dts=dim_${dim}_derive_tables
    local dt
    if [[ -v dts ]]; then
      for dt in $dts; do
        local -n dtd=derive_table_${dt}_data
        if [[ ! -v dtd ]]; then
          log_fatal "Missing derive table data for $dt"
          fail1
        fi
      done
    fi
    derive_tables_loaded=t
  end_function
  handle_return
}

calc_coordinates_next_unknown_dim_found() {
  local needs_narrowing=${needs_narrowing:-t} \
    log_show_vars=dim
  begin_function

    resolved_dims+=" $dim"

    local -n \
      sdim=s_$dim \
      sdims=s_$dims \
      ddim=d_$dim \
      ddims=d_$dims \

    #local -n derive_tables_loaded=dim_${dim}_derive_tables_loaded
    #if [[ "${derive_tables_loaded:-}" != t ]]; then
    #  load_related_derive_tables $dim || fail
    #fi

    unset sdim ddim ddims sdims
    if [[ $already_expanded == f ]]; then
      sdims=( "${values[@]}" )
      expand_dims $dim || fail
    else
      ddims=( "${values[@]}" )
    fi

    local unknown_dims=${unknown_dims% }
    if [[ "$unknown_dims" == *' '* ]]; then
      unknown_dims="${unknown_dims#* } ${unknown_dims%% *}"
    fi
    remove_word_from_string unknown_dims $dim

    local member ms
    if [[ "${ddims:-}" ]]; then
      ms=( "${ddims[@]}" )
    else
      ms=( "$ddim" )
    fi

    if [[ $needs_narrowing == t ]] && (( ${#ms[*]} > 0 )); then
      result_var=ms \
      narrow_dim || fail
    fi

    if [[ "${ms:-}" ]]; then
      log_debug "Resolved $dim with $phase: ${ms[*]:0:30}"
      progress_bar_nudge
    else
      log_debug "Failed to find any matching values for $dim in $phase phase"
    fi

    if [[ "$row_index" ]] && (( ${#ms[*]} > 1 )); then
      log_fatal "Too many dim members for single coordinate row: ${ms[*]}"
      fail1
    fi

    local -n key_tables=dim_${dim}_key_tables \
      key_functions=dim_${dim}_key_functions \

    unset ddims
    local m
    for m in "${ms[@]}"; do

      if [[ "$m" == all ]]; then
        log_fatal "Internal error: a member should never be 'all' at this point."
        fail1
      fi

      # don't need to validate if in derive phase, since it's already proven valid by the derive
      #   process itself
      local needs_validation=f
      if [[ $phase == default && "$m" != "$empty_member" ]]; then
        needs_validation=t
      fi

      # recursive
      phase=unknown \
      calc_coordinates_next_dim_member || fail

    done; maybe_break

    row_ended=t
    unset ddim

  end_function
  handle_return
}

# will end the coordinate row one way or another
# inputs:
#   unknown_dims
#   all other ddims which may be used to derive the unknown dims
calc_coordinates_next_unknown_dim() {
  local log_show_vars=unknown_dims
  begin_function
    local dim dims \
      phase unknown_dims=${unknown_dims:-} \
      resolved_dims=${resolved_dims:-} \
      row_ended=f \

    if (( coord_limit > 0 && total_coord_rows_added >= coord_limit )); then
      log_warn "Limit of $coord_limit reached, not calculating any further"
      abort
    fi

    local dim_index
    if [[ "${unknown_dims:-}" ]]; then
      log_debug "Attempting to resolve unknowns: $unknown_dims"
      local -A derive_tried=()
      for phase in derive default; do
        for dim in $unknown_dims; do

          needs_narrowing=t

          local -n dim_type=${dim}_dim_type
          get_plural $dim dims

          log_show_vars='dim phase'
          log_debug "Finding values for $dim in phase $phase"

          local values=() already_expanded=f needs_narrowing=t
          if [[ $phase == derive ]]; then
            deriving= \
            attempt_derive || fail
            needs_narrowing=f
          elif [[ " ${all_if_blank:-} " == *" $dim "* ]]; then
            local new_values=()
            values=all
            dim_var=$dim \
            expand_dim_members values
            values=( "${new_values[@]}" )
            already_expanded=t
          else
            if [[ $target_form == seed ]]; then
              local value=all
              expand_dim value values || fail
              already_expanded=t
            else
              attempt_default || fail
            fi
          fi

          if [[ "${values:-}" ]]; then
            calc_coordinates_next_unknown_dim_found || fail
            abort
          fi

        done; maybe_break
      done; maybe_break
    fi

    if [[ $row_ended == f ]]; then
      # whether we resolve all or not, we need to end here
      calc_coordinates_row_end || fail
    fi

  end_function
  handle_return
}

# inputs:
#   dim
calc_coords_validate_member() {
  local member=$1 log_show_vars='dim member'
  begin_function

    is_valid=t
    conflicting_values=()

    log_debug "Validating $dim = $member"

    # all needs to be permitted here in the case of a dim that doesn't have explicit members
    #   but where the user needs to communicate that all are acceptable based on derivation of others?
    if [[ "$member" == all ]]; then
      log_debug "Dim $dim is all, so it's valid"
      abort
    fi

    if [[ ! -v required_dims[$dim] && ( ! "$member" || $member == $empty_member ) ]]; then
      log_debug "Dim $dim is optional and missing, so it's valid"
      abort
    fi

    local values=() derive_found=f
    local -A derive_tried=()
    derive_exactly_one=f \
    deriving= \
    derive_deep=f \
    attempt_derive || fail

    if [[ $derive_found == t ]]; then

      if [[ ! "${values[0]:-}" ]]; then
        is_valid=f
      elif ! array_contains values "$member" && ! array_contains values all; then
        conflicting_values=( "${values[@]}" )
        is_valid=f
      fi

      if [[ $is_valid == f ]]; then
        log_debug "Dim $dim is not valid because it couldn't be derived from existing dims"
        abort
      fi

    fi

    #  should have already been set
    #eval "local d_$dim=\$member"

    # only focussed on the one side for now, hopefully don't need this
    #  local rd
    #  for rd in $resolved_dims; do
    #    if [[ $rd == $dim ]]; then
    #      continue
    #    fi
    #    local stop_after_first_match=t \
    #    deriving= \
    #    from_dim=$dim \
    #    dim=$rd \
    #    attempt_derive || fail

    #    if [[ $can_derive == t ]]; then
    #      if [[ ! "${values:-}" ]]; then
    #        is_valid=f
    #      else
    #        local -n rd_member=d_$rd
    #        if [[ "${rd_member:-}" ]] && ! array_contains values "$rd_member" && ! array_contains values all; then
    #          conflicting_values=( "${values[@]}" )
    #          is_valid=f
    #        fi
    #      fi
    #      log_debug "Dim $dim is not valid because $rd couldn't be derived from it"
    #      abort
    #    fi
    #  done

    log_debug "Dim $dim is valid"

  end_function
  handle_return
}

# inputs:
#   needs_validation
#   dim
#   m                 member value
#   phase             unknown or known.  
calc_coordinates_next_dim_member() {
  local phase=$phase
  log_show_vars='dim m'
  begin_function
    localize
    local -n member=d_$dim
    member=$m
    log_debug "Processing $dim = $member in phase $phase"
    local validated_dims=${validated_dims:-} conflicting_values=() is_valid=t

    local -I cross_dims_tried

    if [[ $needs_validation == t && " $validated_dims " != *" $dim "* ]]; then
      calc_coords_validate_member "$member" || fail
      log_show_vars='dim member'
      fence
    fi

    if [[ $is_valid == t ]]; then

      conflict=

      if [[ "$member" != $empty_member ]]; then
        set_cross_dims_internal || fail

        if [[ "$conflict" ]]; then
          local conflict_plural
          if [[ "$conflict" =~ ^[a-zA-Z0-9_]+$ ]]; then
            get_plural $conflict conflict_plural
            local -n conflict_member=d_$conflict \
              conflict_members=d_$conflict_plural
            log_debug "Conflict found between cross-dim $dim = $member and $conflict = ${conflict_members:-${conflict_member:-}}"
          else
            log_debug "Conflict found for cross-dim $dim = $member $conflict"
          fi
        fi

        local d
        for d in $validated_dims; do
          if [[ $phase == unknown ]]; then
            remove_word_from_string unknown_dims $d
          else
            remove_word_from_string check_dims $d
          fi
        done

      fi

      validated_dims=

      if [[ ! "$conflict" ]]; then
        if [[ $phase == known && "$check_dims" ]]; then
          # recursive
          calc_coordinates_next_dim || fail
        elif [[ "${unknown_dims:-}" ]]; then
          # recursive
          calc_coordinates_next_unknown_dim || fail
        else
          calc_coordinates_row_end || fail
        fi
      else
        log_debug "Row skipped because of cross dim conflict"
      fi
    else
      local extra=
      if [[ "${conflicting_values:-}" ]]; then
        extra=" != ${conflicting_values[*]}"
      fi
      log_debug "Dim member doesn't fit row contraints: $dim: $member$extra, skipping row"
    fi

  end_function
  handle_return
}

# calling this will produce and end at least one coordinate row 
# inputs:
#   check_dims (may be empty)
#   coordinate_fields_plural
calc_coordinates_next_dim() {
  begin_function

    local coord_limit=${coord_limit:-0} total_coord_rows_added=${total_coord_rows_added:-0}
    if (( coord_limit > 0 && total_coord_rows_added >= coord_limit )); then
      log_debug "Limit of $coord_limit reached, not calculating any further"
      abort
    fi

    local dim dims \
      row_index=${row_index:-} \
      unknown_dims=${unknown_dims:-} \
      check_dims=${check_dims:-} \
      resolved_dims=${resolved_dims:-} \

    dim=${check_dims%% *}
    check_dims=${check_dims##$dim*( )}

    if [[ "$dim" ]]; then

      log_debug "Checking dim $dim"
      get_plural $dim dims

      eval "local -I d_$dim d_$dims"
      local -n member=d_$dim \
        members=d_$dims

      # This should not be needed now that all derive tables are loaded always
      #local -n derive_tables_loaded=dim_${dim}_derive_tables_loaded

      #if [[ "${derive_tables_loaded:-}" != t ]]; then
      #  load_related_derive_tables $dim || fail
      #fi

      if [[ "${member:-}" || "${members:-}" ]]; then
        
        local m ms conflict
        resolved_dims+=" $dim"

        if [[ "${member:-}" ]]; then
          ms=( "$member" )
        else
          ms=( "${members[@]}" )
        fi

        result_var=ms \
        narrow_dim || fail
        needs_validation=f

        if [[ "$row_index" ]] && (( ${#ms[*]} > 1 )); then
          log_fatal "Too many possibilities found for a single coordinate row: ${ms[*]}"
          fail1
        fi

        if [[ ! "$ms" ]]; then
          log_fatal "$dim has no matching values that align with $conflict"
          fail1
        fi

        if [[ "${#ms[*]}" == 1 ]]; then
          m=$ms
        fi

        local -n key_tables=dim_${dim}_key_tables

        unset members
        unset -n members member

        local phase=known
        if [[ "${m:-}" ]]; then
          calc_coordinates_next_dim_member || fail
        else
          begin_for m in "${ms[@]}"; doo
            calc_coordinates_next_dim_member || fail
          end_for
        fi

        log_show_vars='dim member'

        # if none of the members are valid, we just skip the row
        # if any are valid, they will have added their own rows already
        abort

      else # no members
        log_debug "Dim unknown: $dim"
        unknown_dims+="$dim "
        calc_coordinates_next_dim || fail
      fi

    else # check_dims is empty, need to proceed to unknowns
      calc_coordinates_next_unknown_dim || fail
    fi

  end_function
  handle_return
}

# internal function
seed_coordinates_handle_row() {
  log_show_vars=row_index
  begin_function
    localize
    local is_valid seed_field
    check_table_row
    if [[ $is_valid == t ]]; then

      for field_index in ${!seed_fields[*]}; do
        seed_field=${seed_fields[$field_index]}
        if [[ -v all_dims[$seed_field] ]]; then
          local -n member=d_$seed_field
          (( seed_data_index = row_index * seed_field_count + field_index ))
          member=${seed_data[$seed_data_index]}
        fi
      done

      if [[ $fill_in_the_blanks == t ]]; then
        local check_dims="${trunk_dims_expanded[*]} 
          ${sub_dims_expanded[*]} 
          ${control_props_expanded[*]} 
          ${data_props_expanded[*]} 
          ${related_dims_expanded[*]}" \
          unknown_dims= dim validated_dims= \

        needs_validation=f \
        calc_coordinates_next_dim || fail
      else
        ignore_missing=t calc_coordinates_add_row || fail
      fi

    fi
  end_function
  handle_return
}

# Will not output fields that don't exist
xlr8_get_input_string() {
  local fields_to_export=$*
  begin_function
    for f in $fields_to_export; do
      local -n x=$f
      if [[ -v x ]]; then
        if is_array x; then
          local m
          v="( "
          for m in "${x[@]}"; do
            shell_quote_var m
            v+="$m "
          done
          v+=")"
        else
          v=$x
        fi
        shell_quote_var v
        input_string+="$f=$v$NL"
      fi
    done
  end_function
  handle_return
}

xlr8_execute() {
  begin_function
    case $source_type in
      simple_java)
        java -cp $target_path Main || fail
      ;;
      *)
        log_fatal "Don't know how to execute source type $source_type yet"
        fail1
      ;;
    esac
  end_function
  handle_return
}

xlr8() {
  local function_name=$1; shift
  local fields_to_export=$*
  begin_function

    debug_start

    local xlr8_command_path=/work/xlr8/op/$function_name \
      target_path=$xlr8_command_path/target \
      source_path=$xlr8_command_path/src \
      standard_fields='
        bisect_test
        debug_bisect
        debug_bisect_max
        debug_bisect_min
        debug_exit
        debug_function_old
        debug_id
        debug_id_current
        debug_immediate
        debug_quick_function
        debug_quick_stop_less_than_depth
        debug_restart_command
        debug_step_to_mid_function
        debugging
        fork_debug_id
        fork_id_current
        pause_at_functions
        pause_at_vars
        secret_vars
        show_time
        show_time_prev
        trace_condition
        trace_expression
        trace_fun
        trace_structure
        trace_time
        trace_time_fd
        trace_time_log
        trace_var
        trace_vars
        trace_var_always
        trace_var_old
        trace_var_sub
      '

    if [[ ! -d $xlr8_command_path ]]; then
      log_fatal "Function $function_name doesn't exist in $xlr8_command_path"
      fail1
    fi

    if [[ ! -d $target_path ]]; then
      fork execute_commands "$xlr8_command_path" update || fail
    fi

    if [[ ! -d $target_path ]]; then
      log_fatal "Function $function_name didn't produce a target path"
      fail1
    fi

    if [[ -f $target_path/Main.class ]]; then
      source_type=simple_java
    else
      log_fatal "Can't identify source type of xlr8 op: $xlr8_command_path"
      fail1
    fi

    local input_string= v f
    xlr8_get_input_string $standard_fields $fields_to_export || fail

    result=$(echo "$input_string" | xlr8_execute) || fail
    if [[ "$result" ]]; then
      source "$result" || fail
    fi

  end_function
  handle_return
}

calc_coordinates_refine_get_matching_rows() {
  local -n derive_fields=${coord_type}_coordinate_fields
  
  local column_index \
    field_count=${#derive_fields[*]} \
    field \
    fields \
    members \

  local -A new_matching_rows

  for (( column_index = 0; column_index < field_count; column_index++ )); do

    field=${derive_fields[$column_index]}
    get_plural $field fields

    local -n ddim=d_$field \
      ddims=d_$fields \

    if [[ "${ddim:-}" ]]; then
      members=( "$ddim" )
    elif [[ "${ddims:-}" ]]; then
      members=( "${ddims[@]}" )
    else
      local values=()
      dim=$field \
      attempt_default || fail
      members=( "${values[@]}" )
    fi

    if [[ "${members:-$empty_member}" != $empty_member ]]; then

      clear_set new_matching_rows
      local filter_found=f

      for member in "${members[@]}"; do

        local -n index=${coord_type}_coordinate_index_${field}
        if [[ -v index[$member] ]]; then
          row_indexes=( ${index[$member]} )
          array_to_set row_indexes new_matching_rows
          filter_found=t
        else
          local index_count=${#index[*]}
          if (( index_count > 0 )); then
            # Accoridng to the index, no values exist in this table which match the known dim value
            clear_set matching_rows
            abort
          fi
        fi

      done; maybe_break

      if [[ $filter_found == t ]]; then
        intersect_with_all matching_rows new_matching_rows matching_rows
      fi

    fi

  done
}

# inputs:
#   check_dims
#   coordinate_data
#   coordinate_count
#   coordinate_rows
#   coordinate_fields_count
calc_coordinates_refine_multi() {
  begin_function

    local target_dim_var_type
    if [[ $seed_already_expanded == f ]]; then
      target_dim_var_type=sdims
    else
      target_dim_var_type=ddim
    fi

    local -A matching_rows
    matching_rows[all]=1

    #  This needs to filter existing rows
    #if [[ $seed_already_expanded == f ]]; then
      calc_coordinates_refine_get_matching_rows || fail
    #fi

    if (( ${#matching_rows[*]} == 0 )); then
      log_fatal "No coordinates are possible given user inputs and base possibility sets of the dimensions of this cell."
      log_fatal "Adjust your dimension specs to fit this cell."
      fail1
    fi

    local row_index needs_validation
    begin_for (( row_index = 0; row_index < coordinate_rows; row_index++ )); doo
      if [[ -v matching_rows[all] || -v matching_rows[$row_index] ]]; then

        local -A cross_dims_tried=()

        table=${coord_type}_coordinate \
        convert_table_to_dims || fail

        if [[ $seed_already_expanded == f ]]; then
          expand_dims $check_dims || fail
        fi

        needs_validation=t
        calc_coordinates_next_dim || fail
        log_debug "Finished coordinate row $((row_index+1)) of $coordinate_rows"

      fi
    end_for

  end_function
  handle_return
}

prep_seed_dims() {

  local dim dims
  for dim in ${!all_dims[*]}; do

    get_plural $dim dims

    local -n \
      ddim=d_$dim ddims=d_$dims \
      idim=i_$dim idims=i_$dims \

    ddim=${idim:-}
    ddims=${idims:-}

  done

}

calc_coordinates_slow() {
  begin_function

    local row_index=${row_index:-} \
      check_dims="${coordinate_fields[*]}" \
      validated_dims= \

    if [[ $target_form == seed ]]; then
      prep_seed_dims || fail
    fi

    local dim

    local -A cross_dims_tried=()
    begin_for dim in ${!all_dims[*]}; doo

      local -n idim=i_$dim \
        ddim=d_$dim \

      if [[ "${idim:-}" ]]; then
        ddim=$idim
      fi

      if [[ "${ddim:-}" ]]; then
        member=$ddim \
        set_cross_dims || fail
      fi

    end_for

    local total_coord_rows_added=0 needs_validation=t

    progress_bar_start
    if (( coordinate_rows > 0 )); then
      log_debug "Refining existing $coord_type dim coordinates"
      calc_coordinates_refine_multi || fail
    else
      # it is assumed that dims are already expanded before this point, and so ddims will be used
      local extra=
      if [[ $target_form == seed ]]; then
        extra="seed of "
      fi
      log_debug "Calculating $extra$coord_type cell coordinates for dims: ${coordinate_fields[*]}"
      calc_coordinates_next_dim || fail
    fi
    progress_bar_stop

    coordinate_data=( "${new_coordinate_data[@]}" )

  end_function
  handle_return
}

xlr8_get_dim_fields() {
  local dims=$*
  begin_function
    local field
    dim_fields=

    for dim in $*; do
      dim_fields+="
        dim_${dim}_aliases
        dim_${dim}_members
        "
    done
  end_function
  handle_return
}

make_coord_index() {
  begin_function

    local row_count field_count data_count coord_type=$coord_type

    local -n fields=${coord_type}_coordinate_fields \
      data=${coord_type}_coordinate_data \

    field_count=${#fields[*]}
    if (( field_count > 0 )); then
      data_count=${#data[*]}
      (( row_count = data_count / field_count ))
      table=${coord_type}_coordinate \
      make_table_index || fail
    fi

  end_function
  handle_return
}

# inputs:
#   coord_type
#   source       set to dims to load coordinates from existing dims
#                set to coords to using existing coordinates and attempt to fill in blanks
#   all ddims of that type OR existing coords
# assumes ddims are in array form (not space separated)
# assumes all checks were done previously to determine if this is needed
calc_coordinates() {
  local clear_existing_coords=${clear_existing_coords:-t} \
    coord_type=$coord_type \
    coord_limit=${coord_limit:-} \
    target_form=tree \
    seed_already_expanded=${seed_already_expanded:-f} \

  begin_function

    localize

    local dim_var \
      new_coordinate_data=() \
      problem_message= \
      coordinate_fields_count=0 \
      coordinate_count=0 \
      coordinate_rows=0 \
      derive_deep=t \

    unset row_index

    local -n coordinate_data=${coord_type}_coordinate_data \
      coordinate_fields=${coord_type}_coordinate_fields \

    if [[ $coord_type == *_seed ]]; then
      target_form=seed
    fi
    
    setup_coord_fields || fail

    if [[ $clear_existing_coords == t ]]; then
      coordinate_data=()
      # Skipping seeding as a test for now
      #if [[ $target_form == tree && -v ${coord_type}_seed_coordinate_fields ]]; then
      #  seed_table=${coord_type}_seed_coordinate \
      #  seed_coordinates || fail
      #  make_coord_index || fail
      #  seed_already_expanded=t
      #fi
    fi

    if [[ ! "${coordinate_fields:-}" ]]; then
      local -n refined=${coord_type}_coordinate_refined
      if [[ $target_form == seed ]]; then
        refined=f
      else
        refined=t
      fi
      abort
    fi

    coordinate_fields_count=${#coordinate_fields[*]}
    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))
    unknown_dims= resolved_dims=

    log_debug "Calculating ${coord_type} coordinates using fields: ${coordinate_fields[*]}"

    #if (( coordinate_fields_count <= 1 )); then
    #  if [[ $target_form == seed ]]; then
    #    log_debug "Too few fields found ($coordinate_fields_count) to generate useful $coord_type seed coords"
    #    refined=f
    #    abort
    #  else
    #  fi
    #fi

    if (( coordinate_fields_count == 0 )); then
      log_debug "No fields found to generate $coord_type coords"
      refined=t
      abort
    fi

    #if [[ ${xlr8:-f} == t ]]; then
    #  local -n fields=${coord_type}_coordinate_fields
    #  local dt dt_fields=
    #  for dt in ${derive_tables[*]}; do
    #    dt_fields+="${dt}_fields ${dt}_data "
    #  done
    #  local coord_fields="
    #    coordinate_data
    #    coordinate_count
    #    coordinate_rows
    #    coordinate_fields_count
    #  "
    #  local dim_fields
    #  local dim_type=trunk_dims
    #  xlr8_get_dim_fields ${trunk_dims_expanded[*]}
    #  xlr8 load_coordinates $coord_fields $dim_fields $fields $dt_fields || fail
    #else
      calc_coordinates_slow || fail
    #fi

    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))

    if (( coordinate_count == 0 )); then
      case ${handle_no_coords:-error} in
        error)
          if [[ "$problem_message" ]]; then
            log_fatal "$problem_message"
          fi
          log_fatal "Could not calculate any coordinate rows. Try specifying more dims."
          fail1
        ;;
        ignore)
          log_debug "Could not calculate any coordinate rows."
        ;;
        *)
          log_fatal "Invalid value for handle_no_coords: $handle_no_coords"
          fail1
        ;;
      esac
    fi

    #  Allowing this for now, to handle situations where support dims split the rows
    #if [[ $target_form == tree && $coord_type == branch && ${cell_is_leaf:-f} == t ]] \
    #   && (( coordinate_rows > 1 )); then
    #  log_fatal "Cell error: found more than one branch coordinate possibility on a leaf cell."
    #  fail1
    #fi

    # refine is used to determine if coords need to be calculated
    local -n refined=${coord_type}_coordinate_refined
    if [[ $target_form == seed ]]; then
      refined=f
    else
      refined=t
    fi

    log_debug "$coordinate_rows $coord_type coordinate rows found" 

  end_function
  handle_return
}

# Doesn't do anything at the moment
# only run if the cell is actually a leaf
build_context_leaf() {
  begin_function
    local context_type=leaf last_type=var
    log_debug "Building leaf context for $cell_path"

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    if [[ -e $context_path-$context_type.new ]]; then
      mv $context_path-$context_type.new $context_path-$context_type || fail
    fi

  end_function
  handle_return
}

# not sure this makes sense
calc_anchor_dims() {
  begin_function
    # all anchors and non-branch dim calculations are dynamic per command execution
    # and so can't be precalculated and stored in the context
    : ${anchor_dims:=${anchor_dims:-${default_anchor_dims:-}}}

    if [[ "$anchor_dims" ]]; then
      local new_anchors=
      for dim in $anchor_dims; do
        new_anchors+="$dim "
      done
      anchor_dims=${new_anchors% }
    else
      anchor_dims=${trunk_dims_expanded[*]}
    fi

    if [[ "${branch_dims:-}" && "$branch_dims" != "$anchor_dims" ]]; then
      local branch_dim
      for branch_dim in ${branch_dims[*]}; do
        remove_word_from_string anchor_dims $branch_dim
      done
      if [[ "$anchor_dims" ]]; then
        anchor_dims="${branch_dims[*]} $anchor_dims"
      else
        anchor_dims="${branch_dims[*]}"
      fi
    fi
  end_function
  handle_return
}

get_highest_trunk_context_cell() {
  begin_function
    local parent_cell=${cell_path%/*}
    while [[ -e $parent_cell/.cyto/context-trunk ]]; do
      parent_cell=${parent_cell%/*}
    done
    if [[ -e $parent_cell/.cyto/context-trunk ]]; then
      highest_trunk_context_cell=$parent_cell
    fi
  end_function
  handle_return
}

get_group_dims() {
  begin_function
    local group_path=$1 contents item dim
    contents=$(find1 $group_path -type d -not -name ".*" | sort) || fail
    begin_for item in $contents; doo
      item=$(realpath $item) || fail
      dim=${item##*/}
      if [[ $dim == _* ]]; then
        get_group_dims $item || fail
      else
        group_dims+="$dim "
      fi
    end_for
  end_function
  handle_return
}

# inputs:
#   lib_dim_path
#   cache_path
make_dim_cache() {
  begin_function

    log_debug "Generating dim cache for $lib_dim_path"

    if [[ -f $cache_path.new ]]; then
      rm $cache_path.new || fail
    fi

    local dim_paths dim_path dim context_file=$cache_path.new
    local -A dim_group=()
    dim_paths=$(find1 $lib_dim_path -type d -not -name ".*" | sort) || fail

    for dim_path in $dim_paths; do
      dim=${dim_path##*/}
      if [[ $dim == _* ]]; then
        local group_dims=
        get_group_dims $dim_path || fail
        dim_group[$dim]="$group_dims"
      else
        build_dim_info_single $dim_path || fail
      fi
    done

    write_vars_to_context \
      dim_group \
      secret_vars \
      all_dims \
      dim_shorts \
      || fail

    mv $cache_path.new $cache_path || fail

  end_function
  handle_return
}

load_dim_caches() {
  local work_path=$1
  begin_function

    if [[ $work_path == /*/*/* ]]; then
      load_dim_caches ${work_path%/*} || fail
    fi

    local lib_dim_path=$work_path/.lib/dim

    if [[ -d $lib_dim_path ]]; then
      local dt files links link type is_generated \
        cache_path=$work_path/.lib/dim-cache \
        real_path real_path_parent \

      dim_caches+="$cache_path "

      if [[ ! -f $cache_path ]]; then
        fork make_dim_cache || fail
      fi

      source $cache_path || fail

    fi

  end_function
  handle_return
}

build_branch_seed_coords() {
  begin_function
    local parent_coord_path=${cell_path%/*}/.cyto/context-branch-coords \
      seed_already_expanded=f \
      clear_existing_coords=t \

    if [[ -f $parent_coord_path ]]; then
      source $parent_coord_path || fail
      seed_already_expanded=t
      clear_existing_coords=f
    fi

    local coord_type=branch_seed
    calc_coordinates || fail
    make_coord_index || fail

    if [[ "${branch_seed_coordinate_data:-}" ]]; then
      write_coordinates_to_shell_file $context_path-branch-coords || fail
    fi
  end_function
  handle_return
}

build_context() {
  local cell_path=$1
  begin_function

    load_dim_caches $cell_path || fail
    load_derive_caches $cell_path || fail

    if [[ ! -f $context_path-trunk ]]; then
      local trunk_context_path=$trunk_cell/.cyto/context
      if [[ $cell_is_trunk == t || ! -f $trunk_context_path-trunk ]]; then
        context_path=$trunk_cell/.cyto/context \
        build_context_trunk || fail
      else
        source $trunk_context_path-trunk || fail
      fi
      if [[ $cell_is_trunk == f ]]; then
        safe_link $trunk_context_path-trunk $context_path-trunk || fail
      fi
    else
      source $context_path-trunk || fail
    fi

    setup_dims || fail

    if [[ ! -f $context_path-branch ]]; then
      build_context_branch || fail
    else
      source $context_path-branch || fail
    fi

    #  disabling seeding for now
    #if [[ "${trunk_dims_expanded:-}" ]]; then
    #  if [[ ! -f $context_path-branch-coords ]]; then
    #    build_branch_seed_coords || fail
    #  else
    #    source $context_path-branch-coords || fail
    #  fi
    #fi

    #  unused at the moment
    #if [[ $cell_is_leaf == t ]]; then
    #  if [[ ! -f $context_path-leaf ]]; then
    #    build_context_leaf || fail
    #  else
    #    source $context_path-leaf || fail
    #  fi
    #fi

    if [[ -e $context_path.new ]]; then
      rm $context_path.new || fail
    fi

    local dim_cache derive_cache

    begin_for dim_cache in ${dim_caches:-}; doo
      cat $dim_cache >>$context_path.new || fail
    end_for

    begin_for derive_cache in ${derive_caches:-}; doo
      cat $derive_cache >>$context_path.new || fail
    end_for

    if [[ -e $context_path-trunk ]]; then
      cat $context_path-trunk >>$context_path.new || fail
    fi

    local dim_type dim
    for dim_type in trunk_dims support_dims sub_dims control_props data_props; do
      local -n dim_array=${dim_type}_expanded
      for dim in ${dim_array[*]}; do
        local -n dt=dim_${dim}_type
        dt=$dim_type
        write_vars_to_context dim_${dim}_type || fail
      done
    done

    if [[ -e $context_path-branch ]]; then
      cat $context_path-branch >>$context_path.new || fail
    fi

    if [[ -e $context_path-leaf ]]; then
      cat $context_path-leaf >>$context_path.new || fail
    fi

    if [[ -e $context_path.new ]]; then
      mv $context_path.new $context_path || fail
    fi

  end_function
  handle_return
}

# inputs:
#   $1   cell path to search for branches
#   dim  dimension to gather members of
get_members_from_branches() {
  local cell_path=$cell_path dim=$dim
  begin_function
    local branch_folders folder value
    branch_folders=$(find1 $cell_path -name "$dim:*" -type d) || fail
    values=()
    for folder in ${branch_folders}; do
      local member_var_path=$folder/.member
      if [[ -f $member_var_path ]]; then
        value=$(<$member_var_path) || fail
      else
        value=${folder##*:}
      fi
      values+=( "$value" )
    done
  end_function
  handle_return
}

# 'value' is the loop var
parallel_loop() {
  local loop_over_var2=$loop_over_var head2=${head:-} \
    body2=$body tail2=${tail:-} \
    par2=$par fork2=$fork \

  local log_show_vars='loop_over_var=loop_over_var2 par=par2 fork=fork2'
  begin_function_lo

    # Make sure these variables don't get passed into inner loops
    local loop_over_var= head= body= tail= par= fork=
    local -n array=$loop_over_var2

    if [[ ! -v array ]]; then
      log_fatal "Internal error: Variable doesn't exist: $loop_over_var2"
      fail1
    fi

    local parallel=f size=${#array[*]}
    if [[ $size -gt 1 && $parallel_execution == t && $par2 == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi

    local processes= value
    leave_loop=0

    local extra
    if [[ $parallel == t ]]; then
      extra=" in parallel"
    else
      extra=" sequentially"
    fi

    if (( size > 1 )); then
      log_debug "Looping over $size values$extra. body: $body2"
    fi

    begin_for value in "${array[@]}"; doo

      log_debug "Current iteration value=$value"

      if [[ "$head2" ]]; then
        eval "$head2" || fail
      fi

      if [[ $parallel == t ]]; then
        fork_bg "$body2" 
        processes+=" $!"
      else
        if [[ $fork2 == t ]]; then
          fork_fg "$body2" || fail
        else
          eval "$body2" || fail
        fi
      fi

      if [[ "$tail2" ]]; then
        eval "$tail2" || fail
      fi

    end_for

    wait_for_sub_processes || fail

  end_function
  handle_return
}

for_each_member_single() {
  local -I dim command_history
  local -n ddim=d_$dim
  ddim=$values
  local member=$values
  log_debug "Current iteration value=$member"
  unset value values
  $function || return 1
}

for_each_member_multi() {
  begin_function_lo

    member_count=${#values[*]}

    # don't refine the upstream link if there would be multiple matches
    local upstream_cell_link=

    if (( member_count == 0 )); then
      log_fatal "No members found for $dim"
      fail1
    fi

    unset dim_members dims_members
    loop_over_var=values \
      head="local -I dim command_history
        local d_$dim=\"\$value\" d_$dims
        local member=\$d_$dim
        unset value values
        " \
      body=$function \
      tail='
        if [[ $leave_loop -gt 0 ]]; then
          break
        fi
        ' \
      parallel_loop || fail

  end_function
  handle_return
}

# input: 
#   $1=dim
#   function=function to execute for each member
#   fork=whether the process should be forked before executing 
#     the function. (optional)
for_each_member() {
  local dim=$1 \
    function=$function leave_loop=${leave_loop:-0} \
    fork=${fork:-t} \
    par=${par:-t} \
    cell_path=${cell_path:-} \

  local log_vars='fork par' \
    log_show_vars='dim function'
  begin_function

    local dims values=() member_count=0 \

    get_plural $dim dims

    local -n coord_fields=branch_coordinate_fields \
        dims_members=d_$dims dim_members=d_$dim \

    if [[ -v coord_fields[*] && " ${coord_fields[*]} " == *" $dim "* ]]; then
      coord_type=branch \
      fetch_values_from_coordinates || fail
    elif [[ "${dim_member:-}" ]]; then
      values=( "$dim_member" )
    elif [[ "${dim_members:-}" ]]; then
      values=( "${dim_members[@]}" )
    fi

    member_count=${#values[*]}

    if (( member_count == 0 )); then
      log_fatal "Failed to resolve required dim: $dim. Either specify the value directly, or specify a dim that this can be derived from. See cell help for more info (cell . ??)"
      fail1
    elif (( member_count == 1 )); then
      for_each_member_single || fail
    else
      for_each_member_multi || fail
    fi

  end_function
  handle_return
}

# input:
#   from_file
#   to_file
#   key_path
#   tmp_path
cell_decrypt_file() {
  local from_file=$1 to_file=$2 user=${safe_user:-$USER} \
    user_private_key=${user_private_key:-~/.ssh/id_rsa} \
    ignore_failure=${ignore_failure:-f} \

  begin_function

    if [[ ! "$key_path" || ! -d "$key_path" ]]; then
      if [[ $ignore_failure == f ]]; then
        log_fatal "No key path was found. Use 'cell safe key add' to create the first key."
        fail1
      else
        log_warn "Could not decrypt file $from_file because key_path doesn't exist"
        abort
      fi
    fi

    if [[ ! -f $key_path/$user.key ]]; then
      if [[ $ignore_failure == f ]]; then
        log_fatal "No key was found for user $user in key_path $key_path. Use 'cell safe key add' to create a key for this user."
        fail1
      else
        log_warn "Could not decrypt file $from_file because user $user doesn't have a key"
        abort
      fi
    fi

    validate_user_key $key_path/$user.key || fail

    if [[ ! -d $tmp_path ]]; then
      mkdir $tmp_path || fail
    fi

    local mk_path=$tmp_path/mk
    defer "rm $mk_path"
    extract_master_key $key_path/$user.key $mk_path || fail
    master_key=$mk_path \
    simple_decrypt $from_file $to_file || fail

  end_function
  handle_return
}

plant_seed_internal() {
  local from=$1 to=$2 contents x x_part deep=${deep:-t} \
    cell_is_leaf=${cell_is_leaf:-t}

  begin_function

    if [[ ! -d $to ]]; then

      log_verbose "Planting seed from $from to $to"

      if [[ $from == /seed/* && -d $from ]]; then
        plant_seed_internal ${from%/*} ${to%/*} || fail
      else
        log_fatal "Seed doesn't exist for $to"
        fail1
      fi

    else

      contents=( $(find1 $from | sort -g) ) || fail
      local target
      begin_for x in ${contents[*]}; doo
        x_part=${x##*/}
        target=$to/$x_part
        if [[ -d $x ]]; then
          if [[ ! -e $target ]]; then
            if [[ $x_part == .dna || $x_part == .root ]]; then
              safe_link $(realpath $x) $to/ || fail
            elif [[ $x_part == .lib ]]; then
              mkdir $target || fail
              safe_link $(realpath $x)/* $target/ || fail
            elif [[ $x_part == .mock && "${current_mock:-f}" != f && -d $x/$current_mock ]]; then
              safe_link $(realpath $x)/$current_mock/!(export) $to/ || fail
            elif [[ $x_part == *:* ]]; then

              if [[ "${branch_coordinate_fields:-}" ]]; then
                local dim_part=${x_part%%:*} \
                  mem_part=${x_part#*:}

                if [[ ! $dim_part =~ ^[a-zA-Z0-9_]+$ ]]; then
                  log_fatal "Invalid dim name: $dim_part, found in $x"
                  fail1
                fi

                local values
                coord_type=branch \
                dim=$dim_part \
                fetch_values_from_coordinates $dim_part || fail

                local value_count=${#values[*]}

                # Hashed members currently not supported
                # Not too hard to implement, but isn't likely to be needed
                if (( value_count == 1 )) && [[ "$values" == "$mem_part" ]]; then
                  plant_seed_internal $x $to || fail
                fi
              fi

            elif [[ $x_part != .* ]]; then
              mkdir $target || fail
            fi
          fi
          if [[ $x_part != .* && -d $target && $deep == t ]]; then
            plant_seed_internal $x $target || fail
          fi
        elif [[ $cell_is_leaf == t && ! -e $target && $x_part != .* ]]; then
          if [[ $x == *.safe ]]; then
            ignore_failure=t \
            cell_decrypt_file $x ${target%.safe} || fail
          else
            cp -a $x $to/ || fail
          fi
        fi
      end_for

    fi
  end_function
  handle_return
}

# inputs: $1  work path to the cell
plant_seed() {
  local seed_path from=$1 to=${2:-$1} \
    deep=${deep:-t} \
    ignore_nonexistent=${ignore_nonexistent:-f}

  begin_function

    if [[ ! -d "$to" ]]; then
      log_fatal "plant_seed called on a non-existant work path: $to"
      fail1
    fi

    find_seed_path $from || fail
    if [[ ! "$seed_path" ]]; then
      log_fatal "No seed is associated with this path: $to"
      fail1
    fi

    local dna_path=$seed_path
    if [[ $command_requires_cell == t ]]; then
      while [[ ! -d $dna_path/.dna ]]; do
        dna_path=${dna_path%/*}
        if [[ $dna_path != /*/* ]]; then
          log_fatal "Could not find dna in seed: $seed_path"
          fail1
        fi
      done

      if [[ $dna_path != $seed_path ]]; then
        safe_link $dna_path/.dna $to/ || fail
      fi

    fi

    plant_seed_internal $seed_path $to || fail

  end_function
  handle_return
}

init_coord() {
  local coord_type=$1
  local -n \
    coordinate_data=${coord_type}_coordinate_data \
    coordinate_fields=${coord_type}_coordinate_fields \
    seed_table_fields=to_${coord_type}_coords_fields \
    seed_table_data=to_${coord_type}_coords_data \

  coordinate_data=() \
  coordinate_fields=() \
  seed_table_fields=() \
  seed_table_data=() \

}

load_repo_paths() {
  declare -gA repo_paths
  begin_function
    local repo repos
    repos=$(find1 /repo -not -name '.*' -type d) || fail
    begin_for repo in $repos; doo
      if [[ -d $repo/seed ]]; then
        local module modules
        modules=$(find1 $repo/seed -not -name '.*' -type d) || fail
        for module in $modules; do
          module=${module##*/}
          repo_paths[$module]=$repo
        done
      fi
    end_for
  end_function
  handle_return
}

broken_link_check() {
  begin_function
    local broken_links
    broken_links=( $(find -L $cyto_path -type l -print -o -name ".*" -prune) ) || fail
    if [[ "${broken_links:-}" ]]; then
      log_debug "Broken links found in cyto: $broken_links. Will rebuild cyto."
      problem_found=t
    fi
  end_function
  handle_return
}

link_single() {
  local only_one=${only_one:-f}
  begin_function

    extract_simple_name choice_name o choice_name
    local choice_var=${choice_name//-/_}

    if [[ $only_one == t ]]; then
      local -n choice_path=up_${up_var}_path
    else
      local -n choice_path=up_${up_var}_choices_${choice_var}_path
    fi

    if [[ ! -v choice_path ]]; then
      log_fatal "Missing choice path var"
      fail1
    fi

    if [[ ! -d $choice_path ]]; then
      log_fatal "Missing choice path"
      fail1
    fi

    if [[ $only_one == t ]]; then
      safe_link $choice_path $dep_path || fail
    else
      safe_link $choice_path $dep_path/choices/$choice_name || fail
    fi

  end_function
  handle_return
}

# inputs: dep_path up_name 
link_choices() {
  begin_function
    local choice_var choice_name o
    begin_for choice_name in ${choices[*]}; doo
      link_single || fail
    end_for
  end_function
  handle_return
}

make_cyto_reactors() {
  begin_function
    mkdir $reactor_path || fail
    local reactor_name
    for reactor_name in ${reactors[*]}; do
      local dep_path=$reactor_path/$reactor_name \
        reactor_var=${reactor_name//-/_}
      local -n path=reactors_${reactor_var}_path
      if [[ ! -v path ]]; then
        log_fatal "Missing reactor path var"
        fail1
      fi
      if [[ ! -d $path ]]; then
        log_fatal "Missing reactor path"
        fail1
      fi
      safe_link $path $dep_path || fail
    done; maybe_break
  end_function
  handle_return
}

make_cyto_up_single() {
  local up_name=$1
  begin_function
    local dep_path=$up_path/$up_name \
      up_var
    local up_var=${up_name//-/_}
    local -n choices=up_${up_var}_choices
    if [[ -v choices ]]; then
      mkdir -p $dep_path/choices || fail
      link_choices || fail
    else
      local choice_name=$up_name
      if [[ -d $dep_path ]]; then
        rm -rf $dep_path || fail
      fi
      only_one=t link_single || fail
    fi
  end_function
  handle_return
}

make_cyto_up() {
  begin_function
    if [[ ! -e $up_path ]]; then
      mkdir $up_path || fail
    fi
    local up_name o
    begin_for up_name in ${up[*]}; doo
      make_cyto_up_single $up_name || fail
    end_for
  end_function
  handle_return
}

make_cyto_validator_single() {
  local validator_name=$1
  begin_function

    local validator_var=${validator_name//-/_} \
      dep_path \

    validator_var=${validator_var%%,*}
    validator_var=${validator_var%%:*}
    dep_path=$validator_path/$validator_var \

    if [[ -d $dep_path ]]; then
      rm -rf $dep_path || fail
    fi

    local -n choice_path=validator_${validator_var}_path
    safe_link $choice_path $dep_path || fail

  end_function
  handle_return
}

make_cyto_validator() {
  begin_function
    if [[ ! -e $validator_path ]]; then
      mkdir $validator_path || fail
    fi
    local validator_name o
    begin_for validator_name in ${validator[*]}; doo
      make_cyto_validator_single $validator_name || fail
    end_for
  end_function
  handle_return
}

get_required_freshness() {
  required_freshness=${fresh:-${default_freshness:-}}

  # this can be used in upstream prep functions to pass freshness to upstream
  : ${top_fresh:=$required_freshness}

  return 0
}

# inputs:
#   $*   the dims to check, must use short dims (like trunk_dims, etc)
any_dim_is_set() {
  local dim dims is_set=f
  for dim in $*; do
    get_plural $dim dims
    local -n ddim=d_${dim} ddims=d_${dims}
    if [[ "${ddim:-}" || "${ddims:-}" ]]; then
      is_set=t
      break
    fi
  done
  [[ $is_set == t ]]
}

dim_is_missing_from_coords() {
  local dim is_missing=f
  for dim in $*; do
    local coord_fields=${coord_type}_coordinate_fields
    if [[ " ${coord_fields[*]:-} " != *" $dim "* ]]; then
      is_missing=t
      break
    fi
  done
  [[ $is_missing == t ]]
}

calc_coords_branch() {
  begin_function
    local coord_type=branch
    if [[ "${branch_coordinate_refined:-}" != t ]]; then
      if [[ -v branch_coordinate_data ]]; then
        local dims_to_check="${trunk_dims_expanded[*]} ${support_dims_expanded[*]}"
        local skip=t

        if dim_is_missing_from_coords $dims_to_check; then
          skip=f
          log_debug "Not skipping coordinate refinement since seed coord fields don't match tree coord fields"
        fi

        if any_dim_is_set $dims_to_check; then
          skip=f
          log_debug "Not skipping coordinate refinement since dim filters were set"
        fi

        if [[ $skip == f ]]; then
          seed_already_expanded=t \
          clear_existing_coords=f \
          calc_coordinates || fail
        else
          log_debug "Skipping coordinate refinement since no dim filters were set"
        fi

      else
        calc_coordinates || fail
      fi
    fi
  end_function
  handle_return
}

# should only be executed on leaf cells
calc_coords_leaf() {
  begin_function

    local coord_type=leaf
    if [[ "${leaf_coordinate_refined:-}" != t ]]; then
      calc_coordinates || fail
    fi

    local leaf_coordinate_field_count=${#leaf_coordinate_fields[*]}
    local leaf_coordinate_data_count=${#leaf_coordinate_data[*]}
    if (( leaf_coordinate_field_count > 0 && leaf_coordinate_data_count > 0 )); then

      local leaf_coordinate_rows=$(( leaf_coordinate_data_count / leaf_coordinate_field_count ))

      if (( leaf_coordinate_rows == 1 )); then
        target_dim_var_type=ddim \
        table=${coord_type}_coordinate \
        convert_table_to_dims || fail
      fi

    fi

  end_function
  handle_return
}

# should only be executed on leaf cells
calc_coords_sub() {
  begin_function

    local coord_type=sub
    if [[ "${sub_coordinate_refined:-}" != t ]]; then
      calc_coordinates || fail
    fi

    local sub_coordinate_field_count=${#sub_coordinate_fields[*]}
    local sub_coordinate_data_count=${#sub_coordinate_data[*]}
    if (( sub_coordinate_field_count > 0 && sub_coordinate_data_count > 0 )); then

      local sub_coordinate_rows=$(( sub_coordinate_data_count / sub_coordinate_field_count ))

      if (( sub_coordinate_rows == 1 )); then
        target_dim_var_type=ddim \
        table=${coord_type}_coordinate \
        convert_table_to_dims || fail
      fi

    fi

  end_function
  handle_return
}

load_post_context_dynamic_vars() {
  begin_function

    if [[ $cell_is_leaf == t && "${trunk_dims_expanded:-}" && -v branch_coordinate_fields ]]; then
      target_dim_var_type=ddim \
      table=branch_coordinate \
      convert_table_to_dims || fail
    fi

    get_required_freshness || fail

    if [[ ! "${seed_path:-}" ]]; then
      find_seed_path $cell_path || fail
    fi

    mock_path=$seed_path/.mock

    current_mock=f
    if [[ -e $cell_path/.mock ]]; then
      current_mock=$(<$cell_path/.mock) || fail
    fi

    if [[ "${force_mock:-}" \
       && ( $force_mock == f || -d $mock_path/$force_mock ) \
       && $current_mock != $force_mock ]]; then
      log_debug "Changing mock: $current_mock -> $force_mock (because of force_mock parameter)"
      current_mock=$force_mock
      echo "$force_mock" >$cell_path/.mock || fail
    elif [[ -f $cell_path/.mock ]]; then
      :
    elif [[ -f $trunk_cell/.mock ]]; then
      local trunk_seed
      find_seed_path $trunk_cell trunk_seed || fail
      #mock_path=$trunk_seed/.mock
    elif [[ "${mock:-}" && -d $mock_path/$mock && $current_mock != $mock ]]; then
      log_debug "Changing mock: $current_mock -> $mock (because of mock parameter)"
      current_mock=$mock
      echo "$mock" >$cell_path/.mock || fail
    else
      current_mock=f
    fi

    if [[ $current_mock != f && $current_mock != disabled && ! -d $mock_path/$current_mock ]]; then
      log_fatal "Invalid mock in $short_cell: $current_mock doesn't exist in $mock_path"
      fail1
    fi

    if [[ "${out_path_relative:-}" ]]; then
      out_path=$cell_path/$out_path_relative
    else
      out_path=$cell_path
    fi

  end_function
  handle_return
}

build_cyto() {
  local cell_path=$1

  begin_function

    log_debug "Building cyto for $short_cell"
    dna_path=$cell_path/.dna \
    cyto_path=$cell_path/.cyto \

    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    if [[ ! -d $status_path ]]; then
      mkdir $status_path || fail
    fi

    #  This already happened earlier
    #init_context || fail
    load_branch_info || fail
    find_seed_path $cell_path || fail

    if [[ ! -f $context_path ]]; then
      build_context $cell_path || fail
    fi

    if [[ $cell_is_leaf == t ]]; then
      if [[ "${up:-}" && ! -d $up_path ]]; then
        make_cyto_up || fail
      fi

      if [[ "${validator:-}" && ! -d $validator_path ]]; then
        make_cyto_validator || fail
      fi

      if [[ "${reactors:-}" && ! -d $reactor_path ]]; then
        make_cyto_reactors || fail
      fi
    fi

  end_function
  handle_return
}

check_foundation() {
  begin_function
    if [[ -f $dna_path/cell_is_foundation.var && ! -v cell_is_foundation ]]; then
      context_type= \
      prefix= \
      load_dna_item $dna_path/cell_is_foundation.var || fail
    fi

    if [[ $cell_path != */foundation/* 
       && -d $module_path/foundation/all 
       && ! -d $module_path/foundation/all/.cyto
       && ${cell_is_foundation:-f} == f
       ]]; then
      log_fatal "Foundation cells have not been updated, so update can't proceed. Update $module_path/foundation/all before attempting to update other cells."
      fail1
    fi
  end_function
  handle_return
}

# inputs:
#   $1   cell_path
#   anchor_dims (as a space separated string)
# load_branch_info should be executed BEFORE this
# setup_dims should usually be executed AFTER this
# followed by calc_coords
switch_context() {
  cell_path=$1
  module_path=${cell_path#/*/*/}
  module_path=${cell_path%/$module_path}

  if [[ "${last_context_loaded:-}" != $cell_path ]]; then

    local log_show_vars=^cell_path rebuild_attempted=f
    begin_function

      get_short_cell
      log_debug "Loading context for $short_cell"

      if [[ "$cell_path" == /seed/* ]]; then
        log_fatal "Can't switch contexts to a seed path. Make sure to run this command in a work folder."
        fail1
      fi

      dna_path=$cell_path/.dna \
      cyto_path=$cell_path/.cyto \

      local dna_exists=f
      if [[ -e $dna_path ]]; then
        dna_exists=t
      fi

      if [[ $dna_exists == t ]]; then
        if [[ "$clean_cells" ]]; then
          local cell_to_clean
          cells_already_cleaned=${cells_already_cleaned:-}
          if [[ " $cells_already_cleaned " == *" $cell_path "* ]]; then
            log_debug "Cell already cleaned: $cell_path"
          else
            begin_for cell_to_clean in $clean_cells; doo
              if [[ /$cell_path/ == */$cell_to_clean/* ]]; then
                if [[ -e $cyto_path ]]; then
                  log_info "Cleaning cell ${cell_to_clean#/work/*/} => $short_cell..."
                  rm -rf $cell_path/!(.*) $cyto_path || fail
                else
                  log_info "Cell already clean: $cell_to_clean => $short_cell"
                fi
                cells_already_cleaned+=" $cell_path"
                break
              fi
            end_for
          fi
        fi
      fi

      context_path=$cyto_path/context
      init_context || fail

      seed_path=
      if [[ $dna_exists == t ]]; then

        check_foundation || fail

        if [[ ! -f $context_path ]]; then
          fork build_cyto $cell_path || fail
        fi

        source $context_path || fail

        #  this is now built into the context
        #if [[ "$derive_caches" ]]; then
        #  local derive_cache
        #  for derive_cache in $derive_caches; do
        #    if [[ -f $derive_caches ]]; then
        #      source $derive_cache || fail
        #    else
        #      log_fatal "Internal error: Derive cache is expected to exist at this point but is missing."
        #      fail1
        #    fi
        #  done
        #fi

        #if [[ -f $context_path-branch-coords ]]; then
        #  source $context_path-branch-coords || fail
        #fi

        setup_dims || fail

        local problem_found=f
        broken_link_check || fail
        if [[ $problem_found == t ]]; then
          if [[ $rebuild_attempted == f ]]; then
            log_verbose "Problem found, rebuilding context"
            rm -rf $cyto_path/up* $context_path* || fail
            rebuild_attempted=t
            continue
          else
            log_fatal "Context rebuild failed to resolve problem"
            fail1
          fi
        fi
      fi

      load_post_context_dynamic_vars || fail

      if [[ ! -f $context_path-check ]]; then
        context_type=check \
        write_vars_to_context \
          out_file \
          out_path \
          cell_is_leaf \
          check_op_var \
          data_props_expanded \
          default_freshness \
          || fail
        mv $context_path-check.new $context_path-check || fail
      fi

      last_context_loaded=$cell_path

      error_if_unresolved=t \
      handle_questions || fail

    end_function
    handle_return

  else
    log_debug "Context already loaded: $short_cell"
  fi

  return 0
}

cell_open_log_file() {
  begin_function
    if [[ ! "${log_path:-}" ]]; then
      # can't log until this is set
      abort
    fi
     
    if [[ "${omni_log_job_id:-0}" != 0 ]]; then

      cell_log_file_stack+=( $logging_to_file )

      omni_log_fork_id=${omni_log_fork_parent:-}-${omni_log_fork_child}
      omni_log_fork_id=${omni_log_fork_id#-}

      local new_log_file=$log_path/$omni_log_job_id:$omni_log_fork_id.olog
      local first_log_path=${new_log_file%/*}/first.olog
      if [[ ! -f $first_log_path ]]; then
        from_must_exist=f \
          safe_link $new_log_file $first_log_path || fail
      fi

      log_function=${FUNCNAME[1]} \
        change_log_file || fail

    fi
  end_function
  handle_return
}

cell_close_log_file() {
  begin_function
    if [[ "${cell_log_file_stack:-}" ]]; then
      local previous_log=${cell_log_file_stack[-1]}
      unset cell_log_file_stack[-1]
      log_function=${FUNCNAME[1]} \
        new_log_file=$previous_log \
        resume_existing_log=t \
        logging_to_file= \
        change_log_file || fail
    fi
  end_function
  handle_return
}

get_job_id() {
  begin_function

    if [[ ! -v job_id_log ]]; then
      log_fatal "Internal error: Missing job_id_log"
      fail1
    fi

    if [[ ! -d ${job_id_log%/*} ]]; then
      mkdir ${job_id_log%/*} || fail
    fi

    timeout=5 lock_path=$job_id_log fd_write_lock || {
      log_fatal "Failed to get lock on $job_id_log" 
      fail1
    }

    if [[ -f "$job_id_log" ]]; then
      local last_id=$(tail -n1 $job_id_log | awk '{print $1}')
      (( omni_log_job_id = last_id + 1 ))
    else
      omni_log_job_id=1
    fi

    if [[ ! "$command_to_log" ]]; then
      log_fatal "Missing command to log."
      fail1
    fi

    echo "$omni_log_job_id $cell_path $command_to_log" >>$job_id_log || fail

    fd_unlock

    log_return_vars=omni_log_job_id
  end_function
  handle_return
}

execute_command_log_prep() {
  begin_function
    local cyto_path=$cell_path/.cyto
    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    local job_path=$cyto_path/job
    if [[ ! -d $job_path ]]; then
      mkdir $job_path || fail
    fi

    if [[ "${omni_log_job_id:-0}" == 0 ]]; then
      job_start_time=${EPOCHREALTIME//./}
      command_to_log="${original_cmd#* }" \
        get_job_id || fail
    fi

    current_job_path=$job_path/$omni_log_job_id
    if [[ ! -d $current_job_path ]]; then
      mkdir $current_job_path || fail
    fi

    # only set this for the first cell in the job, all other cells should 
    #   use the same fork_id log so that they all have unique ids across the job
    if [[ ! "${fork_id_log:-}" ]]; then
      fork_id_log=$current_job_path/fork-id-log
    fi

    log_path=$current_job_path/log
    if [[ ! -d $log_path ]]; then
      mkdir $log_path || fail
    fi

    background_log=$log_path/background
    running_job_path=$job_path/running

    local link_target
    begin_for link_target in $cell_command-attempt attempt; doo
      if [[ -e "$job_path/last-$link_target" ]]; then
        mv $job_path/last-$link_target $job_path/prev-$link_target || fail
      fi
      safe_link $current_job_path $job_path/last-$link_target || fail
    end_for

  end_function
  handle_return
}

validate_command_parameters() {
  begin_function
    local name required type=command
    local -n parameter_names=parameter_names_$type \
      parameter_defaults=parameter_defaults_$type \
      parameter_required=parameter_required_$type \

    if [[ "${parameter_names:-}" ]]; then
      for (( index = 0; index < ${#parameter_names[*]}; index++ )); do
        name=${parameter_names[$index]}
        required=${parameter_required[$index]}
        local -n parameter_var=$name
        if [[ ! "${parameter_var:-}" && $required == t ]]; then
          while true; do
            choose "Enter required parameter (use ? if you need help): $name=" parameter_var || fail
            if [[ "$parameter_var" == \? ]]; then
              show_parameter_help_single || fail
              continue
            fi
            break
          done
        fi
      done; maybe_break
    fi
  end_function
  handle_return
}

prep_fork() {
  begin_function_lo

    change_log2=${change_log:-}
    # Prevents this variable from bleeding through to lower called functions
    change_log=

    if [[ $change_log2 == t && $disable_log == f ]]; then
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    if [[ "$fork_id_current" ]]; then
      fork_id_current=$fork_id_current.$debug_id_current
    else
      fork_id_current=$debug_id_current
    fi
    debug_id_current=0
    fork_debug_id=$fork_id_current.0

    cleanup_on_exit=
    setup_exit_trap

  end_function
  handle_return
}

reply_to_caller() {
  if [[ "${reply_file:-}" ]]; then
    echo "$*" >>$reply_file || return 1
  fi
  return 0
}

# this should be run in a subshell
fork_inside() {
  begin_function_lo

    local change_log2
    prep_fork || fail

    if [[ "$to_var" ]]; then
      eval "$to_var=\$($fork_command)"; return_code=$?
      reply_to_caller "$to_var='${!to_var}'" || fail
    else
      eval "$fork_command"; return_code=$?
    fi

    if [[ $change_log2 == t ]]; then
      cell_close_log_file || fail
    fi

    if [[ "${debugging:-}" == t ]]; then
      reply_to_caller "debugging=t" || fail
    fi

    if (( return_code != 0 )); then
      reply_to_caller "return_code=$return_code" || fail
      return_value=$return_code
    fi

    if [[ $change_log2 == t ]]; then
      reply_to_caller "omni_log_pos=$previous_log_pos" || fail
    fi

    if [[ "${command_successful:-}" ]]; then
      reply_to_caller "command_successful=$command_successful" || fail
    fi

    if [[ "${debug_log_level_filter:-}" ]]; then
      reply_to_caller "debug_log_level_filter=$debug_log_level_filter" || fail
    fi

    if [[ "${trace_vars:-}" ]]; then
      copy_map trace_var_old trace_var_sub
      local s="unset trace_var_sub; $(declare -p trace_var_sub)" 
      s=${s/ -A / -Ag }
      reply_to_caller "$s" || fail
    fi

    if (( ${progress_bar_nesting:-0} > 0 )); then
      reply_to_caller "progress_bar_total=${progress_bar_total:-}
progress_bar_nesting=${progress_bar_nesting:-}
progress_bar_front_load=${progress_bar_front_load:-}
progress_bar_start_time=${progress_bar_start_time:-}
progress_bar_current=${progress_bar_current:-}
" || fail
    fi

  end_function
  handle_return
}

# run outside of the subshell afterwards
after_fork() {
  begin_function_lo
    if [[ -f "${reply_file:-}" ]]; then
      #pause "Sourcing $reply_file."
      #echo "$(<$reply_file)" >&$fd_original_err
      source $reply_file || fail
      if [[ ${debugging:-f} == t ]]; then
        [[ "${debug_debug:-f}" == t ]] && echo "debugging=$debugging, so starting debugging after fork" >&$fd_original_err

        debug_immediate=f \
        first_run=f \
        debugging=f \
        debug_skip_breakpoints=f \
        debug_start

      fi
      if [[ "${debug_log_level_filter:-}" ]]; then
        local log=$debug_log_level_filter
        resolve_log_var
        log_format=default
        log_level_filter_changed
      fi
      rm $reply_file
      reply_file=
    fi
  end_function
  handle_return
}

get_new_reply_file() {
  reply_file=$tmp_folder/reply.$BASHPID
  if [[ -f $reply_file ]]; then
    log_fatal "reply_file already exists: $reply_file"
    return 1
  fi
  return 0
}

before_fork() {
  begin_function_lo

    if [[ ${background:-f} == t ]]; then
      change_log=t
    fi

    : ${omni_log_fork_child:=0}
    (( omni_log_fork_child++ ))

    get_new_reply_file || fail
    defer "rm $reply_file"

  end_function
  handle_return
}

# usage: fork {command to execute}
#  background=f (whether to run as a background process)
#  change_log=f (whether to change the log)
#  to_var       (write output to the given var instead of stdout)
fork() {
  local fork_command=$*
  begin_function_lo
    local reply_file return_code=0 \
      background=${background:-f} \
      change_log=${change_log:-f} \
      to_var=${to_var:-}

    before_fork || fail

    if [[ $background == t ]]; then
      ( fork_inside ) &
    else
      ( fork_inside )
      return_code=$?
      after_fork || (( return_code++ ))
    fi

    return_value=$return_code
  end_function
  handle_return
}

fork_fg() {
  background=f fork "$@"
}

fork_bg() {
  background=t fork "$@"
}

get_is_stale() {
  local status_path=$status_path
  begin_function
    is_stale=t
    if [[ ! "${required_freshness:-}" || "$required_freshness" == inf ]]; then
      is_stale=f
    elif [[ $required_freshness != 0 ]]; then
      local fresh_seconds
      convert_to_seconds $required_freshness fresh_seconds || fail
      local fresh_cutoff=$((EPOCHSECONDS-fresh_seconds)) \
        out_timestamp= 
      is_stale=f
      if [[ -f $status_path/last-good-update-end ]]; then
        out_timestamp=$(date -r $status_path/last-good-update-end +%s)
      fi
      if [[ "$out_timestamp" && $out_timestamp -lt $fresh_cutoff ]]; then
        is_stale=t
      fi
    fi
  end_function
  handle_return
}

wait_for_low_load() {
  local cell_max_load=${cell_max_load:-10}
  local cell_load_wait_timeout=${cell_load_wait_timeout:-600}
  local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
  if [[ $current_load -gt $cell_max_load ]]; then
    log_warn "Load average is too high ($current_load > $cell_max_load)," \
      "waiting until things cool down first." || fail
    local time_waited=0
    while [[ $current_load -gt $cell_max_load ]]; do
      current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
      sleep 5; let time_waited+=5
      if [[ "$cell_load_wait_timeout" -gt 0 && $time_waited -ge $cell_load_wait_timeout ]]; then
        log_fatal "Timed out waiting for cpu load to be low enough. Aborting"
        return 1
      fi
    done
  fi
  return 0
}

reply_file=

# input: parallel processes
wait_for_sub_processes() {
  begin_function
    if [[ "$processes" ]]; then
      log_debug "Waiting for sub processes to complete"
      local process last_err_code= last_failed_process= rc
      for process in $processes; do
        log_debug "Waiting for process $process"
        wait $process &>/dev/null; rc=$?
        if [[ $rc -gt 0 && $rc -lt 127 ]]; then
          if [[ ! "$last_err_code" ]]; then
            last_err_code=$rc
            last_failed_process=$process
          else
            log_fatal "Subprocess $process failed to terminate successfully"
            fail1
          fi
        fi
      done
      after_fork
      if [[ "$last_err_code" ]]; then
        if [[ "$last_err_code" == 1 ]]; then
          log_fatal "Subprocess $last_failed_process failed to terminate successfully"
          fail1
        fi
        return_value=$last_err_code
        break_out=t
        break
      fi
      processes=
    fi
  end_function
  handle_return
}

trace_step_execution=${trace_step_execution:-f}
trace_op=${trace_op:-}

# Usage: execute_op {op name}
# If {op_name}_op_var variable exists, it will be evaluated as the body of the {op_name}_op function
#   and then executed
# Otherwise {op_name}_op function is executed
#
# output
#   missing   set to t if no op found
execute_op() {
  local op_name=$1 op_function= ignore_missing=${ignore_missing:-f}

  local log_vars='cell_path op_name'
  begin_function

    op_function=${op_name}_op
    local -n op_var=${op_name}_op_var

    missing=f
    if [[ "${op_var:-}" == f ]]; then
      missing=t
    else

      if [[ "${op_var:-}" ]]; then
        unset $op_function
        if [[ "${op_var#${op_name}_op()}" != "${op_var}" ]]; then
          eval "$op_var"
        else
          eval "${op_name}_op() {
begin_function
$op_var
end_function
handle_return
}"
        fi
      fi

      if type -t $op_function &>/dev/null; then

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=t
        fi

        $op_function || fail

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=f
        fi

      else
        missing=t
      fi

    fi

    if [[ $missing == t ]]; then
      if [[ $ignore_missing == t ]]; then
        log_debug "No ${op_name}_op function found, ignoring"
      else
        log_fatal "No ${op_name}_op function found"
        fail1
      fi
    fi

  end_function
  handle_return
}

# inputs: parent_path seed_path member dim
plant_member() {
  begin_function
    local deep=${deep:-f} repair=${repair:-f}
    get_sane_value "$member" || fail
    member_path=$parent_path/$dim:$sane_value
    if [[ ! -d $member_path || $repair == t ]]; then

      local new_path=$member_path.new

      if [[ -d $new_path ]]; then
        rm -rf $new_path || fail
      fi

      mkdir $new_path || fail
      if [[ "$member" != "$sane_value" ]]; then
        echo -n "$member" >$new_path/.member || fail
      fi

      local cell_is_leaf=t
      if [[ ${child_dims:-} ]] && (( ${#child_dims[*]} > 1 )); then
        cell_is_leaf=f
      fi
      plant_seed $member_path $new_path || fail

      #if [[ -e $parent_path/.mock ]]; then
      #  if [[ ! -d $new_path/.cyto ]]; then
      #    mkdir $new_path/.cyto || fail
      #  fi
      #  cp $parent_path/.mock $new_path/.mock || fail
      #fi

      if [[ -e $member_path ]]; then
        rm -rf $member_path || fail
      fi
      mv $new_path $member_path || fail

    fi
  end_function
  handle_return
}

# input: $* = cell values in dim order
# output: cell_id = string cell id
get_cell_id() {
  local v
  cell_id=
  for v in "$@"; do
    get_sane_value "$v"
    v=$sane_value
    cell_id+=_$v
  done
  cell_id=${cell_id#_}
}

encrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=$to \
    key=${key:-$user_private_key}

  begin_function

    if [[ "$to" == */ ]]; then
      to+=${from##*/}
    fi

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ -e $to ]]; then
      log_fatal "File already exists: $to"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    setup_tmp_path || fail
    if ! log_and_run openssl pkeyutl -encrypt -inkey $key -in $from -out $to; then
      log_fatal "Failed to encrypt file: $from"
      fail1
    fi

  end_function
  handle_return
}

encrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from \
    to=$to \
    tmp_path=$tmp_path \
    key_path=$key_path \
    user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Encrypting $from to $to"

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to encrypt non-existent file: $from"
      fail1
    fi

    if [[ -f "$to" ]]; then
      log_fatal "Encrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then

      local key_count=$(find -L $key_path -mindepth 1 -maxdepth 1 -name 'key.*' -type f | wc -l)

      if (( key_count > 0 )); then

        log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
        find -L $key_path -name "key.*" >&2
        fail1

      else

        log_debug "There are no keys for this cell yet. Will create a new key."

        # create a new main key
        if ! out_to_file=$tmp_path/main log_and_run openssl rand -base64 40; then
          log_fatal "Failed to generate new main key."
          fail1
        fi
        defer "rm $tmp_path/main"

        # create a compatible public key from the user's private key
        if ! log_and_run openssl pkey -in $user_private_key -out $tmp_path/public -pubout; then 
          log_fatal "Failed to convert private key to public key."
          fail1
        fi

        # encrypt main key with given user key
        if ! log_and_run openssl pkeyutl -encrypt -pubin -inkey $tmp_path/public -in $tmp_path/main -out $key_path/key.$USER; then
          log_fatal "Failed to encrypt main key."
          fail1
        fi

      fi
    else 
      # extract the main key
      if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in $key_path/key.$USER -out $tmp_path/main; then
        log_fatal "Failed to decrypt main key." 
        fail1
      fi

      defer "rm $tmp_path/main"
    fi
      
    # encrypt the file with main key
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -pass file:$tmp_path/main; then
      log_fatal "Failed to create new secret file."
      fail1
    fi

  end_function

  if [[ -f $tmp_path/main ]]; then
    rm $tmp_path/main
  fi

  handle_return

}

handle_secure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    setup_tmp_path || fail
    local unsafe_file=${file%.safe}
    local new_unsafe_file=$tmp_path/$unsafe_file.new
    local old_unsafe_file=$tmp_path/$unsafe_file.old

    if [[ -f $new_unsafe_file ]]; then
      log_fatal "$new_unsafe_file already exists, delete that first if you want to edit $file"
      fail1
    fi

    defer "rm $new_unsafe_file"
    defer "rm $old_unsafe_file"

    if [[ -f $old_file ]]; then
      from=$old_file to=$old_unsafe_file decrypt_file_with_shared_key || fail
      cp $old_unsafe_file $new_unsafe_file || fail
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" >$new_unsafe_file || fail
    else
      $EDITOR $new_unsafe_file || fail
    fi

    if [[ -f $old_unsafe_file ]]; then
      if files_are_different $old_unsafe_file $new_unsafe_file >/dev/null; then
        changed=t
      else
        log_debug "No change"
        rm $new_unsafe_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      from=$new_unsafe_file to=$new_file encrypt_file_with_shared_key || fail
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

handle_insecure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    if [[ -f $old_file ]]; then
      cp $old_file $new_file || fail 
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" | trim_nl >$new_file || fail
    else
      $EDITOR $new_file || fail
    fi

    if [[ -f $old_file ]]; then
      if files_are_different $old_file $new_file >/dev/null; then
        changed=t
      else
        log_debug "No change"
        rm $new_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

update_modify_times() {
  local file=$1
  if [[ "$status_path" && -f "$status_path/up-to-date" ]]; then
    rm $status_path/up-to-date || return 1
  fi
  return 0
}

setup_context_defaults() {
  return 0
}

update_cell_value_file() {
  begin_function
    if [[ "${cell_values:-}" && ! -f $cell_path/cell_values ]]; then
      local v s='cell_values=( '
      for v in "${cell_values[@]}"; do
        s+="\"$v\" "
      done
      s+=')'
      echo "$s" >$cell_path/cell_values || fail
    fi
  end_function
  handle_return
}

get_cell() {
  cell_path=$1
  [[ ${#cell_path} -lt 3 ]] && return 1
  [[ -d $cell_path/.dna ]] && return 0
  [[ -d $cell_path/.cyto ]] && return 0
  get_cell ${cell_path%/*} || return 1
  return 0
}

setup_tmp_path() {
  if [[ ! "${tmp_path:-}" ]]; then
    if [[ -d ${cell_path:-}/.cyto/tmp ]]; then
      tmp_path=$cell_path/.cyto/tmp
    elif [[ -d ~/tmp ]]; then
      tmp_path=~/tmp
    else
      tmp_path=/tmp
    fi
  fi
  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || return 1
  fi
  return 0
}

# inputs:
#   from    encrypted file to decrypt
#   to      (optional) file to save decrypted form to
#           if 'to' is missing, then it writes the decrypted value to stdout
decrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=${to:-} \
    to_var=${to_var:-} \
    key=${key:-$user_private_key}

  local log_show_vars='^from ^to to_var'
  begin_function_hi

    if [[ ! "$to" && ! "$to_var" ]]; then
      log_fatal "decrypt_file: Must set either 'to' or 'to_var'"
      fail1
    fi

    pause_tee

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    if [[ "$to" ]]; then
      if [[ -e $to ]]; then
        log_fatal "File already exists: $to"
        fail1
      fi
      setup_tmp_path || fail
      if ! openssl pkeyutl -decrypt -inkey $key -in $from -out $to; then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    else
      local -n v=$to_var
      v=$(openssl pkeyutl -decrypt -inkey $key -in $from)
      if (( $? > 0 )); then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    fi
     
    unpause_tee

  end_function
  handle_return
}

# Will leave key_path blank if not found
get_key_path() {

  key_path=$seed_path
  while [[ $key_path == /*/*/* && ! -d $key_path/.key ]]; do
    key_path=${key_path%/*}
  done

  if [[ -d $key_path/.key ]]; then
    key_path=$key_path/.key
  else
    key_path=
  fi

}

validate_user_key() {
  if [[ ! -f $key_path/$user.key ]]; then
    local others=( $key_path/* )
    local o users
    for o in ${others[*]}; do
      o=${o##*/}
      users+="${o%.key} "
    done
    if [[ "$users" ]]; then
      log_fatal "No key found for user $user. Ask someone who has access to add your key. These users have access: $users"
    else
      log_fatal "No keys were found. Use 'cell safe key add' to create the first key."
    fi
    return 1
  fi
}

extract_master_key() {
  local from=$1 to=$2 user_private_key=$user_private_key
  if ! openssl pkeyutl -decrypt -inkey $user_private_key -in $from -out $to; then
    log_fatal "Failed to decrypt master key." 
    return 1
  fi
}

make_master_key() {
  begin_function
    local pub_key=$pub_key master_key=$master_key target=$target tmp_folder=$tmp_folder

    defer "rm $tmp_folder/pub_key"

    # convert public key to format openssl likes
    ssh-keygen -f $pub_key -m PKCS8 -e >$tmp_folder/pub_key || {
      log_fatal "Failed to convert public key."
      fail1
    }

    # encrypt main key with new key
      openssl pkeyutl -encrypt -pubin -inkey $tmp_folder/pub_key -in $master_key -out $target || {
      log_fatal "Failed to encrypt main key."
      fail1
    }
  end_function
  handle_return
}

simple_encrypt() {
  local master_key=$master_key from_file=$1 to_file=$2
  begin_function
    if ! openssl enc -aes256 -pbkdf2 -in $from_file -out $to_file -pass file:$master_key; then
      log_fatal "Failed to encrypt the file."
      fail1
    fi
  end_function
  handle_return
}

simple_decrypt() {
  local master_key=$master_key from_file=$1 to_file=$2
  begin_function
    if ! openssl enc -aes256 -pbkdf2 -in $from_file -out $to_file -d -pass file:$master_key; then 
      log_fatal "Failed to decrypt the file."
      fail1
    fi
  end_function
  handle_return
}

# inputs: from to tmp_path current_cell
# will write output to file at $to
decrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from
  local to=$to
  local tmp_path=$tmp_path
  local key_path=$key_path
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Decrypting $from to $to" || return 1

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to decrypt non-existent file: $from"
      fail1
    fi

    if [[ -s "$to" ]]; then
      log_fatal "Decrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then
      log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
      find -L $key_path -name "key.*" >&2
      fail1
    fi

    # extract the main key
    if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in "$key_path/key.$USER" -out $tmp_path/main; then
      log_fatal "Failed to decrypt main key." 
      fail1
    fi
    defer "rm $tmp_path/main"

    # decrypt the secret file
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -d -pass file:$tmp_path/main; then 
      log_fatal "Failed to decrypt secret file." 
      fail1
    fi

  end_function
  handle_return

}

get_sane_value() {
  local -r value=$1 
  local -n _s=${2:-sane_value}
  if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
    _s=$value
  else
    hash=$(echo -n "$value" | sha1sum | awk '{ print $1 }')
    _s=${hash:0:8}
  fi
  debug_return_vars=_s
  return 0
}

is_cell() {
  [[ -d "$1/.dna" ]]
}

# Used by the help system to describe a command and it's parameters to the user
new_command() {
  local name=$name description=$description
  command_description=$description
  unset ${!parameter_*}
  #parameter_names=()
  #parameter_descriptions=()
  #parameter_defaults=()
  #parameter_choices=()
}

add_parameter() {

  local type=${type:-command} \
    name=$name \
    description=$description \
    default=${default:-} \
    choices=${choices:-} \
    aliases=${aliases:-${alias:-}} \
    required=${required:-f} \
    delay_questions=${delay_questions:-f} \

  local -n parameter_names=parameter_names_$type \
    parameter_descriptions=parameter_descriptions_$type \
    parameter_choices=parameter_choices_$type \
    parameter_defaults=parameter_defaults_$type \
    parameter_aliases=parameter_aliases_$type \
    parameter_delay_questions=parameter_delay_questions_$type \
    parameter_required=parameter_required_$type \

  parameter_names+=( "$name" ) 
  parameter_descriptions+=( "$description" ) 
  parameter_defaults+=( "$default" ) 
  parameter_choices+=( "$choices" )
  parameter_aliases+=( "$aliases" )
  parameter_delay_questions+=( $delay_questions )
  parameter_required+=( $required )

  local a
  for a in ${parameter_aliases[*]:-}; do
    if [[ -v ${a}_append ]]; then
      eval "${name}_append=\$${a}_append"
    fi
    if [[ -v ${a}_prepend ]]; then
      eval "${name}_prepend=\$${a}_prepend"
    fi
    if [[ -v ${a}_remove ]]; then
      eval "${name}_remove=\$${a}_remove"
    fi
  done

}

add_command_alias() {
  local name=$name command=$command
  command_aliases+=( "$name" )
  command_alias_command+=( "$command" )
}

tee_output_to_log() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    exec 1> >(tee -a "$logging_to_file") || return 1
    exec 2>&1 || return 1
    eval "exec $fd_trace>&1" || return 1
    BASH_XTRACEFD=$fd_trace
    tee_files+=( $logging_to_file )
  fi
  return 0
}

untee_output() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    if [[ "${tee_files:-}" ]]; then
      BASH_XTRACEFD=
      exec 1>&$fd_original_out || return 1
      exec 2>&$fd_original_err || return 1
      eval "exec $fd_trace>&$fd_original_trace" || return 1
      unset tee_files[-1]
    else
      # log_warn "untee was called when nothing was teed"
      :
    fi
  fi
  return 0
}

pause_tee() {
  if [[ "${tee_files:-}" ]]; then
    paused_tee_file=${tee_files[-1]}
    untee_output || return 1
  fi
  return 0
}

unpause_tee() {
  if [[ "$paused_tee_file" ]]; then
    tee_output_to_log $paused_tee_file || return 1
    paused_tee_file=
  fi
  return 0
}

# locks the given cell, or fails if it can't obtain a lock
# may lock an individual file instead if the path given isn't a cell
cell_lock() {

  local cell_path=$1 \
    write_lock=${write_lock:-t} \
    timeout=$timeout \
    lock_fd \
    lock_type=read \
    lock_path

  local log_show_vars="timeout ^cell_path"
  begin_function

    if [[ -e $cell_path/.cyto/context ]]; then
      lock_path=$cell_path/.cyto/context
    else
      log_fatal "Missing context: $cell_path/.cyto/context"
      fail1
    fi

    if [[ $write_lock == t ]]; then
      lock_type=write
    fi

    if [[ -f $lock_path ]]; then
      if [[ $write_lock == t ]]; then
        fd_write_lock || fail
      else
        fd_read_lock || fail
      fi
      cell_locks+=( $lock_fd )
    fi

  end_function
  handle_return

}

# locks the given cell, or fails if it can't obtain a lock
cell_unlock() {
  local lock_fd
  for lock_fd in ${cell_locks[*]:-}; do
    fd_unlock || return 1
  done
  return 0
}

up_delegate() {
  local cyto_up_path=$1 # .../.cyto/up/{dep_name}
  local cell_path=${cyto_up_path%/.cyto/up/*} \
    up_lock=$cyto_up_path/chosen/.cyto/lock \
    up_name=${cyto_up_path##*/}
  local log_show_vars='^cyto_up_path ^cell_path up_lock'
  begin_function_hi

    if [[ -e $up_lock ]]; then
      local locks_folder=$cell_path/.cyto/up-locks
      if [[ ! -d $locks_folder ]]; then
        mkdir $locks_folder || fail
      fi
      safe_link $up_lock $locks_folder/$up_name || fail
    fi

    local out_item
    out_items=$(find1 $cyto_up_path/chosen -not -name ".*") || fail
    for out_item in $out_items; do
      safe_link $out_item $cell_path/ || fail
    done; maybe_break

  end_function
  handle_return
}

# inputs:
#   table_fields variable name holding array of fields
#   table_data   variable name holding array of cells
#   row          which row to select from the table
#   field_count
#   prefix       prefix of variable name to set
#execute_auto_load_add_constraints() {
#  begin_function
#    local f t
#    begin_for (( f = 0; f < field_count; f++ )); doo
#
#      local field=${table_fields[$f]}
#      (( t = row * field_count + f ))
#      expected_value=${table_data[$t]}
#      if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
#        continue # try next field, since this one matches
#      fi
#
#      keys["$field $expected_value"]=1
#
#    end_for
#
#  end_function
#  handle_return
#}

#execute_auto_load_tab() {
#  local table_name=$1 prefix=${prefix:-}
#  begin_function
#    local -n table_fields=${table_name}_fields table_data=${table_name}_data
#    if [[ ! -v table_fields || ! -v table_data ]]; then
#      log_fatal "Missing expected vars: ${table_name}_fields or ${table_name}_data"
#      fail1
#    fi
#    local row \
#      field_count=${#table_fields[*]} data_count=${#table_data[*]}
#    local row_count=$((data_count/field_count))
#    local -A keys
#    begin_for (( row = 0; row < row_count; row++ )); doo
#      check_table_row || fail
#      if [[ $is_valid == t ]]; then
#        execute_auto_load_add_constraints || fail
#      fi
#    end_for
#
#    local value key key_field field value
#    begin_for field in "${table_fields[@]}"; doo
#      local -n target_field=$field
#      if [[ "${target_field:-}" ]]; then
#        continue
#      fi
#      begin_for key in "${!keys[@]}"; doo
#        key_field=${key%% *}
#        if [[ "$key_field" != "$field" ]]; then
#          continue
#        fi
#        value=${key#$key_field }
#        target_field+=( "$value" )
#      end_for
#    end_for
#  end_function
#  handle_return
#}

execute_auto_loads() {
  local auto_loads=( "$@" )
  begin_function
    local table_name prefix i
    for item in "${auto_loads[@]}"; do
      case $item in
# OLD CODE, should remove if not used soon
#        *.tab)
#          execute_auto_load_tab ${item%.tab} || fail
#        ;;
        *.var)
          local v=${item%.*}
          if [[ -v $v ]]; then
            local quoted=${!v}
            quoted=${quoted//\"/\\\"}
            eval "$v=\"$quoted\""
          fi
        ;;
        *)
          log_fatal "Can't auto load $item"
          fail1
        ;;
      esac
    done
  end_function
  handle_return
}

get_trunk_cell() {
  trunk_cell=$1
  while [[ $trunk_cell == */*:* ]]; do
    trunk_cell=${trunk_cell%/*}
  done
  debug_return_vars=trunk_cell
}

# inputs:
#   debug_log    (optional)
#   result_file
#   $1           headers and url to query
http_get() {
  local parameters="$*" timeout=${timeout:-60}
  begin_function

    local curl_command="curl -Lkvgs -m $timeout -w '%{stderr}TIMINGS
      time_namelookup=%{time_namelookup}
      time_connect=%{time_connect}
      time_appconnect=%{time_appconnect}
      time_pretransfer=%{time_pretransfer}
      time_redirect=%{time_redirect}
      time_starttransfer=%{time_starttransfer}
      time_total=%{time_total}
    ' $parameters"
    echo "$curl_command" >$debug_log
    if [[ -e $result_file ]]; then
      rm $result_file || fail
    fi

    err_to_file=${debug_log:-} \
    out_to_file=$result_file \
    log_and_run "$curl_command" || fail

    if log_level_at_least verbose; then
      local timings=$(awk 'BEGIN { flow=0 } flow == 1 { print } /TIMINGS/ { flow=1 }' $debug_log)
      log_verbose "curl timings:$NL$timings"
    fi

    local response_line response_code response_message response_code_message response_error
    response_line=$(grep -E '^< HTTP/[^ ]+ ' $debug_log | tail -n1)
    response_code_description=${response_line#* * }
    response_code=${response_code_description%% *}

    response_error=$(jq -r .error $result_file 2>/dev/null) || true
    if [[ "$response_code" != 200 ]]; then
      if [[ "$response_error" ]]; then
        log_fatal "curl failed: $response_error"
      elif [[ "$response_code_message" ]]; then
        log_fatal "curl failed: $response_code_message"
      else
        log_fatal "curl failed for unknown reason. Check $debug_log or $result_file for more details."
      fi
      fail1
    fi

  end_function
  handle_return
}
