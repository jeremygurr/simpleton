#!/bin/bash
# depends on lib/bash-lib being sourced first to provide needed aliases

[[ -v cell_lib_loaded ]] && return 0
cell_lib_loaded=t

cell_lib_init() {
  # don't let other users read any files written by these scripts
  umask 0077

  empty_member=_ 
  execute_inner=${execute_inner:-${dig:-m}}

  handle_special_vars trace_vars
  handle_special_vars pause_at_vars

  : ${risk_tolerance:=${risk:-0}}
  case "$risk_tolerance" in
    l*)
      risk_tolerance=0
      ;;
    m*)
      risk_tolerance=1
      ;;
    h*)
      risk_tolerance=2
      ;;
    v*)
      risk_tolerance=3
      ;;
    [0-9])
      risk_tolerance=${risk_tolerance:-${risk}}
      ;;
    *)
      log_fatal "Unknown risk level: $risk. Should be one of: low medium high very_high (or 0 1 2 3). Defaults to low."
      fail1
      ;;
  esac

  tee_files=( )
  paused_tee_file=

  parallel_default=f 
  [[ ${debug:-f} == t ]] && parallel_default=f
  parallel_execution=${parallel_execution:-${par:-$parallel_default}}

  # used to detect upstream circular dependencies
  downstream_cell_stack=( ) 
  disable_log=${disable_log:-}

  command_aliases=()
  command_alias_command=()

  trace_dims=${trace_dims:-${trace_dim:-}}
}

handle_special_vars() {
  local -n vars=$1
  local t new_vars=
  for t in $vars; do
    if [[ $t == ^* ]]; then
      t=${t#^}
      new_vars+="p_$t p_${t}s d_$t d_${t}s s_$t s_${t}s "
    else
      new_vars+="$t "
    fi
  done
  vars=${new_vars% }
}

# allocates a unique file optionally based on a given name in the cell tmp_path
# returns tmp_file set to the full path of the file
get_tmp_file() {
  local base=${1:-tmp}
  if [[ ! -e $tmp_path ]]; then
    mkdir $tmp_path || return 1
  fi
  tmp_file=$(mktemp $tmp_path/$base.$$.XXXXXX) || return 1
  defer "rm $tmp_file"
  return 0
}

write_to_context() {
  local context_type=$context_type new_type=$1 
  local -n _content=$2
  begin_function_lo
    last_type=${last_type:-var}
    if [[ $last_type == fun || $new_type == fun ]]; then
      echo >>$context_path-$context_type.new || fail
    fi
    trim_ws _content
    echo "${_content}" >>$context_path-$context_type.new || fail
    last_type=$new_type
    eval "$_content" || {
      if [[ "${var_full_path:-}" ]]; then
        log_fatal "Invalid dna file: $var_full_path"
      else
        log_fatal "Invalid dna file. Contents:"
        log_fatal "$_content"
      fi
      fail1
    }
  end_function
  handle_return
}

write_vars_to_context() {
  local context_type=$context_type vars_to_write=$*
  begin_function_lo
    local var val quoted_val
    begin_for var in $vars_to_write; doo
      local -n val=$var
      if is_set val; then
        set_to_string val quoted_val
      elif is_array val; then
        array_to_string val quoted_val
      else
        local quoted_val=${val:-}
        shell_quote_var quoted_val
      fi
      local content="$var=$quoted_val"
      write_to_context var content || fail
    end_for
  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_fun_to_code() {
  local full_path=$1 content name=$2
  begin_function_lo
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" =~ ^[a-zA-Z_]+\(\) ]]; then
      code="$content"
    else
      #  can't indent the code because it may contain multiline strings, which this would corrupt
      #content=$(echo -n "$content" | sed 's/^/    /')
      level=_lo
      if [[ $name == update_op ]]; then
        level=
      fi
      code="$name() {
begin_function$level
$content
end_function
handle_return
}"
    fi

  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_var_to_code() {
  local full_path=$1 name=$2 content append=f
  begin_function_lo

    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    if [[ "$content" != [\"\']* ]]; then
      shell_quote_var content
    fi

    if [[ $append == t ]]; then
      append_vars[$name]=1
      code="$name+=$content"
    else
      code="$name=$content"
    fi

  end_function
  handle_return
}

# will skip empty / whitespace lines
load_arr_to_code() {
  begin_function_lo

    local full_path=$1 content name=$2 append=f
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    code="$name"
    if [[ $append == t ]]; then
      append_vars[$name]=1
      code+="+=("
    else
      code+="=("
    fi

    while IFS= read -r line || [[ "$line" ]]; do
      trim_ws line
      if [[ "$line" ]]; then
        if [[ "$line" != [\"\']* ]]; then
          shell_quote_var line
        fi
        code+=" $line" || fail
      fi
    done < <(echo -n "$content")

    code+=" )"

  end_function
  handle_return
}


# Will load the given derive table if not already loaded
load_derive_table() {
  local name=$1
  begin_function_grip

  local -n derive_table_data=derive_table_${name}_data

  if [[ ! -v derive_table_data ]]; then

    log_verbose "Loading derive table $name"
    local -n dtp=derive_table_${name}_path \
      derive_table_fields=derive_table_${name}_fields \

    load_dna_tab $dtp derive_table_$name || fail

    local row_index field_index row_count field_count data_count data_offset field value
    field_count=${#derive_table_fields[*]}
    data_count=${#derive_table_data[*]}
    (( row_count = data_count / field_count ))

    for (( field_index = 0; field_index < field_count; field_index++ )); do

      field=${derive_table_fields[$field_index]}
      local -n index=derive_table_${name}_index_${field}
      if [[ ! -v index[*] ]]; then
        eval "declare -gA derive_table_${name}_index_${field}=()"
      fi

      for (( row_index = 0; row_index < row_count; row_index++ )); do
        (( data_offset = row_index * field_count + field_index ))
        value=${derive_table_data[$data_offset]}
        if [[ "$value" ]]; then
          index[$value]+="$row_index "
        fi
      done

    done

    fence_grip

    for (( field_index = 0; field_index < field_count; field_index++ )); do

      field=${derive_table_fields[$field_index]}
      local -n index=derive_table_${name}_index_${field}
      local card=${#index[*]}
      if (( card == row_count )); then
        local -n cross_dim_tables=dim_${field}_cross_dim_tables
        cross_dim_tables+="$name "
      fi

      local -n card_table=dim_${field}_card_table

      if [[ -v card_table ]]; then
        local -n old_index=derive_table_${card_table}_index_${field}
        local old_card=${#old_index[*]}
        if (( card > old_card )); then
          card_table=$name
        fi
      else
        card_table=$name
      fi

    done

  fi

  end_function
  handle_return
}

# inputs:
#   $1   path to derive table
#   $2   name of derive table
add_derive_table() {
  local derive_path=$1 name=${2:-}
  begin_function_lo

    local fields name
    fields=$(head -n1 $derive_path)
    if [[ ! "$name" ]]; then
      name=${derive_path##*/}
      name=${name%.*tab}
      name=${name//-/_}
    fi

    derive_tables+=( $name )

    local -n derive_table_fields=derive_table_${name}_fields
    derive_table_fields=( $fields )

    local -n dtp=derive_table_${name}_path
    dtp=$derive_path

    write_vars_to_context derive_table_${name}_fields derive_table_${name}_path || fail

    local field
    for field in $fields; do
      local -n ddt=dim_${field}_derive_tables
      ddt+="$name "
    done

  end_function
  handle_return
}

# not handling failure here for performance reasons
# should be nearly impossible to fail at this point anyway
maybe_write_newline_to_context() {
  local new_type=$1
  last_type=${last_type:-none}
  if [[ $last_type != none ]]; then
    if [[ $last_type == fun || $new_type == fun \
       || $last_type == tab || $new_type == tab \
       ]]; then
      echo >>$context_path-$context_type.new
    fi
  fi
  last_type=$new_type
}

# this duplicates code from write_dna_tab_to_context on purpose for performance reasons
# inputs:
#   $1     full path to tab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
load_dna_tab() {

  begin_function_lo
    local full_path=$1 name=$2

    # must not indent data in case it's a multi-line string
    eval "$(
    awk '
    NR == 1 { print "'$name'_fields=( " $0 " )"; print "'$name'_data=(" }
    NR > 1 { print $0 }
    END { print ")" }
    ' $full_path
    )" || fail

  end_function
  handle_return
}

# this duplicates code from write_dna_vtab_to_context on purpose for performance reasons
# inputs:
#   $1     full path to vtab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
load_dna_vtab() {

  begin_function_lo
    local full_path=$1 name=$2

    local -n fields=${name}_fields data=${name}_data

    fields=( $(awk '{ print $1 }' $full_path) ) || fail
    local field_count=${#fields[*]}
    eval "local array=( $(<$full_path) )" || fail

    local row_offset col_offset data_index array_index current_field_index=0 \
      col_count=$(( ${#array[*]} / field_count )) \

    begin_for (( row_offset = 0; row_offset < ${#array[*]}; row_offset += col_count )); doo
      if [[ "${array[$row_offset]}" != ${fields[$current_field_index]} ]]; then
        log_fatal "Bad data in file $full_path around line $current_field_index"
        fail1
      fi

      begin_for (( col_offset = 1; col_offset < col_count; col_offset++ )); doo
        (( array_index = row_offset + col_offset )) || true
        (( data_index = ( col_offset - 1 ) * field_count + current_field_index ))
        data[$data_index]=${array[$array_index]}
      end_for

      (( current_field_index++ )) || true
    end_for

  end_function
  handle_return
}

# inputs:
#   $1     full path to vtab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
write_dna_vtab_to_context() {

  begin_function_lo
    local full_path=$1 name=$2

    load_dna_vtab $full_path $name
    local array_assignment

    make_array_assignment ${name}_fields || fail
    write_to_context var array_assignment || fail

    if [[ $name == *_derive ]]; then
      eval "$array_assignment" || fail
    fi

    make_array_assignment ${name}_data || fail
    write_to_context var array_assignment || fail

  end_function
  handle_return
}

# inputs:
#   $1     full path to tab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
write_dna_tab_to_context() {

  begin_function_lo
    local full_path=$1 name=$2

    maybe_write_newline_to_context tab
    local content
    content=$(
      awk '
      NR == 1 { print "'$name'_fields=( " $0 " )"; print "'$name'_data=(" }
      NR > 1 { print "  " $0 }
      END { print ")" }
      ' $full_path
    ) || fail

    echo "$content" >>$context_path-$context_type.new || fail

  end_function
  handle_return
}

# usage: split_ordinal {from_var} {ordinal_part_var} {base_part_var}
split_ordinal() {
  local -n _f=$1 _o=$2 _b=$3
  if [[ $_f =~ ^([0-9]+)-([^/]*)$ ]]; then
    _o=${BASH_REMATCH[1]}
    _b=${BASH_REMATCH[2]}
  else
    _o=9999
    _b=$_f
  fi
  debug_return_vars="$2 $3"
}

# usage: get_simple_name {from var} {ordinal var} {to var}
extract_simple_name() {
  local to_var=$3
  local -n _from=$1 _ord=$2 _to=$to_var
  split_ordinal _from _ord _to
  #_to=${_to//-/_}
  debug_return_vars=$to_var
}

# usage: get_simple_name {from array} {to array}
extract_simple_name_across_array() {
  local -n _from=$1 _to=$2
  local o i f t
  for (( i = 0; i < ${#_from[*]}; i++ )); do
    f=${_from[$i]}
    extract_simple_name f o t
    _to[$i]=$t
  done
  return 0
}

# inputs:
#   $1             full path to dna file
#   prefix         optional prefix
#   context_type   if empty, only loads the variable, if set, records to context
load_dna_item() {
  begin_function_grip
    local var_full_path=$1 prefix=${prefix:-} \
      suffix= \
      file_name \

    last_type=${last_type:-var}

    file_name=${var_full_path##*/}
    if [[ $file_name == *.* ]]; then
      suffix=${file_name##*.}
      file_name=${file_name%.*}
    fi

    local var_name o code= load_type=var is_auto=f
    extract_simple_name file_name o var_name

    if [[ $var_name == auto-* ]]; then
      is_auto=t
      var_name=${var_name#auto-}
    fi

    var_name=${var_name//-/_}

    if [[ $is_auto == t ]]; then
      auto_loads+=( $var_name.$suffix )
    fi

    var_name=$prefix$var_name

    case "$suffix" in
      var)
        load_var_to_code $var_full_path $var_name || fail
      ;;
      arr)
        load_arr_to_code $var_full_path $var_name || fail
      ;;
      fun)
        load_fun_to_code $var_full_path $var_name || fail
        load_type=fun
      ;;
      tab)
        if [[ "${context_type:-}" ]]; then
          write_dna_tab_to_context $var_full_path $var_name || fail
        else
          load_dna_tab $var_full_path $var_name || fail
        fi
      ;;
      vtab)
        if [[ "${context_type:-}" ]]; then
          write_dna_vtab_to_context $var_full_path $var_name || fail
        else
          load_dna_vtab $var_full_path $var_name || fail
        fi
      ;;
      *)
        if [[ $ignore_unknown == f ]]; then
          log_fatal "Unknown dna object: $item."
          fail1
        fi
      ;;
    esac

    if [[ "$code" ]]; then
      if [[ "${context_type:-}" ]]; then
        write_to_context $load_type code || fail
      else
        eval "$code" || fail
      fi
    fi

  end_function
  handle_return
}

make_array_assignment() {
  local arr_name=$1 append=${append:-f}
  local -n arr=${2:-$1}
  begin_function_lo
    if [[ $append == t ]]; then
      array_assignment="$arr_name+=("
    else
      array_assignment="$arr_name=("
    fi
    local v
    for v in "${arr[@]}"; do
      shell_quote_var v
      array_assignment+=" $v"
    done
    array_assignment+=" )"
  end_function
  debug_return_vars=array_assignment
  handle_return
}

# finds the nearest ancestor of the given path which has .dna in it
# will set bottom_cell, which will be empty if no cell cells are found
get_bottom_cell() {
  local subject=$1
  bottom_cell=
  if [[ $subject == /seed/* ]]; then
    log_fatal "Called get_bottom_cell on a seed path"
    return 1
  fi
  while [[ -d "$subject" && "$subject" == /*/* ]]; do
    if [[ -e $subject/.dna ]]; then
      bottom_cell=$subject
      break
    fi
    subject=${subject%/*}
  done
  debug_return_vars=bottom_cell
  return 0
}

build_context_expand_find_members() {
  begin_function

    local branch other_found=f member_paths
    member_paths=$(find1 $seed_path -name "$dim:*" -type d | sort -g) || fail

    begin_for branch in $member_paths; doo
      m=${branch##*/*:}
      if [[ $m == all ]]; then
        log_fatal "Should not have an all as a dim member: $branch"
        fail1
      elif [[ $m == _other ]]; then
        other_found=t
      else
        local member_var_path=$branch/.member
        if [[ -f $member_var_path ]]; then
          m=$(<$member_var_path) || fail
        fi
        members+=( "$m" )
      fi
    end_for

    if [[ "$member_paths" && $other_found == f ]]; then
      has_explicit_member_list=t
    fi

  end_function
  handle_return
}

build_context_expand_handle_default() {
  begin_function_lo

    local -n default=dim_${dim}_default

    if [[ -v default ]]; then

      code+="
    '')
      values=( \"$default\" )
    ;;"

    elif function_exists dim_${dim}_default_function; then

      code+="
    '')
    "
      code+="$(echo "dim_${dim}_default_function" | indent 2)"
      code+="
    ;;"

    else

      code+="
    '')
      problem=\"Missing required parameter: $dim\"
    ;;"

    fi
  end_function
  handle_return
}

build_context_expand_handle_aliases() {
  begin_function_lo
    local a_line first remaining
    for a_line in "${aliases[@]}"; do
      first=${a_line%% *}
      remaining=${a_line#* }
      code+="
    $first)
      _out=( $remaining )
    ;;"
    done
  end_function
  handle_return
}

build_context_expand_members_unknown() {
  code+="
    *)
      _out=( \"\$_in\" )
    ;;
  esac
}"
}

get_all_values_from_derive_table() {
  local derive_table=$1 output_var=$2
  local -n __out=$output_var \
    index=derive_table_${derive_table}_index_$dim \

  __out=( "${!index[@]}" )
}

value_exists_in_derive_table() {
  local derive_table=$1 value=$2
  local -n index=derive_table_${derive_table}_index_$dim
  [[ -v index["$value"] ]]
}

build_context_expand_members_derive() {
  begin_function_lo

    code+="
    *)
      local -n dt=dim_${dim}_card_table
      if [[ ! -v dt ]]; then
        problem='No members defined for $dim'
        return 0
      fi
    ;;&
    all)
      get_all_values_from_derive_table \$dt _out || fail
    ;;
    *)
      if value_exists_in_derive_table \$dt \"\$value\"; then
        _out=( \"\$_in\" )
      else
        problem=\"Invalid $dim: \$_in\"
      fi
    ;;
  esac
}"

  end_function
  handle_return
}

build_context_expand_members_known() {
  begin_function_lo
    local quoted_members= members_with_pipes=${members[*]} need_quotes=f m
    for m in "${members[@]}"; do
      quoted_members+="\"$m\" "
      if [[ $m == *\ * ]]; then
        need_quotes=t
      fi
    done

    if [[ $need_quotes == f ]]; then
      quoted_members="${members[*]}"
    fi

    local members_with_pipes=${members_with_pipes// /\|}

    code+="
    all)
      _out=( $quoted_members )
    ;;
    $members_with_pipes)
      _out=( \$_in )
    ;;
    *)
      problem=\"Invalid $dim: \$_in\"
    ;;
  esac
}"
  end_function
  handle_return
}

# inputs:
#   dim
# outputs:
#   code
build_context_expand() {
  begin_function_grip

    local has_explicit_member_list=f has_derive_table=f fun

    local -n member_type=dim_${dim}_member_type

    if [[ -v member_type ]]; then
      case $member_type in
        dynamic|static)
          :
        ;;
        *)
          log_fatal "Invalid member_type variable loaded from dna: $member_type. Must be either dynamic or static."
          fail1
        ;;
      esac
    fi

    local -n members=dim_${dim}_members \
      dim_derive_tables=dim_${dim}_derive_tables \

    if [[ -v members ]] && (( ${#members[*]} > 0 )); then
      has_explicit_member_list=t
    elif [[ "${dim_derive_tables:-}" ]]; then
      has_derive_table=t
    fi

    if [[ ! "${member_type:-}" ]]; then
      if [[ $has_explicit_member_list == t || $has_derive_table == t ]]; then
        member_type=static
      else
        member_type=dynamic
      fi
      write_vars_to_context dim_${dim}_member_type || fail
    fi

    local -n aliases=dim_${dim}_aliases

    code="dim_${dim}_expand() {
  local -n _in=\${1:-value} _out=\${2:-values}
  problem=
  case \"\$_in\" in"

    build_context_expand_handle_default || fail

    if [[ -v aliases ]]; then
      build_context_expand_handle_aliases || fail
    fi

    if [[ $has_explicit_member_list == t ]]; then
      build_context_expand_members_known || fail
    elif [[ $has_derive_table == t ]]; then
      build_context_expand_members_derive || fail
    else
      build_context_expand_members_unknown || fail
    fi

    write_to_context fun code || fail

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more sub coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_shell_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    echo "${coord_type}_coordinate_fields=( ${c_fields[*]} )" >$target_file || fail
    echo "${coord_type}_coordinate_data=(" >>$target_file || fail

    local line=
    for (( row_index = 0; row_index < c_rows; row_index++ )); do

      line="  "

      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        fi
      done

      echo "${line% }" >>$target_file || fail

    done

    echo ")" >>$target_file || fail

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more sub coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_tab_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    local line=

    begin_for (( field_index = 0; field_index < c_fields_count; field_index++ )); doo
      field=${c_fields[$field_index]}
      if [[ " $skip_dims " != *" $field "* ]]; then
        line+="$field "
      fi
    end_for
    echo "${line% }" >>$target_file || fail

    for (( row_index = 0; row_index < c_rows; row_index++ )); do
      line=
      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        fi
      done

      echo "${line% }" >>$target_file || fail
    done

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more sub coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_vtab_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    local line

    begin_for (( field_index = 0; field_index < c_fields_count; field_index++ )); doo
      field=${c_fields[$field_index]}
      line=
      if [[ " $skip_dims " != *" $field "* ]]; then
        line+="$field "
        for (( row_index = 0; row_index < c_rows; row_index++ )); do
          (( data_offset = row_index * c_fields_count + field_index ))
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        done
      fi
      echo "${line% }" >>$target_file || fail
    end_for

  end_function
  handle_return
}

# Adds the branch coords (from existing dims) to the given table file
append_coords_to_file() {
  local from=$1 to=$2 coord_type=$coord_type fill_in_the_blanks=${fill_in_the_blanks:-f}
  begin_function
    log_debug "Appending $coord_type coordinates to $to from $from"
    local old_table type=${to##*.}

    case $type in
      tab)
        load_dna_tab $from old_table || fail
      ;;
      vtab)
        load_dna_vtab $from old_table || fail
      ;;
      *)
        log_fatal "Invalid file type for append_coords_to_file: $type"
        fail1
      ;;
    esac

    seed_table=old_table \
    add_implicit_dims=t \
    seed_coordinates || fail

    if [[ -e $to ]]; then
      rm $to || fail
    fi

    case $type in
      tab)
        write_coordinates_to_tab_file $to || fail
      ;;
      vtab)
        write_coordinates_to_vtab_file $to || fail
      ;;
    esac

  end_function
  handle_return
}

get_plural() {
  local dim=$1
  local target_var=${2:-plural}
  local -n target=$target_var
  if [[ $dim == *s ]]; then
    target=${dim}es
  elif [[ $dim == *y ]]; then
    target=${dim%y}ies
  else
    target=${dim}s
  fi
  debug_return_vars=$target_var
  return 0
}

# inputs:
#   table                  variable name containing the table, without _fields or _data
#   row_index              defaults to 0
#   target_dim_var_type    one of: sdims ddims sdim ddim
# will load nothing if the given row_index doesn't exist in the given table
convert_table_to_dims() {
  local table=$table row_index=${row_index:-0} target_dim_var_type=$target_dim_var_type
  begin_function

    local field fields field_index values=() count field_count data_offset

    local -n c_fields=${table}_fields \
             c_data=${table}_data \

    local c_fields_count=${#c_fields[*]} \

    local c_data_count=0
    if [[ -v c_data ]]; then
      c_data_count=${#c_data[*]}
    fi

    if (( c_data_count >= c_fields_count * (row_index + 1) )); then

      begin_for (( field_index = 0; field_index < c_fields_count; field_index++ )); doo
        field=${c_fields[$field_index]}
        get_plural $field fields

        local -n sdim=s_$field sdims=s_$fields ddim=d_$field ddims=d_$fields

        (( data_offset = c_fields_count * row_index + field_index ))
        case $target_dim_var_type in 
          sdims)
            sdims=${c_data[$data_offset]}
            unset sdim ddim ddims
          ;;
          ddims)
            ddims=${c_data[$data_offset]}
            unset sdim sdims ddim
          ;;
          sdim)
            sdim=${c_data[$data_offset]}
            unset sdims ddim ddims
          ;;
          ddim)
            ddim=${c_data[$data_offset]}
            unset sdim sdims ddims
          ;;
          *)
            log_fatal "Invalid target_dim_var_type: $target_dim_var_type"
            fail1
          ;;
        esac

      end_for

    fi

  end_function
  handle_return
}

# input: 
#   dim
#   $1       name of input var
#   $2       name of output var
# output: values 
expand_dim() {
  local in_var=$1 out_var=$2
  begin_function_lo

    if [[ "${!in_var:-}" && "${!in_var}" != \? ]]; then

      if ! function_exists dim_${dim}_expand; then
        log_fatal "Internal error: Missing dim_${dim}_expand function, which should have been created by make_context method"
        fail1
      fi

      local problem
      dim_${dim}_expand $in_var $out_var || fail
      if [[ "${problem:-}" ]]; then
        log_fatal "$problem"
        fail1
      fi

    fi

  end_function
  handle_return
}

# inputs:
#   $1           array var name which contains the members
#   dim_var      dim being expanded
# outputs:
#   new_values   array of expanded members
expand_dim_members() {
  local -n _members=$1
  local members=( "${_members[@]}" )
  local value values
  new_values=()
  for value in "${members[@]}"; do
    dim=$dim_var \
    expand_dim value values || return 1
    if [[ "$values" ]]; then
      new_values+=( "${values[@]}" )
    fi
  done
}

# inputs:
#   $*      list of dims to expand
# expands aliases for the known dims array
# collapses singular and plural dims into plural dims
# should only be used after prep_dims, which means 
#   all dims should be stored in sdim/sdims or ddim/ddims
#   plural dims should always be arrays, not space separated
# ddim is expanded form of sdim, and takes priority over sdim
# this function will generate ddim/ddims where they are not already set based on sdim/sdims
# this function guaranteeds ddims will be set for all known dims
# ddims will be an array after this function
expand_dims() {
  local to_expand=$*
  begin_function_lo

    local dim_var plural dim_type
    for dim_var in $to_expand; do

      local dims_var
      get_plural $dim_var dims_var
      local -n \
        sdim=s_$dim_var sdims=s_$dims_var \
        ddim=d_$dim_var ddims=d_$dims_var \

      if [[ ! "${ddim:-}" && ! "${ddims:-}" && \
            ( "${sdim:-}" || "${sdims:-}" ) ]]; then

        #log_debug "Expanding dim $dim_var"

        local members single=t
        if [[ "${sdims:-}" ]]; then
          members=( "${sdims[@]}" )
          single=f
        else
          members=( "$sdim" )
        fi

        local value new_values
        expand_dim_members members || fail

        if [[ $single == t ]]; then
          if (( ${#new_values[*]} > 1 )); then
            log_fatal "Too many values for $dim_var: ${new_values[*]}"
            fail1
          fi
        fi

        if (( ${#new_values[*]} == 1 )); then
          ddim=${new_values}
          unset ddims sdim sdims
        else
          ddims=( "${new_values[@]}" )
          unset ddim sdim sdims
        fi

      elif [[ ! "${ddims:-}" ]]; then
        if [[ "${ddim:-}" ]]; then
          unset ddims sdim sdims
        else
          unset ddims ddim sdim sdims
        fi
      fi

    done

  end_function
  handle_return
}

extract_from_derive_table_find_row_indexes() {
  local row_indexes \
    row_index_count \
    column_index \

  for (( column_index = 0; column_index < field_count; column_index++ )); do
    field=${derive_fields[$column_index]}
    if [[ $field != $dim ]]; then
      local -n ddim=d_$field
      if [[ -v ddim ]]; then
        local -n dt_index=derive_table_${derive_table}_index_${field}
        if [[ -v dt_index["$ddim"] ]]; then
          row_indexes=( ${dt_index["$ddim"]} )
          row_index_count=${#row_indexes[*]}
          if (( row_index_count < best_row_index_count )); then
            best_row_index_count=$row_index_count
            best_row_indexes=( ${row_indexes[*]} )
            if (( best_row_index_count <= 1 )); then
              # don't need to keep looking
              break
            fi
          fi
        else
          # Accoridng to the index, no values exist in this table which match the known dim value
          values=()
          value_set=()
          abort
        fi
      fi
    fi
  done
}

extract_from_derive_table_check_row() {
  begin_function_grip

    local field value column_index
    for (( column_index = 0; column_index < field_count; column_index++ )); do

      field=${derive_fields[$column_index]}
      value=${derive_data[$((data_index + column_index))]}

      log_show_vars='field value'
      fence_grip

      if [[ $field == $dim ]]; then

        if [[ "$value" != all && ${#value_set[*]} -gt 0 && ! "${value_set[$value]:-}" ]]; then
          # don't need to check this row if value isn't in the list of choices
          everything_matches=f
          break
        fi

        if [[ "$value" ]]; then
          row_result=$value
        else
          row_result=$empty_member
        fi

        if [[ $validate_rows == f ]]; then
          break
        fi

      elif [[ " $ignore_dims " != *" $field "* && $validate_rows == t ]]; then

        local -n ddim=d_$field

        if [[ "${ddim:-}" ]]; then
          if [[ "$ddim" != "$value" && "$value" != all && "$ddim" != all ]]; then
            #log_debug "Row doesn't match because dim $field = $ddim but table shows $value"
            everything_matches=f
          fi
        else # ddim not set
          if [[ $strict_matching == t && "$value" && "$value" != all ]]; then
            #log_debug "Row doesn't match because $field is not set"
            everything_matches=f
            break
          fi
        fi

        if [[ $everything_matches == f && -v all_dims[$field] ]]; then
          local expanded_values
          dim=$field expand_dim value expanded_values || fail
          if array_contains expanded_values $ddim; then
            everything_matches=t
          fi
        fi

        if [[ $everything_matches == f ]]; then
          break
        fi

      fi

    done

  end_function
  handle_return
}

# inputs:
#   value_found
#   derive_table            name of var of derive table
#   values                  previously determined values, may be empty if value_found == f
#   value_set               each valid value
#   dim                     which field to read from the table
#   stop_after_first_match  optional
#   validate_rows           optional
#   ignore_dims             space separated list of dims to not check
# outputs:
#   value_set               the var out_set points to will contain a set of all matches
#   values                  the var out_arr points to will contain an array of all matches
extract_from_derive_table() {
  local stop_after_first_match=${stop_after_first_match:-f} \
    validate_rows=${validate_rows:-t} \
    ignore_dims=${ignore_dims:-} \
    derive_table=$derive_table \

  begin_function_grip
      
    local -n derive_fields=derive_table_${derive_table}_fields \
             derive_data=derive_table_${derive_table}_data \

    if [[ ! -v derive_data ]]; then
      load_derive_table $derive_table || fail
    fi

    if [[ ! -v derive_data ]]; then
      log_fatal "Couldn't load derive table $derive_table"
      fail1
    fi

    #if ! is_set value_set; then
    #  log_fatal "Internal error: extract_from_derive_table was called with value_set pointing to a variable that isn't an associative array."
    #  fail1
    #fi

    #if [[ ! -v derive_fields ]]; then
    #  log_fatal "Interal error: Missing ${derive_table}_fields"
    #  fail1
    #fi

    local field_count=${#derive_fields[*]} \
      data_count=${#derive_data[*]} \
      strict_matching=${strict_matching:-f} \
      maybe data_index \
      value= row_result everything_matches \
      invalid=f \
      best_row_indexes=() \
      row_index \

    local best_row_index_count=$(( data_count / field_count ))

    extract_from_derive_table_find_row_indexes
    maybe_break

    for (( data_index = 0; data_index < data_count; data_index += field_count )); do

      (( row_index = data_index / field_count ))

      if [[ "$best_row_indexes" && " ${best_row_indexes[*]} " != *" $row_index "* ]]; then
        # Skip row since it doesn't match
        continue
      fi

      everything_matches=t

      extract_from_derive_table_check_row

      if [[ $everything_matches == t ]]; then
        #log_debug "Matching row found"
        if [[ ! -v value_set["$row_result"] ]]; then
          value_set["$row_result"]=1
          values+=( "$row_result" )
          value_found=t
        fi
        if [[ $stop_after_first_match == t ]]; then
          break
        fi
      else
        #log_debug "No matching row found"
        :
      fi

    done

    debug_return_vars=values
  end_function
  handle_return
}

fetch_column_from_table() {

  local table_var=$table_var field=$field
  local -n table_data=${table_var}_data \
    table_fields=${table_var}_fields \

  local field_count=${#table_fields[*]} \
    data_count=${#table_data[*]} \
    data_index \
    value= field \
    found=f \

  for (( data_index = 0; data_index < field_count; data_index++ )); do
    if [[ ${table_fields[$data_index]} == $field ]]; then
      found=t
      break
    fi
  done

  if [[ $found == f ]]; then
    log_fatal "Internal error: Table $table_var doesn't contain field $field"
    return 1
  fi

  for (( ; data_index < data_count; data_index += field_count )); do
    values+=( "${table_data[$data_index]}" )
  done

  return 0

}

# inputs:
#   dim
#   from_dim
#   value_found
#   deep
# outputs:
#   value_found
#   values
attempt_derive2() {
  local deep=$deep
  begin_function_lo

    local one_row_complete=f \
      derived_from_row derived_from_dim derived_from_long_dim \
      complete_row derived_from_incomplete=f \
      maybe_resolved

    for derived_from_row in "${derived_from[@]}"; do
      if [[ ! "$from_dim" || " $derived_from_row " == *" $from_dim "* ]]; then

        complete_row=t
        local row_array=( $derived_from_row ) i
        log_debug "Attempting to derive $dim from: ${row_array[*]:1}"

        maybe_resolved=
        for (( i = 1; i < ${#row_array[*]}; i++ )); do
          derived_from_long_dim=${row_array[$i]}
          derived_from_dim=${derived_from_long_dim%%-*}
          maybe_resolved+="$derived_from_dim "

          if [[ " $deriving " == *" $derived_from_dim "* ]]; then
            complete_row=f
            break
          fi

          local -n derive_from_dim_value=d_$derived_from_dim
          if [[ ! "${derive_from_dim_value:-}" ]]; then

            if [[ $deep == t ]]; then

              # recursive
              from_dim= \
              attempt_derive $derived_from_dim || fail

              if [[ $value_found == f ]]; then
                complete_row=f
                break
              fi

              if (( "${#values[*]}" > 1 )); then
                local plural
                get_plural $derived_from_dim
                local -n ddims=d_$plural
                ddims=( "${values[@]}" )
              else
                derive_from_dim_value=$values
              fi

              values=()
              value_found=f

            else

              complete_row=f
              break

            fi

          fi
        done

        if [[ $complete_row == t ]];then

          one_row_complete=t
          resolved_dependencies+=( $maybe_resolved )

          local action=${row_array[0]}

          if [[ ! "$action" =~ ^[a-zA-Z0-9_-]+\.(tab|fun)$ ]]; then
            log_fatal "Invalid action format for derived_from of dim $dim. First field of a derived_from must be the derive table or function to execute. For example: 'ez.tab' or 'derive_ez.fun'"
            fail1
          fi

          local action_type=${action##*.} \
            action_name=${action%.*} \

          if [[ ! "$action_name" || "$action_name" == "$action" ]]; then
            log_fatal "Invalid action name: $action_name found in derived_from of dim $dim"
            fail1
          fi

          case $action_type in
            tab)
              derive_table=$action_name \
              extract_from_derive_table || fail
            ;;
            fun)
              function_name=$action_name \
              attempt_derive_from_function || fail
            ;;
            *)
              log_fatal "Unknown derive action: $action_type"
              fail1
            ;;
          esac

          if [[ "${values:-}" ]]; then
            break
          fi

        fi

      fi
    done

    if [[ $one_row_complete == f ]]; then
      derived_from_incomplete=t
    fi

  end_function
  handle_return
}

# inputs:
#   dim             dimension to derive
#   from_dim        optional, will only look for ways to derive 'dim' from 'from_dim'
#   value_found
#   deriving        list of dims we are in the process of deriving, to avoid infinite loops
#   skip_dims       should be set to blank when starting. Is use to avoid failing to derive the same
#                   dim multiple times.
# output:
#   values          array of members
#   can_derive      whether a derive function or derive table exists for the given dim
#   value_found
attempt_derive() {

  local dim=$1 from_dim=${from_dim:-} \
    old_values_string=${old_values_string:-} \
    stop_after_first_match=${stop_after_first_match:-f} \
    deriving=${deriving:-} \

  log_show_vars='dim from_dim'
  begin_function_grip
    local -n derived_from=dim_${dim}_derived_from
    values=()
    can_derive=f
    value_found=${value_found:-f}

    if [[ " $deriving " == *" $dim "* || " $skip_dims " == *" $dim "* ]]; then
      abort
    fi
    deriving+="$dim "

    local resolved_dependencies=()
    local -A value_set=()

    if [[ "${derived_from:-}" ]]; then
      deep=t \
      attempt_derive2 || fail
    fi

    if (( ${#value_set[*]} > 0 )); then

      local new_values=() v
      for v in "${values[@]}"; do
        if [[ -v value_set["$v"] ]]; then
          new_values+=( "$v" )
          unset value_set["$v"]
        fi
      done
      values=( "${new_values[@]}" )
      value_found=t

      log_debug "Derive of $dim successful: ${values[*]}"

    elif [[ ! "${values:-}" ]]; then
      log_debug "Derive of $dim failed"
      skip_dims+="$dim "
    else
      value_found=t
      log_debug "Derive of $dim successful: ${values[*]}"
    fi

  end_function
  handle_return
}

alias localize='[[ "${localize_dims:-}" ]] && eval "local -I $localize_dims"'

fetch_values_from_coordinates2_row() {
  begin_function_lo

    localize

    table=${coord_type}_coordinate \
    target_dim_var_type=ddim \
    convert_table_to_dims || fail

    fence_grip

    value_found=f
    skip_dims= \
    attempt_derive $dim_var || fail

    if [[ $value_found == t ]]; then
      new_values+=( "${values[@]}" )
    else
      log_fatal "Could not extract dim $dim_var from ${coord_type}_coordinate table at row $row_index"
      fail1
    fi

  end_function
  handle_return
}

fetch_values_from_coordinates2() {
  begin_function_grip
    
    local -n table_data=${coord_type}_coordinate_data
    local data_count=${#table_data[*]} \
      field_count=${#table_fields[*]} \
      new_values=() \
      value_found \

    local row_count=$(( data_count / field_count ))
    for (( row_index = 0; row_index < row_count; row_index++ )); do
      fetch_values_from_coordinates2_row || fail
    done

    values=( "${new_values[@]}" )

  end_function
  handle_return
}

# inputs:
#   $1          name of dim to fetch
#   coord_type
# outputs:
#   values      array of dim members
fetch_values_from_coordinates() {
  local dim_var=$1 coord_type=$coord_type
  begin_function
    values=()
    local table_var=${coord_type}_coordinate
    local -n table_fields=${table_var}_fields

    if [[ " ${table_fields[*]} " == *" $dim_var "* ]]; then
      field=$dim_var \
      fetch_column_from_table || fail
    else
      fetch_values_from_coordinates2 || fail
    fi

    if [[ "$values" != *"$NL"* ]]; then
      sort_array values
    fi

    if [[ "${values[*]:-}" ]]; then
      log_debug "$dim_var fetched from coordinates: ${values[*]}"
    else
      log_debug "Failed to fetch $dim_var from coordinates"
    fi
  end_function
  handle_return
}

prep_dims() {
  begin_function

    local dim_var dims_var
    for dim_var in ${!all_dims[*]}; do

      get_plural $dim_var dims_var

      # p_dims are what the user sets when putting parameters on the commandline (without the p_), or explicitly set in environemnt (with the p_)
      # i_dims are set in the dna and are a permanent feature of the cell and can't be overridden by the user
      # s_dims are taken from p and i dims, and may contain members which are aliases or groups of other dims
      # d_dims are the final form of dim, after the s_dims have been expanded
      local -n \
        ddim=d_$dim_var ddims=d_$dims_var \
        sdim=s_$dim_var sdims=s_$dims_var \
        pdim=p_$dim_var pdims=p_$dims_var \
        idim=i_$dim_var idims=i_$dims_var \

      # We do not support pulling from simple dim here
      # If we want to set an dim in env vars, it must be set with p_dim form
      sdim=${sdim:-${idim:-${pdim:-}}}

      if [[ ! "${sdims:-}" ]]; then
        if [[ "${idims:-}" ]]; then
          sdims=( "${idims[@]}" )
        elif [[ "${pdims:-}" ]]; then
          # Multiple members that have spaces inside are not supported
          # Only single member dims can be used if the value requires spaces or special characters
          sdims=( $pdims )
        else
          sdims=()
        fi
      fi

      # from here on out only sdims and ddims should be used
      # sdims may contain shortcuts, ddims are always expanded (never shortcuts)
      unset p_$dim_var p_$dims_var 

      # idims are needed when calculating seed coordinates
      # unset i_$dim_var i_$dims_var

      [[ "${sdim:-}" == $empty_member ]] && sdim=
      [[ "${sdims:-}" == $empty_member ]] && sdims=()
      [[ "${ddim:-}" == $empty_member ]] && ddim=
      [[ "${ddims:-}" == $empty_member ]] && ddims=()

      local -n is_optional=dim_${dim_var}_is_optional
      if [[ ${is_optional:-} == t && " $optional_dims " != *" $dim_var "* ]]; then
        optional_dims+=" $dim_var"
        optional_dims=${optional_dims# }
      fi

    done

  end_function
  handle_return
}

# child dims are anchor dims which have not yet been converted into branch dims
# they are dims which will form sub cells, and need to be expanded
load_child_dims() {
  begin_function
    local i

    if [[ ! "${child_dims:-}" ]]; then
      child_dims=()
      local trunk_dim_count=${#trunk_dims[*]}
      if [[ ! "${anchor_dims:-}" ]]; then
        for (( i = branch_dim_count; i < trunk_dim_count; i++ )); do
          child_dims+=( ${trunk_dims[$i]} )
        done
      else
        local anchor_dim branch_dim leftovers=" $anchor_dims "
        
        for branch_dim in ${branch_dims[*]}; do
          remove_word_from_string leftovers $branch_dim
        done

        for anchor_dim in $anchor_dims; do
          if [[ " ${trunk_dims[*]} ${support_dims[*]} " != *" $anchor_dim "* ]]; then
            log_fatal "Invalid anchor_dim: $anchor_dim. It does not exist in the list of possible leaf nodes: ${trunk_dims[*]} ${support_dims[*]}"
            fail1
          fi
        done
        maybe_break
        
        child_dims=( $leftovers )
      fi

      child_dim_count=${#child_dims[*]}

      if (( child_dim_count > 0 )); then
        cell_is_leaf=f
      else
        cell_is_leaf=t
      fi
    fi

    current_branch_dim=
    if [[ "${child_dims[0]:-}" ]]; then
      current_branch_dim=${child_dims[0]}
    fi

  end_function
  handle_return
}

init_dims() {
  local types=${*:-trunk_dims sub_dims} \
    new_value=${new_value:-} vars=${vars:-ddim}
  begin_function
    begin_for dim_type in $types; doo
      log_debug "Setting $dim_type ${vars// / s and }s to '$new_value'"
      local -n dims=$dim_type
      begin_for dim in ${dims[*]:-}; doo
        local plural
        get_plural $dim
        if [[ " $vars " == *" ddim "* ]]; then
          local -n ddims=d_$plural ddim=d_$dim
          ddim= ddims=$new_value
        fi
        if [[ " $vars " == *" sdim "* ]]; then
          local -n sdims=s_$plural sdim=s_$dim
          sdim= sdims=$new_value
        fi
      end_for
    end_for
  end_function
  handle_return
}

setup_dims() {
  begin_function

    prep_dims || fail
    load_child_dims || fail
    if [[ $cell_is_leaf == t ]]; then
      expand_dims ${sub_dims[*]:-} ${control_props[*]:-} ${data_props[*]:-} || fail
      load_implicit_dims || fail
    else
      expand_dims ${trunk_dims[*]:-} ${support_dims[*]:-} || fail
    fi

  end_function
  handle_return
}

# should make sure load_branch_info was run before calling this
# inputs: 
#   $1  work path to target folder, which may be a cell or a folder of a cell
#   $2  target var to save seed path to, defaults to seed_path
# outputs: seed_path work_path
find_seed_path() {
  local d s=$1 i h dim dim_count
  local -n target=${2:-seed_path} 
  begin_function
    target=

    s=/seed${s#/work}

    while [[ ! -d $s && $s == *:* ]]; do
      s=${s%/*}
    done

    if [[ ${ignore_nonexistent:-f} == t ]]; then
      while [[ ! -d $s && $s == */*/*/* ]]; do
        s=${s%/*}
      done
    fi

    if [[ ! -d $s ]]; then
      log_fatal "Couldn't find seed for $s"
      fail1
    fi

    work_path=/work${s#/seed}

    # go through each seed folder and find matching dim
    local found_branch=t dim_folder
    begin_while [[ $found_branch == t ]]; doo
      
      found_branch=f
      dim_folder=$(find1 $s -name "*:*" -type d | head -n1) || fail
      if [[ "$dim_folder" ]]; then

        local seed_dim=${dim_folder##*/}
        seed_dim=${seed_dim%%:*}

        for (( i = 0; i < branch_dim_count; i++ )); do

          dim=${branch_dims[$i]}
          if [[ $dim == $seed_dim ]]; then
            h=${branch_hashes[$i]}
            if [[ -d $s/$dim:$h ]]; then
              s+=/$dim:$h
              found_branch=t
            elif [[ -d $s/$dim:_other ]]; then
              s+=/$dim:_other
              found_branch=t
            fi
            break
          fi

        done

      fi

    end_while

  end_function

  if [[ "$s" && -d $s ]]; then
    target=$s
  fi

  local log_return_vars='target work_path'
  handle_return
}

get_short_cell() {
  short_cell=${cell_path#/work/*/}
  debug_return_vars=short_cell
}

init_command_vars() {
  cell_command_path=$path_to_commands/$cell_command \
    command_allows_logs=f \
    command_requires_cell=f \
    command_requires_resolved_dims=f \
    command_modifies_context=f \
    command_modifies_upstream=f
}

init_context() {
  begin_function

    # required_freshness:
    #   inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
    #   1w means refresh if it's older than a week.
    # shuffle_chance:
    #   chance out of 1000 of not following the computed strategy order
    # min_pause:
    #   number of ms to wait between cycles
    #   this number doubles each time there is nothing to do, until it reaches max_pause
    # reuse_existing_out:
    #   if set to t: 
    #   new output folder won't be created when updating, but the existing one will be used
    #   should set to true when creating a new output folder would be expensive
    #   these cells must detect for themselves whether a change has happened in an
    #     update and set something_changed=t accordingly. 

    # need to make sure that expand functions don't bleed into sub command execution

    unset ${!dim_*}
    #declare -Ag dim_member_type=() \
    #  dim_derived_from=() \
    #  dim_derived_to=() \
    #  dim_aliases=() \
    #  dim_description=() \
    #  dim_examples=() \
    #  dim_type=() \

    declare -Ag all_dims=()

    auto_loads=() \
    cell_expiration= \
    cell_is_outdated=t \
    check_op_var=f \
    child_dims=() \
    control_props=() \
    current_pause=250 \
    data_props=() \
    default_anchor_dims= \
    default_freshness= \
    default_strategies=crl \
    dna_up_files=() \
    implicit_dims=() \
    key_path= \
    localize_dims= \
    localize_reverse_dims= \
    lock_timeout=2 \
    max_attempts=1 \
    max_pause=60000 \
    min_pause=250 \
    optional_dims= \
    out_file= \
    out_path= \
    post_validate=f \
    pre_validate=f \
    refresh_less_than=${refresh_less_than:-1} \
    retry_delay=1 \
    retry_delay_max=10 \
    retry_scale=2 \
    reuse_existing_out=t \
    shuffle_chance=100 \
    sub_dims=() \
    trunk_dims=() \
    up=() \
    update_cost=1 \
    update_risk=3 \

    unset \
      check_op \
      update_op \
      get_op \
      aggregate_op \

    context_path=$cyto_path/context \
    dna_key_path=$dna_path/key \
    down_path=$cyto_path/down \
    job_path=$cyto_path/job \
    key_path=$cyto_path/key \
    req_path=$cyto_path/req \
    status_path=$cyto_path/status \
    tmp_path=$cyto_path/tmp \
    up_path=$cyto_path/up \
    up_chosen_path=$cyto_path/up-chosen \
    reactor_path=$cyto_path/reactors \

    lock_path=$context_path \
    replay_path=$job_path/pipe_replay \

  end_function
  handle_return
}

setup_cell_paths() {
  dna_path=$cell_path/.dna
  cyto_path=$cell_path/.cyto
  init_context
}

branch_local_vars='branch_dims branch_members branch_hashes branch_dim_count trunk_cell short_cell prev_branch_info_cell'
load_branch_info() {
  local cell_path=${1:-$cell_path}

  begin_function

    if [[ "${prev_branch_info_cell:-}" == $cell_path ]]; then
      # already loaded
      abort
    fi
    prev_branch_info_cell=$cell_path

    branch_dims=() \
    branch_members=() \
    branch_hashes=() \

    local c=$cell_path p d m
    begin_while [[ $c == *:* ]]; doo
      p=${c##*/}
      if [[ $p == *:* ]]; then

        d=${p%%:*}

        if [[ " ${branch_dims[*]} " == *" $d "* ]]; then
          log_fatal "Duplicate branch dim found: $d in $cell_path"
          fail1
        fi

        branch_dims=( $d ${branch_dims[*]} )

        m=${p#*:}
        branch_hashes=( $m ${branch_hashes[*]} )

        local member_var_path=$c/.member
        if [[ -f $member_var_path ]]; then
          IFS= read -r -d '' m <$member_var_path
        fi
        branch_members=( "$m" "${branch_members[@]}" )

        local -n dim_var=d_$d
        dim_var=$m

      fi
      c=${c%/*}
    end_while

    trunk_cell=$c
    branch_dim_count=${#branch_dims[*]}

    if (( branch_dim_count > 0 )); then
      cell_is_trunk=f
    else
      cell_is_trunk=t
    fi

    if [[ "${branch_dims:-}" ]]; then
      log_debug "Branch dims found: ${branch_dims[*]}" || fail
    fi

    local x y dim_string= 
    if [[ "${branch_hashes:-}" ]]; then
      dim_string="${branch_hashes[*]}"
      dim_string=:${dim_string// /\/}
    fi
    local short_trunk=${trunk_cell#/*/*/}

  end_function
  handle_return
}

execute_command_prep() {
  begin_function

    get_short_cell
    load_branch_info || fail

    trunk_changed=f
    if [[ $trunk_cell != "${previous_trunk:-}" ]]; then
      trunk_changed=t
      previous_trunk=$trunk_cell
    fi

    setup_cell_paths

    unset default_anchor_dims
    if [[ $top_level_command == f ]]; then
      anchor_dims=
    fi

  end_function
  handle_return
}

# Inputs:
#   $1    cell_path   should be real path
#   $2    command
execute_command() {
  local cell_path=$1 cell_command=$2 \
    log_show_vars='short_cell cell_command'
  begin_function_hi

    case $cell_command in
      dim-*|up-*)
        if [[ $cell_path == /seed/* ]]; then
          cell_path=/work${cell_path#/seed}
        fi
      ;;
      *)
        if [[ $cell_path != /work* ]]; then
          log_fatal "You must run this command from within the workspace (any subfolder of /work)"
          fail1
        fi
      ;;
    esac

    strong_log=t log_verbose "Executing cell command: $short_cell $cell_command" || fail

    if [[ $command_requires_cell == t ]]; then
      if [[ ! -e "$cell_path" ]]; then
        plant_seed $cell_path || {
          log_fatal "Not a cell: $cell_path"
          fail1
        }
      fi

      if [[ ! -e $cell_path/.dna ]]; then
        log_fatal "Invalid cell: $cell_path"
        fail1
      fi
    fi

    #  replacing logs with a simpler and faster mechanism
    #if [[ $command_allows_logs == t ]]; then
    #  disable_log=f
    #else
      disable_log=t
    #fi

    if [[ $disable_log == t ]]; then
      #log_debug "Logging disabled." || fail
      :
    else
      execute_command_log_prep || fail
    fi

    if [[ $disable_log == f ]]; then
      : ${omni_log_fork_child:=0}
      (( omni_log_fork_child++ ))
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    local omni_log_fork_parent=${omni_log_fork_parent:-}-${omni_log_fork_child:-1} \
      omni_log_fork_child=0
    omni_log_fork_parent=${omni_log_fork_parent#-}

    if [[ " ${command_history:-}" == *" $cell_command $short_cell "* ]]; then
      log_fatal "Circular dependency found: arrived at $cell_command $short_cell a second time."
      fail1
    fi

    local command_history=${command_history:-}
    command_history+="$cell_command $short_cell "

    local cell_command_function=${cell_command//-/_}_command
    if function_exists $cell_command_function; then
      $cell_command_function || fail
    else
      log_fatal "Missing command function $cell_command_function which should be in $cell_command_path"
      fail1
    fi

    if [[ $disable_log == f ]]; then
      cell_close_log_file || fail
    fi

  end_function

  if failed; then
    log_fatal "Failed while executing command: $cell_command in folder $cell_path"
  fi
  handle_return
}

substitute_command_alias() {
  begin_function
    local alias_command parameters
    for (( i = 0; i < ${#command_aliases[*]}; i++ )); do
      if [[ "${command_aliases[$i]}" == "$cell_command" ]]; then
        alias_command=${command_alias_command[$i]}
        cell_command=${alias_command%% *}
        parameters=${alias_command#$cell_command }
        update_original_cmd=f parameters_to_env $parameters
        abort
      fi
    done
  end_function
  handle_return
}

# inputs:
#   $1    cell_path   should be real path
#   $2... commands
execute_commands() {
  local cell_path=$1; shift
  local cell_commands=( $* ) cell_command
  local log_show_vars='^cell_path cell_commands'
  begin_function

    if [[ "$pause_at_cells" ]]; then
      local pac
      for pac in $pause_at_cells; do
        if [[ "$cell_path" == *"$pac"* ]]; then
          handle_user_interrupt "Cell reached (execute_command): $pac."
        fi
      done
    fi

    local top_level_command=${top_level_command_next:-t}

    # so top_level_command is set to t throughout this function, yet if it's called again, it will
    #   be set to f
    top_level_command_next=f

    eval "local $branch_local_vars" || fail
    local previous_trunk=${previous_trunk:-}
    execute_command_prep || fail

    begin_for cell_command in ${cell_commands[*]}; doo

      local original_cell_command=$cell_command
      substitute_command_alias || fail
      init_command_vars || fail

      if [[ -e $cell_command_path.info ]]; then
        source $cell_command_path.info || fail
        handle_questions || fail
      else
        log_warn "Missing file $cell_command_path.info" || fail
      fi

      if [[ ! -d $cell_path/.dna && $command_requires_cell == t ]]; then

        if [[ $top_level_command == t ]]; then
          log_warn "Skipping $cell_path because it is not a cell"
        else
          log_verbose "Skipping $cell_path because it is not a cell"
        fi

      else

        if [[ -e $cell_command_path ]]; then
          source $cell_command_path || fail
        else
          log_fatal "Internal error: Missing $cell_command command in $cell_command_path"
          fail1
        fi

        validate_command_parameters || fail
        execute_command $cell_path $cell_command || fail

        if [[ $command_modifies_context == t \
           || $command_modifies_upstream == t ]]; then
          # make sure cell rebuilds context next time it's updated
          if [[ -e $context_path ]]; then
            rm $context_path* || fail
          fi
        fi

        if [[ $command_modifies_upstream == t ]]; then
          if [[ -e $up_path ]]; then
            rm -rf $up_path || fail
          fi
          if [[ -e $up_chosen_path ]]; then
            rm -rf $up_chosen_path || fail
          fi
        fi

      fi

    end_for

  end_function
  handle_return
}

load_dna_contents_update_cell() {
  local file=$1 original_cell_path=$cell_path cell_path work_path
  begin_function

    local bottom_cell cell_path parent=${file%/*}
    if [[ ! -d "$parent" ]]; then
      ignore_nonexistent=t plant_seed $parent || fail
      cell_path=$work_path
    else
      get_bottom_cell $parent
      if [[ ! "$bottom_cell" ]]; then
        log_fatal "Could not find cell for $file"
        fail1
      fi
      cell_path=$bottom_cell
    fi
    local short_cell
    get_short_cell

    needs_update= \
    fork execute_commands "$cell_path" update || fail

    if [[ ! -f "$file" ]]; then
      log_fatal "Cell $short_cell did not produce file at $file as required by dna of $original_cell_path"
      fail1
    fi

  end_function
  handle_return
}

get_dim_path() {

  local start_path=$1 lib_dim_path

  lib_dim_path=$start_path/.lib/dim
  if [[ -d $lib_dim_path/$long_dim ]]; then
    dim_path=$lib_dim_path/$long_dim
  else

    local shorts=( $lib_dim_path/$dim-* )
    if (( ${#shorts[*]} > 1 )); then
      log_fatal "Too many matching dims: ${shorts[*]}, choose one specifically using the longer dim form"
      return 1
    fi

    if [[ -d "$shorts" ]]; then
      dim_path=$shorts
    elif [[ $start_path == /*/*/* ]]; then
      get_dim_path ${start_path%/*}
    fi

  fi

}

# inputs:
#   downstream_dim    optional
build_dim_info_single() {
  local long_dim=$1 downstream_dim_row=${downstream_dim_row:-} \
    log_show_vars=long_dim
  begin_function_grip

    local dims dim_path= \
      dim=${long_dim%%-*} \

    if [[ ! "$dim" =~ ^[a-zA-Z0-9_]+$ ]]; then
      log_fatal "Invalid dim name: $dim. Dims must consist of alphanumeric characters or underscores."
      fail1
    fi

    if [[ "$downstream_dim_row" ]]; then
      local -n derived_to=dim_${dim}_derived_to
      derived_to+=( "$downstream_dim_row" )
    fi

    get_plural $dim dims

    get_dim_path $cell_path
    if [[ ! "$dim_path" ]]; then
      log_fatal "Could not find dim $long_dim in any .lib/dim folders of the parents of $cell_path"
      fail1
    fi

    local -n expand_function=dim_${dim}_expand

    unset default_function

    prefix=dim_${dim}_ \
    load_dna_contents $dim_path || fail

    local -n is_secret=dim_${dim}_is_secret
    if [[ -v is_secret && $is_secret == t ]]; then
      add_word_to_string secret_vars "$dim $dims s_$dim s_$dims d_$dim d_$dims"
    fi

    local -n expand_function=dim_${dim}_expand
    if ! function_exists expand_function; then
      build_context_expand || fail
    fi

    local -n dim_dim_type=dim_${dim}_type
    dim_dim_type=$dim_type

    local -n derived_from=dim_${dim}_derived_from
    if [[ -v derived_from ]]; then
      local upstream_long_dim upstream_dim upstream_dim_row
      begin_for upstream_dim_row in "${derived_from[@]}"; doo
        begin_for upstream_long_dim in ${upstream_dim_row#* }; doo
          upstream_dim=${upstream_long_dim%%-*}
          local -n upstream_dim_type=dim_${upstream_dim}_type
          if [[ ! -v upstream_dim_type && ! -v all_dims[$upstream_dim] ]]; then
            all_dims[$upstream_dim]=1
            downstream_dim_row="$dim ${upstream_dim_row#* }" \
            dim_type=support_dims \
            build_dim_info_single "$upstream_dim" || fail
          fi
        end_for
      end_for
    fi

    local -n ddt=dim_${dim}_derive_tables
    if [[ -v ddt ]]; then
      write_vars_to_context dim_${dim}_derive_tables || fail
    fi

    write_vars_to_context dim_${dim}_type || fail

  end_function
  handle_return
}

# assumes that dim_derived_from for the given dim already exists
# inputs:
#   dim_derived_from
add_derived_to_support_dims() {
  local derived_from long_dim short_dim row OIFS=$IFS
  for row in "${dim_derived_from[@]}"; do
    local is_first=t
    for long_dim in $row; do

      if [[ $is_first == t ]]; then
        # skip the action part
        is_first=f
        continue
      fi

      if ! array_contains trunk_dims $long_dim \
        && ! array_contains support_dims $long_dim; then

        downstream_dim_row= \
        build_dim_info_single "$long_dim" || fail

        support_dims+=( $long_dim )

        short_dim=${long_dim%%-*}
        local -n dim_derived_from=dim_${short_dim}_derived_from
        if [[ -v dim_derived_from ]]; then
          add_derived_to_support_dims || fail
        fi

      fi

    done
  done
}

build_context_support_dims() {
  begin_function

    local dim dim_type=trunk_dims
    support_dims=()
    begin_for dim in "${trunk_dims[@]}"; doo
      local -n dim_derived_from=dim_${dim}_derived_from
      if [[ -v dim_derived_from ]]; then
        add_derived_to_support_dims || fail
      fi
    end_for

    sort_array support_dims

    log_debug "Calculated support_dims: ${support_dims[*]}"
    write_vars_to_context support_dims || fail

  end_function
  handle_return
}

build_dim_info() {
  begin_function

    local long_dim dim_type
    localize_dims=
    localize_reverse_dims=

    begin_for dim_type in trunk_dims sub_dims control_props data_props; doo

      fence_grip
      local -n dim_array=${dim_type}

      begin_for long_dim in "${dim_array[@]}"; doo
        downstream_dim_row= \
        build_dim_info_single "$long_dim" || fail
      end_for

    end_for
    fence_grip

    build_context_support_dims || fail

    for dim_type in trunk_dims support_dims sub_dims control_props data_props; do

      local -n short_dims=${dim_type}_short \
        dim_array=${dim_type} \

      short_dims=()

      for long_dim in "${dim_array[@]}"; do

        local dim=${long_dim%%-*} dims
        get_plural $dim dims
        short_dims+=( $dim )
        all_dims[$dim]=1

        localize_dims+=" d_$dim d_$dims"
        localize_reverse_dims+=" $dim=\${d_$dim:-} $dims=( \"\${d_$dims[@]:-}\" )"
        
      done

    done

    write_vars_to_context \
      localize_dims localize_reverse_dims \
      secret_vars \
      all_dims \
      ${dim_type}_short \
      || fail

  end_function
  handle_return
}

load_dna_contents_handle_dir() {
  begin_function_lo
    if [[ "$current_var" && $item_var != _* ]]; then
      array_content+=( "$item_name" )
      if [[ -L $item || -d $item ]]; then
        result="${current_var}_${item_var}_path=$real_path"
        write_to_context var result || fail
      fi
      array_ord+=( $ord )
    fi

    if [[ ! -d $real_path/.dna ]]; then

      local new_pass_thru=f

      if [[ $item_var != _* ]]; then
        new_prefix+=${item_var}_
      else
        new_pass_thru=t
      fi

      # recursive
      prefix=$new_prefix pass_thru=$new_pass_thru load_dna_contents $item || fail

    fi
  end_function
  handle_return
}
 
# if context_type is not set, then no context will be written
load_dna_contents() {
  local folder=$1 prefix=${prefix:-} \
    pass_thru=${pass_thru:-f} recursive=${recursive:-t} \
    ignore_unknown=${ignore_unknown:-f} \
    context_type=${context_type:-} \

  begin_function

    local items new_items
    items=$(find1 $folder -not -name '.*' -not -name root | sort -g) || fail

    local current_var=${prefix%_} ord item_name item_var= result 
    if [[ $pass_thru == f ]]; then
      local array_content=( )
      local -n array_ord=${current_var}_ord
    fi
    current_var=${current_var//-/_}

    begin_for item in $items; doo

      item_name=${item##*/}

      local dna_prefix=f
      if [[ "$item_name" == dna-* ]]; then
        dna_prefix=t
        item_name=${item_name#dna-}
      fi

      if [[ "$item_name" == *:* ]]; then
        local filter filters=${item_name%:*}
        for filter in ${filters//:/ }; do
          if [[ $cell_path != */"$filter"/* && $cell_path != */"$filter" ]]; then
            continue 2
          fi
        done
        item_name=${item_name##*:}
      fi

      extract_simple_name item_name ord item_name
      item_var=${item_name//-/_}

      local new_prefix= 
      if [[ "$current_var" && $dna_prefix == f ]]; then
        new_prefix=${current_var}_
      fi

      local real_path=$(realpath -m $item)
      if [[ -L $item && $item != */up/* && $item != */reactors/* ]]; then

        local real_path_parent=${real_path%/*}

        if [[ -d $real_path_parent/.dna && $real_path == /work/* ]]; then
          # TODO: build freshness mechanism here to auto-refresh stale data
          dna_up_files+=( "$item" )
          if [[ ! -e $real_path ]]; then
            load_dna_contents_update_cell $real_path || fail
          fi
        fi

      fi

      if [[ -d $item ]]; then
        if [[ $recursive == t ]]; then
          load_dna_contents_handle_dir || fail
        fi
      elif [[ -f $item ]]; then
        prefix=$new_prefix load_dna_item $item || fail
      elif [[ -L $item ]]; then
        log_fatal "Broken link in dna: $item"
        fail1
      fi

    end_for

    if [[ "$current_var" && "${array_content:-}" && $pass_thru == f ]]; then
      local append=f
      local -n v=$current_var
      [[ "${v:-}" ]] && append=t
      make_array_assignment $current_var array_content || fail
      write_to_context var array_assignment || fail
    fi

  end_function
  handle_return
}

build_context_reactors() {
  begin_function_lo
    reactor_groups=
    local ord
    for ord in ${reactors_ord[*]:-}; do
      reactor_groups+="$ord "
    done
    reactor_groups=( $(echo "${reactor_groups% }" | sed 's/ /\n/g' | sort -gu) )
    write_vars_to_context reactor_groups || fail
  end_function
  handle_return
}

load_parent_context() {
  local path=$1
  begin_function
    if [[ "$path" == /*/*/* ]]; then
      load_parent_context ${path%/*}
    fi
    local root_path=$path/.root
    if [[ -e $root_path ]]; then
      log_debug "Appending parent trunk context ${path#/*/*/}"
      echo "$NL# FROM $root_path" >>$context_path-$context_type.new || fail
      if [[ -d $root_path ]]; then
        load_dna_contents $root_path || fail
      elif [[ -f $root_path ]]; then
        cat $root_path >>$context_path-$context_type.new || fail
      fi
    fi
  end_function
  handle_return
}

build_context_trunk_dna() {
  local log_vars=cell_path log_show_vars=short_cell
  begin_function

    local item_name last_part dna_full_item suffix context_type=trunk
    local -A append_vars

    if [[ -e $context_path-$context_type ]]; then
      log_fatal "Internal error: $context_type context already exists. Should have been deleted before calling this function."
      fail1
    fi

    if [[ -d $dna_path ]]; then

      auto_loads=()

      if [[ "$cell_path" == */*/* ]]; then
        load_parent_context ${cell_path%/*} || fail
      fi

      echo "$NL# FROM $dna_path" >>$context_path-$context_type.new || fail
      prefix= load_dna_contents $dna_path || fail

      build_dim_info || fail
      fence

      write_vars_to_context auto_loads || fail

      if [[ "${dna_up_files:-}" ]]; then
        write_vars_to_context dna_up_files || fail
      fi

      if [[ ! "${default_anchor_dims:-}" ]]; then
        default_anchor_dims="${trunk_dims[*]:-}"
        write_vars_to_context default_anchor_dims || fail
      fi

      mv $context_path-$context_type.new $context_path-$context_type.new2 || fail
      echo "#!/usr/env bash" >$context_path-$context_type.new || fail
      local v
      for v in ${!append_vars[*]}; do
        echo "$v=" >>$context_path-$context_type.new || fail
      done

      cat $context_path-$context_type.new2 >>$context_path-$context_type.new || fail
      rm $context_path-$context_type.new2 || fail

      build_context_reactors || fail

    elif [[ -f $dna_path ]]; then
      safe_link $dna_path $context_path-$context_type.new || fail
      source $dna_path || fail
    else
      log_vars=dna_path log_fatal "Internal error: dna not found"
      fail1
    fi

  end_function
  handle_return
}

build_context_gather_derive_tables_single() {
  local start_path=$1 lib_dim_path

  if [[ $start_path == /*/*/* ]]; then
    build_context_gather_derive_tables_single ${start_path%/*}
  fi

  lib_dt_path=$start_path/.lib/derive-tables
  if [[ -d $lib_dt_path ]]; then
    local dt from_written=f
    for dt in $(find -L $lib_dt_path -type f -not -name '.*' -name '*.*tab' | sort -g); do

      if [[ $from_written == f ]]; then
        echo "$NL# FROM $lib_dt_path" >>$context_path-$context_type.new || fail
        from_written=t
      fi

      add_derive_table $dt || fail

    done
  fi

}

build_context_gather_derive_tables() {
  begin_function_lo

    derive_tables=()
    build_context_gather_derive_tables_single $cell_path || fail
    write_vars_to_context derive_tables || fail

  end_function
  handle_return
}

build_context_trunk() {
  begin_function

    local context_type=trunk last_type=var \

    log_debug "Building trunk context for $short_cell" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    build_context_gather_derive_tables || fail

    build_context_trunk_dna || fail

    if [[ ! -d $status_path ]]; then
      mkdir -p $status_path || fail
    fi

    get_key_path || fail
    write_vars_to_context key_path || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

build_context_branch() {
  begin_function

    local context_type=branch last_type=var
    log_debug "Building branch context for $short_cell" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    local dim assignment member i members_string=
    begin_for ((i = 0; i < branch_dim_count; i++)); doo
      dim=${branch_dims[$i]}
      member=${branch_members[$i]}
      shell_quote_var member
      assignment="d_$dim=$member"
      members_string+="$member "
      write_to_context var assignment || fail
    end_for

    local content="
branch_dims=( ${branch_dims[*]} )
branch_dim_count=$branch_dim_count
branch_members=( ${members_string% } )
branch_hashes=( ${branch_hashes[*]} )
cell_is_leaf=$cell_is_leaf
"
    write_to_context var content || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

seed_coordinates_prep() {
  begin_function
    if (( ${coordinate_count:-0} > 0 )); then
      log_fatal "Coordinates already have data, can't seed them."
      fail1
    fi

    if [[ $seed_table == auto ]]; then
      local derive_table biggest_table= biggest_size=0
      for derive_table in ${derive_tables[*]}; do
        local -n derive_fields=derive_table_${derive_table}_fields \
                 derive_data=derive_table_${derive_table}_data \

        local size=${#derive_data[*]}
        if (( size > biggest_size )); then
          biggest_size=$size
          biggest_table=$derive_table
        fi
      done

      seed_table=$biggest_table

    fi

    if [[ ! "$seed_table" ]]; then
      log_fatal "Missing seed_table"
      fail1
    fi
  end_function
  handle_return
}

check_table_field() {
  local field=$1 expected_value=$expected_value value=${2:-} values=${3:-} fields

  is_valid=t
  if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
    return 0 # this one always matches
  fi

  if [[ ! "$value" || ! "$values" ]]; then

    get_plural $field fields
    local -n ddim=d_$field \
             ddims=d_$fields \
             pdim=p_$field \
             pdims=p_$fields \

    if [[ ! "$value" ]]; then
      value=${ddim:-${pdim:-}}
    fi
      
    if [[ ! "$values" ]]; then
      values=( "${ddims[@]:-${pdims:-}}" )
    fi

  fi
      
  if [[ "${values:-${value}}" == *"*"* ]]; then
    if [[ "$expected_value" != ${values:-${value}} ]]; then
      is_valid=f
    fi
  elif [[ "$value" && "$value" != all && "$value" != $empty_member \
       && "$value" != "$expected_value" ]]; then
    is_valid=f
  elif [[ "$values" && "$values" != all && "$values" != $empty_member \
       && " $values " != *" $expected_value "* ]]; then
    local v
    is_valid=f
    for v in "${values[@]}"; do
      if [[ "$v" == "$expected_value" ]]; then
        is_valid=t
        break
      fi
    done
  fi
  
  return 0
}

# inputs:
#   table_fields       
#   table_data
#   offset       (optional) offset into data structure where row starts
#   row_index    (optional) which row to select from the table
# either offset or row must be set
# outputs:
#   is_valid 
check_table_row() {
  local offset=${offset:-} row_index=${row_index:-} field_count=${#table_fields[*]}
  begin_function_grip
    local f t
    if [[ ! "$offset" ]]; then
      (( offset = row_index * field_count ))
    fi
    is_valid=t
    for (( f = 0; f < field_count; f++ )); do

      log_show_vars=f
      fence_grip

      local field=${table_fields[$f]}
      (( t = offset + f ))
      local expected_value=${table_data[$t]}

      if [[ -v all_dims[$field] ]]; then
        check_table_field $field
      fi

      if [[ $is_valid == f ]]; then
        break
      fi

    done
  end_function
  handle_return
}

# Will add a row to new_coordinate_data based on current ddim values and coordinate_fields
# Should only be called when the row is known to be valid
# inputs:
#   coordinate_fields
#   coordinate_fields_count
#   ignore_missing            (optional)
#   validate_row              (optional)
# outputs:
#   new_coordinate_data
#   total_coord_rows_added
#   row_is_valid
calc_coordinates_add_row() {
  local ignore_missing=${ignore_missing:-f}
  begin_function_lo

    local i new_coords=()
    for (( i = 0; i < coordinate_fields_count; i++ )); do
      local dim_var=${coordinate_fields[$i]}
      local -n dim_value=d_$dim_var
      if [[ ! "${dim_value:-}" ]]; then
        if [[ $ignore_missing == f ]]; then
          log_fatal "Missing dim: $dim_var"
          fail1
        fi
        new_coords+=( "" )
      else
        new_coords+=( "$dim_value" )
      fi
    done

    new_coordinate_data+=( "${new_coords[@]}" )
    log_debug "${coord_type}_coordinate_data+=( ${new_coords[*]} )"
    (( total_coord_rows_added++ ))

  end_function
  handle_return
}

setup_coord_fields() {
  begin_function

    case $coord_type in
      branch)
        coordinate_fields=( ${trunk_dims[*]:-} )
      ;;
      leaf)
        coordinate_fields=( ${control_props[*]:-} ${data_props[*]:-} )
      ;;
      sub)
        coordinate_fields=( ${sub_dims[*]:-} )
      ;;
      tree)
        coordinate_fields=( ${trunk_dims[*]:-} ${sub_dims[*]:-} )
      ;;
      *)
        log_fatal "Internal error: invalid coord_type=$coord_type"
        fail1
      ;;
    esac

    #  Not sure if this is correct
    #if [[ $target_form == seed ]]; then

    #  local new_fields=() dim

    #  for dim in ${coordinate_fields[*]}; do
    #    local -n member_type=dim_${dim}_member_type
    #    if [[ $member_type == static ]]; then
    #      new_fields+=( $dim )
    #    fi
    #  done

    #  coordinate_fields=( ${new_fields[*]} )

    #fi

    coordinate_fields_count=${#coordinate_fields[*]}

  end_function
  handle_return
}

load_implicit_dims() {
  begin_function_lo
    local d
    implicit_dims=()
    if [[ -e $out_path/output.tab ]]; then
      for d in $(head -n1 $out_path/output.tab); do
        if [[ ! " ${trunk_dims[*]} ${sub_dims[*]} " == *" $d "* ]]; then
          implicit_dims+=( $d )
          all_dims[$d]=1
        fi
      done
    fi
  end_function
  handle_return
}

# initialized coordinatas with a table to speed up coordinate calculation
#   of all possibilities
# won't work if coordinates already has data
# inputs:
#   coord_type: which coordinates to load
#   seed_table: defaults to auto, which will just choose the largest available table
seed_coordinates() {
  local seed_table=${seed_table:-auto} \
    coord_type=$coord_type \
    add_implicit_dims=${add_implicit_dims:-f} \
    fill_in_the_blanks=${fill_in_the_blanks:-f} \

  begin_function
    local -n coordinate_data=${coord_type}_coordinate_data \
      coordinate_fields=${coord_type}_coordinate_fields \

    local coordinate_fields_count=0 \
      coordinate_count=0 \
      coordinate_rows=0 \

    log_debug "Seeding $coord_type coordinates with seed table $seed_table"
    seed_coordinates_prep || fail

    local -n seed_fields=${seed_table}_fields \
             seed_data=${seed_table}_data \

    if [[ ! -v seed_fields ]]; then
      log_fatal "Invalid seed table: $seed_table"
      fail1
    fi

    local seed_field_count=${#seed_fields[*]} \
          seed_data_count=${#seed_data[*]} \
          total_coord_rows_added=0 \

    local seed_table_rows=$(( seed_data_count / seed_field_count ))

    setup_coord_fields || fail
    if [[ $add_implicit_dims == t ]]; then
      local f p
      for f in ${seed_fields[*]}; do
        if ! array_contains coordinate_fields $f; then
          coordinate_fields+=( $f )
          (( coordinate_fields_count++ ))
          all_dims[$f]=1
          get_plural $f p
          localize_dims+=" d_$f d_$p"
        fi
      done
    fi

    local field_index seed_field seed_data_index \
      new_coordinate_data=() \

    local -n \
      field_count=seed_field_count \
      table_fields=seed_fields \
      table_data=seed_data \

    begin_for (( row_index = 0; row_index < seed_table_rows; row_index++ )); doo
      seed_coordinates_handle_row || fail
    end_for

    coordinate_data=( "${new_coordinate_data[@]}" )
    (( coordinate_count = ${#coordinate_data[*]} ))
    (( coordinate_rows = coordinate_count / coordinate_fields_count ))

    if (( coordinate_rows > 1 )); then
      calc_coordinates_dedup || fail
    fi

  end_function
  handle_return
}

attempt_derive_check_derive_table() {
  local resolved_row resolved_dim
  for resolved_row in "${resolved_dependencies[@]}"; do
    found=t
    for resolved_dim in $resolved_row; do
      if [[ " ${fields[*]} " != *" $resolved_dim "* ]]; then
        found=f
        break
      fi
    done
    if [[ $found == t ]]; then
      break
    fi
  done
}

# inputs
#   dim    dim to output
#   var    var name containing value of dim
#   $1     message to output
show_trace_dim_message() {
  local var=$var dim=$dim message="$1"
  get_var_value $var
  local show_val=$value
  if [[ "${secret_vars:-}" && " ${secret_vars} " == *" $var "* ]]; then
    show_val='****'
  fi
  echo " ${DIM_DEBUG_COLOR}debug_id=$fork_debug_id $dim=$show_val$RESET $message" >&$fd_original_err
}

attempt_derive_from_function() {
  local function_name=$function_name
  if function_exists dim_${dim}_$function_name; then
    #log_debug "Trying derive function ${dim_type}_${dim}_$function_name"

    # This should be set to t in the derive function if requirements are met
    can_derive=f

    dim_${dim}_$function_name || return 1
    if [[ " $trace_dims " == *" $dim "* && "$values" ]]; then
      var=values \
      show_trace_dim_message "Derived from derive function: dim_${dim}_$function_name"
    fi
  fi
  return 0
}

# inputs:
#   value_found
#   dim
#   derive_table
# outputs:
#   values
#   value_found
# DEPRECATED, use extract_from_derive_table instead
#  attempt_derive_from_table() {
#  
#    local derive_table=$1
#    begin_function_lo
#  
#      local found=f
#      local -n fields=derive_table_${derive_table}_fields
#  
#      #  this should have already been checked before this function was called
#      #attempt_derive_check_derive_table
#  
#      can_derive=t
#  
#      out_field=$dim \
#      out_set=new_values \
#      extract_from_derive_table || return 1
#  
#      if [[ ! "${new_values[*]:-}" ]]; then
#        log_debug "No derived members found in derive table $derive_table which are valid for this row"
#        values=()
#        abort
#      fi
#  
#      if [[ -v old_values[*] && " ${!old_values[*]} " != *" all "* ]]; then
#        intersect old_values new_values intersected
#        copy_set intersected old_values
#      else
#        copy_set new_values old_values
#      fi
#  
#    end_function
#    handle_return
#  
#  }

# input:
#   dim
#   dim_type
#   $1        target var name
# output:
#   values    array of dim members
read_dim() {
  local -n target=$1
  begin_function_lo
    local -n is_secret=${dim_type}_${dim}_is_secret
    while true; do
      if [[ "${is_secret:-f}" == t ]]; then
        read -u $fd_original_in -p "(? for more info) $dim=" -rs values >&$fd_original_err || fail
        echo '************' >&$fd_original_err
      else
        read -u $fd_original_in -p "(? for more info) $dim=" -r values >&$fd_original_err || fail
      fi
      if [[ "$values" == \?* ]]; then
        command_detail=1 show_dimension $dim || fail
      else
        local problem=
        dim_var=$dim expand_dim_members values || fail
        if [[ "$problem" ]]; then
          echo "$problem" >&$fd_original_err
        else
          # value is valid
          if [[ "${new_values[*]}" != "$values" ]]; then
            echo "Expanded to: ${new_values[*]}" >&$fd_original_err || fail
            values=( "${new_values[@]}" )
          fi
          break
        fi
      fi
    done
  end_function
  handle_return
}

attempt_default() {
  local dim=$1
  begin_function_lo

    local problem
    local -n dim_type=${dim}_dim_type

    if function_exists ${dim_type}_${dim}_default; then
      ${dim_type}_${dim}_default || fail

      if [[ " $trace_dims " == *" $dim "* && "$values" ]]; then
        var=values \
        show_trace_dim_message "Default value taken from default function: ${dim_type}_${dim}_default"
      fi

    fi

    if [[ ! "${values:-}" ]] && function_exists ${dim_type}_${dim}_expand; then
      value= ${dim_type}_${dim}_expand || fail
      already_expanded=t

      if [[ " $trace_dims " == *" $dim "* && "$values" ]]; then
        if [[ -v ${dim_type}_${dim}_default ]]; then
          var=values \
          show_trace_dim_message "Default value taken from default value: ${dim_type}_${dim}_default"
        else
          var=values \
          show_trace_dim_message "Default value taken from expand function: ${dim_type}_${dim}_expand"
        fi
      fi

    fi

    if [[ "${values:-}" == ask ]]; then
      read_dim values || fail
      already_expanded=t
    fi

    if [[ ! "${values:-}" ]]; then

      if [[ " $optional_dims " == *" $dim "* ]]; then
        values=( $empty_member )
      fi
      already_expanded=t

    fi

  end_function
  handle_return
}

calc_coordinates_row_end() {
  begin_function_grip

    if [[ "$optional_dims" ]]; then
      local unknown_dim new_unknown_dims=
      for unknown_dim in ${unknown_dims[*]:-}; do
        if [[ " $optional_dims " != *" $unknown_dim "* ]]; then
          new_unknown_dims+="$unknown_dim "
        fi
      done
      unknown_dims=${new_unknown_dims% }
    fi

    if [[ "${unknown_dims:-}" ]]; then
      log_debug "Skipped row because of unresolvable dims: ${unknown_dims[*]}"
      problem_message="Could not resolve dims: ${unknown_dims[*]}"
      progress_bar_nudge x
    else
      ignore_missing=t \
      calc_coordinates_add_row || fail
      problem_message=
      progress_bar_nudge
    fi

  end_function
  handle_return
}

calc_coordinates_dedup_output_rows() {
  local row_id
  for ((row_id = 0; row_id < coordinate_rows; row_id++ )); do
    (( row_start = row_id * coordinate_fields_count ))
    echo "${coordinate_data[*]:$row_start:$coordinate_fields_count} $row_id"
  done
}

# will remove duplicate coordinates
# inputs:
#   coordinate_rows
#   coordinate_data
#   coordinate_fields_count
calc_coordinates_dedup() {
  begin_function

    local prev_row_count=$coordinate_rows \
      sorted_row_ids row_id row_start \
      prev_coordinate_data=( "${coordinate_data[@]}" ) \

    sorted_row_ids=$(calc_coordinates_dedup_output_rows | tee /tmp/out | sort | sed -E 's/^(.*) ([0-9]+)$/\2 \1/' | tee /tmp/out2 | uniq -f 1 | awk '{print $1}')
    coordinate_data=()
    for row_id in $sorted_row_ids; do
      (( row_start = row_id * coordinate_fields_count ))
      coordinate_data+=( "${prev_coordinate_data[@]:$row_start:$coordinate_fields_count}" )
    done

    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))
    if (( coordinate_rows != prev_row_count )); then
      log_debug "Coord dedup reduced rows: $prev_row_count -> $coordinate_rows"
    fi
    
  end_function
  handle_return
}

# inputs:
#   derive_table
#   dim
set_cross_dims_single() {

  local -n derive_fields=derive_table_${derive_table}_fields \
           derive_data=derive_table_${derive_table}_data \

  local field_count=${#derive_fields[*]} \
    data_count=${#derive_data[*]} \
    row_index data_index=0 column_index \
    value= field \

  local row_count=$((data_count / field_count))

  local -n dt_index=derive_table_${derive_table}_index_${dim}
  if [[ -v dt_index["$member"] ]]; then
    row_index=( ${dt_index["$member"]} )
    if (( ${#row_index[*]} > 1 )); then
      log_fatal "Too many rows found in derive table matching cross dim: $row_index"
      fail1
    fi

    for (( column_index = 0; column_index < field_count; column_index++ )); do
      field=${derive_fields[$column_index]}
      local fields
      get_plural $field fields
      if [[ $field != $dim ]]; then
        (( data_index = row_index * field_count + column_index ))
        value=${derive_data[$data_index]}
        local -n field_dim=d_$field
        if dim=$field \
           single_member="${field_dim:-}" \
           multi_member=d_$fields \
           target_member="$value" \
           member_conflicts; then
          conflict=$field
          break
        else
          if [[ "$value" != all ]]; then
            log_debug "Cross dim set: $field=$value"
            field_dim=$value
            validated_dims+=" $field"
          fi
        fi
      fi
    done
  else
    log_debug "Member ($member) doesn't exist in derive table ($derive_table)"
    conflict='(missing from table)'
  fi

}

# input: dim
set_cross_dims() {
  begin_function_grip

    local -n member=d_$dim 
    local derive_table

    for derive_table in $cross_dim_tables; do
      set_cross_dims_single
    done

    if [[ "$conflict" ]]; then
      local conflict_plural
      if [[ "$conflict" =~ ^[a-zA-Z0-9_]+$ ]]; then
        get_plural $conflict conflict_plural
        local -n conflict_member=d_$conflict \
          conflict_members=d_$conflict_plural
        log_debug "Conflict found between cross-dim $dim = $member and $conflict = ${conflict_members:-${conflict_member:-}}"
      else
        log_debug "Conflict found for cross-dim $dim = $member $conflict"
      fi
    fi

  end_function
  handle_return
}

calc_coordinates_next_unknown_dim_found() {
  local needs_narrowing=${needs_narrowing:-t} \
    log_show_vars=dim
  begin_function_grip

    resolved_dims+=" $dim"
    progress_bar_next

    local -n \
      sdim=s_$dim \
      sdims=s_$dims \
      ddim=d_$dim \
      ddims=d_$dims \

    local -n derive_tables_loaded=dim_${dim}_derive_tables_loaded
    if [[ "${derive_tables_loaded:-}" != t ]]; then
      load_related_derive_tables $dim || fail
    fi

    unset sdim ddim ddims sdims
    if [[ $already_expanded == f ]]; then
      sdims=( "${values[@]}" )
      expand_dims $dim || fail
    else
      ddims=( "${values[@]}" )
    fi

    local new_unknown_dims=( ${unknown_dims[*]:$((dim_index+1))} ${unknown_dims[*]:0:$dim_index} )

    local member ms
    if [[ "${ddims:-}" ]]; then
      ms=( "${ddims[@]}" )
    else
      ms=( "$ddim" )
    fi

    if [[ $needs_narrowing == t ]] && (( ${#ms[*]} > 3 )); then

      local derive_table 
      local -A old_values new_values intersected
      array_to_set ms old_values

      log_debug "Narrowing down possibilities"

      local -n dim_derive_tables=dim_${dim}_derive_tables
      begin_for derive_table in ${dim_derive_tables[*]:-}; doo

        out_field=$dim \
        out_set=new_values \
        in_set=old_values \
        extract_from_derive_table || fail

        log_show_vars=dim
        fence_grip

        old_values=()
        add_to_set new_values old_values
        new_values=()

      end_for

      if (( ${#old_values[*]} < ${#ms[*]} )); then
        ms=( "${!old_values[@]}" )
      fi

    fi

    if [[ "${ms:-}" ]]; then
      log_debug "Resolved $dim with $phase: ${ms[*]:0:30}"
    else
      log_debug "Failed to find any matching values for $dim in $phase phase"
    fi

    if [[ "$row_index" ]] && (( ${#ms[*]} > 1 )); then
      log_fatal "Too many dim members for single coordinate row: ${ms[*]}"
      fail1
    fi

    local -n cross_dim_tables=dim_${dim}_cross_dim_tables

    unset ddims
    local m
    for m in "${ms[@]}"; do

      if [[ "$m" == all ]]; then
        log_fatal "Internal error: a member should never be 'all' at this point."
        fail1
      fi

      # don't need to validate if in derive phase, since it's already proven valid by the derive
      #   process itself
      local needs_validation=f
      if [[ $phase == default ]]; then
        needs_validation=t
      fi

      # recursive
      phase=unknown \
      calc_coordinates_next_dim_member || fail

    done; maybe_break

    row_ended=t
    unset ddim

  end_function
  handle_return
}

# will end the coordinate row one way or another
# inputs:
#   unknown_dims
#   all other ddims which may be used to derive the unknown dims
calc_coordinates_next_unknown_dim() {
  local log_show_vars=unknown_dims
  begin_function_grip
    local dim dims \
      phase unknown_dims=( ${unknown_dims:-} ) \
      resolved_dims=${resolved_dims:-} \
      row_ended=f \

    if (( coord_limit > 0 && total_coord_rows_added >= coord_limit )); then
      log_warn "Limit of $coord_limit reached, not calculating any further"
      abort
    fi

    local dim_index
    if [[ "${unknown_dims:-}" ]]; then
      log_debug "Attempting to resolve unknowns: ${unknown_dims[*]}"
      for phase in derive default; do
        for (( dim_index = 0; dim_index < ${#unknown_dims[*]}; dim_index++ )); do
          dim=${unknown_dims[$dim_index]}

          local -n dim_type=${dim}_dim_type
          get_plural $dim dims

          log_show_vars='dim phase unknown_dims'
          fence_grip
          log_debug "Finding values for $dim in phase $phase"

          local values=() already_expanded=f needs_narrowing=t value_found=f
          if [[ $phase == derive ]]; then
            deriving= \
            skip_dims= \
            attempt_derive $dim || fail
            needs_narrowing=f
          elif [[ " ${all_if_blank:-} " == *" $dim "* ]]; then
            local new_values=()
            values=all
            dim_var=$dim \
            expand_dim_members values
            values=( "${new_values[@]}" )
            already_expanded=t
          else
            attempt_default $dim || fail
          fi

          if [[ "${values:-}" ]]; then
            calc_coordinates_next_unknown_dim_found || fail
            abort
          fi

        done; maybe_break
      done; maybe_break
    fi

    if [[ $row_ended == f ]]; then
      # whether we resolve all or not, we need to end here
      calc_coordinates_row_end || fail
    fi

  end_function
  handle_return
}

calc_coords_validate_member() {
  local dim=$1 member=$2 log_show_vars='dim member'
  begin_function_grip
    is_valid=t
    conflicting_values=()

    log_debug "Validating $dim = $member"

    # all needs to be permitted here in the case of a dim that doesn't have explicit members
    #   but where the user needs to communicate that all are acceptable based on derivation of others?
    if [[ "$member" == all ]]; then
      abort
    fi

    if [[ " $optional_dims " == *" $dim "* && ( ! "$member" || $member == $empty_member ) ]]; then
      abort
    fi

    local values=() can_derive value_found=f
    deriving= \
    skip_dims= \
    attempt_derive $dim || fail

    log_show_vars='dim member'
    fence_grip

    if [[ $can_derive == t ]]; then
      if [[ ! "${values[0]:-}" ]]; then
        #log_debug "Failed to derive dim $dim when can_derive == t, skipping row"
        is_valid=f
      elif ! array_contains values "$member" && ! array_contains values all; then
        conflicting_values=( "${values[@]}" )
        is_valid=f
      fi
      abort
    fi

    #  should have already been set
    #eval "local d_$dim=\$member"
    local rd
    for rd in $resolved_dims; do
      if [[ $rd == $dim ]]; then
        continue
      fi
      local value_found=f
      stop_after_first_match=t \
      deriving= \
      skip_dims= \
      from_dim=$dim attempt_derive $rd || fail

      if [[ $can_derive == t ]]; then
        if [[ ! "${values:-}" ]]; then
          is_valid=f
        else
          local -n rd_member=d_$rd
          if [[ "${rd_member:-}" ]] && ! array_contains values "$rd_member" && ! array_contains values all; then
            conflicting_values=( "${values[@]}" )
            is_valid=f
          fi
        fi
        abort
      fi
    done
  end_function
  handle_return
}

# inputs:
#   dim            can't be empty
#   single_member  may be empty
#   multi_member   name of array var, may be empty
#   target_member  can't be empty
# outputs:
#   returns 0 if there are conflicts
member_conflicts() {
  begin_function

  if [[ "$single_member" ]]; then
    if [[ "$single_member" != "$target_member" && "$target_member" != all && "$single_member" != all ]]; then
      return 0
    fi
  elif [[ "$multi_member" ]]; then
    local -n members=$multi_member
    if [[ "${members:-}" ]]; then

      local found=f new_values v
      dim_var=$dim expand_dim_members $multi_member || return 0

      for v in "${new_values[@]}"; do
        if [[ "$v" == "$target_member" || "$target_member" == all || "$v" == all ]]; then
          found=t
          break
        fi
      done

      if [[ $found == f ]]; then
        return 0
      fi

    fi
  fi
  return 1

  end_function
  handle_return
}

# inputs:
#   dim
#   m       member value
#   phase   unknown or known.  
calc_coordinates_next_dim_member() {
  local phase=$phase
  log_show_vars='dim m'
  begin_function_grip
    localize
    local -n member=d_$dim
    member=$m
    log_debug "Processing $dim = $member"
    local validated_dims=${validated_dims:-} conflicting_values=() is_valid

    if [[ $needs_validation == t && " $validated_dims " != *" $dim "* ]]; then
      calc_coords_validate_member $dim "$member" || fail
      log_show_vars='dim member'
      fence_grip
    else
      is_valid=t
    fi

    if [[ $is_valid == t ]]; then

      conflict=
      if [[ -v cross_dim_tables ]]; then
        set_cross_dims || fail

        local d
        for d in $validated_dims; do
          if [[ $phase == unknown ]]; then
            remove_array_element new_unknown_dims $d
          else
            remove_word_from_string check_dims $d
          fi
        done

      fi

      validated_dims=

      if [[ ! "$conflict" ]]; then
        # recursive
        if [[ $phase == known ]]; then
          calc_coordinates_next_dim || fail
        else
          unknown_dims="${new_unknown_dims[*]}" \
          calc_coordinates_next_unknown_dim || fail
        fi
      else
        log_debug "Row skipped because of cross dim conflict"
      fi
    else
      local extra=
      if [[ "${conflicting_values:-}" ]]; then
        extra=" != ${conflicting_values[*]}"
      fi
      log_debug "Dim member doesn't fit row contraints: $dim: $member$extra, skipping row"
    fi

  end_function
  handle_return
}

# input:
#   $1   name of dim
# output:
#   derive_tables_loaded
load_related_derive_tables() {
  local dim=$1
  begin_function_lo
    local -n dts=dim_${dim}_derive_tables
    local dt
    for dt in $dts; do
      local -n dtd=derive_table_${dt}_data
      if [[ ! -v dtd ]]; then
        load_derive_table $dt || fail
      fi
    done
    derive_tables_loaded=t
  end_function
  handle_return
}

# calling this will produce and end at least one coordinate row 
# inputs:
#   check_dims (may be empty)
#   coordinate_fields_plural
calc_coordinates_next_dim() {
  begin_function_grip

    local coord_limit=${coord_limit:-0} total_coord_rows_added=${total_coord_rows_added:-0}
    if (( coord_limit > 0 && total_coord_rows_added >= coord_limit )); then
      log_debug "Limit of $coord_limit reached, not calculating any further"
      abort
    fi

    local dim dims \
      row_index=${row_index:-} \
      unknown_dims=${unknown_dims:-} \
      check_dims=${check_dims:-} \
      resolved_dims=${resolved_dims:-} \
      needs_validation=${needs_validation:-t} \

    dim=${check_dims%% *}
    check_dims=${check_dims##$dim*( )}

    if [[ "$dim" ]]; then

      log_debug "Checking dim $dim"
      get_plural $dim dims

      eval "local -I d_$dim d_$dims"
      local -n member=d_$dim \
        members=d_$dims

      local -n derive_tables_loaded=dim_${dim}_derive_tables_loaded

      if [[ "${derive_tables_loaded:-}" != t ]]; then
        load_related_derive_tables $dim || fail
      fi

      if [[ $target_form == seed ]]; then
        if [[ ! "$member" && ! "$members" ]]; then
          local value=all
          expand_dim value values || fail
          members=( "${values[@]}" )
        fi
      fi

      if [[ "${member:-}" || "${members:-}" ]]; then
        
        local m
        local -n dim_type=dim_${dim}_type

        resolved_dims+=" $dim"
        progress_bar_next

        if [[ "${member:-}" ]]; then
          m=$member
        else
          local ms=( "${members[@]}" )
          if [[ "$row_index" ]] && (( ${#ms[*]} > 1 )); then
            log_fatal "Too many possibilities found for a single coordinate row: ${ms[*]}"
            fail1
          fi
        fi

        local -n cross_dim_tables=dim_${dim}_cross_dim_tables

        unset members
        unset -n members member

        local phase=known
        if [[ "${m:-}" ]]; then
          calc_coordinates_next_dim_member || fail
        else
          for m in "${ms[@]}"; do
            calc_coordinates_next_dim_member || fail
          done; maybe_break
        fi

        log_show_vars='dim member'
        fence_grip

        # if none of the members are valid, we just skip the row
        # if any are valid, they will have added their own rows already
        abort

      else # no members
        log_debug "Dim unknown: $dim"
        unknown_dims+=" $dim"
        calc_coordinates_next_dim || fail
      fi

    else # check_dims is empty, need to proceed to unknowns
      calc_coordinates_next_unknown_dim || fail
    fi

  end_function
  handle_return
}

# internal function
seed_coordinates_handle_row() {
  log_show_vars=row_index
  begin_function_grip
    localize
    local is_valid
    check_table_row
    if [[ $is_valid == t ]]; then
      for field_index in ${!seed_fields[*]}; do
        seed_field=${seed_fields[$field_index]}
        if [[ -v all_dims[$seed_field] ]]; then
          local -n member=d_$seed_field
          (( seed_data_index = row_index * seed_field_count + field_index ))
          member=${seed_data[$seed_data_index]}
        fi
      done

      if [[ $fill_in_the_blanks == t ]]; then
        local check_dims=${!all_dims[*]} unknown_dims= dim validated_dims=
        needs_validation=f \
        calc_coordinates_next_dim || fail
      else
        ignore_missing=t calc_coordinates_add_row || fail
      fi

    fi
  end_function
  handle_return
}

# Will not output fields that don't exist
xlr8_get_input_string() {
  local fields_to_export=$*
  begin_function
    for f in $fields_to_export; do
      local -n x=$f
      if [[ -v x ]]; then
        if is_array x; then
          local m
          v="( "
          for m in "${x[@]}"; do
            shell_quote_var m
            v+="$m "
          done
          v+=")"
        else
          v=$x
        fi
        shell_quote_var v
        input_string+="$f=$v$NL"
      fi
    done
  end_function
  handle_return
}

xlr8_execute() {
  begin_function
    case $source_type in
      simple_java)
        java -cp $target_path Main || fail
      ;;
      *)
        log_fatal "Don't know how to execute source type $source_type yet"
        fail1
      ;;
    esac
  end_function
  handle_return
}

xlr8() {
  local function_name=$1; shift
  local fields_to_export=$*
  begin_function

    debug_start

    local xlr8_command_path=/work/xlr8/op/$function_name \
      target_path=$xlr8_command_path/target \
      source_path=$xlr8_command_path/src \
      standard_fields='
        bisect_test
        debug_bisect
        debug_bisect_max
        debug_bisect_min
        debug_exit
        debug_function_old
        debug_id
        debug_id_current
        debug_immediate
        debug_quick_function
        debug_quick_stop_less_than_depth
        debug_restart_command
        debug_step_to_mid_function
        debugging
        fork_debug_id
        fork_id_current
        pause_at_functions
        pause_at_vars
        secret_vars
        show_time
        show_time_prev
        trace_condition
        trace_expression
        trace_fun
        trace_structure
        trace_time
        trace_time_fd
        trace_time_log
        trace_var
        trace_vars
        trace_var_always
        trace_var_old
        trace_var_sub
      '

    if [[ ! -d $xlr8_command_path ]]; then
      log_fatal "Function $function_name doesn't exist in $xlr8_command_path"
      fail1
    fi

    if [[ ! -d $target_path ]]; then
      fork execute_commands "$xlr8_command_path" update || fail
    fi

    if [[ ! -d $target_path ]]; then
      log_fatal "Function $function_name didn't produce a target path"
      fail1
    fi

    if [[ -f $target_path/Main.class ]]; then
      source_type=simple_java
    else
      log_fatal "Can't identify source type of xlr8 op: $xlr8_command_path"
      fail1
    fi

    local input_string= v f
    xlr8_get_input_string $standard_fields $fields_to_export || fail

    result=$(echo "$input_string" | xlr8_execute) || fail
    if [[ "$result" ]]; then
      source "$result" || fail
    fi

  end_function
  handle_return
}

# inputs:
#   check_dims
#   coordinate_data
#   coordinate_count
#   coordinate_rows
#   coordinate_fields_count
calc_coordinates_refine_multi() {
  begin_function_lo
    front_load=6 progress_bar_start $(( coordinate_rows * coordinate_fields_count ))

    local target_dim_var_type
    if [[ $seed_already_expanded == f ]]; then
      target_dim_var_type=sdims
    else
      target_dim_var_type=ddim
    fi

    begin_for (( row_index = 0; row_index < coordinate_rows; row_index++ )); doo

      table=${coord_type}_coordinate \
      convert_table_to_dims || fail

      if [[ $seed_already_expanded == f ]]; then
        expand_dims $check_dims || fail
      fi

      calc_coordinates_next_dim || fail
      progress_bar_next
      log_debug "Finished coordinate row $((row_index+1)) of $coordinate_rows"

    end_for
    progress_bar_stop
  end_function
  handle_return
}

prep_seed_dims() {
  local dim dims
  for dim in ${!all_dims[*]}; do

    get_plural $dim dims

    local -n \
      ddim=d_$dim ddims=d_$dims \
      idim=i_$dim idims=i_$dims \

    ddim=${idim:-}
    ddims=${idims:-}

  done
}

calc_coordinates_slow() {
  begin_function
    local row_index=${row_index:-} \
      check_dims="${coordinate_fields[*]}" \
      validated_dims= \

    if [[ $target_form == seed ]]; then
      prep_seed_dims || fail
    fi

    local total_coord_rows_added=0
    if (( coordinate_rows > 0 )); then
      log_debug "Refining existing $coord_type dim coordinates"
      calc_coordinates_refine_multi || fail
    else
      # it is assumed that dims are already expanded before this point, and so ddims will be used
      log_debug "Calculating $coord_type cell coordinates for dims: ${coordinate_fields[*]}"
      front_load=6 progress_bar_start $coordinate_fields_count
      calc_coordinates_next_dim || fail
      progress_bar_stop
    fi

    coordinate_data=( "${new_coordinate_data[@]}" )

  end_function
  handle_return
}

xlr8_get_dim_fields() {
  local dims=$*
  begin_function
    local field
    dim_fields=

    for dim in $*; do
      dim_fields+="
        ${dim_type}_${dim}_aliases
        ${dim_type}_${dim}_members
        "
    done
  end_function
  handle_return
}

# inputs:
#   coord_type
#   source       set to dims to load coordinates from existing dims
#                set to coords to using existing coordinates and attempt to fill in blanks
#   target_form  seed / tree whether to produce seed coords or not
#                seed coords don't take into account user provided dims, but
#                will calculate all possible dims to be filtered later
#   all ddims of that type OR existing coords
# assumes ddims are in array form (not space separated)
# assumes all checks were done previously to determine if this is needed
calc_coordinates() {
  local clear_existing_coords=${clear_existing_coords:-t} \
    coord_type=$coord_type \
    coord_limit=${coord_limit:-} \
    target_form=${target_form:-tree} \
    seed_already_expanded=${seed_already_expanded:-f} \

  begin_function

    localize

    local dim_var \
      new_coordinate_data=() \
      problem_message= \
      coordinate_fields_count=0 \
      coordinate_count=0 \
      coordinate_rows=0 \
      coord_prefix= \

    #  we want the name to be the same to make refining easier
    #if [[ $target_form == seed ]]; then
    #  coord_prefix=seed_
    #fi

    local -n coordinate_data=$coord_prefix${coord_type}_coordinate_data \
      coordinate_fields=$coord_prefix${coord_type}_coordinate_fields \

    if [[ $clear_existing_coords == t ]]; then

      local parent_coord_path=${cell_path%/*}/.cyto/context-branch-coords

      if [[ $target_form == tree && -f $context_path-$coord_type-coords ]]; then
        source $context_path-$coord_type-coords || fail
        seed_already_expanded=t
      elif [[ -f $parent_coord_path ]]; then
        source $parent_coord_path || fail
        seed_already_expanded=t
      else
        coordinate_data=()
        setup_coord_fields || fail
      fi

    fi

    coordinate_fields_count=${#coordinate_fields[*]}
    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))
    unknown_dims= resolved_dims=

    if [[ ! "${coordinate_fields:-}" ]]; then
      abort
    fi

    if [[ ${xlr8:-f} == t ]]; then
      local -n fields=${coord_type}_coordinate_fields
      local dt dt_fields=
      for dt in ${derive_tables[*]}; do
        dt_fields+="${dt}_fields ${dt}_data "
      done
      local coord_fields="
        coordinate_data
        coordinate_count
        coordinate_rows
        coordinate_fields_count
      "
      local dim_fields
      local dim_type=trunk_dims
      xlr8_get_dim_fields ${trunk_dims[*]}
      xlr8 load_coordinates $coord_fields $dim_fields $fields $dt_fields || fail
    else
      calc_coordinates_slow || fail
    fi

    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))

    if (( coordinate_count == 0 )); then
      case ${handle_no_coords:-error} in
        error)
          if [[ "$problem_message" ]]; then
            log_fatal "$problem_message"
          fi
          log_fatal "Could not calculate any coordinate rows. Try specifying more dims."
          fail1
        ;;
        ignore)
          log_debug "Could not calculate any coordinate rows."
        ;;
        *)
          log_fatal "Invalid value for handle_no_coords: $handle_no_coords"
          fail1
        ;;
      esac
    fi

    if [[ $coord_type == branch && ${cell_is_leaf:-f} == t ]] && (( coordinate_rows > 1 )); then
      log_fatal "Cell error: found more than one branch coordinate possibility on a leaf cell."
      fail1
    fi

    # refine is used to determine if coords need to be calculated
    local -n refined=${coord_type}_coordinate_refined
    if [[ $target_form == seed ]]; then
      refined=f
    else
      refined=t
    fi

    log_debug "$coordinate_rows $coord_type coordinate rows found" 

  end_function
  handle_return
}

# Doesn't do anything at the moment
# only run if the cell is actually a leaf
build_context_leaf() {
  begin_function
    local context_type=leaf last_type=var
    log_debug "Building leaf context for $cell_path" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    if [[ -e $context_path-$context_type.new ]]; then
      mv $context_path-$context_type.new $context_path-$context_type || fail
    fi

  end_function
  handle_return
}

# not sure this makes sense
calc_anchor_dims() {
  begin_function
    # all anchors and non-branch dim calculations are dynamic per command execution
    # and so can't be precalculated and stored in the context
    : ${anchor_dims:=${anchor_dims:-${default_anchor_dims:-}}}
    if [[ "${branch_dims:-}" && "$branch_dims" != "$anchor_dims" ]]; then
      local branch_dim
      for branch_dim in ${branch_dims[*]}; do
        remove_word_from_string anchor_dims $branch_dim
      done
      if [[ "$anchor_dims" ]]; then
        anchor_dims="${branch_dims[*]} $anchor_dims"
      else
        anchor_dims="${branch_dims[*]}"
      fi
    fi
  end_function
  handle_return
}

get_highest_trunk_context_cell() {
  begin_function
    local parent_cell=${cell_path%/*}
    while [[ -e $parent_cell/.cyto/context-trunk ]]; do
      parent_cell=${parent_cell%/*}
    done
    if [[ -e $parent_cell/.cyto/context-trunk ]]; then
      highest_trunk_context_cell=$parent_cell
    fi
  end_function
  handle_return
}

build_context() {
  local cell_path=$1
  begin_function

    if [[ ! -f $context_path-trunk ]]; then
      local trunk_context_path=$trunk_cell/.cyto/context
      if [[ $cell_is_trunk == t || ! -f $trunk_context_path-trunk ]]; then
        context_path=$trunk_cell/.cyto/context \
        build_context_trunk || fail
      else
        source $trunk_context_path-trunk || fail
      fi
      if [[ $cell_is_trunk == f ]]; then
        safe_link $trunk_context_path-trunk $context_path-trunk || fail
      fi
    else
      source $context_path-trunk || fail
    fi
    fence

    #  doesn't make sense?
    #calc_anchor_dims || fail

    setup_dims || fail
    if [[ ! -f $context_path-branch ]]; then
      build_context_branch || fail
    else
      source $context_path-branch || fail
    fi
    fence_grip

    if [[ ! -f $context_path-branch-coords ]]; then

      coord_type=branch \
      target_form=seed \
      calc_coordinates || fail

      fence

      coord_type=branch \
      write_coordinates_to_shell_file $context_path-branch-coords || fail

    fi

    #  unused at the moment
    #if [[ $cell_is_leaf == t ]]; then
    #  if [[ ! -f $context_path-leaf ]]; then
    #    build_context_leaf || fail
    #  else
    #    source $context_path-leaf || fail
    #  fi
    #fi

    if [[ -e $context_path.new ]]; then
      rm $context_path.new || fail
    fi

    if [[ -e $context_path-trunk ]]; then
      cat $context_path-trunk >>$context_path.new || fail
    fi

    if [[ -e $context_path-branch ]]; then
      cat $context_path-branch >>$context_path.new || fail
    fi

    if [[ -e $context_path-leaf ]]; then
      cat $context_path-leaf >>$context_path.new || fail
    fi

    if [[ -e $context_path.new ]]; then
      mv $context_path.new $context_path || fail
    fi

    if [[ ! -f $context_path-check ]]; then
      context_type=check \
      write_vars_to_context \
        out_file \
        out_path \
        cell_is_leaf \
        check_op_var \
        data_props \
        default_freshness \
        || fail
      mv $context_path-check.new $context_path-check || fail
    fi

  end_function
  handle_return
}

# inputs:
#   $1   cell path to search for branches
#   dim  dimension to gather members of
get_members_from_branches() {
  local cell_path=$cell_path dim=$dim
  begin_function
    local branch_folders folder value
    branch_folders=$(find1 $cell_path -name "$dim:*" -type d) || fail
    values=()
    for folder in ${branch_folders}; do
      local member_var_path=$folder/.member
      if [[ -f $member_var_path ]]; then
        value=$(<$member_var_path) || fail
      else
        value=${folder##*:}
      fi
      values+=( "$value" )
    done
  end_function
  handle_return
}

# 'value' is the loop var
parallel_loop() {
  local loop_over_var2=$loop_over_var head2=${head:-} \
    body2=$body tail2=${tail:-} \
    par2=$par fork2=$fork \

  local log_show_vars='loop_over_var=loop_over_var2 par=par2 fork=fork2'
  begin_function_lo

    # Make sure these variables don't get passed into inner loops
    local loop_over_var= head= body= tail= par= fork=
    local -n array=$loop_over_var2

    if [[ ! -v array ]]; then
      log_fatal "Internal error: Variable doesn't exist: $loop_over_var2"
      fail1
    fi

    local parallel=f size=${#array[*]}
    if [[ $size -gt 1 && $parallel_execution == t && $par2 == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi

    local processes= value
    leave_loop=0

    local extra
    if [[ $parallel == t ]]; then
      extra=" in parallel"
    else
      extra=" sequentially"
    fi

    if (( size > 1 )); then
      log_debug "Looping over $size values$extra. body: $body2" || fail
    fi

    begin_for value in "${array[@]}"; doo

      log_debug "Current iteration value=$value" || fail

      if [[ "$head2" ]]; then
        eval "$head2" || fail
      fi

      if [[ $parallel == t ]]; then
        fork_bg "$body2" 
        processes+=" $!"
      else
        if [[ $fork2 == t ]]; then
          fork_fg "$body2" || fail
        else
          eval "$body2" || fail
        fi
      fi

      if [[ "$tail2" ]]; then
        eval "$tail2" || fail
      fi

    end_for

    wait_for_sub_processes || fail

  end_function
  handle_return
}

for_each_member_single() {
  local -I dim command_history
  local -n ddim=d_$dim
  local member=$ddim
  log_debug "Current iteration value=$member"
  $function || return 1
}

for_each_member_multi() {
  begin_function_lo

    member_count=${#values[*]}

    # don't refine the upstream link if there would be multiple matches
    local upstream_cell_link=

    if (( member_count == 0 )); then
      log_fatal "No members found for $dim"
      fail1
    fi

    unset dim_members dims_members
    loop_over_var=values \
      head="local -I dim command_history
        local d_$dim=\"\$value\" d_$dims
        local member=\$d_$dim
        unset value values
        " \
      body=$function \
      tail='
        if [[ $leave_loop -gt 0 ]]; then
          break
        fi
        ' \
      parallel_loop || fail

  end_function
  handle_return
}

# input: 
#   $1=dim
#   function=function to execute for each member
#   fork=whether the process should be forked before executing 
#     the function. (optional)
#   get_members_from
for_each_member() {
  local dim=$1 \
    function=$function leave_loop=${leave_loop:-0} \
    fork=${fork:-t} \
    par=${par:-t} \
    cell_path=${cell_path:-} \
    get_members_from=${get_members_from:-coords}

  local log_vars='fork par' \
    log_show_vars='dim function'
  begin_function

    local dims values=() member_count=0
    get_plural $dim dims

    case $get_members_from in
      coords)
        coord_type=branch \
        fetch_values_from_coordinates $dim || fail
      ;;
      existing_dims)
        local -n dims_members=d_$dims dim_members=d_$dim
        values=( "${dims_members[@]:-${dim_members[@]:-}}" )
      ;;
      existing_branches)
        get_members_from_branches || fail
      ;;
      *)
        log_fatal "Internal error: invalid get_members_from value: $get_members_from"
        fail1
      ;; 
    esac

    member_count=${#values[*]}

    if (( member_count == 0 )); then
      log_fatal "Failed to resolve required dim: $dim. Either specify the value directly, or specify a dim that this can be derived from. See cell help for more info (cell . ??)"
      fail1
    elif (( member_count == 1 )); then
      for_each_member_single || fail
    else
      for_each_member_multi || fail
    fi

  end_function
  handle_return
}

# input:
#   from_file
#   to_file
#   key_path
#   tmp_path
cell_decrypt_file() {
  local from_file=$1 to_file=$2 user=${safe_user:-$USER} \
    user_private_key=${user_private_key:-~/.ssh/id_rsa} \

  begin_function
    if [[ ! "$key_path" ]]; then
      log_fatal "No key path was found. Use 'cell safe key add' to create the first key."
      fail1
    fi
    validate_user_key $key_path/$user.key || fail

    if [[ ! -d $tmp_path ]]; then
      mkdir $tmp_path || fail
    fi

    local mk_path=$tmp_path/mk
    defer "rm $mk_path"
    extract_master_key $key_path/$user.key $mk_path || fail
    master_key=$mk_path \
    simple_decrypt $from_file $to_file || fail
  end_function
  handle_return
}

plant_seed_internal() {
  local from=$1 to=$2 contents x x_part deep=${deep:-t} \
    cell_is_leaf=${cell_is_leaf:-t}

  begin_function

    if [[ ! -d $to ]]; then

      log_verbose "Planting seed from $from to $to" || fail

      if [[ $from == /seed/* && -d $from ]]; then
        plant_seed_internal ${from%/*} ${to%/*} || fail
      else
        log_fatal "Seed doesn't exist for $to"
        fail1
      fi

    else

      contents=( $(find1 $from | sort -g) ) || fail
      local target
      begin_for x in ${contents[*]}; doo
        x_part=${x##*/}
        target=$to/$x_part
        if [[ -d $x ]]; then
          if [[ ! -e $target ]]; then
            if [[ $x_part == .dna || $x_part == .root || $x_part == .lib ]]; then
              safe_link $(realpath $x) $to/ || fail
            elif [[ $x_part == .mock && "${current_mock:-f}" != f && -d $x/$current_mock ]]; then
              safe_link $(realpath $x)/$current_mock/!(export) $to/ || fail
            elif [[ $x_part == *:* ]]; then

              if [[ "${branch_coordinate_fields:-}" ]]; then
                local dim_part=${x_part%%:*} \
                  mem_part=${x_part#*:}

                local values
                coord_type=branch \
                fetch_values_from_coordinates $dim_part || fail

                local value_count=${#values[*]}

                # Hashed members currently not supported
                # Not too hard to implement, but isn't likely to be needed
                if (( value_count == 1 )) && [[ "$values" == "$mem_part" ]]; then
                  plant_seed_internal $x $to || fail
                fi
              fi

            elif [[ $x_part != .* ]]; then
              mkdir $target || fail
            fi
          fi
          if [[ $x_part != .* && -d $target && $deep == t ]]; then
            plant_seed_internal $x $target || fail
          fi
        elif [[ $cell_is_leaf == t && ! -e $target && $x_part != .* ]]; then
          if [[ $x == *.safe ]]; then
            cell_decrypt_file $x ${target%.safe} || fail
          else
            cp -a $x $to/ || fail
          fi
        fi
      end_for

    fi
  end_function
  handle_return
}

# inputs: $1  work path to the cell
plant_seed() {
  local seed_path from=$1 to=${2:-$1} \
    deep=${deep:-t} \
    ignore_nonexistent=${ignore_nonexistent:-f}

  begin_function

    if [[ ! -d "$to" ]]; then
      log_fatal "plant_seed called on a non-existant work path: $to"
      fail1
    fi

    find_seed_path $from || fail
    if [[ ! "$seed_path" ]]; then
      log_fatal "No seed is associated with this path: $to"
      fail1
    fi

    local dna_path=$seed_path
    if [[ $command_requires_cell == t ]]; then
      while [[ ! -d $dna_path/.dna ]]; do
        dna_path=${dna_path%/*}
        if [[ $dna_path != /*/* ]]; then
          log_fatal "Could not find dna in seed: $seed_path"
          fail1
        fi
      done

      if [[ $dna_path != $seed_path ]]; then
        safe_link $dna_path/.dna $to/ || fail
      fi

    fi

    plant_seed_internal $seed_path $to || fail

  end_function
  handle_return
}

init_coord() {
  local coord_type=$1
  local -n \
    coordinate_data=${coord_type}_coordinate_data \
    coordinate_fields=${coord_type}_coordinate_fields \
    seed_table_fields=to_${coord_type}_coords_fields \
    seed_table_data=to_${coord_type}_coords_data \

  coordinate_data=() \
  coordinate_fields=() \
  seed_table_fields=() \
  seed_table_data=() \

}

load_repo_paths() {
  declare -gA repo_paths
  begin_function
    local repo repos
    repos=$(find1 /repo -not -name '.*' -type d) || fail
    begin_for repo in $repos; doo
      if [[ -d $repo/seed ]]; then
        local module modules
        modules=$(find1 $repo/seed -not -name '.*' -type d) || fail
        begin_for module in $modules; doo
          module=${module##*/}
          repo_paths[$module]=$repo
        end_for
      fi
    end_for
  end_function
  handle_return
}

broken_link_check() {
  begin_function
    local broken_links
    broken_links=( $(find -L $cyto_path -type l -print -o -name ".*" -prune) ) || fail
    if [[ "${broken_links:-}" ]]; then
      log_debug "Broken links found in cyto: $broken_links. Will rebuild cyto."
      problem_found=t
    fi
  end_function
  handle_return
}

link_single() {
  local only_one=${only_one:-f}
  begin_function

    extract_simple_name choice_name o choice_name
    local choice_var=${choice_name//-/_}

    if [[ $only_one == t ]]; then
      local -n choice_path=up_${up_var}_path
    else
      local -n choice_path=up_${up_var}_choices_${choice_var}_path
    fi

    if [[ ! -v choice_path ]]; then
      log_fatal "Missing choice path var"
      fail1
    fi

    if [[ ! -d $choice_path ]]; then
      log_fatal "Missing choice path"
      fail1
    fi

    if [[ $only_one == t ]]; then
      safe_link $choice_path $dep_path || fail
    else
      safe_link $choice_path $dep_path/choices/$choice_name || fail
    fi

  end_function
  handle_return
}

# inputs: dep_path up_name 
link_choices() {
  begin_function
    local choice_var choice_name o
    begin_for choice_name in ${choices[*]}; doo
      link_single || fail
    end_for
  end_function
  handle_return
}

make_cyto_reactors() {
  begin_function
    mkdir $reactor_path || fail
    local reactor_name
    begin_for reactor_name in ${reactors[*]}; doo
      local dep_path=$reactor_path/$reactor_name \
        reactor_var=${reactor_name//-/_}
      local -n path=reactors_${reactor_var}_path
      if [[ ! -v path ]]; then
        log_fatal "Missing reactor path var"
        fail1
      fi
      if [[ ! -d $path ]]; then
        log_fatal "Missing reactor path"
        fail1
      fi
      safe_link $path $dep_path || fail
    end_for
  end_function
  handle_return
}

make_cyto_up_single() {
  local up_name=$1
  begin_function
    local dep_path=$up_path/$up_name \
      up_var
    local up_var=${up_name//-/_}
    local -n choices=up_${up_var}_choices
    if [[ -v choices ]]; then
      mkdir -p $dep_path/choices || fail
      link_choices || fail
    else
      local choice_name=$up_name
      if [[ -d $dep_path ]]; then
        rm -rf $dep_path || fail
      fi
      only_one=t link_single || fail
    fi
  end_function
  handle_return
}

make_cyto_up() {
  begin_function
    if [[ ! -e $up_path ]]; then
      mkdir $up_path || fail
    fi
    local up_name o
    begin_for up_name in ${up[*]}; doo
      make_cyto_up_single $up_name || fail
    end_for
  end_function
  handle_return
}

get_required_freshness() {
  required_freshness=${fresh:-${default_freshness:-}}

  # this can be used in upstream prep functions to pass freshness to upstream
  : ${top_fresh:=$required_freshness}

  return 0
}

calc_coords_branch() {
  begin_function
    local coord_type=branch
    if [[ "${branch_coordinate_refined:-}" != t ]]; then
      calc_coordinates || fail
    fi
  end_function
  handle_return
}

# should only be executed on leaf cells
calc_coords_leaf() {
  begin_function

    local coord_type=leaf
    if [[ "${leaf_coordinate_refined:-}" != t ]]; then
      calc_coordinates || fail
    fi

    local leaf_coordinate_field_count=${#leaf_coordinate_fields[*]}
    local leaf_coordinate_data_count=${#leaf_coordinate_data[*]}
    if (( leaf_coordinate_field_count > 0 && leaf_coordinate_data_count > 0 )); then

      local leaf_coordinate_rows=$(( leaf_coordinate_data_count / leaf_coordinate_field_count ))

      if (( leaf_coordinate_rows == 1 )); then
        target_dim_var_type=ddim \
        table=${coord_type}_coordinate \
        convert_table_to_dims || fail
      fi

    fi

  end_function
  handle_return
}

# should only be executed on leaf cells
calc_coords_sub() {
  begin_function

    local coord_type=sub
    if [[ "${sub_coordinate_refined:-}" != t ]]; then
      calc_coordinates || fail
    fi

    local sub_coordinate_field_count=${#sub_coordinate_fields[*]}
    local sub_coordinate_data_count=${#sub_coordinate_data[*]}
    if (( sub_coordinate_field_count > 0 && sub_coordinate_data_count > 0 )); then

      local sub_coordinate_rows=$(( sub_coordinate_data_count / sub_coordinate_field_count ))

      if (( sub_coordinate_rows == 1 )); then
        target_dim_var_type=ddim \
        table=${coord_type}_coordinate \
        convert_table_to_dims || fail
      fi

    fi

  end_function
  handle_return
}

load_post_context_dynamic_vars() {
  begin_function

    if [[ $cell_is_leaf == t ]]; then
      target_dim_var_type=ddim \
      table=branch_coordinate \
      convert_table_to_dims || fail
    fi

    get_required_freshness || fail

    if [[ ! "${seed_path:-}" ]]; then
      find_seed_path $cell_path || fail
    fi

    mock_path=$seed_path/.mock

    current_mock=f
    if [[ -e $cell_path/.mock ]]; then
      current_mock=$(<$cell_path/.mock) || fail
    fi

    if [[ "${force_mock:-}" \
       && ( $force_mock == f || -d $mock_path/$force_mock ) \
       && $current_mock != $force_mock ]]; then
      log_debug "Changing mock: $current_mock -> $force_mock (because of force_mock parameter)"
      current_mock=$force_mock
      echo "$force_mock" >$cell_path/.mock || fail
    elif [[ -f $cell_path/.mock ]]; then
      :
    elif [[ -f $trunk_cell/.mock ]]; then
      local trunk_seed
      find_seed_path $trunk_cell trunk_seed || fail
      #mock_path=$trunk_seed/.mock
    elif [[ "${mock:-}" && -d $mock_path/$mock && $current_mock != $mock ]]; then
      log_debug "Changing mock: $current_mock -> $mock (because of mock parameter)"
      current_mock=$mock
      echo "$mock" >$cell_path/.mock || fail
    else
      current_mock=f
    fi

    if [[ $current_mock != f && $current_mock != disabled && ! -d $mock_path/$current_mock ]]; then
      log_fatal "Invalid mock in $short_cell: $current_mock doesn't exist in $mock_path"
      fail1
    fi

    if [[ "${out_path_relative:-}" ]]; then
      out_path=$cell_path/$out_path_relative
    else
      out_path=$cell_path
    fi

  end_function
  handle_return
}

build_cyto_inner() {
  local cell_path=$1

  begin_function

    log_debug "Building cyto for $short_cell"
    dna_path=$cell_path/.dna \
    cyto_path=$cell_path/.cyto \

    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    if [[ ! -d $status_path ]]; then
      mkdir $status_path || fail
    fi

    #  This already happened earlier
    #init_context || fail
    load_branch_info || fail
    find_seed_path $cell_path || fail

    if [[ ! -f $context_path ]]; then
      build_context $cell_path || fail
    fi

    if [[ "${up:-}" && ! -d $up_path && $cell_is_leaf == t ]]; then
      make_cyto_up || fail
    fi

    if [[ "${reactors:-}" && ! -d $reactor_path && $cell_is_leaf == t ]]; then
      make_cyto_reactors || fail
    fi

  end_function
  handle_return
}

# Can be called on a cell that already has a cyto folder, in which case it will repair missing
#   parts
build_cyto() {
  fork build_cyto_inner "$@"
}

# inputs:
#   $1   cell_path
#   anchor_dims (as a space separated string)
# load_branch_info should be executed BEFORE this
# setup_dims should usually be executed AFTER this
# followed by calc_coords
switch_context() {
  cell_path=$1

  if [[ "${last_context_loaded:-}" != $cell_path ]]; then

    local log_show_vars=^cell_path rebuild_attempted=f
    begin_function

      get_short_cell
      log_debug "Loading context for $short_cell"

      if [[ "$cell_path" == /seed/* ]]; then
        log_fatal "Can't switch contexts to a seed path. Make sure to run this command in a work folder."
        fail1
      fi

      dna_path=$cell_path/.dna \
      cyto_path=$cell_path/.cyto \

      local dna_exists=f
      if [[ -e $dna_path ]]; then
        dna_exists=t
      fi

      if [[ $dna_exists == t ]]; then
        if [[ "$clean_cells" ]]; then
          local cell_to_clean
          cells_already_cleaned=${cells_already_cleaned:-}
          if [[ " $cells_already_cleaned " == *" $cell_path "* ]]; then
            log_debug "Cell already cleaned: $cell_path"
          else
            begin_for cell_to_clean in $clean_cells; doo
              if [[ /$cell_path/ == */$cell_to_clean/* ]]; then
                if [[ -e $cyto_path ]]; then
                  log_info "Cleaning cell ${cell_to_clean#/work/*/} => $short_cell..."
                  rm -rf $cyto_path/!(job) || fail
                else
                  log_info "Cell already clean: $cell_to_clean => $short_cell"
                fi
                #  no we want to clean all matching cells
                #remove_word_from_string clean_cells "$cell_to_clean" 
                cells_already_cleaned+=" $cell_path"
                break
              fi
            end_for
          fi
        fi
      fi

      context_path=$cyto_path/context
      init_context || fail

      seed_path=
      if [[ $dna_exists == t ]]; then
        if [[ ! -f $context_path ]]; then
          build_cyto $cell_path || fail
        fi

        source $context_path || fail
        calc_anchor_dims || fail

        local problem_found=f
        broken_link_check || fail
        if [[ $problem_found == t ]]; then
          if [[ $rebuild_attempted == f ]]; then
            log_verbose "Problem found, rebuilding context"
            rm -rf $cyto_path/up* $context_path* || fail
            rebuild_attempted=t
            continue
          else
            log_fatal "Context rebuild failed to resolve problem"
            fail1
          fi
        fi
      fi

      load_post_context_dynamic_vars || fail

      last_context_loaded=$cell_path

      error_if_unresolved=t \
      handle_questions || fail

    end_function
    handle_return

  else
    log_debug "Context already loaded: $short_cell" || fail
  fi

  return 0
}

cell_open_log_file() {
  begin_function
    if [[ ! "${log_path:-}" ]]; then
      # can't log until this is set
      abort
    fi
     
    if [[ "${omni_log_job_id:-0}" != 0 ]]; then

      cell_log_file_stack+=( $logging_to_file )

      omni_log_fork_id=${omni_log_fork_parent:-}-${omni_log_fork_child}
      omni_log_fork_id=${omni_log_fork_id#-}

      local new_log_file=$log_path/$omni_log_job_id:$omni_log_fork_id.olog
      local first_log_path=${new_log_file%/*}/first.olog
      if [[ ! -f $first_log_path ]]; then
        from_must_exist=f \
          safe_link $new_log_file $first_log_path || fail
      fi

      log_function=${FUNCNAME[1]} \
        change_log_file || fail

    fi
  end_function
  handle_return
}

cell_close_log_file() {
  begin_function
    if [[ "${cell_log_file_stack:-}" ]]; then
      local previous_log=${cell_log_file_stack[-1]}
      unset cell_log_file_stack[-1]
      log_function=${FUNCNAME[1]} \
        new_log_file=$previous_log \
        resume_existing_log=t \
        logging_to_file= \
        change_log_file || fail
    fi
  end_function
  handle_return
}

get_job_id() {
  begin_function

    if [[ ! -v job_id_log ]]; then
      log_fatal "Internal error: Missing job_id_log"
      fail1
    fi

    if [[ ! -d ${job_id_log%/*} ]]; then
      mkdir ${job_id_log%/*} || fail
    fi

    timeout=5 lock_path=$job_id_log fd_write_lock || {
      log_fatal "Failed to get lock on $job_id_log" 
      fail1
    }

    if [[ -f "$job_id_log" ]]; then
      local last_id=$(tail -n1 $job_id_log | awk '{print $1}')
      (( omni_log_job_id = last_id + 1 ))
    else
      omni_log_job_id=1
    fi

    if [[ ! "$command_to_log" ]]; then
      log_fatal "Missing command to log."
      fail1
    fi

    echo "$omni_log_job_id $cell_path $command_to_log" >>$job_id_log || fail

    fd_unlock

    log_return_vars=omni_log_job_id
  end_function
  handle_return
}

execute_command_log_prep() {
  begin_function
    local cyto_path=$cell_path/.cyto
    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    local job_path=$cyto_path/job
    if [[ ! -d $job_path ]]; then
      mkdir $job_path || fail
    fi

    if [[ "${omni_log_job_id:-0}" == 0 ]]; then
      job_start_time=${EPOCHREALTIME//./}
      command_to_log="${original_cmd#* }" \
        get_job_id || fail
    fi

    current_job_path=$job_path/$omni_log_job_id
    if [[ ! -d $current_job_path ]]; then
      mkdir $current_job_path || fail
    fi

    # only set this for the first cell in the job, all other cells should 
    #   use the same fork_id log so that they all have unique ids across the job
    if [[ ! "${fork_id_log:-}" ]]; then
      fork_id_log=$current_job_path/fork-id-log
    fi

    log_path=$current_job_path/log
    if [[ ! -d $log_path ]]; then
      mkdir $log_path || fail
    fi

    background_log=$log_path/background
    running_job_path=$job_path/running

    local link_target
    begin_for link_target in $cell_command-attempt attempt; doo
      if [[ -e "$job_path/last-$link_target" ]]; then
        mv $job_path/last-$link_target $job_path/prev-$link_target || fail
      fi
      safe_link $current_job_path $job_path/last-$link_target || fail
    end_for

  end_function
  handle_return
}

validate_command_parameters() {
  begin_function
    local name required type=command
    local -n parameter_names=parameter_names_$type \
      parameter_defaults=parameter_defaults_$type \
      parameter_required=parameter_required_$type \

    if [[ "${parameter_names:-}" ]]; then
      begin_for (( index = 0; index < ${#parameter_names[*]}; index++ )); doo
        name=${parameter_names[$index]}
        required=${parameter_required[$index]}
        local -n parameter_var=$name
        if [[ ! "${parameter_var:-}" && $required == t ]]; then
          while true; do
            choose "Enter required parameter (use ? if you need help): $name=" parameter_var || fail
            if [[ "$parameter_var" == \? ]]; then
              show_parameter_help_single || fail
              continue
            fi
            break
          done
        fi
      end_for
    fi
  end_function
  handle_return
}

prep_fork() {
  begin_function_lo

    change_log2=${change_log:-}
    # Prevents this variable from bleeding through to lower called functions
    change_log=

    if [[ $change_log2 == t && $disable_log == f ]]; then
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    if [[ "$fork_id_current" ]]; then
      fork_id_current=$fork_id_current.$debug_id_current
    else
      fork_id_current=$debug_id_current
    fi
    debug_id_current=0
    fork_debug_id=$fork_id_current.0

    cleanup_on_exit=
    setup_exit_trap

  end_function
  handle_return
}

reply_to_caller() {
  if [[ "${reply_file:-}" ]]; then
    echo "$*" >>$reply_file || return 1
  fi
  return 0
}

# this should be run in a subshell
fork_inside() {
  begin_function_lo

    local change_log2
    prep_fork || fail

    if [[ "$to_var" ]]; then
      eval "$to_var=\$($fork_command)"; return_code=$?
      reply_to_caller "$to_var='${!to_var}'" || fail
    else
      eval "$fork_command"; return_code=$?
    fi

    if [[ $change_log2 == t ]]; then
      cell_close_log_file || fail
    fi

    if [[ "${debugging:-}" == t ]]; then
      reply_to_caller "debugging=t" || fail
    fi

    if (( return_code != 0 )); then
      reply_to_caller "return_code=$return_code" || fail
      return_value=$return_code
    fi

    if [[ $change_log2 == t ]]; then
      reply_to_caller "omni_log_pos=$previous_log_pos" || fail
    fi

    if [[ "${command_successful:-}" ]]; then
      reply_to_caller "command_successful=$command_successful" || fail
    fi

    if [[ "${debug_log_level_filter:-}" ]]; then
      reply_to_caller "debug_log_level_filter=$debug_log_level_filter" || fail
    fi

    if [[ "${trace_vars:-}" ]]; then
      copy_map trace_var_old trace_var_sub
      local s="unset trace_var_sub; $(declare -p trace_var_sub)" 
      s=${s/ -A / -Ag }
      reply_to_caller "$s" || fail
    fi

    if (( ${progress_bar_nesting:-0} > 0 )); then
      reply_to_caller "progress_bar_total=${progress_bar_total:-}
progress_bar_nesting=${progress_bar_nesting:-}
progress_bar_front_load=${progress_bar_front_load:-}
progress_bar_start_time=${progress_bar_start_time:-}
progress_bar_current=${progress_bar_current:-}
" || fail
    fi

  end_function
  handle_return
}

# run outside of the subshell afterwards
after_fork() {
  begin_function_lo
    if [[ -f "${reply_file:-}" ]]; then
      #pause "Sourcing $reply_file."
      #echo "$(<$reply_file)" >&$fd_original_err
      source $reply_file || fail
      if [[ ${debugging:-f} == t ]]; then
        [[ "${debug_debug:-f}" == t ]] && echo "debugging=$debugging, so starting debugging after fork" >&$fd_original_err

        debug_immediate=f \
        first_run=f \
        debugging=f \
        debug_start

      fi
      if [[ "${debug_log_level_filter:-}" ]]; then
        local log=$debug_log_level_filter
        resolve_log_var
        log_format=default
        log_level_filter_changed
      fi
      rm $reply_file
      reply_file=
    fi
  end_function
  handle_return
}

get_new_reply_file() {
  reply_file=$tmp_folder/reply.$BASHPID
  if [[ -f $reply_file ]]; then
    log_fatal "reply_file already exists: $reply_file"
    return 1
  fi
  return 0
}

before_fork() {
  begin_function_lo

    if [[ ${background:-f} == t ]]; then
      change_log=t
    fi

    : ${omni_log_fork_child:=0}
    (( omni_log_fork_child++ ))

    get_new_reply_file || fail
    defer "rm $reply_file"

  end_function
  handle_return
}

# usage: fork {command to execute}
#  background=f (whether to run as a background process)
#  change_log=f (whether to change the log)
#  to_var       (write output to the given var instead of stdout)
fork() {
  local fork_command=$*
  begin_function_lo
    local reply_file return_code=0 \
      background=${background:-f} \
      change_log=${change_log:-f} \
      to_var=${to_var:-}

    before_fork || fail

    if [[ $background == t ]]; then
      ( fork_inside ) &
    else
      ( fork_inside )
      return_code=$?
      after_fork || (( return_code++ ))
    fi

    return_value=$return_code
  end_function
  handle_return
}

fork_fg() {
  background=f fork "$@"
}

fork_bg() {
  background=t fork "$@"
}

get_is_stale() {
  local status_path=$status_path
  begin_function
    is_stale=t
    if [[ ! "${required_freshness:-}" || "$required_freshness" == inf ]]; then
      is_stale=f
    elif [[ $required_freshness != 0 ]]; then
      local fresh_seconds
      convert_to_seconds $required_freshness fresh_seconds || fail
      local fresh_cutoff=$((EPOCHSECONDS-fresh_seconds)) \
        out_timestamp= 
      is_stale=f
      if [[ -f $status_path/last-good-update-end ]]; then
        out_timestamp=$(date -r $status_path/last-good-update-end +%s)
      fi
      if [[ "$out_timestamp" && $out_timestamp -lt $fresh_cutoff ]]; then
        is_stale=t
      fi
    fi
  end_function
  handle_return
}

wait_for_low_load() {
  local cell_max_load=${cell_max_load:-10}
  local cell_load_wait_timeout=${cell_load_wait_timeout:-600}
  local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
  if [[ $current_load -gt $cell_max_load ]]; then
    log_warn "Load average is too high ($current_load > $cell_max_load)," \
      "waiting until things cool down first." || fail
    local time_waited=0
    while [[ $current_load -gt $cell_max_load ]]; do
      current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
      sleep 5; let time_waited+=5
      if [[ "$cell_load_wait_timeout" -gt 0 && $time_waited -ge $cell_load_wait_timeout ]]; then
        log_fatal "Timed out waiting for cpu load to be low enough. Aborting"
        return 1
      fi
    done
  fi
  return 0
}

reply_file=

# input: parallel processes
wait_for_sub_processes() {
  begin_function
    if [[ "$processes" ]]; then
      log_debug "Waiting for sub processes to complete" || fail
      local process last_err_code= last_failed_process= rc
      for process in $processes; do
        log_debug "Waiting for process $process" || fail
        wait $process &>/dev/null; rc=$?
        if [[ $rc -gt 0 && $rc -lt 127 ]]; then
          if [[ ! "$last_err_code" ]]; then
            last_err_code=$rc
            last_failed_process=$process
          else
            log_fatal "Subprocess $process failed to terminate successfully"
            fail1
          fi
        fi
      done
      after_fork
      if [[ "$last_err_code" ]]; then
        if [[ "$last_err_code" == 1 ]]; then
          log_fatal "Subprocess $last_failed_process failed to terminate successfully"
          fail1
        fi
        return_value=$last_err_code
        break_out=t
        break
      fi
      processes=
    fi
  end_function
  handle_return
}

trace_step_execution=${trace_step_execution:-f}
trace_op=${trace_op:-}

# Usage: execute_op {op name}
# If {op_name}_op_var variable exists, it will be evaluated as the body of the {op_name}_op function
#   and then executed
# Otherwise {op_name}_op function is executed
#
# output
#   missing   set to t if no op found
execute_op() {
  local op_name=$1 op_function= ignore_missing=${ignore_missing:-f}

  local log_vars='cell_path op_name'
  begin_function

    op_function=${op_name}_op
    local -n op_var=${op_name}_op_var

    missing=f
    if [[ "${op_var:-}" == f ]]; then
      missing=t
    else

      if [[ "${op_var:-}" ]]; then
        unset $op_function
        if [[ "${op_var#${op_name}_op()}" != "${op_var}" ]]; then
          eval "$op_var"
        else
          eval "${op_name}_op() {
begin_function
$op_var
end_function
handle_return
}"
        fi
      fi

      if type -t $op_function &>/dev/null; then

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=t
        fi

        $op_function || fail

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=f
        fi

      else
        missing=t
      fi

    fi

    if [[ $missing == t ]]; then
      if [[ $ignore_missing == t ]]; then
        log_debug "No ${op_name}_op function found, ignoring" || fail
      else
        log_fatal "No ${op_name}_op function found"
        fail1
      fi
    fi

  end_function
  handle_return
}

# inputs: parent_path seed_path member
plant_member() {
  begin_function
    local deep=${deep:-f} repair=${repair:-f}
    get_sane_value "$member" || fail
    member_path=$parent_path/$dim:$sane_value
    if [[ ! -d $member_path || $repair == t ]]; then

      local new_path=$member_path.new

      if [[ -d $new_path ]]; then
        rm -rf $new_path || fail
      fi

      mkdir $new_path || fail
      if [[ "$member" != "$sane_value" ]]; then
        echo -n "$member" >$new_path/.member || fail
      fi

      local cell_is_leaf=t
      if [[ ${child_dims:-} ]] && (( ${#child_dims[*]} > 1 )); then
        cell_is_leaf=f
      fi
      plant_seed $member_path $new_path || fail

      #if [[ -e $parent_path/.mock ]]; then
      #  if [[ ! -d $new_path/.cyto ]]; then
      #    mkdir $new_path/.cyto || fail
      #  fi
      #  cp $parent_path/.mock $new_path/.mock || fail
      #fi

      if [[ -e $member_path ]]; then
        rm -rf $member_path || fail
      fi
      mv $new_path $member_path || fail

    fi
  end_function
  handle_return
}

# input: $* = cell values in dim order
# output: cell_id = string cell id
get_cell_id() {
  local v
  cell_id=
  for v in "$@"; do
    get_sane_value "$v"
    v=$sane_value
    cell_id+=_$v
  done
  cell_id=${cell_id#_}
}

encrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=$to \
    key=${key:-$user_private_key}

  begin_function

    if [[ "$to" == */ ]]; then
      to+=${from##*/}
    fi

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ -e $to ]]; then
      log_fatal "File already exists: $to"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    setup_tmp_path || fail
    if ! log_and_run openssl pkeyutl -encrypt -inkey $key -in $from -out $to; then
      log_fatal "Failed to encrypt file: $from"
      fail1
    fi

  end_function
  handle_return
}

encrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from \
    to=$to \
    tmp_path=$tmp_path \
    key_path=$key_path \
    user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Encrypting $from to $to" || fail

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to encrypt non-existent file: $from"
      fail1
    fi

    if [[ -f "$to" ]]; then
      log_fatal "Encrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then

      local key_count=$(find -L $key_path -mindepth 1 -maxdepth 1 -name 'key.*' -type f | wc -l)

      if (( key_count > 0 )); then

        log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
        find -L $key_path -name "key.*" >&2
        fail1

      else

        log_debug "There are no keys for this cell yet. Will create a new key." || fail

        # create a new main key
        if ! out_to_file=$tmp_path/main log_and_run openssl rand -base64 40; then
          log_fatal "Failed to generate new main key."
          fail1
        fi
        defer "rm $tmp_path/main"

        # create a compatible public key from the user's private key
        if ! log_and_run openssl pkey -in $user_private_key -out $tmp_path/public -pubout; then 
          log_fatal "Failed to convert private key to public key."
          fail1
        fi

        # encrypt main key with given user key
        if ! log_and_run openssl pkeyutl -encrypt -pubin -inkey $tmp_path/public -in $tmp_path/main -out $key_path/key.$USER; then
          log_fatal "Failed to encrypt main key."
          fail1
        fi

      fi
    else 
      # extract the main key
      if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in $key_path/key.$USER -out $tmp_path/main; then
        log_fatal "Failed to decrypt main key." 
        fail1
      fi

      defer "rm $tmp_path/main"
    fi
      
    # encrypt the file with main key
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -pass file:$tmp_path/main; then
      log_fatal "Failed to create new secret file."
      fail1
    fi

  end_function

  if [[ -f $tmp_path/main ]]; then
    rm $tmp_path/main
  fi

  handle_return

}

handle_secure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    setup_tmp_path || fail
    local unsafe_file=${file%.safe}
    local new_unsafe_file=$tmp_path/$unsafe_file.new
    local old_unsafe_file=$tmp_path/$unsafe_file.old

    if [[ -f $new_unsafe_file ]]; then
      log_fatal "$new_unsafe_file already exists, delete that first if you want to edit $file"
      fail1
    fi

    defer "rm $new_unsafe_file"
    defer "rm $old_unsafe_file"

    if [[ -f $old_file ]]; then
      from=$old_file to=$old_unsafe_file decrypt_file_with_shared_key || fail
      cp $old_unsafe_file $new_unsafe_file || fail
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" >$new_unsafe_file || fail
    else
      $EDITOR $new_unsafe_file || fail
    fi

    if [[ -f $old_unsafe_file ]]; then
      if files_are_different $old_unsafe_file $new_unsafe_file >/dev/null; then
        changed=t
      else
        log_debug "No change" || fail
        rm $new_unsafe_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      from=$new_unsafe_file to=$new_file encrypt_file_with_shared_key || fail
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

handle_insecure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    if [[ -f $old_file ]]; then
      cp $old_file $new_file || fail 
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" | trim_nl >$new_file || fail
    else
      $EDITOR $new_file || fail
    fi

    if [[ -f $old_file ]]; then
      if files_are_different $old_file $new_file >/dev/null; then
        changed=t
      else
        log_debug "No change" || fail
        rm $new_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

update_modify_times() {
  local file=$1
  if [[ "$status_path" && -f "$status_path/up-to-date" ]]; then
    rm $status_path/up-to-date || return 1
  fi
  return 0
}

setup_context_defaults() {
  return 0
}

update_cell_value_file() {
  begin_function
    if [[ "${cell_values:-}" && ! -f $cell_path/cell_values ]]; then
      local v s='cell_values=( '
      for v in "${cell_values[@]}"; do
        s+="\"$v\" "
      done
      s+=')'
      echo "$s" >$cell_path/cell_values || fail
    fi
  end_function
  handle_return
}

get_cell() {
  cell_path=$1
  [[ ${#cell_path} -lt 3 ]] && return 1
  [[ -d $cell_path/.dna ]] && return 0
  [[ -d $cell_path/.cyto ]] && return 0
  get_cell ${cell_path%/*} || return 1
  return 0
}

setup_tmp_path() {
  if [[ ! "${tmp_path:-}" ]]; then
    if [[ -d ${cell_path:-}/.cyto/tmp ]]; then
      tmp_path=$cell_path/.cyto/tmp
    elif [[ -d ~/tmp ]]; then
      tmp_path=~/tmp
    else
      tmp_path=/tmp
    fi
  fi
  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || return 1
  fi
  return 0
}

# inputs:
#   from    encrypted file to decrypt
#   to      (optional) file to save decrypted form to
#           if 'to' is missing, then it writes the decrypted value to stdout
decrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=${to:-} \
    to_var=${to_var:-} \
    key=${key:-$user_private_key}

  local log_show_vars='^from ^to to_var'
  begin_function_hi

    if [[ ! "$to" && ! "$to_var" ]]; then
      log_fatal "decrypt_file: Must set either 'to' or 'to_var'"
      fail1
    fi

    pause_tee

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    if [[ "$to" ]]; then
      if [[ -e $to ]]; then
        log_fatal "File already exists: $to"
        fail1
      fi
      setup_tmp_path || fail
      if ! openssl pkeyutl -decrypt -inkey $key -in $from -out $to; then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    else
      local -n v=$to_var
      v=$(openssl pkeyutl -decrypt -inkey $key -in $from)
      if (( $? > 0 )); then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    fi
     
    unpause_tee

  end_function
  handle_return
}

# Will leave key_path blank if not found
get_key_path() {

  key_path=$seed_path
  while [[ $key_path == /*/*/* && ! -d $key_path/.key ]]; do
    key_path=${key_path%/*}
  done

  if [[ -d $key_path/.key ]]; then
    key_path=$key_path/.key
  else
    key_path=
  fi

}

validate_user_key() {
  if [[ ! -f $key_path/$user.key ]]; then
    local others=( $key_path/* )
    local o users
    for o in ${others[*]}; do
      o=${o##*/}
      users+="${o%.key} "
    done
    if [[ "$users" ]]; then
      log_fatal "No key found for user $user. Ask someone who has access to add your key. These users have access: $users"
    else
      log_fatal "No keys were found. Use 'cell safe key add' to create the first key."
    fi
    return 1
  fi
}

extract_master_key() {
  local from=$1 to=$2 user_private_key=$user_private_key
  if ! openssl pkeyutl -decrypt -inkey $user_private_key -in $from -out $to; then
    log_fatal "Failed to decrypt master key." 
    return 1
  fi
}

make_master_key() {
  begin_function
    local pub_key=$pub_key master_key=$master_key target=$target tmp_folder=$tmp_folder

    defer "rm $tmp_folder/pub_key"

    # convert public key to format openssl likes
    ssh-keygen -f $pub_key -m PKCS8 -e >$tmp_folder/pub_key || {
      log_fatal "Failed to convert public key."
      fail1
    }

    # encrypt main key with new key
      openssl pkeyutl -encrypt -pubin -inkey $tmp_folder/pub_key -in $master_key -out $target || {
      log_fatal "Failed to encrypt main key."
      fail1
    }
  end_function
  handle_return
}

simple_encrypt() {
  local master_key=$master_key from_file=$1 to_file=$2
  begin_function
    if ! openssl enc -aes256 -pbkdf2 -in $from_file -out $to_file -pass file:$master_key; then
      log_fatal "Failed to encrypt the file."
      fail1
    fi
  end_function
  handle_return
}

simple_decrypt() {
  local master_key=$master_key from_file=$1 to_file=$2
  begin_function
    if ! openssl enc -aes256 -pbkdf2 -in $from_file -out $to_file -d -pass file:$master_key; then 
      log_fatal "Failed to decrypt the file."
      fail1
    fi
  end_function
  handle_return
}

# inputs: from to tmp_path current_cell
# will write output to file at $to
decrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from
  local to=$to
  local tmp_path=$tmp_path
  local key_path=$key_path
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Decrypting $from to $to" || return 1

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to decrypt non-existent file: $from"
      fail1
    fi

    if [[ -s "$to" ]]; then
      log_fatal "Decrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then
      log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
      find -L $key_path -name "key.*" >&2
      fail1
    fi

    # extract the main key
    if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in "$key_path/key.$USER" -out $tmp_path/main; then
      log_fatal "Failed to decrypt main key." 
      fail1
    fi
    defer "rm $tmp_path/main"

    # decrypt the secret file
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -d -pass file:$tmp_path/main; then 
      log_fatal "Failed to decrypt secret file." 
      fail1
    fi

  end_function
  handle_return

}

get_sane_value() {
  local -r value=$1 
  local -n _s=${2:-sane_value}
  if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
    _s=$value
  else
    hash=$(echo -n "$value" | sha1sum | awk '{ print $1 }')
    _s=${hash:0:8}
  fi
  debug_return_vars=_s
  return 0
}

is_cell() {
  [[ -d "$1/.dna" ]]
}

# Used by the help system to describe a command and it's parameters to the user
new_command() {
  local name=$name description=$description
  command_description=$description
  #parameter_names=( )
  #parameter_descriptions=( )
  #parameter_defaults=( )
  #parameter_choices=( )
}

add_parameter() {

  local type=${type:-command} \
    name=$name \
    description=$description \
    default=${default:-} \
    choices=${choices:-} \
    aliases=${aliases:-${alias:-}} \
    required=${required:-f} \
    delay_questions=${delay_questions:-f} \

  local -n parameter_names=parameter_names_$type \
    parameter_descriptions=parameter_descriptions_$type \
    parameter_choices=parameter_choices_$type \
    parameter_defaults=parameter_defaults_$type \
    parameter_aliases=parameter_aliases_$type \
    parameter_delay_questions=parameter_delay_questions_$type \
    parameter_required=parameter_required_$type \

  parameter_names+=( "$name" ) 
  parameter_descriptions+=( "$description" ) 
  parameter_defaults+=( "$default" ) 
  parameter_choices+=( "$choices" )
  parameter_aliases+=( "$aliases" )
  parameter_delay_questions+=( $delay_questions )
  parameter_required+=( $required )

  local a
  for a in ${parameter_aliases[*]:-}; do
    if [[ -v ${a}_append ]]; then
      eval "${name}_append=\$${a}_append"
    fi
    if [[ -v ${a}_prepend ]]; then
      eval "${name}_prepend=\$${a}_prepend"
    fi
    if [[ -v ${a}_remove ]]; then
      eval "${name}_remove=\$${a}_remove"
    fi
  done

}

add_command_alias() {
  local name=$name command=$command
  command_aliases+=( "$name" )
  command_alias_command+=( "$command" )
}

tee_output_to_log() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    exec 1> >(tee -a "$logging_to_file") || return 1
    exec 2>&1 || return 1
    eval "exec $fd_trace>&1" || return 1
    BASH_XTRACEFD=$fd_trace
    tee_files+=( $logging_to_file )
  fi
  return 0
}

untee_output() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    if [[ "${tee_files:-}" ]]; then
      BASH_XTRACEFD=
      exec 1>&$fd_original_out || return 1
      exec 2>&$fd_original_err || return 1
      eval "exec $fd_trace>&$fd_original_trace" || return 1
      unset tee_files[-1]
    else
      # log_warn "untee was called when nothing was teed"
      :
    fi
  fi
  return 0
}

pause_tee() {
  if [[ "${tee_files:-}" ]]; then
    paused_tee_file=${tee_files[-1]}
    untee_output || return 1
  fi
  return 0
}

unpause_tee() {
  if [[ "$paused_tee_file" ]]; then
    tee_output_to_log $paused_tee_file || return 1
    paused_tee_file=
  fi
  return 0
}

# locks the given cell, or fails if it can't obtain a lock
# may lock an individual file instead if the path given isn't a cell
cell_lock() {

  local cell_path=$1 \
    write_lock=${write_lock:-t} \
    timeout=$timeout \
    lock_fd \
    lock_type=read \
    lock_path

  local log_show_vars="timeout ^cell_path"
  begin_function

    if [[ -e $cell_path/.cyto/context ]]; then
      lock_path=$cell_path/.cyto/context
    else
      log_fatal "Missing context: $cell_path/.cyto/context"
      fail1
    fi

    if [[ $write_lock == t ]]; then
      lock_type=write
    fi

    if [[ -f $lock_path ]]; then
      if [[ $write_lock == t ]]; then
        fd_write_lock || fail
      else
        fd_read_lock || fail
      fi
      cell_locks+=( $lock_fd )
    fi

  end_function
  handle_return

}

# locks the given cell, or fails if it can't obtain a lock
cell_unlock() {
  local lock_fd
  for lock_fd in ${cell_locks[*]:-}; do
    fd_unlock || return 1
  done
  return 0
}

up_delegate() {
  local cyto_up_path=$1 # .../.cyto/up/{dep_name}
  local cell_path=${cyto_up_path%/.cyto/up/*} \
    up_lock=$cyto_up_path/chosen/.cyto/lock \
    up_name=${cyto_up_path##*/}
  local log_show_vars='^cyto_up_path ^cell_path up_lock'
  begin_function_hi

    if [[ -e $up_lock ]]; then
      local locks_folder=$cell_path/.cyto/up-locks
      if [[ ! -d $locks_folder ]]; then
        mkdir $locks_folder || fail
      fi
      safe_link $up_lock $locks_folder/$up_name || fail
    fi

    local out_item
    out_items=$(find1 $cyto_up_path/chosen -not -name ".*") || fail
    begin_for out_item in $out_items; doo
      safe_link $out_item $cell_path/ || fail
    end_for

  end_function
  handle_return
}

# inputs:
#   table_fields variable name holding array of fields
#   table_data   variable name holding array of cells
#   row          which row to select from the table
#   field_count
#   prefix       prefix of variable name to set
#execute_auto_load_add_constraints() {
#  begin_function
#    local f t
#    begin_for (( f = 0; f < field_count; f++ )); doo
#
#      local field=${table_fields[$f]}
#      (( t = row * field_count + f ))
#      expected_value=${table_data[$t]}
#      if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
#        continue # try next field, since this one matches
#      fi
#
#      keys["$field $expected_value"]=1
#
#    end_for
#
#  end_function
#  handle_return
#}

#execute_auto_load_tab() {
#  local table_name=$1 prefix=${prefix:-}
#  begin_function
#    local -n table_fields=${table_name}_fields table_data=${table_name}_data
#    if [[ ! -v table_fields || ! -v table_data ]]; then
#      log_fatal "Missing expected vars: ${table_name}_fields or ${table_name}_data"
#      fail1
#    fi
#    local row \
#      field_count=${#table_fields[*]} data_count=${#table_data[*]}
#    local row_count=$((data_count/field_count))
#    local -A keys
#    begin_for (( row = 0; row < row_count; row++ )); doo
#      check_table_row || fail
#      if [[ $is_valid == t ]]; then
#        execute_auto_load_add_constraints || fail
#      fi
#    end_for
#
#    local value key key_field field value
#    begin_for field in "${table_fields[@]}"; doo
#      local -n target_field=$field
#      if [[ "${target_field:-}" ]]; then
#        continue
#      fi
#      begin_for key in "${!keys[@]}"; doo
#        key_field=${key%% *}
#        if [[ "$key_field" != "$field" ]]; then
#          continue
#        fi
#        value=${key#$key_field }
#        target_field+=( "$value" )
#      end_for
#    end_for
#  end_function
#  handle_return
#}

execute_auto_loads() {
  local auto_loads=( "$@" )
  begin_function
    local table_name prefix i
    begin_for item in "${auto_loads[@]}"; doo
      case $item in
# OLD CODE, should remove if not used soon
#        *.tab)
#          execute_auto_load_tab ${item%.tab} || fail
#        ;;
        *.var)
          local v=${item%.*}
          if [[ -v $v ]]; then
            local quoted=${!v}
            quoted=${quoted//\"/\\\"}
            eval "$v=\"$quoted\""
          fi
        ;;
        *)
          log_fatal "Can't auto load $item"
          fail1
        ;;
      esac
    end_for
  end_function
  handle_return
}

get_trunk_cell() {
  trunk_cell=$1
  while [[ $trunk_cell == */*:* ]]; do
    trunk_cell=${trunk_cell%/*}
  done
  debug_return_vars=trunk_cell
}

# inputs:
#   debug_log    (optional)
#   result_file
#   $1           headers and url to query
http_get() {
  local parameters="$*" timeout=${timeout:-60}
  begin_function

    local curl_command="curl -Lkvgs -m $timeout -w '%{stderr}TIMINGS
      time_namelookup=%{time_namelookup}
      time_connect=%{time_connect}
      time_appconnect=%{time_appconnect}
      time_pretransfer=%{time_pretransfer}
      time_redirect=%{time_redirect}
      time_starttransfer=%{time_starttransfer}
      time_total=%{time_total}
    ' $parameters"
    echo "$curl_command" >$debug_log
    if [[ -e $result_file ]]; then
      rm $result_file || fail
    fi

    err_to_file=${debug_log:-} \
    out_to_file=$result_file \
    log_and_run "$curl_command" || fail

    if log_level_at_least verbose; then
      local timings=$(awk 'BEGIN { flow=0 } flow == 1 { print } /TIMINGS/ { flow=1 }' $debug_log)
      log_verbose "curl timings:$NL$timings"
    fi

    local response_line response_code response_message response_code_message response_error
    response_line=$(grep -E '^< HTTP/[^ ]+ ' $debug_log | tail -n1)
    response_code_description=${response_line#* * }
    response_code=${response_code_description%% *}

    response_error=$(jq -r .error $result_file 2>/dev/null) || true
    if [[ "$response_code" != 200 ]]; then
      if [[ "$response_error" ]]; then
        log_fatal "curl failed: $response_error"
      elif [[ "$response_code_message" ]]; then
        log_fatal "curl failed: $response_code_message"
      else
        log_fatal "curl failed for unknown reason. Check $debug_log or $result_file for more details."
      fi
      fail1
    fi

  end_function
  handle_return
}
