#!/bin/bash
# depends on lib/bash-lib being sourced first to provide needed aliases

[[ -v cell_lib_loaded ]] && return 0
cell_lib_loaded=t

cell_lib_init() {
  # don't let other users read any files written by these scripts
  umask 0077

  empty_member=_ 
  execute_inner=${execute_inner:-${dig:-m}}

  : ${risk_tolerance:=${risk:-0}}
  case "$risk_tolerance" in
    l*)
      risk_tolerance=0
      ;;
    m*)
      risk_tolerance=1
      ;;
    h*)
      risk_tolerance=2
      ;;
    v*)
      risk_tolerance=3
      ;;
    [0-9])
      risk_tolerance=${risk_tolerance:-${risk}}
      ;;
    *)
      log_fatal "Unknown risk level: $risk. Should be one of: low medium high very_high (or 0 1 2 3). Defaults to low."
      fail1
      ;;
  esac

  tee_files=( )
  paused_tee_file=

  parallel_default=f 
  [[ ${debug:-f} == t ]] && parallel_default=f
  parallel_execution=${parallel_execution:-${par:-$parallel_default}}

  # Whether we should show logging for each seperate branch or only for leaves
  show_branches=${show_branches:-f}

  # used to detect upstream circular dependencies
  downstream_cell_stack=( ) 
  disable_log=${disable_log:-}
  #export debug_ignore+="
  #  apad
  #  cell_close_log_file
  #  cell_open_log_file
  #  change_log_file
  #  debug_id_inc
  #  debug_start
  #  defer
  #  fd_unlock
  #  fd_write_lock
  #  find1
  #  fork
  #  fork_bg
  #  fork_fg
  #  fork_inside
  #  function_exists
  #  get_bottom_cell
  #  get_new_reply_file
  #  load_log_vars
  #  load_log_vars_and_write_to_log
  #  log_debug
  #  log_error
  #  log_fatal
  #  log_info
  #  log_trace
  #  log_verbose
  #  log_warn
  #  out
  #  parallel_loop
  #  pause_tee
  #  safe_link
  #  save_log_vars
  #  setup_exit_trap
  #  shell_quote_var
  #  snapshot_source_location
  #  tee_output_to_log
  #  unpause_tee
  #  unrealpath
  #  untee_output
  #  write_to_log
  #  write_to_log_and_save
  #  write_to_log_console_out
  #  write_to_log_log_var
  #  write_to_log_process_vars
  #  write_to_log_update_cooked
  #"

  #debug_ignore=( $debug_ignore )
  #debug_ignore=" ${debug_ignore[*]} "

  command_aliases=()
  command_alias_command=()
}

# allocates a unique file optionally based on a given name in the cell tmp_path
# returns tmp_file set to the full path of the file
get_tmp_file() {
  local base=${1:-tmp}
  if [[ ! -e $tmp_path ]]; then
    mkdir $tmp_path || return 1
  fi
  tmp_file=$(mktemp $tmp_path/$base.$$.XXXXXX) || return 1
  defer "rm $tmp_file"
  return 0
}

write_to_context() {
  local context_type=$context_type new_type=$1 content=$2
  begin_function_lo
    last_type=${last_type:-var}
    if [[ $last_type == fun && $new_type == var 
       || $last_type == var && $new_type == fun ]]; then
      echo >>$context_path-$context_type.new || fail
    fi
    trim_ws content
    echo "${content}" >>$context_path-$context_type.new || fail
    last_type=$new_type
    eval "$content" || {
      if [[ "${var_full_path:-}" ]]; then
        log_fatal "Invalid dna file: $var_full_path"
      else
        log_fatal "Invalid dna file. Contents:"
        log_fatal "$content"
      fi
      fail1
    }
  end_function
  handle_return
}

write_vars_to_context() {
  local context_type=$context_type vars_to_write=$*
  begin_function
    local var val quoted_val
    begin_for var in $vars_to_write; doo
      local -n val=$var
      if is_array val; then
        array_to_string val quoted_val
      else
        local quoted_val=${val:-}
        shell_quote_var quoted_val
      fi
      write_to_context var "$var=$quoted_val" || fail
    end_for
  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_fun() {
  local full_path=$1 content name=$2
  begin_function
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" =~ ^[a-zA-Z_]+\(\) ]]; then
      code="$content"
    else
      content=$(echo -n "$content" | sed 's/^/    /')
      code="$name() {
  begin_function
$content
  end_function
  handle_return
}"
    fi

  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_var_to_code() {
  local full_path=$1 name=$2 content append=f
  begin_function

    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    if [[ "$content" != [\"\']* ]]; then
      quotes=single newlines=preserved shell_quote_var content
    fi

    if [[ $append == t ]]; then
      append_vars[$name]=1
      code="$name+=$content"
    else
      code="$name=$content"
    fi

  end_function
  handle_return
}

load_arr_to_code() {
  begin_function

    local full_path=$1 content name=$2 append=f
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    code="$name"
    if [[ $append == t ]]; then
      append_vars[$name]=1
      code+="+=("
    else
      code+="=("
    fi

    while IFS= read -r line || [[ "$line" ]]; do
      trim_ws line
      if [[ "$line" != [\"\']* ]]; then
        quotes=single shell_quote_var line
      fi
      code+=" $line" || fail
    done < <(echo -n "$content")

    code+=" )"

  end_function
  handle_return
}

load_tab() {
  local code=
  load_tab_to_code "$1" "$2" || return 1
  eval "$code"
}

# usage: load_tab {full path to tab file} {target var to store data in}
load_tab_to_code() {

  begin_function
    local full_path=$1 content name=$2 append=f
    local target_var_data=${name}_data target_var_fields=${name}_fields \
      fields i

    if [[ ! -e $full_path ]]; then
      log_fatal "Internal error: load_tab_to_code called on missing file: $full_path"
      fail1
    fi

    content=$(<$full_path)

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    local row_index=0
    begin_while IFS= read -r line || [[ "$line" ]]; doo
      trim_ws line
      if [[ ! "$line" ]]; then
        continue
      fi
      if (( row_index == 0 )); then

        if [[ $append == t ]]; then
          append_vars[$target_var_fields]=1
          code="$target_var_fields+=( "
        else
          code="$target_var_fields=( "
        fi

        eval "fields=( $line )"
        local column_code=() field_count=${#fields[*]}
        begin_for (( i = 0; i < field_count; i++ )); doo
          local field=${fields[$i]}
          quotes=single shell_quote_var field || fail
          code+="$field "
        end_for

        code+=")$NL"

        if [[ $append == t ]]; then
          append_vars[$target_var_data]=1
          code+="$target_var_data+=($NL"
        else
          code+="$target_var_data=($NL"
        fi

      else

        eval "local line_array=( $line )"
        local value line_cell_count=${#line_array[*]}

        if (( line_cell_count != field_count )); then
          log_fatal "Invalid data in table $full_path row $row_index. Number of cells in row doesn't match number of fields."
          fail1
        fi

        code+=" "
        begin_for (( i = 0; i < ${#line_array[*]}; i++ )); doo
          value=${line_array[$i]}
          quotes=single shell_quote_var value || fail
          code+=" $value"
        end_for
        code+="$NL"

      fi
       
      (( row_index++ )) 

    done < <(echo -n "$content")
    maybe_break

    code+=")$NL"

    if [[ $name == *_derive ]]; then
      derive_tables+=( $name )
    fi

  end_function
  handle_return
}

# usage: split_ordinal {from_var} {ordinal_part_var} {base_part_var}
split_ordinal() {
  local -n _f=$1 _o=$2 _b=$3
  if [[ $_f =~ ^([0-9]+)-([^/]*)$ ]]; then
    _o=${BASH_REMATCH[1]}
    _b=${BASH_REMATCH[2]}
  else
    _b=$_f
  fi
  debug_return_vars="$2 $3"
}

# usage: get_simple_name {from var} {ordinal var} {to var}
extract_simple_name() {
  local to_var=$3
  local -n _from=$1 _ord=$2 _to=$to_var
  split_ordinal _from _ord _to
  #_to=${_to//-/_}
  debug_return_vars=$to_var
}

# usage: get_simple_name {from array} {to array}
extract_simple_name_across_array() {
  local -n _from=$1 _to=$2
  local o i f t
  for (( i = 0; i < ${#_from[*]}; i++ )); do
    f=${_from[$i]}
    extract_simple_name f o t
    _to[$i]=$t
  done
  return 0
}

load_dna_item() {
  begin_function
    local var_full_path=$1 prefix=${prefix:-} \
      suffix= code \
      file_name is_auto=f \

    last_type=${last_type:-var}

    file_name=${var_full_path##*/}
    if [[ $file_name == *.* ]]; then
      suffix=${file_name##*.}
      file_name=${file_name%.*}
    fi

    file_name=${file_name#dna-}

    if [[ $file_name == auto-* ]]; then
      is_auto=t
      file_name=${file_name#auto-}
    fi

    local var_name o
    extract_simple_name file_name o var_name
    var_name=$prefix${var_name//-/_}

    local load_type=var
    case "$suffix" in
      var)
        load_var_to_code $var_full_path $var_name || {
          log_fatal "Failed to load simple variable from $var_full_path"
          fail1
        }
      ;;
      arr)
        load_arr_to_code $var_full_path $var_name || {
          log_fatal "Failed to load array variable from $var_full_path"
          fail1
        }
      ;;
      fun)
        load_fun $var_full_path $var_name || {
          log_fatal "Failed to load function from $var_full_path"
          fail1
        }
        load_type=fun
        if [[ $is_auto == t ]]; then
          auto_load+=( $var_name.fun )
        fi
      ;;
      tab)
        load_tab_to_code $var_full_path $var_name || {
          log_fatal "Failed to load table variable from $var_full_path"
          fail1
        }
        if [[ $is_auto == t ]]; then
          auto_load+=( $var_name.tab )
        fi
      ;;
      raw)
        load_raw $var_full_path $var_name || {
          log_fatal "Failed to load raw variable from $var_full_path"
          fail1
        }
        load_type=fun
      ;;
      *)
        if [[ $ignore_unknown == f ]]; then
          log_fatal "Unknown dna object: $item."
          fail1
        else
          succeed
        fi
      ;;
    esac

    if [[ "$context_type" ]]; then
      write_to_context $load_type "$code" || fail
    else
      eval "$code" || fail
    fi

  end_function
  handle_return
}

make_array_assignment() {
  local arr_name=$1
  local -n arr=${2:-$1}
  begin_function
    array_assignment="$arr_name=("
    local v
    for v in "${arr[@]}"; do
      shell_quote_var v
      array_assignment+=" $v"
    done
    array_assignment+=" )"
  end_function
  debug_return_vars=array_assignment
  handle_return
}

# finds the nearest ancestor of the given path which has .dna in it
# will set bottom_cell, which will be empty if no cell cells are found
get_bottom_cell() {
  local subject=$1
  bottom_cell=
  if [[ $subject == /seed/* ]]; then
    log_fatal "Called get_bottom_cell on a seed path"
    return 1
  fi
  while [[ -d "$subject" && "$subject" == /*/* ]]; do
    if [[ -e $subject/.dna ]]; then
      bottom_cell=$subject
      break
    fi
    subject=${subject%/*}
  done
  debug_return_vars=bottom_cell
  return 0
}

build_context_expand_find_members() {
  begin_function

    local branch other_found=f member_paths
    member_paths=$(find1 $seed_path -name "$dim:*" -type d | sort -g) || fail

    begin_for branch in $member_paths; doo
      m=${branch##*/*:}
      if [[ $m == all ]]; then
        log_fatal "Should not have an all as a dim member: $branch"
        fail1
      elif [[ $m == _other ]]; then
        other_found=t
      else
        local member_var_path=$branch/.member
        if [[ -f $member_var_path ]]; then
          m=$(<$member_var_path) || fail
        fi
        members+=( "$m" )
      fi
    end_for

    if [[ "$member_paths" && $other_found == f ]]; then
      has_explicit_member_list=t
    fi

  end_function
  handle_return
}

build_context_expand_handle_default() {
  begin_function
    if [[ -v ${dim_type}_${dim}_default ]]; then

      local -n default=${dim_type}_${dim}_default
      code+="
    '')
      values=( \"$default\" )
    ;;"

    elif [[ -v ${dim_type}_${dim}_default_function ]]; then

      code+="
    '')
    "
      local -n default_fun=${dim_type}_${dim}_default_function
      code+="$(echo "$default_fun" | indent 2)"
      code+="
    ;;"

    else

      code+="
    '')
      problem=\"Missing required parameter: $dim\"
    ;;"

    fi
  end_function
  handle_return
}

build_context_expand_handle_aliases() {
  begin_function
    local a_line first remaining
    begin_for a_line in "${aliases[@]}"; doo
      first=${a_line%% *}
      remaining=${a_line#* }
      code+="
    $first)
      values=( $remaining )
    ;;"
    end_for
  end_function
  handle_return
}

build_context_expand_members_unknown() {
  begin_function
# This needs to be allowed to support derive tables
#    all)
#      problem=\"'all' member not available for this dim: $dim\"
#    ;;
    code+="
    *)
      values=( \"\$value\" )
    ;;
  esac
}"
  end_function
  handle_return
}

build_context_expand_members_known() {
  begin_function
    local quoted_members= members_with_pipes=${members[*]} need_quotes=f m
    begin_for m in "${members[@]}"; doo
      quoted_members+="\"$m\" "
      if [[ $m == *\ * ]]; then
        need_quotes=t
      fi
    end_for

    if [[ $need_quotes == f ]]; then
      quoted_members="${members[*]}"
    fi

    local members_with_pipes=${members_with_pipes// /\|}

    code+="
    all)
      values=( $quoted_members )
    ;;
    $members_with_pipes)
      values=( \$value )
    ;;
    *)
      problem=\"Invalid $dim: \$value\"
    ;;
  esac
}"
  end_function
  handle_return
}

build_context_expand2() {
  begin_function

    local members=() aliases=() \
      has_explicit_member_list=f fun \
      is_optional=f

    if [[ -v ${dim_type}_${dim}_is_optional ]]; then
      local -n is_optional_var=${dim_type}_${dim}_is_optional
      if [[ $is_optional_var == t ]]; then
        is_optional=t
      fi
    fi

    if [[ -v ${dim_type}_${dim}_members ]]; then
      eval "members=( \"\${${dim_type}_${dim}_members[@]}\" )" || fail

      if [[ ${#members[*]} -eq 0 ]]; then
        log_fatal "There are no members defined for $dim."
        fail1
      fi

      has_explicit_member_list=t
    else
      build_context_expand_find_members
    fi

    if [[ -v ${dim_type}_${dim}_aliases ]]; then
      eval "aliases=( \"\${${dim_type}_${dim}_aliases[@]}\" )" || fail
    fi

    code="
${dim_type}_${dim}_expand() {
  problem=
  case \"\$value\" in"

    if [[ $is_optional == f ]]; then
      build_context_expand_handle_default || fail
    fi

    if (( ${#aliases[*]} > 0 )); then
      build_context_expand_handle_aliases || fail
    fi

    if [[ $has_explicit_member_list == f ]]; then
      build_context_expand_members_unknown || fail
    else
      build_context_expand_members_known || fail
    fi

    write_to_context fun "$code" || fail

  end_function
  handle_return
}

build_context_expand() {
  begin_function

    if [[ ! -d $seed_path ]]; then
      log_fatal "No configuration in seed at $seed_path"
      fail1
    fi

    local dim dim_type o
    begin_for dim_type in trunk_dims sub_dims control_props data_props; doo
      local -n dims=$dim_type
      begin_for dim in ${dims[*]:-}; doo
        if ! function_exists ${dim_type}_${dim}_expand; then
          build_context_expand2 || fail
        fi
      end_for
    end_for

  end_function
  handle_return
}

# inputs:
#   coord_type
switch_context_calc_coordinates() {
  begin_function

    local coord_type=${coord_type} dim_var

    local -n coordinate_data=${coord_type}_coordinate_data \
      coordinate_count=${coord_type}_coordinate_count \
      coordinate_rows=${coord_type}_coordinate_rows \
      coordinate_fields=${coord_type}_coordinate_fields \
      coordinate_fields_count=${coord_type}_coordinate_fields_count \
      coordinate_fields_plural=${coord_type}_coordinate_fields_plural \

    coordinate_data=() \
    coordinate_count=0 \
    coordinate_rows=0 \
    missing_dims=() \

    case $coord_type in
      branch)
        coordinate_fields=( ${trunk_dims[*]:-} )
        coordinate_fields_plural=( ${trunk_dims_plural[*]:-} )
      ;;
      leaf)
        coordinate_fields=( ${sub_dims[*]:-} ${control_props[*]:-} ${data_props[*]:-} )
        coordinate_fields_plural=( ${sub_dims_plural[*]:-} ${control_props_plural[*]:-} ${data_props_plural[*]:-} )
      ;;
      *)
        log_fatal "Internal error: invalid coord_type=$coord_type"
        fail1
      ;;
    esac

    coordinate_fields_count=${#coordinate_fields[*]}

    declare -Ag coordinate_dim_index
    local d i=0
    for d in ${coordinate_fields[*]}; do
      coordinate_dim_index[$d]=$i
      (( i++ ))
    done

    if [[ "${coordinate_fields:-}" ]]; then
      log_verbose "Calculating $coord_type cell coordinates for dims: ${coordinate_fields[*]}"
      calc_coordinates_next_known_dim 0 || fail

      if [[ ! "${missing_dims:-}" ]]; then
        if [[ ! "${coordinate_data:-}" ]]; then
          calc_coordinates_add_row || fail
        fi

        coordinate_count=${#coordinate_data[*]}
        coordinate_rows=$(( coordinate_count / coordinate_fields_count ))
        log_verbose "$coordinate_rows $coord_type coordinates found" 
      fi
    fi

  end_function
  handle_return
}

prep_dims() {
  local dim_types=$*
  begin_function

    local dim_var dim_type dims_var
    for dim_type in $dim_types; do
      local -n dim_array=$dim_type
      local -n plural_array=${dim_type}_plural
      local index
      for index in ${!dim_array[*]}; do

        dim_var=${dim_array[$index]}
        dims_var=${plural_array[$index]}

        local -n dim=$dim_var dims=$dims_var \
          ddim=d_$dim_var ddims=d_$dims_var \
          sdim=s_$dim_var sdims=s_$dims_var \
          pdim=p_$dim_var pdims=p_$dims_var \
          is_optional=${dim_type}_${dim_var}_is_optional \

        is_optional=${is_optional:-f}
        sdim=${sdim:-${pdim:-${dim:-}}}
        sdims=${sdims:-${pdims:-${dims:-}}}

        [[ "${sdim:-}" == $empty_member ]] && sdim=
        [[ "${sdims:-}" == $empty_member ]] && sdims=
        [[ "${ddim:-}" == $empty_member ]] && ddim=
        [[ "${ddims:-}" == $empty_member ]] && ddims=

        if [[ ! "${sdims:-}" && ! "${sdim:-}" && ! "${ddim:-}" && ! "${ddims:-}" ]]; then
          if [[ $is_optional == f ]]; then
            missing_dims+=( $dim_var )
          fi
        else
          known_dims+=( $dim_var )
        fi

      done
    done

  end_function
  handle_return
}

# expands aliases for the known dims array
# collapses singular and plural dims into plural dims
expand_dims() {
  begin_function

    local dim_var plural dim_type
    begin_for dim_var in ${known_dims[*]}; doo

      local dims_var
      get_plural $dim_var dims_var
      local -n ddim=d_$dim_var ddims=d_$dims_var

      if [[ ! "${ddim:-}" && ! "${ddims:-}" ]]; then

        local -n sdim=s_$dim_var sdims=s_$dims_var \
          d_dim_type=${dim_var}_dim_type \

        local members single=t
        if [[ "${sdims:-}" ]]; then
          members=$sdims
          single=f
        else
          members=$sdim
        fi

        ddim=
        ddims=

        local value new_values
        expand_dim_members $members || fail

        if [[ $single == t ]]; then
          if (( ${#new_values[*]} > 1 )); then
            log_fatal "Too many values for $dim_var: ${new_values[*]}"
            fail1
          fi
        fi

        ddims=${new_values[*]}

      else
        ddims=${ddims:-$ddim}
      fi

    end_for

    # These need to be discarded, because expansion could have set new dims
    unset known_dims missing_dims

  end_function
  handle_return
}

load_child_dims() {
  begin_function
    local i

    if [[ ! "${child_dims:-}" ]]; then
      child_dims=()
      local trunk_dim_count=${#trunk_dims[*]}
      if [[ ! "${anchor_dims:-}" ]]; then
        begin_for (( i = branch_dim_count; i < trunk_dim_count; i++ )); doo
          child_dims+=( ${trunk_dims[$i]} )
        end_for
      else
        local anchor_dim branch_dim leftovers=" $anchor_dims "
        
        begin_for branch_dim in ${branch_dims[*]}; doo
          remove_word_from_string leftovers $branch_dim
        end_for

        begin_for anchor_dim in $anchor_dims; doo
          if [[ " ${trunk_dims[*]} " != *" $anchor_dim "* ]]; then
            log_fatal "Invalid anchor_dim: $anchor_dim. It does not exist in the list of possible leaf nodes: ${trunk_dims[*]}"
            fail1
          fi
        end_for
        
        child_dims=( $leftovers )
      fi

      child_dim_count=${#child_dims[*]}

      if (( child_dim_count > 0 )); then
        cell_is_leaf=f
      else
        cell_is_leaf=t
      fi
    fi

  end_function
  handle_return
}

setup_dims() {
  begin_function

    local known_dims=() missing_dims=()
    prep_dims trunk_dims sub_dims control_props data_props || fail

    if [[ "${known_dims:-}" ]]; then
      expand_dims || fail
    fi

    load_child_dims || fail

  end_function
  handle_return
}

is_derivable_from_valid_anchors() {
  local dim=$1 row derivable=f is_derivable_skip_dims=${is_derivable_skip_dims:-}
  local -n derived_from=trunk_dims_${dim}_derived_from
  if [[ -v derived_from ]]; then

    if [[ "${is_derivable_skip_dims:-}" ]]; then
      is_derivable_skip_dims+=" $dim"
    else
      is_derivable_skip_dims=$dim
    fi

    for row in "${derived_from[@]}"; do

      derived_from_dims=( $row ) 
      derived_from_count=${#derived_from_dims[*]}

      local valid_count=0 derived_from_dim \
        orig_derived_from_count=$derived_from_count

      if (( derived_from_count > 0 )); then

        for derived_from_dim in ${derived_from_dims[*]}; do

          if [[ " $is_derivable_skip_dims " == *" $derived_from_dim "* ]]; then
            break
          fi

          if [[ "${valid_anchors[$derived_from_dim]:-}" ]] \
             || is_derivable_from_valid_anchors $derived_from_dim; then
            (( valid_count++ ))
          fi

        done

        derived_from_count=$orig_derived_from_count
        if (( valid_count == derived_from_count )); then
          derivable=t
          break
        fi

      fi

    done
  fi
  [[ $derivable == t ]]
}

calculate_default_anchors_check_dims() {
  begin_function

    local derived_dim
    begin_for derived_dim in ${trunk_dims[*]}; doo

      if [[ ! -v valid_anchors[$derived_dim] ]]; then
        continue
      fi

      local row derived_from_count derived_from_dims
      local -n derived_from=trunk_dims_${derived_dim}_derived_from

      if is_derivable_from_valid_anchors $derived_dim; then
        if (( derived_from_count > 0 && derived_from_count < min_derived_from_count )); then
          min_derived_from_count=$derived_from_count
          dim_with_least_deps=$derived_dim
          deps_array=( ${derived_from_dims[*]} )
          if (( derived_from_count == 1 )); then
            # we don't need to keep looking since 1 is the lowest possible number here
            break
          fi
        fi
      fi

    end_for

  end_function
  handle_return
}

calculate_default_anchors_recursive_unset() {
  local dim=$1 recursive_unset_skip=${recursive_unset_skip:-}
  begin_function
    if [[ -v valid_anchors[$dim] && " $recursive_unset_skip " != *" $dim "* ]]; then
      log_debug "Unsetting $dim"
      unset valid_anchors[$dim]
      recursive_unset_skip+=" $dim"
      local -n children=children_of_$dim
      local child
      if is_set children; then
        for child in "${!children[@]}"; do
          unset children[$child]
          calculate_default_anchors_recursive_unset $child || fail 
        done
      fi
    fi
  end_function
  handle_return
}

calculate_default_anchors() {
  begin_function
    local dim 
    local -A valid_anchors removed_anchors

    for dim in ${trunk_dims[*]}; do
      valid_anchors[$dim]=1
    done

    begin_loop; doo

      local min_derived_from_count=1000 dim_with_least_deps= \
        deps_array

      calculate_default_anchors_check_dims || fail

      if (( min_derived_from_count < 1000 )); then
        #log_debug "Removing dim with the least deps: $dim_with_least_deps"
        unset valid_anchors[$dim_with_least_deps]
      else
        break
      fi

    end_loop

    default_anchor_dims=
    begin_for dim in ${trunk_dims[*]}; doo
      if [[ -v valid_anchors[$dim] ]]; then
        default_anchor_dims+="$dim "
      fi
    end_for
    default_anchor_dims=${default_anchor_dims% }
    log_debug "Default anchors calculated: $default_anchor_dims"

  end_function
  handle_return
}

# should make sure load_branch_info was run before calling this
# inputs: 
#   $1  work path to target folder, which may be a cell or a folder of a cell
#   $2  target var to save seed path to, defaults to seed_path
# outputs: seed_path work_path
find_seed_path() {
  local d s=$1 i h dim dim_count
  local -n target=${2:-seed_path} 
  begin_function
    target=

    s=/seed${s#/work}

    while [[ ! -d $s && $s == *:* ]]; do
      s=${s%/*}
    done

    if [[ ${ignore_nonexistent:-f} == t ]]; then
      while [[ ! -d $s && $s == */*/*/* ]]; do
        s=${s%/*}
      done
    fi

    if [[ ! -d $s ]]; then
      log_fatal "Couldn't find seed for $s"
      fail1
    fi

    work_path=/work${s#/seed}

    # go through each seed folder and find matching dim
    local found_branch=t dim_folder
    begin_while [[ $found_branch == t ]]; doo
      
      found_branch=f
      dim_folder=$(find1 $s -name "*:*" -type d | head -n1) || fail
      if [[ "$dim_folder" ]]; then

        local seed_dim=${dim_folder##*/}
        seed_dim=${seed_dim%%:*}

        for (( i = 0; i < branch_dim_count; i++ )); do

          dim=${branch_dims[$i]}
          if [[ $dim == $seed_dim ]]; then
            h=${branch_hashes[$i]}
            if [[ -d $s/$dim:$h ]]; then
              s+=/$dim:$h
              found_branch=t
            elif [[ -d $s/$dim:_other ]]; then
              s+=/$dim:_other
              found_branch=t
            fi
            break
          fi

        done

      fi

    end_while

  end_function

  if [[ "$s" && -d $s ]]; then
    target=$s
  fi

  local log_return_vars='target work_path'
  handle_return
}

get_short_cell() {
  short_cell=${cell_path#/work/*/}
  debug_return_vars=short_cell
}

load_dna_contents_update_cell() {
  local file=$1 original_cell_path=$cell_path cell_path work_path
  begin_function

    local bottom_cell cell_path parent=${file%/*}
    if [[ ! -d "$parent" ]]; then
      ignore_nonexistent=t plant_seed $parent || fail
      cell_path=$work_path
    else
      get_bottom_cell $parent
      if [[ ! "$bottom_cell" ]]; then
        log_fatal "Could not find cell for $file"
        fail1
      fi
      cell_path=$bottom_cell
    fi
    local short_cell
    get_short_cell

    needs_update= \
    fork execute_commands "$cell_path" update || fail

    if [[ ! -f "$file" ]]; then
      log_fatal "Cell $short_cell did not produce file at $file as required by dna of $original_cell_path"
      fail1
    fi

  end_function
  handle_return
}

load_dna_contents_handle_file() {
  begin_function
    if [[ -L $item && ! -e $item ]]; then
      if [[ $real_path == /work/* ]]; then
        load_dna_contents_update_cell $real_path || fail
      else
        log_fatal "Broken link found: $item"
        fail1
      fi
    fi
    prefix=$new_prefix load_dna_item $item || fail
  end_function
  handle_return
}

build_dim_info() {
  begin_function

    local dim_var dim_type dims_var
    localize_dims=
    localize_reverse_dims=
    for dim_type in trunk_dims sub_dims control_props data_props; do
      local -n dim_array=$dim_type
      local -n plural_array=${dim_type}_plural

      plural_array=()
      for dim_var in ${dim_array[*]}; do
        get_plural $dim_var dims_var
        plural_array+=( $dims_var )

        localize_dims+=" d_$dim_var=\${d_$dim_var:-} d_$dims_var=\${d_$dims_var:-}"
        localize_reverse_dims+=" $dim_var=\${d_$dim_var:-} $dims_var=\${d_$dims_var:-}"

        local -n is_secret=${dim_type}_${dim_var}_is_secret
        if [[ -v is_secret && $is_secret == t ]]; then
          add_word_to_string secret_vars "$dim_var $dims_var d_$dim_var d_$dims_var"
        fi

        local -n d_dim_type=${dim_var}_dim_type
        d_dim_type=$dim_type
        write_vars_to_context ${dim_var}_dim_type || fail
      done

      write_vars_to_context \
        ${dim_type}_plural \
        || fail

    done

    write_vars_to_context \
      localize_dims localize_reverse_dims \
      secret_vars \
      derive_tables \
      || fail

  end_function
  handle_return
}

# if context_type is not set, then no context will be written
load_dna_contents() {
  local folder=$1 prefix=${prefix:-} \
    pass_thru=${pass_thru:-f} recursive=${recursive:-t} \
    ignore_unknown=${ignore_unknown:-f} \
    context_type=${context_type:-} \

  begin_function

    local items
    items=$(find1 $folder -not -name '.*' -not -name 'dna-root' | sort -g) || fail

    if [[ "${dna_roots:-}" && $folder != */dna-root/* ]]; then
      load_dna_contents_dna_root || fail
    fi

    local current_var=${prefix%_} ord item_name item_var= result 
    if [[ $pass_thru == f ]]; then
      local array_content=( )
    fi
    current_var=${current_var//-/_}

    begin_for item in $items; doo

      item_name=${item##*/}

      local dna_prefix=f
      if [[ "$item_name" == dna-* ]]; then
        dna_prefix=t
        item_name=${item_name#dna-}
      fi

      extract_simple_name item_name ord item_name
      item_var=${item_name//-/_}

      local new_prefix= 
      if [[ "$current_var" && $dna_prefix == f ]]; then
        new_prefix=${current_var}_
      fi

      local real_path=$(realpath -m $item)

      if [[ ! -e $real_path ]]; then
        if [[ $real_path == /work/* ]]; then
          local seed_path
          ignore_nonexistent=t \
          find_seed_path $real_path || fail
          deep=t plant_seed_internal "$seed_path" "$work_path" || fail
        else
          log_fatal "Missing file in dna: $item"
          fail1
        fi
      fi

      if [[ -d $item ]]; then
        if [[ $recursive == t ]]; then
          load_dna_contents_handle_dir || fail
        fi
      else
        load_dna_contents_handle_file || fail
      fi

    end_for

    if [[ "$current_var" && "${array_content:-}" && $pass_thru == f ]]; then
      make_array_assignment $current_var array_content || fail
      write_to_context var "$array_assignment" || fail
    fi

  end_function
  handle_return
}

build_context_dna() {
  local log_vars=cell_path log_show_vars=short_cell
  begin_function

    local item_name last_part dna_full_item suffix context_type=trunk
    local -A append_vars

    if [[ -e $context_path-$context_type ]]; then
      log_fatal "Internal error: Trunk context already exists. Should have been deleted before calling this function."
      fail1
    fi

    derive_tables=()
    if [[ -d $dna_path ]]; then
      local dna_roots
      dna_roots=$(find -L $dna_path -name up -prune -o -name up-chosen -prune -o -name down -prune -o -name dna-root -print | sort -g) || fail
      prefix= load_dna_contents $dna_path || fail

      build_context_expand || fail
      if [[ ! "${default_anchor_dims:-}" ]]; then
        calculate_default_anchors || fail
      fi
      write_vars_to_context default_anchor_dims || fail

      mv $context_path-$context_type.new $context_path-$context_type.new2 || fail
      echo "#!/usr/env bash
# This file is generated from $dna_path$NL" >$context_path-$context_type.new || fail
      local v
      for v in ${!append_vars[*]}; do
        echo "$v=" >>$context_path-$context_type.new || fail
      done

      cat $context_path-$context_type.new2 >>$context_path-$context_type.new || fail
      rm $context_path-$context_type.new2 || fail

    elif [[ -f $dna_path ]]; then
      safe_link $dna_path $context_path-$context_type.new || fail
      source $dna_path || fail
    else
      log_vars=dna_path log_fatal "Internal error: dna not found"
      fail1
    fi

  end_function
  handle_return
}

build_context_trunk() {
  begin_function

    local context_type=trunk last_type=var \

    log_debug "Building trunk context for $short_cell" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    build_context_dna || fail

    if [[ ! -d $status_path ]]; then
      mkdir -p $status_path || fail
    fi

    build_dim_info || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

build_context_branch() {
  begin_function

    local context_type=branch last_type=var
    log_debug "Building branch context for $short_cell" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    local dim assignment member i members_string=
    begin_for ((i = 0; i < branch_dim_count; i++)); doo
      dim=${branch_dims[$i]}
      member=${branch_members[$i]}
      quotes=single shell_quote_var member
      assignment="d_$dim=$member"
      members_string+="$member "
      write_to_context var "$assignment" || fail
    end_for

    write_to_context var "
branch_dims=( ${branch_dims[*]} )
branch_dim_count=$branch_dim_count
branch_members=( ${members_string% } )
branch_hashes=( ${branch_hashes[*]} )
cell_is_leaf=$cell_is_leaf
" || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

# input: dim_var value
# output: values 
expand_dim() {
  local -n dim_type=${dim_var}_dim_type
  begin_function

    values=
    if [[ "${value:-}" ]]; then

      if ! function_exists ${dim_type}_${dim_var}_expand; then
        log_fatal "Internal error: Missing ${dim_type}_${dim_var}_expand function, which should have been created by make_context method"
        fail1
      fi

      local problem
      ${dim_type}_${dim_var}_expand || fail
      if [[ "${problem:-}" ]]; then
        log_fatal "$problem"
        fail1
      fi

    fi

  end_function
  handle_return
}

handle_missing_dims() {
  local can_ask=${can_ask:-t}
  begin_function
    local dim_var dims_var
    begin_for dim_var in ${missing_dims[*]}; doo

      get_plural $dim_var dims_var
      local -n value=d_$dim_var ddims=d_$dims_var

      if [[ $can_ask == t ]]; then
        choose "Enter required value: $dim_var=" d_$dim_var || fail
        expand_dim || fail
      fi

      if [[ ! "${values:-}" ]]; then
        log_fatal "Missing required parameter: $dim_var. Use 'cell . ?' command to get help about how to use this cell."
        fail1
      fi

      ddims=( "${values[@]}" )

    end_for
    missing_dims=()
  end_function
  handle_return
}

# only run if the cell is actually a leaf
build_context_leaf() {
  begin_function
    local context_type=leaf last_type=var
    log_debug "Building leaf context for $cell_path" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    if [[ ! "${parameter_questions:-}" ]]; then

      local missing_dims=()
      coord_type=branch \
      switch_context_calc_coordinates || fail
      if [[ "${missing_dims:-}" ]]; then
        # TODO will need to find a better way to do this
        log_fatal "Could not resolve all branch dims in build_context_leaf"
        fail1
      fi

      write_vars_to_context \
        branch_coordinate_data \
        branch_coordinate_count \
        branch_coordinate_rows \
        branch_coordinate_fields \
        branch_coordinate_fields_count \
        branch_coordinate_fields_plural \
        || fail

    fi

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

calc_anchor_dims() {
  begin_function
    # all anchors and non-branch dim calculations are dynamic per command execution
    # and so can't be precalculated and stored in the context
    : ${anchor_dims:=${anchor_dims:-${default_anchor_dims:-}}}
    if [[ "${branch_dims:-}" && "$branch_dims" != "$anchor_dims" ]]; then
      local branch_dim
      for branch_dim in ${branch_dims[*]}; do
        remove_word_from_string anchor_dims $branch_dim
      done
      if [[ "$anchor_dims" ]]; then
        anchor_dims="${branch_dim[*]} $anchor_dims"
      else
        anchor_dims="${branch_dim[*]}"
      fi
    fi
  end_function
  handle_return
}

get_highest_trunk_context_cell() {
  begin_function
    local parent_cell=${cell_path%/*}
    while [[ -e $parent_cell/.cyto/context-trunk ]]; do
      parent_cell=${parent_cell%/*}
    done
    if [[ -e $parent_cell/.cyto/context-trunk ]]; then
      highest_trunk_context_cell=$parent_cell
    fi
  end_function
  handle_return
}

build_context() {
  local cell_path=$1
  begin_function

    if [[ ! -f $context_path-trunk ]]; then
      local trunk_context_path=$trunk_cell/.cyto/context
      if [[ $cell_is_trunk == t || ! -f $trunk_context_path-trunk ]]; then
        context_path=$trunk_cell/.cyto/context \
        build_context_trunk || fail
      else
        source $trunk_context_path-trunk || fail
      fi
      if [[ $cell_is_trunk == f ]]; then
        safe_link $trunk_context_path-trunk $context_path-trunk || fail
      fi
    else
      source $context_path-trunk || fail
    fi

    calc_anchor_dims || fail
    setup_dims || fail
    if [[ ! -f $context_path-branch ]]; then
      build_context_branch || fail
    else
      source $context_path-branch || fail
    fi

    if [[ $cell_is_leaf == t ]]; then
      if [[ ! -f $context_path-leaf ]]; then
        build_context_leaf || fail
      else
        source $context_path-leaf || fail
      fi
    fi

    if [[ -e $context_path.new ]]; then
      rm $context_path.new || fail
    fi

    if [[ -e $context_path-trunk ]]; then
      cat $context_path-trunk >>$context_path.new || fail
      context_exists=t
    fi

    if [[ -e $context_path-branch ]]; then
      cat $context_path-branch >>$context_path.new || fail
      context_exists=t
    fi

    if [[ -e $context_path-leaf ]]; then
      cat $context_path-leaf >>$context_path.new || fail
      context_exists=t
    fi

    mv $context_path.new $context_path || fail

  end_function
  handle_return
}

fetch_values_from_coordinates() {
  local dim_var=$1 coord_type=$coord_type
  begin_function
    local -A results # must not be set to empty string here
    out_field=$dim_var \
    out_set=results \
    derive_table=${coord_type}_coordinate \
    execute_derive_table || fail
    keys_to_array results values
    if [[ "${values[*]:-}" ]]; then
      log_debug "$dim_var fetched from coordinates: ${values[*]}"
    else
      log_debug "Failed to fetch $dim_var from coordinates"
    fi
  end_function
  handle_return
}

# input: 
#   $1=dim
#   function=function to execute for each member
#   fork=whether the process should be forked before executing 
#     the function. (optional)
for_each_member() {
  local dim=$1 \
    function=$function leave_loop=${leave_loop:-0} \
    fork=${fork:-t} \
    par=${par:-t} \
    cell_path=${cell_path:-}

  member_count=0
  local log_vars='fork par' \
    log_show_vars='dim function'
  begin_function

    coord_type=branch \
    fetch_values_from_coordinates $dim || fail

    member_count=${#values[*]}

    if (( member_count > 1 )); then
      # don't refine the upstream link if there would be multiple matches
      local upstream_cell_link=
    fi

    if (( member_count == 0 )); then
      log_fatal "No members found for $dim"
      fail1
    fi

    loop_over_var=values \
      head="local member=\$value dim=$dim command_history=\${command_history:-}
        eval 'local d_$dim=\"\$member\"'" \
      body=$function \
      tail='
        if [[ $leave_loop -gt 0 ]]; then
          break
        fi
        ' \
      parallel_loop || fail

  end_function
  handle_return
}

plant_seed_internal() {
  local from=$1 to=$2 contents x x_part deep=${deep:-t} plant_branches=${plant_branches:-f}
  begin_function

    log_debug "Planting seed from $from to $to" || fail

    if [[ ! -d $to ]]; then

      if [[ $from == /seed/* && -d $from ]]; then
        plant_seed_internal ${from%/*} ${to%/*} || fail
      else
        log_fatal "Seed doesn't exist for $to"
        fail1
      fi

    else

      contents=( $(find1 $from | sort -g) ) || fail
      local dim_found= target
      begin_for x in ${contents[*]}; doo
        x_part=${x##*/}
        target=$to/$x_part
        if [[ ! -e $target || $x_part == .mock ]]; then
          if [[ -f $x || $x_part == .dna ]]; then
            safe_link $(realpath $x) $to/ || fail
          elif [[ $x_part == .mock && "${current_mock:-f}" != f && -d $x/$current_mock ]]; then
            safe_link $(realpath $x)/$current_mock/!(export) $to/ || fail
          elif [[ $x_part == .* ]]; then
            : # ignore this
          elif [[ $x_part == *:* ]]; then
            local new_dim=${x_part%%:*}
            if [[ ! "$dim_found" ]]; then
              dim_found=${x_part%%:*}
            elif [[ $dim_found != $new_dim ]]; then
              log_fatal "Seed has two different dims defined, which is not allowed: $dim_found and $new_dim in $from"
              fail1
            fi
          elif [[ -L $x ]]; then
            cp -a $x $to/ || fail
          elif [[ -d $x ]]; then
            mkdir $target || fail
            if [[ $deep == t ]]; then
              plant_seed_internal $x $target || fail
            fi
          fi
        fi
      end_for

      if [[ "$dim_found" && $plant_branches == t ]]; then
        build_context $to || fail

        # recursive
        parent_path=$to \
        seed_path=$from \
        par=f fork=f \
        function=plant_member \
        for_each_member $dim_found || fail

      fi

    fi
  end_function
  handle_return
}

# inputs: $1  work path to the cell
plant_seed() {
  local seed_path from=$1 to=${2:-$1} \
    deep=${deep:-t} plant_branches=${plant_branches:-f} \
    ignore_nonexistent=${ignore_nonexistent:-f}

  begin_function

    if [[ ! -d "$to" ]]; then
      log_fatal "plant_seed called on a non-existant work path: $to"
      fail1
    fi

    find_seed_path $from || fail
    if [[ ! "$seed_path" ]]; then
      log_fatal "No seed is associated with this path: $to"
      fail1
    fi

    local dna_path=$seed_path
    if [[ $command_requires_cell == t ]]; then
      while [[ ! -d $dna_path/.dna ]]; do
        dna_path=${dna_path%/*}
        if [[ $dna_path != /*/* ]]; then
          log_fatal "Could not find dna in seed: $seed_path"
          fail1
        fi
      done

      if [[ $dna_path != $seed_path ]]; then
        safe_link $dna_path/.dna $to/ || fail
      fi

    fi

    plant_seed_internal $seed_path $to || fail

  end_function
  handle_return
}

init_context() {
  begin_function

    # required_freshness:
    #   inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
    #   1w means refresh if it's older than a week.
    # shuffle_chance:
    #   chance out of 1000 of not following the computed strategy order
    # min_pause:
    #   number of ms to wait between cycles
    #   this number doubles each time there is nothing to do, until it reaches max_pause
    # reuse_existing_out:
    #   if set to t: 
    #   new output folder won't be created when updating, but the existing one will be used
    #   should set to true when creating a new output folder would be expensive
    #   these cells must detect for themselves whether a change has happened in an
    #     update and set something_changed=t accordingly. 

    # need to make sure that expand functions don't bleed into sub command execution
    local dim_type dim
    for dim_type in trunk_dims sub_dims control_props data_props; do
      local -n dims=$dim_type
      for dim in ${dims[*]:-}; do
        unset ${dim_type}_${dim}_expand
      done
    done

    branch_coordinate_count= \
    branch_coordinate_data= \
    branch_coordinate_fields= \
    branch_coordinate_fields_count= \
    branch_coordinate_fields_plural= \
    branch_coordinate_rows= \
    cell_expiration= \
    cell_is_external=f \
    cell_is_persistent=f \
    check_op_var=f \
    child_dims=() \
    control_props=() \
    current_pause=250 \
    data_props=() \
    default_anchor_dims= \
    default_freshness= \
    default_strategies=crl \
    leaf_coordinate_count= \
    leaf_coordinate_data= \
    leaf_coordinate_fields= \
    leaf_coordinate_fields_count= \
    leaf_coordinate_fields_plural= \
    leaf_coordinate_rows= \
    localize_dims= \
    localize_reverse_dims= \
    lock_timeout=2 \
    max_pause=60000 \
    min_pause=250 \
    out_fields_choices= \
    out_file= \
    out_form_choices='raw simple table json kv' \
    out_path= \
    post_validate=f \
    pre_validate=f \
    refresh_less_than=${refresh_less_than:-1} \
    retry_delay=1 \
    retry_max=1 \
    retry_scale=2 \
    reuse_existing_out=t \
    shuffle_chance=100 \
    sub_dims=() \
    trunk_dims=() \
    up=() \
    update_cost=1 \
    update_risk=3 \

    unset \
      check_op \
      update_op \
      get_op \

    dna_key_path=$dna_path/key \
    down_path=$cyto_path/down \
    job_path=$cyto_path/job \
    key_path=$cyto_path/key \
    lock_path=$context_path \
    req_path=$cyto_path/req \
    status_path=$cyto_path/status \
    tmp_path=$cyto_path/tmp \
    up_path=$cyto_path/up \
    up_chosen_path=$cyto_path/up-chosen \
    inner_path=$cyto_path/inner \
    outer_path=$cyto_path/outer \

    replay_path=$job_path/pipe_replay

  end_function
  handle_return
}

branch_local_vars='branch_dims branch_members branch_hashes branch_dim_count trunk_cell short_cell prev_branch_info_cell'
load_branch_info() {
  local cell_path=${1:-$cell_path}

  begin_function

    if [[ "${prev_branch_info_cell:-}" == $cell_path ]]; then
      # already loaded
      succeed
    fi
    prev_branch_info_cell=$cell_path

    branch_dims=() \
    branch_members=() \
    branch_hashes=() \

    local c=$cell_path p d m
    begin_while [[ $c == *:* ]]; doo
      p=${c##*/}
      if [[ $p == *:* ]]; then

        d=${p%%:*}

        if [[ " ${branch_dims[*]} " == *" $d "* ]]; then
          log_fatal "Duplicate branch dim found: $d in $cell_path"
          fail1
        fi

        branch_dims=( $d ${branch_dims[*]} )

        m=${p#*:}
        branch_hashes=( $m ${branch_hashes[*]} )

        local member_var_path=$c/.member
        if [[ -f $member_var_path ]]; then
          m=$(<$member_var_path) || fail
        fi
        branch_members=( "$m" "${branch_members[@]}" )

        local -n dim_var=d_$d
        dim_var=$m

      fi
      c=${c%/*}
    end_while

    trunk_cell=$c
    branch_dim_count=${#branch_dims[*]}

    if (( branch_dim_count > 0 )); then
      cell_is_trunk=f
    else
      cell_is_trunk=t
    fi

    if [[ "${branch_dims:-}" ]]; then
      log_debug "Branch dims found: ${branch_dims[*]}" || fail
    fi

    local x y dim_string= 
    if [[ "${branch_hashes:-}" ]]; then
      dim_string="${branch_hashes[*]}"
      dim_string=:${dim_string// /\/}
    fi
    local short_trunk=${trunk_cell#/*/*/}

  end_function
  handle_return
}

load_repo_paths() {
  declare -gA repo_paths
  begin_function
    local repo repos
    repos=$(find1 /repo -not -name '.*' -type d) || fail
    begin_for repo in $repos; doo
      if [[ -d $repo/seed ]]; then
        local module modules
        modules=$(find1 $repo/seed -not -name '.*' -type d) || fail
        begin_for module in $modules; doo
          module=${module##*/}
          repo_paths[$module]=$repo
        end_for
      fi
    end_for
  end_function
  handle_return
}

broken_link_check() {
  begin_function
    local broken_links
    broken_links=( $(find -L $cyto_path -type l -print -o -name ".*" -prune) ) || fail
    if [[ "${broken_links:-}" ]]; then
      log_debug "Broken links found in cyto: $broken_links. Will rebuild cyto."
      problem_found=t
    fi
  end_function
  handle_return
}

load_dna_contents_dna_root() {
  begin_function
    local dna_folder=${dna_folder:-}
    if [[ $folder == */.dna ]]; then
      dna_folder=$folder
    fi
    local child_path=${folder#$dna_folder} root_path
    local dna_root new_items
    begin_for dna_root in $dna_roots; doo
      if [[ -d $dna_root$child_path ]]; then
        new_items=$(find1 $dna_root$child_path -not -name '.*' -not -name 'dna-root' | sort -g) || fail
        items+="$NL$new_items"
      fi
    end_for
  end_function
  handle_return
}

load_dna_contents_handle_dir() {
  begin_function
    if [[ "$current_var" && $item_var != _* ]]; then
      array_content+=( "$item_name" )
      if [[ -L $item || -d $item ]]; then
        result="${current_var}_${item_var}_path=$real_path"
        write_to_context var "$result" || fail
      fi
    fi

    if [[ ! -d $real_path/.dna ]]; then

      local new_pass_thru=f

      if [[ $item_var != _* ]]; then
        new_prefix+=${item_var}_
      else
        new_pass_thru=t
      fi

      # recursive
      prefix=$new_prefix pass_thru=$new_pass_thru load_dna_contents $item || fail

    fi
  end_function
  handle_return
}
 
link_single() {
  local only_one=${only_one:-f}
  begin_function

    extract_simple_name choice_name o choice_name
    local choice_var=${choice_name//-/_}

    if [[ $only_one == t ]]; then
      local -n choice_path=up_${up_var}_path
    else
      local -n choice_path=up_${up_var}_choices_${choice_var}_path
    fi

    if [[ ! -v choice_path ]]; then
      log_fatal "Missing choice path var"
      fail1
    fi

    if [[ ! -d $choice_path ]]; then
      log_fatal "Missing choice path"
      fail1
    fi

    if [[ $only_one == t ]]; then
      safe_link $choice_path $dep_path || fail
    else
      safe_link $choice_path $dep_path/choices/$choice_name || fail
    fi

  end_function
  handle_return
}

# inputs: dep_path up_name 
link_choices() {
  begin_function
    local choice_var choice_name o
    begin_for choice_name in ${choices[*]}; doo
      link_single || fail
    end_for
  end_function
  handle_return
}

make_cyto_inner() {
  begin_function
    mkdir $inner_path || fail
    local inner_name
    begin_for inner_name in ${inner[*]}; doo
      local dep_path=$inner_path/$inner_name \
        inner_var=${inner_name//-/_}
      local -n path=inner_${inner_var}_path
      if [[ ! -v path ]]; then
        log_fatal "Missing inner path var"
        fail1
      fi
      if [[ ! -d $path ]]; then
        log_fatal "Missing inner path"
        fail1
      fi
      safe_link $path $dep_path || fail
    end_for
  end_function
  handle_return
}

make_cyto_up_single() {
  local up_name=$1
  begin_function
    local dep_path=$up_path/$up_name \
      up_var
    local up_var=${up_name//-/_}
    local -n choices=up_${up_var}_choices
    if [[ -v choices ]]; then
      mkdir -p $dep_path/choices || fail
      link_choices || fail
    else
      local choice_name=$up_name
      if [[ -d $dep_path ]]; then
        rm -rf $dep_path || fail
      fi
      only_one=t link_single || fail
    fi
  end_function
  handle_return
}

make_cyto_up() {
  begin_function
    if [[ ! -e $up_path ]]; then
      mkdir $up_path || fail
    fi
    local up_name o
    begin_for up_name in ${up[*]}; doo
      make_cyto_up_single $up_name || fail
    end_for
  end_function
  handle_return
}

get_plural() {
  local dim=$1
  local target_var=${2:-plural}
  local -n target=$target_var
  if [[ $dim == *s ]]; then
    target=${dim}es
  elif [[ $dim == *y ]]; then
    target=${dim%y}ies
  else
    target=${dim}s
  fi
  debug_return_vars=$target_var
  return 0
}

# inputs:
#   $*           members to expand
# outputs:
#   new_values   array of expanded members
expand_dim_members() {
  begin_function
    local value values
    new_values=()
    begin_for value in "$@"; doo
      expand_dim || fail
      if [[ "$values" ]]; then
        new_values+=( "${values[@]}" )
      fi
    end_for
  end_function
  handle_return
}

# inputs:
#   derive_table   name of var of derive table
#   out_field      which field to read from the table
#   out_set        which var to write set of valid members to
# outputs:
#   out_set        the var out_set points to will contain a set of all matches
execute_derive_table() {
  begin_function        
      
    local out_var=$out_set
    local -n derive_fields=${derive_table}_fields \
             derive_data=${derive_table}_data \
             out_set=$out_set \

    if  ! is_set out_set; then
      log_fatal "Internal error: execute_derive_table was called with out_set pointing to a variable that isn't an associative array."
      fail1
    fi

    if [[ ! -v derive_fields ]]; then
      log_fatal "Interal error: Missing ${derive_table}_fields"
      fail1
    fi

    local field_count=${#derive_fields[*]} \
      data_count=${#derive_data[*]} \
      strict_matching=${strict_matching:-f} \
      maybe data_index=0 column_index \
      value= row_result field everything_matches \
      out_field=$out_field \
      invalid=f

    eval "local $localize_reverse_dims" || fail
    begin_while (( data_index < data_count )); doo
      everything_matches=t

      begin_for (( column_index = 0; column_index < field_count; column_index++ )); doo
        field=${derive_fields[$column_index]}
        value=${derive_data[$((data_index + column_index))]}
        if [[ $field == $out_field ]]; then
          row_result=$value
        else

          local -n dim=d_$field

          if [[ "${dim:-}" ]]; then
            if [[ "$dim" != "$value" && "$value" != any && "$dim" != any ]]; then
              #log_debug "Row doesn't match because dim $field = $dim but table shows $value"
              everything_matches=f
              break
            fi
          else # dim not set
            if [[ $strict_matching == t && "$value" && "$value" != any ]]; then
              #log_debug "Row doesn't match because $field is not set"
              everything_matches=f
              break
            fi
          fi

        fi
      end_for

      if [[ $everything_matches == t ]]; then
        #log_debug "Matching row found"
        out_set["$row_result"]=1
      else
        #log_debug "No matching row found"
        :
      fi

      (( data_index += field_count ))
    end_while

    log_return_vars=out_var
  end_function
  handle_return
}

# inputs:
#   dim     dimension to derive
# output:
#   values  array of members
expand_values_check_derive() {
  local old_values_string=${1:-}
  begin_function

    local -n dim_type=${dim}_dim_type
    local -n derived_from=${dim_type}_${dim}_derived_from
    values=

    local derived_from_row derived_from_dim \
      complete_row derived_from_incomplete=f \
      resolved_dependencies=()

    if [[ "${derived_from:-}" ]]; then
      local one_row_complete=f
      begin_for derived_from_row in "${derived_from[@]}"; doo
        if [[ "$derived_from_row" ]]; then
          complete_row=t
          for derived_from_dim in $derived_from_row; do
            local -n derive_from_dim_value=d_$derived_from_dim
            if [[ ! "${derive_from_dim_value:-}" ]]; then
              complete_row=f
              break
            fi
          done
          if [[ $complete_row == t ]];then
            one_row_complete=t
            resolved_dependencies+=( "$derived_from_row" )
          fi
        fi
      end_for
      if [[ $one_row_complete == f ]]; then
        derived_from_incomplete=t
      fi
    fi

    if [[ $derived_from_incomplete == t ]]; then
      #log_debug "Can't derive $dim because it has unresolved dependencies"
      succeed
    fi

    if function_exists ${dim_type}_${dim}_derive; then
      #log_debug "Trying derive function ${dim_type}_${dim}_derive"
      ${dim_type}_${dim}_derive || fail
    fi

    if [[ ! "${values:-}" ]]; then
      local -A old_values new_values intersected
      if [[ "$old_values_string" ]]; then
        string_to_set old_values_string old_values
      fi
      local derive_table
      begin_for derive_table in ${derive_tables[*]}; doo

        local -n fields=${derive_table}_fields
        if [[ ! -v fields ]]; then
          log_fatal "Internal error: derive_tables contains $derive_table, but there is no ${derive_table}_fields"
          fail1
        fi

        if [[ " ${fields[*]} " != *" $dim "* ]]; then
          # we don't need to check this table since it doesn't contain the dim
          continue
        fi

        if [[ "${derived_from:-}" ]]; then
          local found=f

          local resolved_row resolved_dim
          for resolved_row in "${resolved_dependencies[@]}"; do
            found=t
            for resolved_dim in $resolved_row; do
              if [[ " ${fields[*]} " != *" $resolved_dim "* ]]; then
                found=f
                break
              fi
            done
            if [[ $found == t ]]; then
              break
            fi
          done

          if [[ $found == f ]]; then
            # we don't need to check this table since it doesn't use enough set dependent dims
            continue
          fi
        fi

        out_field=$dim \
        out_set=new_values \
        execute_derive_table || fail
        if [[ -v old_values[*] && " ${!old_values[*]} " != *" all "* ]]; then
          intersect old_values new_values intersected
          copy_set intersected old_values
        else
          copy_set new_values old_values
        fi

      end_for
      keys_to_array old_values values

    fi

  end_function
  handle_return
}

expand_values_check_default() {
  begin_function

    local problem
    local -n dim_type=${dim}_dim_type

    if function_exists ${dim_type}_${dim}_default; then
      ${dim_type}_${dim}_default || fail
    fi

    if [[ ! "${values:-}" ]] && function_exists ${dim_type}_${dim}_expand; then
      value= ${dim_type}_${dim}_expand || fail
    fi

    if [[ ! "${values:-}" ]]; then

      local -n is_optional_var=${dim_type}_${dim}_is_optional
      if [[ -v is_optional_var && $is_optional_var == t ]]; then
        values=( $empty_member )
      fi

    fi

  end_function
  handle_return
}

calc_coordinates_process_member() {
  begin_function

    #if [[ "$localize_dims" ]]; then
    #  eval "local $localize_dims" || fail
    #fi

    local -n member=d_$dim \
      members=d_$dims
    member=$current_member

    if (( $current_dim_index < ${#coordinate_fields[*]} )); then

      if [[ $phase == known ]]; then
        # recursive
        calc_coordinates_next_known_dim $current_dim_index || fail
      else
        # recursive
        calc_coordinates_next_unknown_dim $current_dim_index || fail
      fi

    else

      if [[ $phase == known && "${missing_dims:-}" ]]; then
        log_debug "Attempting to resolve unknowns: ${missing_dims[*]}"
        missing_dims=()
        # recursive
        calc_coordinates_next_unknown_dim 0 || fail
      fi

    fi

  end_function
  handle_return
}

# inputs:
#   phase     known or unknown
#   members   array containing dim members to loop over
# outputs:
#   member    var to set with currently selected member
#   current_dim_index
calc_coordinates_loop_members() {
  local phase=$phase
  begin_function
    (( current_dim_index++ ))
    local current_member
    begin_for current_member in "${members[@]}"; doo
      calc_coordinates_process_member || fail
      if [[ "${missing_dims:-}" ]]; then
        break
      fi
    end_for
  end_function
  handle_return
}

calc_coordinates_add_row() {
  begin_function
    local i new_coords=()
    for (( i = 0; i < coordinate_fields_count; i++ )); do
      local -n dim_value=d_${coordinate_fields[$i]}
      coordinate_data+=( "$dim_value" )
      new_coords+=( "$dim_value" )
    done
    log_verbose "${coord_type}_coordinate_data+=( ${new_coords[*]} )"
  end_function
  handle_return
}

calc_coordinates_next_unknown_dim() {
  local current_dim_index=$1
  begin_function
    local dim dims changed=f phase=derive
    begin_loop; doo

      dim=${coordinate_fields[$current_dim_index]}
      dims=${coordinate_fields_plural[$current_dim_index]}
      local -n member=d_$dim \
        members=d_$dims

      if [[ ! "${members:-}" ]]; then

        log_debug "Finding values for $dim in phase $phase"
        local values= prev_phase=$phase
        if [[ $phase == derive ]]; then
          expand_values_check_derive || fail
        else
          expand_values_check_default || fail
        fi

        if [[ "${values:-}" ]]; then

          changed=t
          if [[ "$phase" == default ]]; then
            # go back to derive phase since calculating a new default could
            # open up new derive possibilities
            phase=derive
          fi

          log_debug "Resolved $dim with $prev_phase: ${values[*]:0:30}"

          # don't support aliases here (yet?)
          # local new_values
          # expand_dim_members "${values[@]}" || fail

          members=( "${values[@]}" )

          if (( ${#members[*]} > 1 )); then
            phase=unknown \
            calc_coordinates_loop_members || fail
            break
          else
            member=$members
          fi

        else
          log_debug "Failed to resolve $dim in phase $prev_phase"
          missing_dims+=( $dim )
        fi

      fi

      (( current_dim_index++ ))
      if (( $current_dim_index >= ${#coordinate_fields[*]} )); then
        if (( ${#missing_dims[*]} > 0 )); then
          if [[ $changed == t ]]; then
            # an unknown dim was resolved, so we need to go through again to see if we can resolve more
            changed=f
            current_dim_index=0
            missing_dims=()
          else
            if [[ $phase == derive ]]; then
              phase=default
              current_dim_index=0
              missing_dims=()
            else
              break
            fi
          fi
        else # all dims were resolved
          calc_coordinates_add_row || fail
          break
        fi
      fi

    end_loop

  end_function
  handle_return
}

# inputs:
#   coordinate_fields        array of dims to process
#   coordinate_fields_plural array of dim plurals to process
#   $1   index of dim to process
calc_coordinates_next_known_dim() {
  local current_dim_index=$1
  begin_function
    local dim dims
    begin_loop; doo

      dim=${coordinate_fields[$current_dim_index]}
      dims=${coordinate_fields_plural[$current_dim_index]}
      local -n member=d_$dim \
        members=d_$dims

      if [[ "${members:-}" ]]; then

        local member_array=( $members )
        if (( ${#member_array[*]} > 1 )); then
          phase=known \
          calc_coordinates_loop_members || fail
          break
        else
          member=$members
        fi

      else
        missing_dims+=( $dim )
      fi

      (( current_dim_index++ ))
      if (( current_dim_index >= ${#coordinate_fields[*]} )); then
        break
      fi

    end_loop

    if [[ "${missing_dims:-}" ]]; then
      log_debug "Attempting to resolve unknowns: ${missing_dims[*]}"
      missing_dims=()
      calc_coordinates_next_unknown_dim 0 || fail
    fi

  end_function
  handle_return
}

get_required_freshness() {
  required_freshness=${fresh:-${default_freshness:-}}

  # this can be used in upstream prep functions to pass freshness to upstream
  : ${top_fresh:=$required_freshness}

  # Make this go back to default for any further contexts loaded
  # fresh passed in by user should only apply to top level cell, not to deps or subs
  fresh=
  return 0
}

# needs to be explicity called in commands which need coords
calc_coords() {
  begin_function

    if [[ ! "${branch_coordinate_count:-}" ]]; then
      coord_type=branch \
      switch_context_calc_coordinates || fail
      handle_missing_dims || fail
    fi

    if [[ $cell_is_leaf == t && ! "${leaf_coordinate_count:-}" ]]; then
      coord_type=leaf \
      switch_context_calc_coordinates || fail
      handle_missing_dims || fail
    fi

  end_function
  handle_return
}

load_post_context_dynamic_vars() {
  begin_function

    get_required_freshness || fail

    if [[ ! "${seed_path:-}" ]]; then
      find_seed_path $cell_path || fail
    fi

    mock_path=$seed_path/.mock

    current_mock=f
    if [[ -e $cell_path/.mock ]]; then
      current_mock=$(<$cell_path/.mock) || fail
    fi

    if [[ "${force_mock:-}" \
       && ( $force_mock == f || -d $mock_path/$force_mock ) \
       && $current_mock != $force_mock ]]; then
      log_debug "Changing mock: $current_mock -> $force_mock (because of force_mock parameter)"
      current_mock=$force_mock
      echo "$force_mock" >$cell_path/.mock || fail
    elif [[ -f $cell_path/.mock ]]; then
      :
    elif [[ -f $trunk_cell/.mock ]]; then
      local trunk_seed
      find_seed_path $trunk_cell trunk_seed || fail
      #mock_path=$trunk_seed/.mock
    elif [[ "${mock:-}" && -d $mock_path/$mock && $current_mock != $mock ]]; then
      log_debug "Changing mock: $current_mock -> $mock (because of mock parameter)"
      current_mock=$mock
      echo "$mock" >$cell_path/.mock || fail
    else
      current_mock=f
    fi

    if [[ $current_mock != f && $current_mock != disabled && ! -d $mock_path/$current_mock ]]; then
      log_fatal "Invalid mock in $short_cell: $current_mock doesn't exist in $mock_path"
      fail1
    fi

    if [[ ! "${out_path:-}" ]]; then
      out_path=$cell_path
    elif [[ "$out_path" != /* ]]; then
      out_path=$cell_path/$out_path
    fi

  end_function
  handle_return
}

build_cyto_inner() {
  local cell_path=$1

  begin_function

    log_debug "Building cyto for $short_cell"
    dna_path=$cell_path/.dna \
    cyto_path=$cell_path/.cyto \

    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    if [[ ! -d $status_path ]]; then
      mkdir $status_path || fail
    fi

    init_context || fail
    load_branch_info || fail
    find_seed_path $cell_path || fail

    context_path=$cyto_path/context
    if [[ ! -f $context_path ]]; then
      build_context $cell_path || fail
    fi

    if [[ ! -f $context_path-check ]]; then
      context_type=check \
      write_vars_to_context \
        out_file \
        out_path \
        cell_is_leaf \
        check_op_var \
        data_props \
        || fail
      mv $context_path-check.new $context_path-check || fail
    fi

    if [[ "${up:-}" && ! -d $up_path && $cell_is_leaf == t ]]; then
      make_cyto_up || fail
    fi

    if [[ "${inner:-}" && ! -d $inner_path && $cell_is_leaf == t ]]; then
      make_cyto_inner || fail
    fi

  end_function
  handle_return
}

# Can be called on a cell that already has a cyto folder, in which case it will repair missing
#   parts
build_cyto() {
  fork build_cyto_inner "$@"
}

# inputs:
#   $1   cell_path
#   anchor_dims (as a space separated string)
# load_branch_info should be executed BEFORE this
# setup_dims should usually be executed AFTER this
# followed by calc_coords
switch_context() {
  cell_path=$1

  if [[ "${last_context_loaded:-}" != $cell_path ]]; then

    local log_show_vars=^cell_path rebuild_attempted=f
    begin_function

      get_short_cell
      log_debug "Loading context for $short_cell"

      dna_path=$cell_path/.dna \
      cyto_path=$cell_path/.cyto \

      local dna_exists=f
      if [[ -e $dna_path ]]; then
        dna_exists=t
      fi

      if [[ $dna_exists == t ]]; then
        if [[ "$clean_cells" ]]; then
          local cell_to_clean
          begin_for cell_to_clean in $clean_cells; doo
            if [[ /$cell_path/ == */$cell_to_clean/* ]]; then
              if [[ -e $cyto_path ]]; then
                log_info "Cleaning cell ${cell_to_clean#/work/*/} => $short_cell..."
                rm -rf $cyto_path/!(job) || fail
              else
                log_info "Cell already clean: $cell_to_clean => $short_cell"
              fi
              remove_word_from_string clean_cells "$cell_to_clean" 
              break
            fi
          end_for
        fi
      fi

      context_path=$cyto_path/context
      init_context || fail

      seed_path=
      if [[ $dna_exists == t ]]; then
        if [[ ! -f $context_path ]]; then
          build_cyto $cell_path || fail
        fi

        source $context_path || fail
        calc_anchor_dims || fail

        local problem_found=f
        broken_link_check || fail
        if [[ $problem_found == t ]]; then
          if [[ $rebuild_attempted == f ]]; then
            log_verbose "Problem found, rebuilding context"
            rm -rf $cyto_path/up* $context_path* || fail
            rebuild_attempted=t
            continue
          else
            log_fatal "Context rebuild failed to resolve problem"
            fail1
          fi
        fi
      fi

      load_post_context_dynamic_vars || fail
      last_context_loaded=$cell_path

    end_function
    handle_return

  else
    log_debug "Context already loaded: $short_cell" || fail
  fi

  return 0
}

cell_open_log_file() {
  begin_function
    if [[ ! "${log_path:-}" ]]; then
      # can't log until this is set
      succeed
    fi
     
    if [[ "${omni_log_job_id:-0}" != 0 ]]; then

      cell_log_file_stack+=( $logging_to_file )

      omni_log_fork_id=${omni_log_fork_parent:-}-${omni_log_fork_child}
      omni_log_fork_id=${omni_log_fork_id#-}

      local new_log_file=$log_path/$omni_log_job_id:$omni_log_fork_id.olog
      local first_log_path=${new_log_file%/*}/first.olog
      if [[ ! -f $first_log_path ]]; then
        from_must_exist=f \
          safe_link $new_log_file $first_log_path || fail
      fi

      log_function=${FUNCNAME[1]} \
        change_log_file || fail

    fi
  end_function
  handle_return
}

cell_close_log_file() {
  begin_function
    if [[ "${cell_log_file_stack:-}" ]]; then
      local previous_log=${cell_log_file_stack[-1]}
      unset cell_log_file_stack[-1]
      log_function=${FUNCNAME[1]} \
        new_log_file=$previous_log \
        resume_existing_log=t \
        logging_to_file= \
        change_log_file || fail
    fi
  end_function
  handle_return
}

get_job_id() {
  begin_function

    if [[ ! -v job_id_log ]]; then
      log_fatal "Internal error: Missing job_id_log"
      fail1
    fi

    timeout=5 lock_path=$job_id_log fd_write_lock || {
      log_fatal "Failed to get lock on $job_id_log" 
      fail1
    }

    if [[ -f "$job_id_log" ]]; then
      local last_id=$(tail -n1 $job_id_log | awk '{print $1}')
      (( omni_log_job_id = last_id + 1 ))
    else
      omni_log_job_id=1
    fi

    if [[ ! "$command_to_log" ]]; then
      log_fatal "Missing command to log."
      fail1
    fi

    echo "$omni_log_job_id $cell_path $command_to_log" >>$job_id_log || fail

    fd_unlock

    log_return_vars=omni_log_job_id
  end_function
  handle_return
}

execute_command_log_prep() {
  begin_function
    local cyto_path=$cell_path/.cyto
    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    local job_path=$cyto_path/job
    if [[ ! -d $job_path ]]; then
      mkdir $job_path || fail
    fi

    if [[ "${omni_log_job_id:-0}" == 0 ]]; then
      job_start_time=${EPOCHREALTIME//./}
      command_to_log="${original_cmd#* }" \
        get_job_id || fail
    fi

    current_job_path=$job_path/$omni_log_job_id
    if [[ ! -d $current_job_path ]]; then
      mkdir $current_job_path || fail
    fi

    # only set this for the first cell in the job, all other cells should 
    #   use the same fork_id log so that they all have unique ids across the job
    if [[ ! "${fork_id_log:-}" ]]; then
      fork_id_log=$current_job_path/fork-id-log
    fi

    log_path=$current_job_path/log
    if [[ ! -d $log_path ]]; then
      mkdir $log_path || fail
    fi

    background_log=$log_path/background
    running_job_path=$job_path/running

    local link_target
    begin_for link_target in $cell_command-attempt attempt; doo
      if [[ -e "$job_path/last-$link_target" ]]; then
        mv $job_path/last-$link_target $job_path/prev-$link_target || fail
      fi
      safe_link $current_job_path $job_path/last-$link_target || fail
    end_for

  end_function
  handle_return
}

# Inputs:
#   $1    cell_path   should be real path
#   $2    command
execute_command() {
  local cell_path=$1 cell_command=$2 \
    log_show_vars='short_cell cell_command' \

  begin_function_hi

    case $cell_command in
      dim-*|up-*)
        if [[ $cell_path == /seed/* ]]; then
          cell_path=/work${cell_path#/seed}
        fi
      ;;
      *)
        if [[ $cell_path != /work* ]]; then
          log_fatal "You must run this command from within the workspace (any subfolder of /work)"
          fail1
        fi
      ;;
    esac

    strong_log=t log_info "Executing cell command: $short_cell $cell_command" || fail

    if [[ ! -e "$cell_path" ]]; then
      plant_seed $cell_path || {
        log_fatal "Not a cell: $cell_path"
        fail1
      }
    fi

    if [[ ! -e $cell_path/.dna && $command_requires_cell == t ]]; then
      log_fatal "Invalid cell: $cell_path"
      fail1
    fi

    if [[ $command_allows_logs == t ]]; then
      disable_log=f
    else
      disable_log=t
    fi

    if [[ $disable_log == t ]]; then
      #log_debug "Logging disabled." || fail
      :
    else
      execute_command_log_prep || fail
    fi

    if [[ $disable_log == f ]]; then
      : ${omni_log_fork_child:=0}
      (( omni_log_fork_child++ ))
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    local omni_log_fork_parent=${omni_log_fork_parent:-}-${omni_log_fork_child:-1} \
      omni_log_fork_child=0
    omni_log_fork_parent=${omni_log_fork_parent#-}

    if [[ " ${command_history:-}" == *" $cell_command $short_cell "* ]]; then
      log_fatal "Circular dependency found: arrived at $cell_command $short_cell a second time."
      fail1
    fi

    command_history+="$cell_command $short_cell "

    local cell_command_function=${cell_command//-/_}_command
    if function_exists $cell_command_function; then
      $cell_command_function || fail
    else
      log_fatal "Missing command function $cell_command_function which should be in $cell_command_path"
      fail1
    fi

    if [[ $disable_log == f ]]; then
      cell_close_log_file || fail
    fi

  end_function
  handle_return
}

execute_commands_prep() {
  begin_function
    get_short_cell
    load_branch_info || fail

    if [[ $top_level_command == f ]]; then
      unset anchor_dims
    else
      unset default_anchor_dims
    fi

  end_function
  handle_return
}

substitute_command_alias() {
  begin_function
    local alias_command parameters
    for (( i = 0; i < ${#command_aliases[*]}; i++ )); do
      if [[ "${command_aliases[$i]}" == "$cell_command" ]]; then
        alias_command=${command_alias_command[$i]}
        cell_command=${alias_command%% *}
        parameters=${alias_command#$cell_command }
        update_original_cmd=f parameters_to_env $parameters
        succeed
      fi
    done
  end_function
  handle_return
}

# inputs:
#   $1    cell_path   should be real path
#   $2... commands
execute_commands() {
  local cell_path=$1; shift
  local cell_commands=( $* ) cell_command
  local log_show_vars=cell_commands
  begin_function_hi

    if [[ "$pause_at_cells" ]]; then
      local pac
      for pac in $pause_at_cells; do
        if [[ "$cell_path" == *"$pac"* ]]; then
          pause_qd "Cell reached: $pac."
        fi
      done
    fi

    local top_level_command=${top_level_command_next:-t}

    # so top_level_command is set to t throughout this function, yet if it's called again, it will
    #   be set to f
    top_level_command_next=f

    eval "local $branch_local_vars" || fail
    execute_commands_prep || fail

    begin_for cell_command in ${cell_commands[*]}; doo

      substitute_command_alias || fail

      local cell_command_path=$path_to_commands/$cell_command \
        command_allows_logs=f \
        command_requires_cell=f \

      if [[ -e $cell_command_path.info ]]; then
        source $cell_command_path.info || fail
      else
        log_warn "Missing file $cell_command_path.info" || fail
      fi

      if [[ ! -d $cell_path/.dna && $command_requires_cell == t ]]; then

        if [[ $recursive_command == t ]]; then
          local folder folders
          folders=$(find1 $cell_path -type d -not -name '.*') || fail
          begin_for folder in $folders; doo
            execute_commands $folder ${cell_commands[*]} || fail
          end_for
        else
          if [[ $top_level_command == t ]]; then
            log_warn "Skipping $cell_path because it is not a cell"
          else
            log_verbose "Skipping $cell_path because it is not a cell"
          fi
        fi

      else

        if [[ -e $cell_command_path ]]; then
          source $cell_command_path || fail
        else
          log_fatal "Internal error: Missing $cell_command command in $cell_command_path"
          fail1
        fi

        local showed_parameter_help=f
        if [[ "${parameter_questions:-}" ]]; then
          show_parameters_help || fail
        fi

        if [[ $showed_parameter_help == f ]]; then
          execute_command $cell_path $cell_command || fail
        fi

      fi

    end_for

  end_function
  handle_return
}

# this should be run in a subshell
fork_inside() {
  begin_function_lo

    local change_log2=$change_log
    # Prevents this variable from bleeding through to lower called functions
    change_log=

    if [[ $change_log2 == t && $disable_log == f ]]; then
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    if [[ "$fork_id_current" ]]; then
      fork_id_current=$fork_id_current.$debug_id_current
    else
      fork_id_current=$debug_id_current
    fi
    debug_id_current=0
    fork_debug_id=$fork_id_current.0

    cleanup_on_exit=
    setup_exit_trap

    if [[ "$to_var" ]]; then
      eval "$to_var=\$($fork_command)"; return_code=$?
      reply_to_caller "$to_var='${!to_var}'" || fail
    else
      eval "$fork_command"; return_code=$?
    fi

    if [[ $change_log2 == t ]]; then
      cell_close_log_file || fail
    fi

    if [[ "${debugging:-}" == t ]]; then
      reply_to_caller "debug_state_file='${debug_state_file:-}'; debugging=t" || fail
    fi

    if (( return_code != 0 )); then
      reply_to_caller "return_code=$return_code" || fail
      return_value=$return_code
    fi

    if [[ $change_log2 == t ]]; then
      reply_to_caller "omni_log_pos=$previous_log_pos" || fail
    fi

    if [[ "${command_successful:-}" ]]; then
      reply_to_caller "command_successful=$command_successful" || fail
    fi

    if [[ "${trace_var:-}" ]]; then
      copy_map trace_var_old trace_var_sub
      local s="unset trace_var_sub; $(declare -p trace_var_sub)" 
      s=${s/ -A / -Ag }
      reply_to_caller "$s" || fail
    fi

    #reply_to_caller "debug_id_current=$debug_id_current"

  end_function
  handle_return
}

# run outside of the subshell afterwards
after_fork() {
  begin_function_lo
    if [[ -f "${reply_file:-}" ]]; then
      #pause "Sourcing $reply_file"
      source $reply_file || fail
      if [[ ${debugging:-f} == t ]]; then
        debug_needs_to_load_state=t \
          debug_load_state || fail
        debug_immediate=f \
          first_run=f \
          debug_start
      fi
      rm $reply_file
      reply_file=
    fi
  end_function
  handle_return
}

get_new_reply_file() {
  reply_file=$tmp_folder/reply.$BASHPID
  if [[ -f $reply_file ]]; then
    log_fatal "reply_file already exists: $reply_file"
    return 1
  fi
  return 0
}

# usage: fork {command to execute}
#  background=f (whether to run as a background process)
#  change_log=f (whether to change the log)
#  to_var       (write output to the given var instead of stdout)
fork() {
  local fork_command=$*
  begin_function
    local reply_file return_code=0 \
      background=${background:-f} \
      change_log=${change_log:-f} \
      to_var=${to_var:-}

    if [[ $background == t ]]; then
      change_log=t
    fi

    : ${omni_log_fork_child:=0}
    (( omni_log_fork_child++ ))

    get_new_reply_file || fail
    defer "rm $reply_file"

    if [[ $background == t ]]; then
      ( fork_inside ) &
    else
      ( fork_inside )
      return_code=$?
      after_fork || (( return_code++ ))
    fi

    return_value=$return_code
  end_function
  handle_return
}

fork_fg() {
  background=f fork "$@"
}

fork_bg() {
  background=t fork "$@"
}

get_is_stale() {
  local status_path=$status_path
  begin_function
    is_stale=t
    if [[ ! "$required_freshness" || "$required_freshness" == inf ]]; then
      is_stale=f
    elif [[ $required_freshness != 0 ]]; then
      local fresh_seconds
      convert_to_seconds $required_freshness fresh_seconds || fail
      local fresh_cutoff=$((EPOCHSECONDS-fresh_seconds)) \
        out_timestamp= 
      is_stale=f
      if [[ -f $status_path/last-good-update-end ]]; then
        out_timestamp=$(date -r $status_path/last-good-update-end +%s)
      fi
      if [[ "$out_timestamp" && $out_timestamp -lt $fresh_cutoff ]]; then
        is_stale=t
      fi
    fi
  end_function
  handle_return
}

wait_for_low_load() {
  local cell_max_load=${cell_max_load:-10}
  local cell_load_wait_timeout=${cell_load_wait_timeout:-600}
  local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
  if [[ $current_load -gt $cell_max_load ]]; then
    log_warn "Load average is too high ($current_load > $cell_max_load)," \
      "waiting until things cool down first." || fail
    local time_waited=0
    while [[ $current_load -gt $cell_max_load ]]; do
      current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
      sleep 5; let time_waited+=5
      if [[ "$cell_load_wait_timeout" -gt 0 && $time_waited -ge $cell_load_wait_timeout ]]; then
        log_fatal "Timed out waiting for cpu load to be low enough. Aborting"
        return 1
      fi
    done
  fi
  return 0
}

reply_file=

# input: parallel processes
wait_for_sub_processes() {
  begin_function
    if [[ "$processes" ]]; then
      log_debug "Waiting for sub processes to complete" || fail
      local process last_err_code= last_failed_process= rc
      for process in $processes; do
        log_debug "Waiting for process $process" || fail
        wait $process &>/dev/null; rc=$?
        if [[ $rc -gt 0 && $rc -lt 127 ]]; then
          if [[ ! "$last_err_code" ]]; then
            last_err_code=$rc
            last_failed_process=$process
          else
            log_fatal "Subprocess $process failed to terminate successfully"
            fail1
          fi
        fi
      done
      after_fork
      if [[ "$last_err_code" ]]; then
        if [[ "$last_err_code" == 1 ]]; then
          log_fatal "Subprocess $last_failed_process failed to terminate successfully"
          fail1
        fi
        return_value=$last_err_code
        break_out=t
        break
      fi
      processes=
    fi
  end_function
  handle_return
}

# 'value' is the loop var
parallel_loop() {
  local loop_over_var2=$loop_over_var head2=${head:-} \
    body2=$body tail2=${tail:-} \
    par2=$par fork2=$fork \
    array 

  # Make sure these variables don't get passed into inner loops
  local loop_over_var= head= body= tail= par= fork=

  local log_show_vars='loop_over_var=loop_over_var2 par=par2 fork=fork2'
  begin_function_lo

    if [[ ! -v $loop_over_var2 ]]; then
      log_fatal "Internal error: Variable doesn't exist: $loop_over_var2"
      fail1
    fi

    eval "array=( \"\${$loop_over_var2[@]}\" )"
    local parallel=f
    if [[ ${#array[*]} -gt 1 && $parallel_execution == t && $par2 == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi

    local processes= value
    leave_loop=0

    local extra
    if [[ $parallel == t ]]; then
      extra=" in parallel"
    else
      extra=" sequentially"
    fi

    local size=${#array[*]}
    if (( size > 1 )); then
      log_debug "Looping over $size values$extra. body: $body2" || fail
    fi

    begin_for value in "${array[@]}"; doo

      log_debug "Current iteration value=$value" || fail

      if [[ "$head2" ]]; then
        eval "$head2" || fail
      fi

      if [[ $parallel == t ]]; then
        fork_bg "$body2" 
        processes+=" $!"
      else
        if [[ $fork2 == t ]]; then
          fork_fg "$body2" || fail
        else
          eval "$body2" || fail
        fi
      fi

      if [[ "$tail2" ]]; then
        eval "$tail2" || fail
      fi

    end_for

    wait_for_sub_processes || fail

  end_function
  handle_return
}

trace_step_execution=${trace_step_execution:-f}
trace_op=${trace_op:-}

# Usage: execute_op {op name}
# If {op_name}_op_var variable exists, it will be evaluated as the body of the {op_name}_op function
#   and then executed
# Otherwise {op_name}_op function is executed
#
# output
#   missing   set to t if no op found
execute_op() {
  local op_name=$1 op_function= ignore_missing=${ignore_missing:-f}

  local log_vars='cell_path op_name'
  begin_function

    op_function=${op_name}_op
    local -n op_var=${op_name}_op_var

    missing=f
    if [[ "${op_var:-}" == f ]]; then
      missing=t
    else

      if [[ "${op_var:-}" ]]; then
        if [[ "${op_var#${op_name}_op()}" != "${op_var}" ]]; then
          eval "$op_var"
        else
          eval "${op_name}_op() {
begin_function
$op_var
end_function
handle_return
}"
        fi
      fi

      if type -t $op_function &>/dev/null; then

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=t
        fi

        $op_function || fail

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=f
        fi

      else
        missing=t
      fi

    fi

    if [[ $missing == t ]]; then
      if [[ $ignore_missing == t ]]; then
        log_debug "No ${op_name}_op function found, ignoring" || fail
      else
        log_fatal "No ${op_name}_op function found"
        fail1
      fi
    fi

  end_function
  handle_return
}

# inputs: parent_path seed_path member
plant_member() {
  begin_function
    local deep=${deep:-f} repair=${repair:-f}
    get_sane_value "$member" || fail
    member_path=$parent_path/$dim:$sane_value
    if [[ ! -d $member_path || $repair == t ]]; then

      local new_path=$member_path.new

      if [[ -d $new_path ]]; then
        rm -rf $new_path || fail
      fi

      mkdir $new_path || fail
      if [[ "$member" != "$sane_value" ]]; then
        echo "$member" >$new_path/.member || fail
      fi

      plant_seed $member_path $new_path || fail

      #if [[ -e $parent_path/.mock ]]; then
      #  if [[ ! -d $new_path/.cyto ]]; then
      #    mkdir $new_path/.cyto || fail
      #  fi
      #  cp $parent_path/.mock $new_path/.mock || fail
      #fi

      if [[ -e $member_path ]]; then
        rm -rf $member_path || fail
      fi
      mv $new_path $member_path || fail

    fi
  end_function
  handle_return
}

# input: $* = cell values in dim order
# output: cell_id = string cell id
get_cell_id() {
  local v
  cell_id=
  for v in "$@"; do
    get_sane_value "$v"
    v=$sane_value
    cell_id+=_$v
  done
  cell_id=${cell_id#_}
}

encrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=$to \
    key=${key:-$user_private_key}

  begin_function

    if [[ "$to" == */ ]]; then
      to+=${from##*/}
    fi

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ -e $to ]]; then
      log_fatal "File already exists: $to"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    setup_tmp_path || fail
    if ! log_and_run openssl pkeyutl -encrypt -inkey $key -in $from -out $to; then
      log_fatal "Failed to encrypt file: $from"
      fail1
    fi

  end_function
  handle_return
}

encrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from \
    to=$to \
    tmp_path=$tmp_path \
    key_path=$key_path \
    user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Encrypting $from to $to" || fail

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to encrypt non-existent file: $from"
      fail1
    fi

    if [[ -f "$to" ]]; then
      log_fatal "Encrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then

      local key_count=$(find -L $key_path -mindepth 1 -maxdepth 1 -name 'key.*' -type f | wc -l)

      if (( key_count > 0 )); then

        log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
        find -L $key_path -name "key.*" >&2
        fail1

      else

        log_debug "There are no keys for this cell yet. Will create a new key." || fail

        # create a new main key
        if ! out_to_file=$tmp_path/main log_and_run openssl rand -base64 40; then
          log_fatal "Failed to generate new main key."
          fail1
        fi
        defer "rm $tmp_path/main"

        # create a compatible public key from the user's private key
        if ! log_and_run openssl pkey -in $user_private_key -out $tmp_path/public -pubout; then 
          log_fatal "Failed to convert private key to public key."
          fail1
        fi

        # encrypt main key with given user key
        if ! log_and_run openssl pkeyutl -encrypt -pubin -inkey $tmp_path/public -in $tmp_path/main -out $key_path/key.$USER; then
          log_fatal "Failed to encrypt main key."
          fail1
        fi

      fi
    else 
      # extract the main key
      if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in $key_path/key.$USER -out $tmp_path/main; then
        log_fatal "Failed to decrypt main key." 
        fail1
      fi

      defer "rm $tmp_path/main"
    fi
      
    # encrypt the file with main key
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -pass file:$tmp_path/main; then
      log_fatal "Failed to create new secret file."
      fail1
    fi

  end_function

  if [[ -f $tmp_path/main ]]; then
    rm $tmp_path/main
  fi

  handle_return

}

handle_secure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    setup_tmp_path || fail
    local unsafe_file=${file%.safe}
    local new_unsafe_file=$tmp_path/$unsafe_file.new
    local old_unsafe_file=$tmp_path/$unsafe_file.old

    if [[ -f $new_unsafe_file ]]; then
      log_fatal "$new_unsafe_file already exists, delete that first if you want to edit $file"
      fail1
    fi

    defer "rm $new_unsafe_file"
    defer "rm $old_unsafe_file"

    if [[ -f $old_file ]]; then
      from=$old_file to=$old_unsafe_file decrypt_file_with_shared_key || fail
      cp $old_unsafe_file $new_unsafe_file || fail
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" >$new_unsafe_file || fail
    else
      $EDITOR $new_unsafe_file || fail
    fi

    if [[ -f $old_unsafe_file ]]; then
      if files_are_different $old_unsafe_file $new_unsafe_file >/dev/null; then
        changed=t
      else
        log_debug "No change" || fail
        rm $new_unsafe_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      from=$new_unsafe_file to=$new_file encrypt_file_with_shared_key || fail
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

handle_insecure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    if [[ -f $old_file ]]; then
      cp $old_file $new_file || fail 
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" | trim_nl >$new_file || fail
    else
      $EDITOR $new_file || fail
    fi

    if [[ -f $old_file ]]; then
      if files_are_different $old_file $new_file >/dev/null; then
        changed=t
      else
        log_debug "No change" || fail
        rm $new_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

update_modify_times() {
  local file=$1
  if [[ "$status_path" && -f "$status_path/up-to-date" ]]; then
    rm $status_path/up-to-date || return 1
  fi
  return 0
}

setup_context_defaults() {
  return 0
}

update_cell_value_file() {
  begin_function
    if [[ "${cell_values:-}" && ! -f $cell_path/cell_values ]]; then
      local v s='cell_values=( '
      for v in "${cell_values[@]}"; do
        s+="\"$v\" "
      done
      s+=')'
      echo "$s" >$cell_path/cell_values || fail
    fi
  end_function
  handle_return
}

get_cell() {
  cell_path=$1
  [[ ${#cell_path} -lt 3 ]] && return 1
  [[ -d $cell_path/.dna ]] && return 0
  [[ -d $cell_path/.cyto ]] && return 0
  get_cell ${cell_path%/*} || return 1
  return 0
}

setup_tmp_path() {
  if [[ ! "${tmp_path:-}" ]]; then
    if [[ -d ${cell_path:-}/.cyto/tmp ]]; then
      tmp_path=$cell_path/.cyto/tmp
    elif [[ -d ~/tmp ]]; then
      tmp_path=~/tmp
    else
      tmp_path=/tmp
    fi
  fi
  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || return 1
  fi
  return 0
}

# inputs:
#   from    encrypted file to decrypt
#   to      (optional) file to save decrypted form to
#           if 'to' is missing, then it writes the decrypted value to stdout
decrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=${to:-} \
    to_var=${to_var:-} \
    key=${key:-$user_private_key}

  local log_show_vars='^from ^to to_var'
  begin_function_hi

    if [[ ! "$to" && ! "$to_var" ]]; then
      log_fatal "decrypt_file: Must set either 'to' or 'to_var'"
      fail1
    fi

    pause_tee

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    if [[ "$to" ]]; then
      if [[ -e $to ]]; then
        log_fatal "File already exists: $to"
        fail1
      fi
      setup_tmp_path || fail
      if ! openssl pkeyutl -decrypt -inkey $key -in $from -out $to; then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    else
      local -n v=$to_var
      v=$(openssl pkeyutl -decrypt -inkey $key -in $from)
      if (( $? > 0 )); then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    fi
     
    unpause_tee

  end_function
  handle_return
}

# inputs: from to tmp_path current_cell
# will write output to file at $to
decrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from
  local to=$to
  local tmp_path=$tmp_path
  local key_path=$key_path
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Decrypting $from to $to" || return 1

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to decrypt non-existent file: $from"
      fail1
    fi

    if [[ -s "$to" ]]; then
      log_fatal "Decrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then
      log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
      find -L $key_path -name "key.*" >&2
      fail1
    fi

    # extract the main key
    if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in "$key_path/key.$USER" -out $tmp_path/main; then
      log_fatal "Failed to decrypt main key." 
      fail1
    fi
    defer "rm $tmp_path/main"

    # decrypt the secret file
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -d -pass file:$tmp_path/main; then 
      log_fatal "Failed to decrypt secret file." 
      fail1
    fi

  end_function
  handle_return

}

get_sane_value() {
  local -r value=$1
  if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
    sane_value=$value
  else
    hash=$(echo "$value" | sha1sum | awk '{ print $1 }')
    sane_value=${hash:0:8}
  fi
  debug_return_vars=sane_value
  return 0
}

is_cell() {
  [[ -d "$1/.dna" ]]
}

load_parent_context() {
  local cell=$1
  local parent=${cell%/*}
  if [[ ${#parent} -gt 1 ]]; then
    load_parent_context $parent || return 1
  fi
  if [[ -f $cell/.dna/context ]]; then
    source $cell/.dna/context || return 1
  fi
  return 0
}

# Used by the help system to describe a command and it's parameters to the user
new_command() {
  local name=$name description=$description
  command_description=$description
  #parameter_names=( )
  #parameter_descriptions=( )
  #parameter_defaults=( )
  #parameter_choices=( )
}

add_parameter() {

  local type=${type:-command} \
    name=$name \
    description=$description \
    default=${default:-} \
    choices=${choices:-} \
    aliases=${aliases:-} \
    delay_questions=${delay_questions:-f} \

  local -n parameter_names=parameter_names_$type
  local -n parameter_descriptions=parameter_descriptions_$type
  local -n parameter_choices=parameter_choices_$type
  local -n parameter_defaults=parameter_defaults_$type
  local -n parameter_aliases=parameter_aliases_$type
  local -n parameter_delay_questions=parameter_delay_questions_$type

  parameter_names+=( "$name" ) 
  parameter_descriptions+=( "$description" ) 
  parameter_defaults+=( "$default" ) 
  parameter_choices+=( "$choices" )
  parameter_aliases+=( "$aliases" )
  parameter_delay_questions+=( $delay_questions )

  if [[ $delay_questions == t ]]; then
    parameter_delayed_questions+=" $name"
    if [[ "$aliases" ]]; then
      local a
      for a in $aliases; do
        parameter_delayed_questions+=" $a"
      done
    fi
  fi

}

add_command_alias() {
  local name=$name command=$command
  command_aliases+=( "$name" )
  command_alias_command+=( "$command" )
}

tee_output_to_log() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    exec 1> >(tee -a "$logging_to_file") || return 1
    exec 2>&1 || return 1
    eval "exec $fd_trace>&1" || return 1
    BASH_XTRACEFD=$fd_trace
    tee_files+=( $logging_to_file )
  fi
  return 0
}

untee_output() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    if [[ "${tee_files:-}" ]]; then
      BASH_XTRACEFD=
      exec 1>&$fd_original_out || return 1
      exec 2>&$fd_original_err || return 1
      eval "exec $fd_trace>&$fd_original_trace" || return 1
      unset tee_files[-1]
    else
      # log_warn "untee was called when nothing was teed"
      :
    fi
  fi
  return 0
}

pause_tee() {
  if [[ "${tee_files:-}" ]]; then
    paused_tee_file=${tee_files[-1]}
    untee_output || return 1
  fi
  return 0
}

unpause_tee() {
  if [[ "$paused_tee_file" ]]; then
    tee_output_to_log $paused_tee_file || return 1
    paused_tee_file=
  fi
  return 0
}

# locks the given cell, or fails if it can't obtain a lock
# may lock an individual file instead if the path given isn't a cell
cell_lock() {

  local cell_path=$1 \
    write_lock=${write_lock:-t} \
    timeout=$timeout \
    lock_fd \
    lock_type=read \
    lock_path

  local log_show_vars="timeout ^cell_path"
  begin_function_hi

    if [[ -e $cell_path/.cyto/context ]]; then
      lock_path=$cell_path/.cyto/context
    else
      log_fatal "Missing context: $cell_path/.cyto/context"
      fail1
    fi

    if [[ $write_lock == t ]]; then
      lock_type=write
    fi

    if [[ -f $lock_path ]]; then
      if [[ $write_lock == t ]]; then
        fd_write_lock || fail
      else
        fd_read_lock || fail
      fi
      cell_locks+=( $lock_fd )
    fi

  end_function
  handle_return

}

# locks the given cell, or fails if it can't obtain a lock
cell_unlock() {
  local lock_fd
  for lock_fd in ${cell_locks[*]:-}; do
    fd_unlock || return 1
  done
  return 0
}

up_delegate() {
  local cyto_up_path=$1 # .../.cyto/up/{dep_name}
  local cell_path=${cyto_up_path%/.cyto/up/*} \
    up_lock=$cyto_up_path/chosen/.cyto/lock \
    up_name=${cyto_up_path##*/}
  local log_show_vars='^cyto_up_path ^cell_path up_lock'
  begin_function_hi

    if [[ -e $up_lock ]]; then
      local locks_folder=$cell_path/.cyto/up-locks
      if [[ ! -d $locks_folder ]]; then
        mkdir $locks_folder || fail
      fi
      safe_link $up_lock $locks_folder/$up_name || fail
    fi

    local out_item
    out_items=$(find1 $cyto_up_path/chosen -not -name ".*") || fail
    begin_for out_item in $out_items; doo
      safe_link $out_item $cell_path/ || fail
    end_for

  end_function
  handle_return
}

# inputs:
#   table_fields       
#   table_data
#   row          which row to select from the table
#   field_count  
# outputs:
#   row_is_valid 
execute_auto_load_check_row() {
  begin_function    
    local f t
    row_is_valid=t
    begin_for (( f = 0; f < field_count; f++ )); doo

      local field=${table_fields[$f]}
      (( t = row * field_count + f ))
      local expected_value=${table_data[$t]}
      if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
        continue # try next field, since this one matches
      fi

      local -n dim=d_$field
      local -n var=$field
      local actual_value=
      if [[ -v dim && "$dim" ]]; then
        actual_value=$dim
      elif [[ -v var && "$var" ]]; then
        actual_value=$var
      fi

      if [[ "$actual_value" && "$actual_value" != "$expected_value" ]]; then
        row_is_valid=f
        break
      fi

    end_for
  end_function
  handle_return
}

# inputs:
#   table_fields variable name holding array of fields
#   table_data   variable name holding array of cells
#   row          which row to select from the table
#   field_count
#   prefix       prefix of variable name to set
execute_auto_load_add_constraints() {
  begin_function
    local f t
    begin_for (( f = 0; f < field_count; f++ )); doo

      local field=${table_fields[$f]}
      (( t = row * field_count + f ))
      expected_value=${table_data[$t]}
      if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
        continue # try next field, since this one matches
      fi

      keys["$field $expected_value"]=1

    end_for

  end_function
  handle_return
}

execute_auto_load_tab() {
  local table_name=$1 prefix=${prefix:-}
  begin_function
    local -n table_fields=${table_name}_fields table_data=${table_name}_data
    if [[ ! -v table_fields || ! -v table_data ]]; then
      log_fatal "Missing expected vars: ${table_name}_fields or ${table_name}_data"
      fail1
    fi
    local row \
      field_count=${#table_fields[*]} data_count=${#table_data[*]}
    local row_count=$((data_count/field_count))
    local -A keys
    begin_for (( row = 0; row < row_count; row++ )); doo
      execute_auto_load_check_row || fail
      if [[ $row_is_valid == t ]]; then
        execute_auto_load_add_constraints || fail
      fi
    end_for

    local value key key_field field value
    begin_for field in "${table_fields[@]}"; doo
      local -n target_field=$field
      if [[ "${target_field:-}" ]]; then
        continue
      fi
      begin_for key in "${!keys[@]}"; doo
        key_field=${key%% *}
        if [[ "$key_field" != "$field" ]]; then
          continue
        fi
        value=${key#$key_field }
        target_field+=( "$value" )
      end_for
    end_for
  end_function
  handle_return
}

execute_auto_loads() {
  local auto_loads=( "$@" )
  begin_function
    local table_name prefix i
    begin_for item in "${auto_loads[@]}"; doo
      case $item in
        *.tab)
          execute_auto_load_tab ${item%.tab} || fail
        ;;
        *)
          log_fatal "Can't auto load $item"
          fail1
        ;;
      esac
    end_for
  end_function
  handle_return
}

get_trunk_cell() {
  trunk_cell=$1
  while [[ $trunk_cell == */*:* ]]; do
    trunk_cell=${trunk_cell%/*}
  done
  debug_return_vars=trunk_cell
}

