#!/bin/bash
# depends on lib/bash-lib being sourced first to provide needed aliases

[[ -v cell_lib_loaded ]] && return 0
cell_lib_loaded=t

# don't let other users read any files written by these scripts
umask 0077

empty_member=_ 
wild_sub_path=_ 
pretend=${pretend:-f}

parallel_default=t 
[[ ${debug:-} == t ]] && parallel_default=f
parallel_execution=${parallel_execution:-${par:-$parallel_default}}

# Whether we should show logging for each seperate branch or only for leaves
show_branches=${show_branches:-f}

# used to detect upstream circular dependencies
downstream_cell_stack=( ) 

disable_log=${disable_log:-f}
export debug_ignore+=" apad cell_close_log_file cell_open_log_file change_log_file debug_start defer echo_align fd_unlock fd_write_lock find1 fork fork_bg fork_fg fork_inside get_new_fork_id get_new_reply_file load_log_vars load_log_vars_and_write_to_log log_debug log_error log_fatal log_info log_trace log_warn out parallel_loop pause_tee safe_link save_log_vars setup_exit_trap shell_quote_var snapshot_source_location tee_output_to_log unpause_tee unrealpath untee_output write_to_log write_to_log_console_out write_to_log_log_var write_to_log_update_cooked "

setup_cyto_out() {
  local from=$1 to=$2
  begin_function_flat
    local contents=$(find1 $from) || fail
    begin_for item in $contents; doo
      if [[ -d $item ]]; then
        local last_part=${item##*/}
        if [[ ! -d $to/$last_part ]]; then
          mkdir $to/$last_part || fail
        fi
        # recursive
        setup_cyto_out $from/$last_part $to/$last_part || fail
      elif [[ $item == *.safe ]]; then
        local target_file=${item##*/}
        target_file=${target_file%.safe}
        from=$item to=$to/$target_file decrypt_file_with_shared_key || fail
      else
        safe_link $item $to/ || fail
      fi
    end_for
  end_function
  handle_return
}

copy_cyto_template() {
  local from=$1 to=$2
  local parent=${from%/*}
  if [[ ${#parent} -gt 1 && -d "$parent" ]]; then
    copy_cyto_template $parent $to || return 1
  fi
  if [[ -d $from/.dna/cyto-template ]]; then
    rcp $from/.dna/cyto-template/ $to/ >/dev/null || return 1
  fi
  return 0
}

record_context_before() {
  local cell=$1
  local parent=${cell%/*}
  if [[ ${#parent} -gt 1 ]]; then
    record_context_before $parent || return 1
  fi
  local context_before_path=$cell/.dna/context-before
  if [[ -f $context_before_path ]]; then
    echo "# generated from: $context_before_path" >>$new_context || return 1
    echo | cat $context_before_path - >>$new_context || return 1
  fi
  return 0
}

record_context_after() {
  local cell=$1
  local parent=${cell%/*}
  local context_after_path=$cell/.dna/context-after
  if [[ -f $context_after_path ]]; then
    echo "# generated from: $context_after_path" >>$new_context || return 1
    echo | cat $context_after_path - >>$new_context || return 1
  fi
  if [[ ${#parent} -gt 1 ]]; then
    record_context_after $parent || return 1
  fi
  return 0
}

record_context() {
  local cell=$1
  local parent=${cell%/*}
  local new_context=$new_cyto/context

  record_context_before $cell || return 1

  local context_local_path=$cell/.dna/context-local
  local dna_path=$cell/.dna

  if [[ -f $context_local_path ]]; then
    echo "# generated from: $context_local_path" >>$new_context || return 1
    echo | cat $context_local_path - >>$new_context || return 1
  elif [[ -f $dna_path ]]; then
    echo "# generated from: $dna_path" >>$new_context || return 1
    echo | cat $dna_path - >>$new_context || return 1
  fi

  record_context_after $cell || return 1

  return 0
}

# This is run if cell hasn't been initialized = missing .cyto folder
make_cyto() {
  local new_cyto=$cell_path/.cyto.new \
    log_vars=cell_path log_show_vars=short_cell
  begin_function

    if [[ -e $cell_path/.cyto ]]; then
      log_fatal "$cell_path/.cyto already exists. make_cyto should not be called unless it doesn't."
      stack_trace
      fail1
    fi

    timeout=0 \
      folder_to_lock=$new_cyto \
      folder_lock || {
        log_warn "Waiting for new cyto lock"
        local i=0
        begin_while [[ -d $new_cyto ]]; doo
          (( i++ ))
          if (( i > 50 )); then
            log_fatal "Waited too long for new cyto lock, aborting"
            fail1
          fi
          sleep 0.5
        end_while
      }

    copy_cyto_template $cell_path $new_cyto || fail
    record_context $cell_path || fail

    get_top_cell $cell_path || fail
    if [[ -d $top_cell/.dna/command ]]; then
      safe_link $top_cell/.dna/command $new_cyto/command || fail
    else
      log_fatal "Top cell doesn't have a command folder ($top_cell/.dna/command missing)"
      fail1
    fi
    if [[ -d $top_cell/.dna/lib ]]; then
      safe_link $top_cell/.dna/lib $new_cyto/lib || fail
    fi

    #   more powerful, but more fragile way
    # mkdir -p $new_cyto/command || fail
    # mkdir -p $new_cyto/lib || fail
    # inherit_lib $cell_path || fail

    local context_path=$new_cyto/context
    if [[ -f "$context_path" ]]; then
      source $context_path || fail
    fi

    local dna_path=$cell_path/.dna

    if [[ -d $dna_path/out && "$out_path" ]]; then
      local item
      local out_path=$cell_path/$out_path
      if [[ ! -d $out_path  ]]; then
        mkdir $out_path || fail
      fi

      local key_path=$dna_path/key
      setup_cyto_out $dna_path/out $out_path || fail
    fi

    folder_to_unlock=$new_cyto \
      folder_unlock || fail
    mv $new_cyto $cell_path/.cyto || fail

  end_function
  handle_return
}

get_short_cell() {
  local x y top_cell=${top_cell:-} trunk_cell=$1 dim_string=
  if [[ "$trunk_cell" =~ .dim ]]; then
    x=${trunk_cell//\/.dim\// }
    dim_string=" ${x#* }"
    dim_string=${dim_string/ /:}
    dim_string=${dim_string// /\/}
    trunk_cell=${x%% *}
  fi
  if x=${trunk_cell#$PWD/}
     [[ $x != $trunk_cell && ${#x} -gt 0 ]]; then
    trunk_cell=$x
  elif y=${trunk_cell%/*/*/*} 
       x=${trunk_cell#$y/}
       [[ $x != $trunk_cell && ${#x} -gt 0 ]]; then
    trunk_cell=$x
  elif y=${trunk_cell%/*/*} 
       x=${trunk_cell#$y/}
       [[ $x != $trunk_cell && ${#x} -gt 0 ]]; then
    trunk_cell=$x
  elif x=${trunk_cell##*/} 
       [[ $x != $trunk_cell && ${#x} -gt 0 ]]; then
    trunk_cell=$x
  fi
  short_cell="$trunk_cell$dim_string"
}

# input must be a folder
setup_cell_path_vars() {
  cell_path=$1
  begin_function_flat

    if [[ ! "${top_cell:-}" ]]; then
      get_top_cell $cell_path || fail
    fi

    dna_path=$cell_path/.dna \
      cyto_path=$cell_path/.cyto \
      command_path=$cyto_path/command

    if [[ -d $dna_path/dim ]]; then
      cell_is_leaf=f
    else
      cell_is_leaf=t
    fi

    key_path=$cyto_path/key
    if [[ ! -d $key_path ]]; then
      # create this as needed
      key_path=$dna_path/key
    fi

    lock_path=$cyto_path/lock 

    op_path=$dna_path/op

    dna_up_path=$dna_path/up
    if [[ ! -d $dna_up_path ]]; then
      unset dna_up_path
    fi

    # create this folder as needed
    cyto_up_path=$cyto_path/up
    # to make update ops simpler
    up_path=$cyto_up_path

    dna_down_path=$dna_path/down
    if [[ ! -d $dna_down_path ]]; then
      unset dna_down_path
    fi

    # create this folder as needed
    down_path=$cyto_path/down

    sub_path=$dna_path/sub
    if [[ ! -d $sub_path ]]; then
      unset sub_path
    fi

    # context can override these as needed
    # could be a relative path
    in_path=${in_path:-}
    if [[ "$in_path" && "$in_path" != /* ]]; then
      in_path=$cell_path/$in_path
    fi

    out_path=${out_path:-}
    if [[ "$out_path" && "$out_path" != /* ]]; then
      out_path=$cell_path/$out_path
    fi

    status_path=$cyto_path/status
    if [[ ! -d $status_path ]]; then
      mkdir $status_path || fail
    fi

    debug_path=$cyto_path/debug
    if [[ ! -d $debug_path ]]; then
      unset debug_path
    fi

    req_path=$cyto_path/req
    if [[ ! -d $req_path ]]; then
      unset req_path
    fi

    source_path=$cyto_path/source
    if [[ ! -d $source_path ]]; then
      mkdir $source_path || fail
    fi

    # create this when needed
    tmp_path=$cyto_path/tmp

  end_function
  handle_return
}

# if dims var is localized, last_cell_dims_loaded should also be localized
load_dims() {
  local dims_path=$1 dim_path dim 
  local log_show_vars=^dims_path
  begin_function
    if [[ ${last_cell_dims_loaded:-} != $dims_path ]]; then
      log_debug "Loading dims"
      dim_array=()
      if [[ -d $dims_path ]]; then
        local contents=$(find1 $dims_path -not -name ".*" | sort -g) || return 1
        for dim_path in $contents; do
          source $dim_path || return 1
          dim=${dim_path##*/}
          if [[ $dim =~ [0-9]+-(.*) ]]; then
            dim=${BASH_REMATCH[1]}
          fi
          get_plural $dim
          dims=$plural
          local ddim=d_$dim ddims=d_$dims
          dim_array+=( $dim )
          localize_dim_vars+=" $ddim=\${$ddim:-\${$dim:-}} $ddims=\${$ddims:-\${$dims:-\${$ddim:-\${$dim:-}}}}"
        done
        if [[ "$dim_array" ]]; then
          log_debug "Found dims: ${dim_array[*]}"
        fi
      fi
      dims=( ${dim_array[*]} )
      last_cell_dims_loaded=$dims_path
    else
      log_debug "Already loaded dims: ${dims[*]}"
    fi
  end_function
  handle_return
}

setup_dims() {

  local cell_path=$1

  load_dims $cell_path/.dna/dim || return 1
  leaf_dims=( ${dims[*]:-} )
  if [[ "${leaf_dims:-}" ]]; then
    log_debug "Leaf dims found: ${leaf_dims[*]}"
  fi

  load_dims $cell_path/.dna/sub-dim || return 1
  sub_dims=( ${dims[*]:-} )
  if [[ "${sub_dims:-}" ]]; then
    log_debug "Sub dims found: ${sub_dims[*]}"
  fi

  props=()
  load_props $cell_path/.dna/prop || return 1
  load_props $cell_path/.dna/leaf/prop || return 1
  if [[ "${props:-}" ]]; then
    log_debug "Props found: ${props[*]}"
  fi

}

cell_context_load() {

  get_short_cell $cell_path
  local log_vars=cell_path log_show_vars=short_cell
  begin_function

    if [[ ! -e $cell_path/.dna ]]; then
      log_fatal "$cell_path is not a cell"
      fail1
    fi

    last_context_loaded=${last_context_loaded:-}
    if [[ "$last_context_loaded" != $cell_path ]]; then

      log_debug "Loading context of $short_cell"
      last_context_loaded=$cell_path

      dna_path=$cell_path/.dna
      cyto_path=$cell_path/.cyto
      sub_path=$dna_path/sub

      if [[ -e $cyto_path && $dna_path/context-local -nt $cyto_path/context ]]; then
        rm -rf $cyto_path || fail
      fi

      init_context || fail
      local context_path=$cyto_path/context
      if [[ ! -e $cyto_path ]]; then
        if [[ -d $sub_path ]]; then
          log_debug "Planting seeds"
          plant_seed $sub_path $cell_path || fail
        fi
        make_cyto || fail
      elif [[ -f "$context_path" ]]; then
        source $context_path || fail
      fi

      setup_context_defaults || fail
      setup_dims $cell_path || fail
      setup_cell_path_vars $cell_path || fail
      setup_branch_dims $cell_path || fail

    fi

  end_function
  handle_return
}

plant_seed() {
  local from=$1 to=$2 contents x x_part
  begin_function_flat
    contents=( $(find1 $from -not -name "$wild_sub_path") ) || fail
    begin_for x in ${contents[*]}; doo
      x_part=${x##*/}
      if [[ ! -e $to/$x_part ]]; then
        if [[ -f $x || $x == */.dna ]]; then
          safe_link $(realpath $x) $to/ || fail
        elif [[ -d $x ]]; then
          mkdir $to/$x_part || fail
          plant_seed $x $to/$x_part || fail
        fi
      fi
    end_for
  end_function
  handle_return
}

setup_dep_defaults() {
  required_freshness=${required_freshness:-${fresh:-${default_freshness:-}}} \
  # Make this go back to default for any further contexts loaded
  # fresh passed in by user should only apply to top level cell, not to deps or subs
  fresh=
  return 0
}

cell_open_log_file() {
  if [[ "${omni_log_job_id:-}" && $disable_log == f ]]; then
    local previous_fork_id=$omni_log_fork_id
    get_new_fork_id || return 1
    local new_log_file=$log_path/$omni_log_job_id:$new_fork_id.olog
    local first_log_path=${new_log_file%/*}/first.olog
    if [[ ! -f $first_log_path ]]; then
      from_must_exist=f \
        safe_link $new_log_file $first_log_path || return 1
    fi
    omni_log_fork_id=$new_fork_id
    log_function=${FUNCNAME[1]} \
      change_log_file
  fi
}

cell_close_log_file() {
  if [[ "${cell_log_file_stack:-}" ]]; then
    local previous_log=${cell_log_file_stack[-1]}
    unset cell_log_file_stack[-1]
    log_function=${FUNCNAME[1]} \
      new_log_file=$previous_log \
      resume_existing_log=t \
      logging_to_file= \
      change_log_file
  fi
}

# this should be run in a subshell
fork_inside() {

  begin_function_flat

    local change_log2=$change_log
    # Prevents this variable from bleeding through to lower called functions
    change_log=

    if [[ $change_log2 == t ]]; then
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    cleanup_on_exit=
    setup_exit_trap

    if [[ "$to_var" ]]; then
      eval "$to_var=\$($command)"; return_code=$?
      reply_to_caller "$to_var='${!to_var}'" || fail
    else
      eval "$command"; return_code=$?
    fi

    if [[ $change_log2 == t ]]; then
      cell_close_log_file || fail
    fi

  end_function

  if [[ "${debugging:-}" == t ]]; then
    reply_to_caller "debug_state_file='${debug_state_file:-}'; debugging=t" || fail
  fi

  if (( return_code != 0 )); then
    reply_to_caller "return_code=$return_code" || fail
    return_value=$return_code
  fi

  if [[ $change_log2 == t ]]; then
    reply_to_caller "omni_log_pos=$previous_log_pos" || fail
  fi

  handle_return

}

# run outside of the subshell afterwards
after_fork() {
  if [[ -f "${reply_file:-}" ]]; then

    source $reply_file || return 1
    if [[ ${debugging:-f} == t ]]; then
      local debugging
      debug_load_state || return 1
      debug_immediate=f \
        first_run=f \
        debug_needs_to_load_state=t \
        debug_start || return 1
    fi
    rm $reply_file
    reply_file=
  fi
  return 0
}

# usage: fork {command to execute}
#  background=f (whether to run as a background process)
#  change_log=f (whether to change the log)
#  to_var       (write output to the given var instead of stdout)
fork() {

  local reply_file command=$* return_code=0 \
    background=${background:-f} \
    change_log=${change_log:-f} \
    to_var=${to_var:-}

  if [[ $background == t ]]; then
    change_log=t
  fi

  get_new_reply_file || return 1
  defer "rm $reply_file"

  if [[ $background == t ]]; then
    ( fork_inside ) &
  else
    ( fork_inside )
  fi
  return_code=$?

  after_fork || (( return_code++ ))

  return $return_code
}

fork_fg() {
  background=f fork "$@"
}

fork_bg() {
  background=t fork "$@"
}

# checks one particular folder in .dna/up that is not a cell
# each sub folder needs to be searched for cells. 
# If one cell is found which is fresh, the whole folder is considered fresh.
get_upstream_needs_update2() {

  local up_folder=$1
  begin_function_flat

      log_debug "Checking upstream folder of $short_cell: ${up_folder##*/}"
      local -r upstream_cells=( 
        $(find1 $up_folder -not -name '.*' | sort -g) 
        ) || fail
      begin_for up in ${upstream_cells[*]}; doo

        log_debug "Checking $up"

        if [[ -d $up/.dna ]]; then
          # recursive
          check_upstream_depth=$((check_upstream_depth-1)) get_needs_update $up_cyto || fail
        elif [[ -d $up ]]; then
          get_upstream_needs_update2 $up || fail
        fi

        if [[ $needs_update == f ]]; then
          succeed
        fi

      end_for

  end_function
  handle_return

}

get_upstream_needs_update() {

  local cell_path=$1
  local short_cell \
    cyto_up_path=$cell_path/.cyto/up \
    dna_up_path=$cell_path/.dna/up 
  get_short_cell $cell_path

  local log_show_vars=short_cell log_vars=cell_path
  begin_function
    if [[ "${dna_up_path:-}" && -d "$dna_up_path" ]] \
       && (( check_upstream_depth > 0 )); then
      #log_debug "Checking upstream of $short_cell"
      local -r upstream_cells=( 
        $(find1 $dna_up_path -not -name '.*' | sort -g) 
        ) || fail
      local up up_part
      begin_for up in ${upstream_cells[*]}; doo

        up_part=${up##*/}
        log_debug "Checking $up_part"
        up_cyto=$cyto_up_path/$up_part/chosen
        if [[ ! -e $up_cyto ]]; then
          log_debug "Cyto up is missing, needs update"
          needs_update=t
          break
        fi

        check_upstream_depth=$((check_upstream_depth-1)) get_needs_update $up_cyto || fail

        if [[ $needs_update == t ]]; then
          break
        fi

      end_for
    fi

  end_function
  handle_return

}

# returns needs_update
get_needs_update() {
  if [[ ! -e $1 ]]; then
    log_fatal "Cell doesn't exist: $1"
    stack_trace
    return 1
  fi

  local cell_path=$(realpath $1)
  local status_path=$cell_path/.cyto/status \
    cyto_up_path=$cell_path/.cyto/up \
    log_message="No update needed" \
    check_upstream_depth=${check_upstream_depth:-1}

  local short_cell
  get_short_cell $cell_path

  local log_vars=cell_path log_show_vars=short_cell
  begin_function

    if [[ "$needs_update" ]]; then
      # needs_update is already known, don't need to compute it again
      log_message="needs_update is already set."
      succeed
    fi

    if [[ ! -d $cell_path/.dna ]]; then
      log_fatal "Attempted to run get_needs_update on folder that is not a cell: $cell_path"
      fail1
    fi

    needs_update=

    local dims localize_dim_vars=local leaf_dims \
      last_cell_dims_loaded
    load_dims $cell_path/.dna/dim || fail
    leaf_dims=( ${dims[*]:-} )
    if [[ "$localize_dim_vars" != local ]]; then
      eval "$localize_dim_vars" || fail
    fi

    if [[ "${downstream_ref_path:-}" && ! -e "$downstream_ref_path" ]]; then
      needs_update=t
      log_message="Needs update because downstream_ref_path hasn't been linked yet"
    elif (( refresh_less_than > update_cost ))
    then
      needs_update=t
      log_message="Needs update because update_cost ($update_cost) < refresh_less_than ($refresh_less_than)"
    elif [[ ! -e $status_path/last-good-update-end ]]
    then
      needs_update=t
      log_message="Needs update because cell has never been updated successfully"
    elif [[ ! -e $status_path/up-to-date ]]
    then
      needs_update=t
      log_message="Needs update because something changed"
    elif get_prop_changed $cell_path || fail
         [[ $prop_changed == t ]]
    then
      needs_update=t
      log_message="Needs update because properties have changed"
    elif get_is_stale $status_path || fail
         [[ $is_stale == t ]]
    then
      needs_update=t
      log_message="Needs update because cell is stale"
    elif [[ -v leaf_dims ]] \
         && { 
           function=get_leaf_needs_update \
             for_each_leaf_flat ${leaf_dims[*]} || fail 
         } \
         && [[ $needs_update == t ]]
    then
      log_message="Needs update because at least one leaf cell is out of date"
    elif [[ -v dna_up_path ]] \
         && { get_upstream_needs_update $cell_path || fail; } \
         && [[ $needs_update == t ]]
    then
      log_message="Needs update because at least one upstream cell is out of date"
    fi

    if [[ $needs_update == t && ${pre_validate:-f} == t ]]; then

      local check_successful=f
      log_debug "Pre validating"

      if execute_op check; then
        if [[ $check_successful == t ]]; then
          log_debug "Validation failed"
          needs_update=f
          log_message="No update needed because remote value already matches intended value"
        fi
      else
        log_fatal "Failed to pre-validate. Something is wrong with the check operator."
        fail1
      fi

    fi

  end_function

  if succeeded; then
    local level=log_debug
    if [[ ${cell_is_leaf:-t} == t || $show_branches == t ]]; then
      level=log_info
    fi
    action=update_check $level "$log_message ($short_cell)"
  else
    action=update_check log_fatal "Failed to check update need"
  fi

  if [[ ! "$needs_update" ]]; then
    needs_update=f
  fi

  handle_return
}

get_leaf_needs_update() {
  needs_update=
  if [[ ! "${leaf_path:-}" ]]; then
    log_fatal "leaf_path is missing"
    return 1
  fi
  local leaf_cell_path=$cell_path$leaf_path

  if [[ -d $leaf_cell_path ]]; then
    # recursive
    get_needs_update $leaf_cell_path || return 1
  else
    needs_update=t
  fi

  if [[ $needs_update == t ]]; then
    leave_loop=1
  fi
  return 0
}

get_prop_changed() {
  local cell_path=$1 \
    status_path=$cell_path/.cyto/status \
    prop_hash=0 \
    value
  prop_changed=t
  if [[ ! "${props:-}" ]]; then
    prop_changed=f
  elif [[ -d $status_path ]]; then
    local -r status_file=$status_path/last_run_prop_hash
    get_prop_hash || return 1
    if [[ -f $status_file && "$prop_hash" == $(<$status_file) ]]; then
      prop_changed=f
    fi
  fi
  return 0
}

update_prop_hash() {
  local prop_hash
  get_prop_hash || return 1
  local -r status_file=$status_path/last_run_prop_hash
  echo "$prop_hash" >$status_file || return 1
  return 0
}

get_prop_hash() {
  local prop=
  for prop in ${props[*]:-}; do
    if [[ -v d_$prop ]]; then
      eval "value=\$d_$prop"
      prop_hash=$(echo "$prop=$value" | sha1sum) || return 1
    fi
  done
  return 0
}

get_is_stale() {
  local status_path=$status_path
  begin_function_flat
    is_stale=t
    if [[ ! "$required_freshness" || "$required_freshness" == inf ]]; then
      is_stale=f
    elif [[ $required_freshness != 0 ]]; then
      local fresh_seconds
      convert_to_seconds $required_freshness fresh_seconds || fail
      local fresh_cutoff=$((EPOCHSECONDS-fresh_seconds)) \
        out_timestamp= 
      is_stale=f
      if [[ -f $status_path/last-good-update-end ]]; then
        out_timestamp=$(date -r $status_path/last-good-update-end +%s)
      fi
      if [[ "$out_timestamp" && $out_timestamp -lt $fresh_cutoff ]]; then
        is_stale=t
      fi
    fi
  end_function
  handle_return
}

wait_for_low_load() {
  local cell_max_load=${cell_max_load:-10}
  local cell_load_wait_timeout=${cell_load_wait_timeout:-600}
  local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
  if [[ $current_load -gt $cell_max_load ]]; then
    log_warn "Load average is too high ($current_load > $cell_max_load)," \
      "waiting until things cool down first."
    local time_waited=0
    while [[ $current_load -gt $cell_max_load ]]; do
      current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
      sleep 5; let time_waited+=5
      if [[ "$cell_load_wait_timeout" -gt 0 && $time_waited -ge $cell_load_wait_timeout ]]; then
        log_fatal "Timed out waiting for cpu load to be low enough. Aborting"
        return 1
      fi
    done
  fi
  return 0
}

# run within the subshell at the beginning
begin_fork() {
  return 0
}

reply_to_caller() {
  if [[ "${reply_file:-}" ]]; then
    echo "$*" >>$reply_file || return 1
  fi
  return 0
}

reply_file=

get_new_reply_file() {
  reply_file=$tmp_folder/reply.$BASHPID
  if [[ -f $reply_file ]]; then
    log_fatal "reply_file already exists: $reply_file"
    return 1
  fi
  return 0
}

# input: parallel processes
wait_for_sub_processes() {
if [[ "$processes" ]]; then
  log_debug "Waiting for sub processes to complete"
  local process last_err_code= last_failed_process= rc
  for process in $processes; do
    log_debug "Waiting for process $process"
    wait $process &>/dev/null; rc=$?
    if [[ $rc -gt 0 && $rc -lt 127 ]]; then
      if [[ ! "$last_err_code" ]]; then
        last_err_code=$rc
        last_failed_process=$process
      else
        log_warn "Subprocess $process failed to terminate successfully"
        return 1
      fi
    fi
  done
  after_fork
  if [[ "$last_err_code" ]]; then
    if [[ "$last_err_code" == 1 ]]; then
      log_warn "Subprocess $last_failed_process failed to terminate successfully"
      return 1
    fi
    return $last_err_code
  fi
  processes=
fi
return 0
}

# 'value' is the loop var
parallel_loop() {
  local loop_over_var2=$loop_over_var head2=${head:-} \
    body2=$body tail2=${tail:-} \
    par2=$par fork2=$fork \
    array 

  # Make sure these variables don't get passed into inner loops
  local loop_over_var= head= body= tail= par= fork=

  local log_show_vars='loop_over_var=loop_over_var2 par=par2 fork=fork2'
  begin_function_flat

    if [[ ! -v $loop_over_var2 ]]; then
      log_fatal "Internal error: Variable doesn't exist: $loop_over_var2"
      stack_trace
      fail
    fi

    eval "array=( \"\${$loop_over_var2[@]}\" )"
    local parallel=f
    if [[ ${#array[*]} -gt 1 && $parallel_execution == t && $par2 == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi

    local processes= value
    leave_loop=0

    local extra
    if [[ $parallel == t ]]; then
      extra=" in parallel"
    else
      extra=" sequentially"
    fi

    local size=${#array[*]}
    if (( size > 1 )); then
      log_debug "Looping over $size values$extra. body: $body2"
    fi

    begin_for value in "${array[@]}"; doo

      log_debug "Current iteration value=$value"

      if [[ "$head2" ]]; then
        eval "$head2" || fail
      fi

      if [[ $parallel == t ]]; then
        fork_bg "$body2" 
        processes+=" $!"
      else
        if [[ $fork2 == t ]]; then
          fork_fg "$body2" || fail
        else
          eval "$body2" || fail
        fi
      fi

      if [[ "$tail2" ]]; then
        eval "$tail2" || fail
      fi

    end_for

    wait_for_sub_processes || fail

  end_function
  handle_return
}

propagate_change_to_downstream2() {
  begin_function_flat

    local cell=$(realpath $value)

    local short_cell
    get_short_cell $cell || fail

    local t1 t2 trunk_cell
    get_trunk_cell $cell
    t1=$trunk_cell
    get_trunk_cell $from_cell
    t2=$trunk_cell
    if [[ $t1 == $t2 ]]; then
      log_fatal "Cell is propagating change to itself: $cell" 
      fail1
    fi
    
    local status_self=$cell/.cyto/status
    
    if already_in_dep_stack $cell; then
      succeed
    fi
    dep_stack+=( $cell )

    if [[ -d $cell ]]; then
      if [[ -d $status_self ]]; then
        # can't combine these if statements or it will alter the else condition
        #   and break things
        if [[ -f $status_self/up-to-date ]]; then
          rm $status_self/up-to-date || fail
          from_cell=$cell \
            propagate_change_to_downstream || fail
        fi
      else
        # recursive
        from_cell=$cell \
          propagate_change_to_downstream || fail
      fi
    fi

  end_function
  handle_return
}

propagate_change_to_downstream() {
  begin_function_flat

  local from_cell=$from_cell \
    down_path=$from_cell/.cyto/down down_folder folders

  if [[ -d $down_path ]]; then
    local dep_stack=( ${downstream_cell_stack[*]} )
    folders=( $(find1 $down_path -not -name '.*' -type d) ) || fail
    loop_over_var=folders \
    background=f \
      par=${par:-t} fork=f \
      body=propagate_change_to_downstream2 \
      parallel_loop || fail
  fi

  end_function
  handle_return
}

get_trunk_cell() {
  local cell=$1
  local parent=${cell%/*}
  local parent_part=${parent##*/}
  if [[ $parent_part == .dim ]]; then
    local grandparent=${parent%/*}
    if [[ "$grandparent" != "$parent" ]]; then
      # recursive
      get_trunk_cell $grandparent || return 1
    else
      return 1
    fi
  elif [[ ! -e $cell/.dna ]]; then
    if [[ "$parent" != "$cell" ]]; then
      # recursive
      get_trunk_cell $parent || return 1
    else
      return 1
    fi
  else
    trunk_cell=$cell
  fi
  return 0
}

already_in_dep_stack() {
  local find_dep=$1
  local dep
  for dep in ${dep_stack[*]}; do
    if [[ $dep == $find_dep ]]; then
      return 0
    fi
  done
  return 1
}

inherit_lib() {
  local cell_from=$1
  local parent=${cell_from%/*}
  begin_function_flat
    if [[ "${#parent}" -gt 1 ]]; then
      # recursive
      inherit_lib $parent || fail
    fi
    if [[ -d $cell_from/.dna ]]; then
      local lib
      if [[ -d $cell_from/.dna/lib ]]; then
        inherit_lib_folder $cell_from/.dna/lib $new_cyto/lib || fail
      fi
      if [[ -d $cell_from/.dna/command ]]; then
        inherit_lib_folder $cell_from/.dna/command $new_cyto/command || fail
      fi
    fi
  end_function
  handle_return
}

inherit_lib_folder() {
  local from=$1 to=$2
  begin_function_flat
    local folder_name lib
    mkdir -p $to || fail
    local from_contents=$(find1 $from -not -name '.*') || fail
    begin_for lib in $from_contents; doo
      if [[ -f $lib ]]; then
        local source_path=${lib%/*} target_file=${lib##*/} base prefix
        if [[ ! $target_file =~ ([0-9]+)-(.*) ]]; then
          base=$target_file
          found=( $(find1 $to -regex '[0-9]+-'$base'$' | sort -g) ) || fail
          if [[ "${found:-}" ]]; then
            target_file=$found
            if [[ "${#found[*]}" -gt 1 ]]; then
              log_warn "Found more than one match for $lib in $to. Will use $target_file."
            fi
          fi
        fi
        safe_link $lib $to/$target_file || fail
      elif [[ -d $lib ]]; then
        folder_name=${lib##*/}
        inherit_lib_folder $lib $to/$folder_name || fail
      fi
    end_for
  end_function
  handle_return
}

gather_leaf_cells() {
  leaf_cells+=( $leaf_path )
}

# executes a step of the folder language
# folder language
#   {cell}                update the given cell with the current coordinates
#   choose-{n}-{name}     multi-path, stopping after {n} choices are successful. {name} is optional
#   each-{var}-in-{vars}  loop over {vars} storing current value in {var}
#                         can be file or folder
#                         executes each element in parallel
#   each-{var}            loop over {vars} (adds 's' to index var)
#   loop-{var}-in-{vars}  same as each, except executes sequentially
#   {file}.go             execute go code
#                         should define a single method named after the file which will be executed
#   {file}.py             execute python script
#   {file}.js             execute js code
#   {file}.java           execute java code
#   {file}.bash           execute bash code
#   {folder}              go through each item in folder and execute according to folder language
execute_command_step() {
  local step=$1

  local log_show_vars=^step log_vars=
  begin_function_flat
    local step_name=${step##*/} prefix= base

    if [[ $step_name =~ [0-9]+-([^/]*)$ ]]; then
      base=${BASH_REMATCH[1]}
    else
      base=$step_name
    fi
    
    if [[ -d $step/.dna ]]; then
      # recursive
      downstream_ref_path=$up_cyto \
        execute_command $step update || fail
      safe_link $step $source_path/$base || fail
    elif [[ -d $step ]]; then
      if [[ $base =~ ^choose-.* ]]; then
        # TODO ...
        incomplete
        safe_link $choice $source_path/$last_part || fail
      elif [[ $base =~ ^loop-.* ]]; then
        serial=t execute_command_step_loop || fail
      elif [[ $base =~ ^each-.* ]]; then
        serial=f execute_command_step_loop || fail
      else
        execute_command_step_folder || fail
      fi
    elif [[ -f $step ]]; then
      execute_command_step_file $step || fail
    else 
      log_fatal "I don't know how to process this step: $step"
      fail1
    fi

  end_function
  handle_return
}

trace_step_execution=${trace_step_execution:-f}
trace_op=${trace_op:-}

# Usage: execute_op {op name}
# returns 1 if no op found
execute_op() {
  local op_name=$1 op ignore_missing=${ignore_missing:-f} \
    found_op= found_op_function=

  local log_vars='cell_path op_name'
  begin_function_flat

    find_op_or_function $op_name || fail

    if [[ "$found_op" || "$found_op_function" ]]; then

      if [[ $trace_op == $op_name ]]; then
        trace_step_execution=t
      fi

      if [[ "$found_op_function" ]]; then
        $found_op_function || fail
      else
        execute_command_step $op || fail
      fi

      if [[ $trace_op == $op_name ]]; then
        trace_step_execution=f
      fi

    else

      if [[ $ignore_missing == t ]]; then
        log_debug "No $op_name operation found in $op_path, ignoring"
      else
        log_fatal "No $op_name operation found in $op_path"
        fail1
      fi

    fi

  end_function
  handle_return
}

# returns either found_op_function or found_op
find_op_or_function() {
  local op_name=$1 
  found_op_function= found_op=
  if type -t op_$op_name &>/dev/null; then
    found_op_function=op_$op_name
  else
    for op in $op_path/$op_name $op_path/$op_name.*; do
      if [[ -e $op ]]; then
        found_op=$op
        break
      fi
    done
  fi
}

# inputs: fork_id_log 
# outputs: new_fork_id
get_new_fork_id() {
  if [[ ! "${fork_id_log:-}" ]]; then
    log_fatal "Missing fork_id_log"
    stack_trace
    return 1
  fi
  timeout=5 lock_path=$fork_id_log fd_write_lock || {
    echo "Failed to get lock on $fork_id_log" >&2
    return 1
  }
  local last_id=$(tail -n1 $fork_id_log | awk '{print $1}')
  (( new_fork_id = last_id + 1 ))
  echo $new_fork_id >>$fork_id_log || return 1
  fd_unlock
  return 0
}

get_job_id() {
  begin_function_flat

    if [[ ! -v job_id_log ]]; then
      log_fatal "Internal error: Missing job_id_log"
      fail1
    fi

    timeout=5 lock_path=$job_id_log fd_write_lock || {
      log_fatal "Failed to get lock on $job_id_log" 
      fail1
    }

    if [[ -f "$job_id_log" ]]; then
      local last_id=$(tail -n1 $job_id_log | awk '{print $1}')
      (( omni_log_job_id = last_id + 1 ))
    else
      omni_log_job_id=1
    fi

    if [[ ! "$command_to_log" ]]; then
      log_fatal "Missing command to log."
      fail1
    fi

    echo "$omni_log_job_id $cell_path $command_to_log" >>$job_id_log || fail

    fd_unlock

  end_function
  handle_return
}

# is run in a subshell since it loads the context
execute_command_internal() {

  local log_vars='cell_path' \
    log_show_vars='short_cell current_command' 
  begin_function_flat

    if [[ " ${command_history:-}" == *" $current_command $short_cell "* ]]; then
      log_fatal "Circular dependency found: arrived at $current_command $short_cell a second time."
      fail1
    fi

    command_history="${command_history:- }$current_command $short_cell "

    case $current_command in
      edit)
        if [[ ! "$cell_path" ]]; then
          log_fatal "You must execute this command from within a cell"
          fail1
        fi
        dna_path=$cell_path/.dna
        key_path=$dna_path/key
        status_path=
        if [[ ! -e $key_path ]]; then
          mkdir $key_path || fail
        fi
      ;;
      log)
        job_path=$cell_path/.job
      ;;
      *)
        cell_context_load || {
          log_fatal "Context failed to load for $cell_path"
          fail1
          }

        if [[ "$localize_dim_vars" != local ]]; then
          eval "$localize_dim_vars" || fail
        fi
      ;;
    esac

    local command_path=$cell_path/.cyto/command/$current_command

    if [[ ! -e $command_path && ! -e $cell_path/.cyto ]]; then
      local dna_command=
      command=$current_command get_dna_command || fail
      if [[ "$dna_command" ]]; then
        command_path=$dna_command
      fi
    fi

    if [[ ! -e $command_path ]]; then
      log_fatal "Command $current_command doesn't exist in $command_path or as a function"
      fail1
    fi

    if type -t command_${current_command}_prep &>/dev/null; then
      command_${current_command}_prep || fail
    elif [[ -f $command_path.prep ]]; then
      source $command_path.prep || fail
      if ! type -t ${current_command}_prep &>/dev/null; then
        log_fatal "$command_path.prep must contain a function named ${current_command}_prep"
        fail1
      fi
      ${current_command}_prep || fail
    fi

    if [[ ${skip_dim_validation:-f} == f ]]; then
      validate_dims || fail
    fi

    if [[ ${cell_is_leaf:-t} == t || $show_branches == t ]]; then
      log_info "Executing command: $current_command $short_cell"
    else
      log_debug "Executing command: $current_command $short_cell"
    fi

    if type -t command_$current_command &>/dev/null; then
      command_$current_command || fail
    else
      # recursive
      execute_command_step $command_path || fail
    fi

  end_function
  handle_return
}

execute_command() {

  local starting_point=$(realpath $1) current_command=$2 \
    short_cell disable_log=${disable_log:-f} cell_path

  get_cell_path $starting_point
  get_short_cell $cell_path

  local log_vars='cell_path' \
    log_show_vars='short_cell current_command' 
  begin_function

    if [[ ! -e "$starting_point" ]]; then
      log_fatal "Folder doesn't exist: $starting_point"
      fail1
    fi

    local job_path=$cell_path/.job

    case $current_command in log|edit)
      disable_log=t
    esac

    if [[ $disable_log == t ]]; then
      log_debug "Logging disabled."
      # setup_block_aliases
      # write_to_log() { :; }
    fi

    if [[ $current_command != edit \
       && $cell_path == */.dna/sub/* 
       ]]; then
      local new_cell=${cell_path//\/.dna\/sub\//\/}
      if [[ -d $new_cell ]]; then
        cell=$new_cell
      else
        log_fatal "You can't run this command within a seed."
        fail1
      fi
    fi

    local omni_log_job_id=${omni_log_job_id:-}
    if [[ $disable_log == f ]]; then
      if [[ ! "${omni_log_job_id:-}" ]]; then
        job_start_time=${EPOCHREALTIME//./}
        command_to_log="${original_cmd#* }" \
          get_job_id || fail
      fi

      local current_job_path=$job_path/$omni_log_job_id
      local running_job_path=$job_path/running
      local log_path=$current_job_path/log

      if [[ ! -d $log_path ]]; then
        mkdir -p $log_path || fail
      fi

      force=t safe_link $current_job_path $job_path/last-$current_command-attempt || fail
      force=t safe_link $current_job_path $job_path/last-attempt || fail

      # only set this for the first cell in the job, all other cells should 
      #   use the same fork_id log so that they all have unique ids across the job
      if [[ ! "${fork_id_log:-}" ]]; then
        fork_id_log=$current_job_path/fork-id-log
      fi

    fi

    change_log=t \
      fork_fg execute_command_internal || fail_later

  end_function
  handle_return
}

get_dna_command() {
  local cell_path=$cell_path command=$command
  local parent=${cell_path%/*}
  if [[ -e $cell_path/.dna/command/$command ]]; then
    dna_command=$cell_path/.dna/command/$command
  elif [[ $parent != $cell_path ]]; then
    cell=$parent get_dna_command || return 1
  fi
  return 0
}

execute_command_step_file() {

  local log_vars=step
  begin_function_flat
    case $base in
      *.py)
        log_fatal "Python steps not implemented yet"
        fail1
      ;;
      *.js)
        log_fatal "JavaScript steps not implemented yet"
        fail1
      ;;
      *.go)
        log_fatal "GoLang steps not implemented yet"
        fail1
      ;;
      *.java)
        log_fatal "Java steps not implemented yet"
        fail1
      ;;
      *)
        source $step || fail
        local function_name=${base%.bash}
        function_name=${function_name##*/}
        function_name=${function_name//-/_}
        local function_exists=$(type -t $function_name &>/dev/null && echo true)
        if [[ "$function_exists" ]]; then
          $function_name || fail
        else
          log_fatal "Step $step requires that a function named $function_name be defined in that file."
          fail1
        fi
      ;;
  #    *)
  #      log_fatal "Unknown file format for $step. Can't execute."
  #      fail1
  #    ;;
    esac
  end_function
  handle_return
}

execute_command_step_loop() {
  local serial=$serial
  begin_function_flat

    # leave early if the folder of instructions is empty
    dir_is_empty $step && succeed

    local ref= ref_group=

    setup_default_each_handler || fail
    local before_block_files=( $(find1 $step -regex '.*/block-before.*' | sort -g) ) || fail
    local before_block_file
    begin_for before_block_file in "${before_block_files[@]}"; doo
      # recursive
      execute_command_step "$before_block_file" || fail
    end_for

    if [[ ! "$ref_group" ]]; then

      if [[ $base =~ (each|loop)-([^-]+)-in-([^-]+) ]]; then
        ref=${BASH_REMATCH[2]}
        ref_group=${BASH_REMATCH[3]}
      elif [[ $base =~ (each|loop)-([^-]+) ]]; then
        ref=${BASH_REMATCH[2]}
        ref_group=${ref}s
        if [[ ! "${!ref_group:-}" ]]; then
          ref_group=${ref}es
        fi
        if [[ ! "${!ref_group:-}" ]]; then
          ref_group=${ref%?}ies
        fi
        if [[ ! "${!ref_group:-}" ]]; then
          ref_group=
        fi
      fi

    fi

    # This can be overridden in a block-before file to provide custom looping
    handle_step_loop || fail

    local after_block_files=( $(find1 $step -regex '.*/block-after.*' | sort -g) ) || fail
    local after_block_file
    begin_for after_block_file in "${after_block_files[@]}"; doo
      # recursive
      execute_command_step "$after_block_file" || fail
    end_for

  end_function
  handle_return
}

setup_default_each_handler() {
  handle_step_loop() {

  begin_function_flat

    if [[ ! -v ref_group || ! -v $ref_group ]]; then
      # nothing to do if there are no values
      succeed
    fi

    local a
    eval "a=( \"\${$ref_group[@]:-}\" )"

    if [[ ! "$a" ]]; then
      # nothing to do if there are no values
      succeed
    fi

    local leave_loop p
    if [[ $serial == f ]]; then
      p=t
    else
      p=f
    fi

    loop_over_var=a \
      fork=f \
      par=${par:-$p} \
      head='eval "$ref=\$value" || fail' \
      body=execute_command_step_folder \
      tail='
        if [[ $leave_loop -gt 0 ]]; then
          break
        fi
        ' \
      parallel_loop || fail

  end_function 
  handle_return

  }
}

# may be run in a subshell
execute_command_step_folder() {
  local step=$step

  local log_vars=step
  begin_function_flat

    local contents=( $(find1 $step -not -name ".*" -not -name "*-before*" -not -name "*-after*" | sort -g) ) || fail 
    local files i=0 file_index
    [[ ! "${contents:-}" ]] && succeed

    begin_loop

      files=( ${contents[$i]} )
      if [[ $files =~ ([0-9]+)-[^/]*$ ]]; then
        file_index=${BASH_REMATCH[1]}
      else
        file_index=-1
      fi

      gather_files_with_same_index || fail

      local leave_loop=0
      loop_over_var=files \
        fork=f
        par=${par:-t}
        body='execute_command_step $value' \
        tail='
          if [[ $leave_loop -gt 0 ]]; then
            break
          fi
          ' \
        parallel_loop || fail

      let i++ || true
      [[ $i -ge ${#contents[*]} ]] && break

      if [[ $leave_loop -gt 0 ]]; then
        let leave_loop-- || true
        break
      fi

    end_loop

  end_function
  handle_return
}

gather_files_with_same_index() {
  begin_function_flat
    local next_file_index=$file_index next_file n=$i
    begin_loop
      let n++ || true
      [[ $n -ge ${#contents[*]} ]] && break
      next_file=${contents[$n]}
      if [[ $next_file =~ ([0-9]+)-[^/]*$ ]]; then
        next_file_index=${BASH_REMATCH[1]}
      else
        next_file_index=-1
      fi
      if [[ $next_file_index == $file_index ]]; then
        files+=( $next_file )
        let i++ || true
      else
        break
      fi
    end_loop
  end_function
  handle_return
}

# input: $* = cell values in dim order
# output: cell_id = string cell id
get_cell_id() {
  local v
  cell_id=
  for v in "$@"; do
    get_sane_value "$v"
    v=$sane_value
    cell_id+=_$v
  done
  cell_id=${cell_id#_}
}

get_cell_path() {
  local subject=$1
  cell_path=
  if [[ -d $subject/.cyto || -d $subject/.dna ]]; then
    cell_path=$subject
  else
    subject=${subject%/*}
    if [[ "$subject" =~ / ]]; then
      get_cell_path $subject
    fi
  fi
}

validate_dims() {
  local dim
  for dim in ${leaf_dims[*]} ${sub_dims[*]} ${props[*]}; do
    if dim_is_required $dim; then
      local plural
      get_plural $dim
      local value=
      if [[ -v d_$dim ]]; then
        eval "local d_value=\${d_$dim}"
        if [[ "$d_value" ]]; then
          eval "value=\${d_$plural:-\${$plural:-\${d_$dim:-\${$dim}}}}"
        fi
      fi
      if [[ ! "$value" ]]; then
        log_fatal "Missing require parameter: $dim"
        return 1
      fi
    fi
  done
  return 0
}

log_and_run() {
  local command=$*
  echo "$command" >&2
  eval "$command"
}

encrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=$to \
    key=${key:-$user_private_key}

  begin_function

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ -e $to ]]; then
      log_fatal "File already exists: $to"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    setup_tmp_path || fail
    if ! log_and_run openssl pkeyutl -encrypt -inkey $key -in $from -out $to; then
      log_fatal "Failed to encrypt file: $from"
      fail1
    fi

  end_function
  handle_return
}

encrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from \
    to=$to \
    tmp_path=$tmp_path \
    key_path=$key_path \
    user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Encrypting $from to $to"

  local log_vars='from to'
  begin_function

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to encrypt non-existent file: $from"
      fail1
    fi

    if [[ -f "$to" ]]; then
      log_fatal "Encrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then

      local key_count=$(find -L $key_path -mindepth 1 -maxdepth 1 -name 'key.*' -type f | wc -l)

      if (( key_count > 0 )); then

        log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
        find -L $key_path -name "key.*" >&2
        fail1

      else

        log_debug "There are no keys for this cell yet. Will create a new key."

        # create a new main key
        if ! out_to_file=$tmp_path/main log_and_run openssl rand -base64 40; then
          log_fatal "Failed to generate new main key."
          fail1
        fi
        defer "rm $tmp_path/main"

        # create a compatible public key from the user's private key
        if ! log_and_run openssl pkey -in $user_private_key -out $tmp_path/public -pubout; then 
          log_fatal "Failed to convert private key to public key."
          fail1
        fi

        # encrypt main key with given user key
        if ! log_and_run openssl pkeyutl -encrypt -pubin -inkey $tmp_path/public -in $tmp_path/main -out $key_path/key.$USER; then
          log_fatal "Failed to encrypt main key."
          fail1
        fi

      fi
    else 
      # extract the main key
      if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in $key_path/key.$USER -out $tmp_path/main; then
        log_fatal "Failed to decrypt main key." 
        fail1
      fi

      defer "rm $tmp_path/main"
    fi
      
    # encrypt the file with main key
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -pass file:$tmp_path/main; then
      log_fatal "Failed to create new secret file."
      fail1
    fi

  end_function

  if [[ -f $tmp_path/main ]]; then
    rm $tmp_path/main
  fi

  handle_return

}

handle_secure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function

    setup_tmp_path || fail
    local unsafe_file=${file%.safe}
    local new_unsafe_file=$tmp_path/$unsafe_file.new
    local old_unsafe_file=$tmp_path/$unsafe_file.old

    if [[ -f $new_unsafe_file ]]; then
      log_fatal "$new_unsafe_file already exists, delete that first if you want to edit $file"
      fail1
    fi

    defer "rm $new_unsafe_file"
    defer "rm $old_unsafe_file"

    if [[ -f $old_file ]]; then
      from=$old_file to=$old_unsafe_file decrypt_file_with_shared_key || fail
      cp $old_unsafe_file $new_unsafe_file || fail
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" >$new_unsafe_file || fail
    else
      $EDITOR $new_unsafe_file || fail
    fi

    if [[ -f $old_unsafe_file ]]; then
      if files_are_different $old_unsafe_file $new_unsafe_file >/dev/null; then
        changed=t
      else
        log_trace $log_trace "No change"
        rm $new_unsafe_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      from=$new_unsafe_file to=$new_file encrypt_file_with_shared_key || fail
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

handle_insecure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function

    if [[ -f $old_file ]]; then
      cp $old_file $new_file || fail 
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" | trim_nl >$new_file || fail
    else
      $EDITOR $new_file || fail
    fi

    if [[ -f $old_file ]]; then
      if files_are_different $old_file $new_file >/dev/null; then
        changed=t
      else
        log_debug "No change"
        rm $new_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

update_modify_times() {
  local file=$1
  if [[ "$status_path" && -f "$status_path/up-to-date" ]]; then
    rm $status_path/up-to-date || return 1
  fi
  return 0
}

# will set top_cell, which will be empty if no cell cells are found
get_top_cell() {
  local subject=$1
  top_cell=
  get_top_cell2 $subject || return 1
  return 0
}

get_top_cell2() {
  local subject=$1
  local parent=${subject%/*}
  if [[ -e $subject/.dna ]]; then
    top_cell=$subject
  fi
  if [[ ${#parent} -gt 1 ]]; then
    # recursive
    get_top_cell2 $parent || return 1
  fi
  return 0
}

# will set bottom_cell, which will be empty if no cell cells are found
get_bottom_cell() {
  local subject=$1
  bottom_cell=
  get_bottom_cell2 $subject || return 1
  return 0
}

get_bottom_cell2() {
  local subject=$1
  local parent=${subject%/*}
  if [[ -e $subject/.dna ]]; then
    bottom_cell=$subject
  elif [[ ${#parent} -gt 1 ]]; then
    # recursive
    get_bottom_cell2 $parent || return 1
  fi
  return 0
}

setup_context_defaults() {
  setup_dep_defaults || return 1
  return 0
}

init_context() {
  # required_freshness:
  #   inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
  #   1w means refresh if it's older than a week.
  # shuffle_chance:
  #   chance out of 1000 of not following the computed strategy order
  # min_pause:
  #   number of ms to wait between cycles
  #   this number doubles each time there is nothing to do, until it reaches max_pause
  # reuse_existing_out:
  #   if set to t: 
  #   new output folder won't be created when updating, but the existing one will be used
  #   should set to true when creating a new output folder would be expensive
  #   these cells must detect for themselves whether a change has happened in an
  #     update and set something_changed=t accordingly. 

  localize_dim_vars=local \
  default_freshness= \
  retry_max=1 \
  retry_delay=1 \
  retry_scale=2 \
  cell_expiration= \
  cell_is_persistent=f \
  cell_is_external=f \
  default_strategies=crl \
  shuffle_chance=100 \
  lock_timeout=2 \
  pre_validate=f \
  post_validate=f \
  min_pause=250 \
  current_pause=250 \
  max_pause=60000 \
  reuse_existing_out=f \
  branch_dims= \
  props= \
  leaf_dims= \
  sub_dims= \
  in_path= \
  out_path=out \
  update_cost=1 \
  refresh_less_than=${refresh_less_than:-1} 
  return 0
}

# returns:
#   branch_dims
#   branch_dim_count
#   trunk_dims
#   trunk_dim_count
setup_branch_dims() {
  local cell_path=$1 \
    trunk_cell dims

  get_trunk_cell $cell_path || return 1
  get_dims $trunk_cell || return 1
  trunk_dims=( ${dims[*]} )
  trunk_dim_count=${#trunk_dims[*]}

  branch_dims=() 
  local dim
  for dim in ${dims[*]}; do
    if [[ $cell_path =~ .dim ]]; then
      cell_path=${cell_path%/.dim/*}
      branch_dims+=( $dim )
    else
      break
    fi
  done
  branch_dim_count=${#branch_dims[*]}
  if [[ "${branch_dims:-}" ]]; then
    log_debug "Branch dims found: ${branch_dims[*]}"
  fi

  return 0
}

# returns array of dims, which may be empty if there are no dims
get_dims() {
  local -r cell=$1
  if [[ -d $cell/.dna/dim ]]; then
    dims=( $( \
      find1 $cell/.dna/dim \
      -not -name '.*' \
      -printf '%f\n' \
      | sort -g \
      | sed -E 's/^[0-9]+-(.*)/\1/' \
      ) ) || return 1
  else
    dims=()
  fi
  return 0
}


update_cell_value_file() {
  begin_function_flat
    if [[ "${cell_values:-}" && ! -f $cell_path/cell_values ]]; then
      local v s='cell_values=( '
      for v in "${cell_values[@]}"; do
        s+="\"$v\" "
      done
      s+=')'
      echo "$s" >$cell_path/cell_values || fail
    fi
  end_function
  handle_return
}

get_cell() {
  cell_path=$1
  [[ ${#cell_path} -lt 3 ]] && return 1
  [[ -d $cell_path/.dna ]] && return 0
  [[ -d $cell_path/.cyto ]] && return 0
  get_cell ${cell_path%/*} || return 1
  return 0
}

setup_tmp_path() {
  if [[ ! "${tmp_path:-}" ]]; then
    if [[ -d ${cell_path:-}/.cyto/tmp ]]; then
      tmp_path=$cell_path/.cyto/tmp
    elif [[ -d ~/tmp ]]; then
      tmp_path=~/tmp
    else
      tmp_path=/tmp
    fi
  fi
  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || return 1
  fi
  return 0
}

# params: $1 (subject)
# output: workspace
get_workspace() {
  local subject=$1
  workspace=
  while [[ ${#subject} -gt 1 && $subject =~ / ]]; do
    if [[ "$subject" == "$top_cell"/* ]]; then
      workspace=$subject
      break
    fi
    subject=${subject%/*}
  done
  [[ "$workspace" ]]
}

# inputs:
#   from    encrypted file to decrypt
#   to      (optional) file to save decrypted form to
#           if 'to' is missing, then it writes the decrypted value to stdout
decrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=${to:-} \
    to_var=${to_var:-} \
    key=${key:-$user_private_key}

  local log_show_vars='^from ^to'
  begin_function

    if [[ ! "$to" && ! "$to_var" ]]; then
      log_fatal "decrypt_file: Must set either 'to' or 'to_var'"
      fail1
    fi

    pause_tee

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    if [[ "$to" ]]; then
      if [[ -e $to ]]; then
        log_fatal "File already exists: $to"
        fail1
      fi
      setup_tmp_path || fail
      if ! openssl pkeyutl -decrypt -inkey $key -in $from -out $to; then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    else
      local -n v=$to_var
      v=$(openssl pkeyutl -decrypt -inkey $key -in $from)
      if (( $? > 0 )); then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    fi
     
    unpause_tee

  end_function
  handle_return
}

# inputs: from to tmp_path current_cell
# will write output to file at $to
decrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from
  local to=$to
  local tmp_path=$tmp_path
  local key_path=$key_path
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Decrypting $from to $to"

  local log_vars='from to'
  begin_function

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to decrypt non-existent file: $from"
      fail1
    fi

    if [[ -s "$to" ]]; then
      log_fatal "Decrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then
      log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
      find -L $key_path -name "key.*" >&2
      fail1
    fi

    # extract the main key
    if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in "$key_path/key.$USER" -out $tmp_path/main; then
      log_fatal "Failed to decrypt main key." 
      fail1
    fi
    defer "rm $tmp_path/main"

    # decrypt the secret file
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -d -pass file:$tmp_path/main; then 
      log_fatal "Failed to decrypt secret file." 
      fail1
    fi

  end_function
  handle_return

}

# input: dim
# output: values 
expand_values() {
  begin_function_flat

    local dims=${dim}s 
    local ddims=d_$dims \
          ddim=d_$dim \
          new_value_list= new_values= value \
          has_member_expand_function=f

    values=( ${!ddim:-} )
    type -t ${dim}_member_expand >/dev/null && has_member_expand_function=t

    local problem= failed=f
    if [[ ! "${values:-}" ]]; then
      expand_values_plural || failed=t
    else
      expand_values_single || failed=t
    fi
    if [[ "$problem" ]]; then
      log_fatal "$problem"
      fail1
    elif [[ $failed == t ]]; then
      if [[ ! "$values" ]]; then
        log_fatal "Missing required dimension: $dim"
        fail1
      else
        log_fatal "Error expanding values for dimension: $dim"
        fail1
      fi
    fi

    values=( $new_value_list )

  end_function
  handle_return
}

# input: 
#   $1=dim
#   function=function to execute for each member
#   fork=whether the process should be forked before executing 
#     the function. (optional)
for_each_member() {
  local dim=$1 \
    function=$function leave_loop=${leave_loop:-0} \
    fork=${fork:-t} \
    par=${par:-t}

  member_count=0
  local log_vars='fork par' \
    log_show_vars='dim function'
  begin_function_flat

    expand_values || fail

    member_count=${#values[*]}

    loop_over_var=values \
      head="local member=\$value
        eval \"local d_$dim=\$member\"" \
      body=$function \
      tail='
        if [[ $leave_loop -gt 0 ]]; then
          break
        fi
        ' \
      parallel_loop || fail

  end_function
  handle_return
}

# same as for_each_leaf but faster but can't divide into parallel processes or fork
# use for simple cases
for_each_leaf_flat() {
local dim_array=( $* ) multi_cell \
  leaf_function=$function

begin_function_flat

  log_debug "Checking leaves of $short_cell"
  if [[ "$localize_dim_vars" != local ]]; then
    eval "$localize_dim_vars" || fail
  fi
  local member_index_stack \
    member_index_stack_count \
    member_stack \
    member_stack_count \
    leaf_path_stack \
    branch_values \
    member_index \
    dim dim_index dim_count=${#dim_array[*]} \
    leave_loop=${leave_loop:-0} \
    branch_values \
    leaf_path \
    i value
  local last_row_index=$((dim_count-1))

  begin_loop

    if [[ "${member_index_stack:-}" ]]; then
      member_index_stack_count=${#member_index_stack[*]}
    else
      member_index_stack_count=0
    fi

    local -n member_row
    local member_row_count
    if [[ "${member_stack:-}" ]]; then
      member_row=${member_stack[$last_row_index]}
      member_row_count=${#member_row[*]}
    fi

    if (( member_index_stack_count < dim_count )); then
      for_each_leaf_flat_expand_members || fail
    elif (( member_index == member_row_count - 1 )); then
      begin_while (( member_index == member_row_count - 1 )); doo
        unset member_index_stack[-1] \
          leaf_path_stack[-1] \
          branch_values[-1] \
          member_stack[-1]
        if [[ ${#member_index_stack[*]} == 0 ]]; then
          succeed
        fi
        member_index=${member_index_stack[-1]}
        member_row=${member_stack[-1]}
        member_row_count=${#member_row[*]}
      end_while
      let member_index++ || true
      for_each_leaf_flat_expand_members || fail
    elif [[ ! "${member_index:-}" ]]; then
      member_index=0
    else
      let member_index++ || true
    fi

    member_row=${member_stack[$last_row_index]}
    if [[ "${#member_row[*]}" -gt 1 ]]; then
      multi_cell=t
    else
      multi_cell=f
    fi

    value=${member_row[$member_index]}
    get_sane_value "$value"

    if (( ${#leaf_path_stack[*]} > 1 )); then
      leaf_path=${leaf_path_stack[-2]}/.dim/$sane_value
    else
      leaf_path=/.dim/$sane_value
    fi

    branch_values[-1]=$value
    eval "local d_$dim=\$value"

    $leaf_function || fail

    if [[ $leave_loop -gt 0 ]]; then
      let leave_loop-- || true
      break
    fi
    
  end_loop

end_function
handle_return
}

for_each_leaf_flat_expand_members() {
begin_function_flat
local row 
if [[ "${member_stack:-}" ]]; then
  member_stack_count=${#member_stack[*]}
else
  member_stack_count=0
fi
begin_for ((row=member_stack_count; row < dim_count; row++)); doo

  dim=${dim_array[$row]}
  expand_values || fail
  value=$values
  eval "local d_$dim=\$value"
  branch_values+=( "$value" )

  eval "members$row=( \"\${values[@]}\" )"
  member_stack+=( members$row )

  if [[ "${member_index_stack:-}" ]]; then
    member_index_stack[-1]=$member_index
  fi
  member_index=0
  member_index_stack+=( 0 )

  local previous_leaf_stack
  if (( row > 0 )); then
    previous_leaf_path=${leaf_path_stack[-1]}
  else
    previous_leaf_path=
  fi

  get_sane_value "$value"
  leaf_path_stack+=( $previous_leaf_path/.dim/$sane_value )

end_for

end_function
handle_return
}

# will construct cell_values array with current set of values of the
#   cell dims, which can be used in branch or leaf functions
for_each_leaf() {

local dim_array=( $* ) multi_cell=f \
  leaf_function=$function leave_loop=${leave_loop:-0} \
  fork=${fork:-t} \
  par=${par:-t}

local dim=${dim_array[0]} \
  remaining_dims=( ${dim_array[*]:1} ) \
  function= \
  branch_values=${branch_values[*]:-()} \
  leaf_path=${leaf_path:-}

local log_vars='dim fork par function'
begin_function_flat

  expand_values || fail

  if [[ "${#values[*]}" -gt 1 ]]; then
    multi_cell=t
  fi

  local loop_function=$leaf_function
  if [[ "${remaining_dims:-}" ]]; then
    loop_function="function=\"$leaf_function\" for_each_leaf ${remaining_dims[*]}"
  fi

  branch_values+=()
  local parent_leaf_path=$leaf_path
  loop_over_var=values \
    head="local member=\$value
      branch_values[-1]=\$value
      get_sane_value \"\$value\"
      leaf_path=$parent_leaf_path/.dim/\$sane_value
      eval \"local d_$dim=\$member\"
      par=\$par2 fork=\$fork2
      " \
    body=$loop_function \
    tail='
      if [[ $leave_loop -gt 0 ]]; then
        break
      fi
      ' \
    parallel_loop || fail

end_function
handle_return
}

expand_values_single() {

begin_function_flat

  if [[ "${#values[*]}" -gt 1 ]]; then
    log_fatal "Too many values for a singular dim $dim." \
      "Use plural dim $dims if you intend to have multiple values."
    fail1
  fi

  if [[ $has_member_expand_function == t ]]; then
    if [[ "$values" == $empty_member ]]; then
      values=
    fi
    value=$values ${dim}_member_expand || fail
    if [[ ! "${values:-}" ]]; then
      log_fatal "Dim $dim has invalid value '$value'"
      fail1
    fi
    if [[ "${#values[*]}" -gt 1 ]]; then
      log_fatal "Too many values for a singular dim $dim." \
        "Use plural dim $dims if you intend to have multiple values."
      fail1
    fi
  fi

  new_value_list="$values"

end_function
handle_return

}

expand_values_plural() {

begin_function_flat

  values=( ${!ddims:-} )

  if [[ ! "${values:-}" ]]; then

    if [[ $has_member_expand_function == t ]]; then
      value= ${dim}_member_expand || fail
      new_values=( "${values[@]}" )
    else
      log_fatal "Missing value for dimension: $RESET$dim"
      fail1
    fi

  else

    if [[ $has_member_expand_function == t ]]; then
      begin_for value in "${values[@]}"; doo
        if [[ "$value" == $empty_member ]]; then
          value=
        fi
        value=$value ${dim}_member_expand || fail
        if [[ ! "${values:-}" ]]; then
          log_fatal "Dim $dims has invalid value '$value'"
          fail1
        fi
        new_values+=( "${values[@]}" )
      end_for
    else
      new_values=( "${values[@]}" )
    fi

  fi

  # remove duplicate values
  local new_value
  for new_value in "${new_values[@]}"; do
    if [[ ! $new_value_list =~ \ $new_value\  ]]; then
      new_value_list+=" $new_value "
    fi
  done

end_function
handle_return
}

get_sane_value() {
local -r value=$1
if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
  sane_value=$value
else
  hash=$(echo "$value" | sha1sum | awk '{ print $1 }')
  sane_value=${hash:0:8}
fi
return 0
}

is_cell() {
[[ -d "$1/.dna" ]]
}

is_inside_of_cell() {
local c=$1
if [[ $c == "$top_cell"/* ]]; then
  while [[ $c == "$top_cell"/* ]]; do
    if [[ -d $c/.dna ]]; then
      return 0
    fi
    c=${c%/*}
  done
else
  while [[ $c == /*/* ]]; do
    if [[ -d $c/.dna ]]; then
      return 0
    fi
    c=${c%/*}
  done
fi
return 1
}

load_props() {
local prop_path=$1 dim_path dim
if [[ -d $prop_path ]]; then
  local contents=$(find1 $prop_path -not -name ".*" | sort -g) || return 1
  for dim_path in $contents; do
    source $dim_path || return 1
    dim=${dim_path##*/}
    if [[ $dim =~ [0-9]+-(.*) ]]; then
      dim=${BASH_REMATCH[1]}
    fi
    props+=( $dim )

    local value= values=
    if [[ -v $dim ]]; then
      value=${!dim}
      if [[ $value == $empty_member ]]; then
        value=
      fi
    fi
    local f=${dim}_member_expand 
    if type -t $f &>/dev/null; then
      $f || true
    fi
    if [[ "$values" ]]; then
      value=$values
    fi

    eval "$dim=\$value" || return 1

    get_plural $dim
    local dims=$plural
    local ddim=d_$dim ddims=d_$dims

    localize_dim_vars+=" $ddim=\${$ddim:-\${$dim:-}} $ddims=\${$ddims:-\${$dims:-\${$ddim:-\${$dim:-}}}}"
  done
fi
}

get_plural() {
  local dim=$1
  if [[ ${dim%s} != $dim ]]; then
    plural=${dim}es
  else
    plural=${dim}s
  fi
  return 0
}

dim_is_required() {
  local dim=$1 values= problem=
  value= ${dim}_member_expand || return 0
  return 1
}

load_parent_context() {
  local cell=$1
  local parent=${cell%/*}
  if [[ ${#parent} -gt 1 ]]; then
    load_parent_context $parent || return 1
  fi
  if [[ -f $cell/.dna/context ]]; then
    source $cell/.dna/context || return 1
  fi
  return 0
}

# Used by the help system to describe a command and it's parameters to the user
new_command() {
  local name=$name description=$description
  command_description=$description
  parameter_names=( )
  parameter_descriptions=( )
  parameter_defaults=( )
}

add_parameter() {
  local name=$name description=$description default=${default:-}
  parameter_names+=( "$name" ) 
  parameter_descriptions+=( "$description" ) 
  parameter_defaults+=( "$default" ) 
}

tee_files=( )
paused_tee_file=

tee_output_to_log() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    exec 1> >(tee -a "$logging_to_file") || return 1
    exec 2>&1 || return 1
    eval "exec $fd_trace>&1" || return 1
    BASH_XTRACEFD=$fd_trace
    tee_files+=( $logging_to_file )
    #start_tracing
  fi
  return 0
}

untee_output() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    if [[ "${tee_files:-}" ]]; then
      #stop_tracing
      BASH_XTRACEFD=
      exec 1>&$fd_original_out || return 1
      exec 2>&$fd_original_err || return 1
      eval "exec $fd_trace>&$fd_original_trace" || return 1
      unset tee_files[-1]
    else
      # log_warn "untee was called when nothing was teed"
      :
    fi
  fi
  return 0
}

pause_tee() {
  if [[ "${tee_files:-}" ]]; then
    paused_tee_file=${tee_files[-1]}
    untee_output || return 1
  fi
  return 0
}

unpause_tee() {
  if [[ "$paused_tee_file" ]]; then
    tee_output_to_log $paused_tee_file || return 1
    paused_tee_file=
  fi
  return 0
}

get_cell_name() {
  local cell_path=$1
  local short_cell
  get_short_cell $cell_path || fail
  cell_name=${short_cell//\//_}
  cell_name=${cell_name// /:}
}

cd_to_leaf() {
  while true; do
    local last_part=${PWD##*/}
    if [[ -d .dim ]]; then
      cd .dim || return 1
    elif [[ "$last_part" == .dim ]]; then
      if [[ "${1:-}" && -d "$1" ]]; then
        cd "$1" || return 1
        shift || true
      else
        local files=( $(find -mindepth 1 -maxdepth 1 -type d -not -name ".*") )
        if [[ -d "$files/.dim" ]]; then
          cd $files/.dim || return 1
        elif [[ -d "$files/.dna" ]]; then
          cd $files || return 1
          break
        else
          break
        fi
      fi
    else
      break
    fi
  done
  return 0
}

cd_to_trunk() {
  local trunk_cell
  get_trunk_cell $PWD || return 1
  if [[ "$trunk_cell" ]]; then
    cd "$trunk_cell" 
  else
    echo "No trunk found" >&2
    return 1
  fi
  return 0
}

cd_to_seed() {
  local seed from=$PWD
  find_seed $from || return 1
  if [[ "$seed" ]]; then
    local path=${from#$seed/}
    local to=$seed/.dna/sub/$path 
    while [[ ! -d $to ]]; do
      to=${to%/*}
    done
    cd $to || return 1
  else
    echo "No seed found" >&2
    return 1
  fi
  return 0
}

cd_to_plant() {
  local from=$PWD
  local to=${from//.dna\/sub\//}
  if [[ "$from" != "$to" ]]; then
    while [[ ! -d $to ]]; do
      to=${to%/*}
    done
    cd $to || return 1
  else
    echo "No plant found" >&2
    return 1
  fi
  return 0
}

# locks the given cell, or fails if it can't obtain a lock
# may lock an individual file instead if the path given isn't a cell
cell_lock() {

  local cell_path=$1 \
    write_lock=${write_lock:-t} \
    timeout=$timeout \
    lock_fd \
    lock_type=read
  local lock_path

  if [[ -e $cell_path/.dna ]]; then
    lock_path==$cell_path/.cyto/lock
  elif [[ -f $cell_path ]]; then
    lock_path==$cell_path/.cyto/lock
  else
    log_fatal "Invalid lock path: $cell_path"
    return 1
  fi

  if [[ $write_lock == f && -f $cell_path/.cyto/require-write-lock ]]; then
    write_lock=t
  fi

  if [[ $write_lock == t ]]; then
    lock_type=write
  fi

  local log_show_vars="lock_type timeout ^lock_path"
  begin_function
    if [[ -f $lock_path ]]; then
      if [[ $write_lock == t ]]; then
        fd_write_lock || return 1
      else
        fd_read_lock || return 1
      fi
      cell_locks+=( $lock_fd )
    fi
  end_function
  handle_return

}

# locks the given cell, or fails if it can't obtain a lock
cell_unlock() {
  local lock_fd
  for lock_fd in ${cell_locks[*]:-}; do
    fd_unlock || return 1
  done
  return 0
}

# Used by background functions to save and replay (for testing) background interations
declare -A replay_tracking_to replay_tracking_from

# input:
#   line        command to send to pipe
#   pipe_in
#   pipe_out
#   timeout_to  number of seconds for timeout
# output:
#   
to_background_process_single() {
  local command=$1 timeout=$timeout_to

  begin_function_flat

    replay_tracking_to[$pipe_in]+=$command

    local timeout_ms=$(dc -e "$timeout 1000 * p")
    timeout_ms=${timeout_ms%.*}

    if (( timeout_ms == 0 )); then
      log_debug "Sending output to process without timeout: $command"
      if [[ $pretend == f ]]; then
        echo -n "$command" >$pipe_in || fail
      fi
    else

      # don't know why 'k' command in dc isn't working properly, so working around it
      local pid \
        time_left=$timeout_ms \
        wait_message=f \
        delay_ms=250
      local delay_s=$(dc -e "$delay_ms 1000 / p")

      log_debug "Sending output to process with ${timeout}s timeout: $command"

      timed_out=f wait_time=0
      if [[ $pretend == f ]]; then

        echo -n "$command" >$pipe_in & 
        pid=$!

        begin_while ps $pid &>/dev/null; doo

          log_debug "Sleeping for ${delay_s}s"
          sleep $delay_s || fail

          (( time_left -= delay_ms 
           , wait_time += delay_ms ))

          if (( time_left <= 0 )); then
            log_debug "Timed out trying to execute: $command"
            timed_out=t
            kill $pid || log_warn "Failed to kill $pid"
            break
          fi

          if (( wait_time > 2 )) && [[ $wait_message == f ]]; then
            log_warn "${NL}Waiting for pipe to be open (time_left=$time_left)"
            wait_message=t
          fi

        end_while

      fi

      local wait_time_s=$(dc -e "$wait_time 1000 / p")
      log_debug "Finished waiting. Took ${wait_time_s}s."

    fi

  end_function
  handle_return
}

to_background_process() {
  local pipe_in=${pipe}_in pipe_out=${pipe}_out \
    secret=${secret:-none} \
    pretend=${pretend:-f} \
    sleep_between_lines=${sleep_between_lines:-0} \
    timeout_to=${timeout_to:-0.5} \
    pipe_replay=${pipe_replay:-${replay:-f}}
  local -n from=$from_var
  local masked_from=$from
  if [[ "$secret" != none ]]; then
    masked_from=${from//$secret/****}
  fi

  local log_show_vars='from=masked_from' \
    log_vars=pipe
  begin_function

    if [[ ! -p $pipe_in ]]; then
      log_fatal "Invalid FIFO: $pipe_in"
      fail1
    fi

    from="${from%%*($NL| |$TAB)}$NL"

    if (( sleep_between_lines > 0 )); then
      local line
      while IFS= read -r line || [[ "$line" ]]; do
        to_background_process_single "$line" || fail
        if [[ $timed_out == t ]]; then
          succeed
        fi
        sleep $sleep_between_lines
      done <<<"$from"
      handle_break
    else
      to_background_process_single "$from" || fail
    fi

  end_function
  handle_return
}

from_background_process__record_line() {
  local no_newline=${no_newline:-f}
  local result=$line
  [[ "$no_newline" == f ]] && result=$result$NL
  to+=$result
  replay_tracking_from[$pipe_in]+=$result
  return 0
}

# sets found or failed
from_background_process__check_line() {
  begin_function_flat

    if [[ "$fail_after" ]]; then
      begin_for ((i=0; i < succeed_after_count; i++)); doo
        if [[ "$line" =~ ${fail_after[$i]} ]]; then
          log_debug "Failed after [${fail_after[$i]}]"
          failed=t
          succeed
        fi
      end_for
    fi

    if (( interact_count > 0 )); then
      local pretend=$pretending
      begin_for ((i=0; i < interact_count; i++)); doo
        if [[ "$line" =~ ${interact_in[$i]} ]]; then
          log_debug "Interact matched [${interact_in[$i]}]"
          local output=${interact_out[$i]}
          pretend=$pretend secret="$secret" from_var=output to_background_process || fail
          interacted=t
          break
        fi
      end_for
    fi

    if [[ "$succeed_after" ]]; then
      begin_for ((i=0; i < succeed_after_count; i++)); doo
        if [[ "$line" =~ ${succeed_after[$i]} ]]; then
          log_debug "Stopped after [${succeed_after[$i]}]"
          succeeded=t
          succeed
        fi
      end_for
    fi

    if [[ "$required_output" ]]; then
      if [[ "$line" =~ ${required_output} ]]; then
        log_debug "Found required text: [$required_output]"
        requirement_met=t
      fi
    fi

  end_function
  handle_return
}

from_background_process__prep() {

  if [[ "$interact" ]]; then

    split_to_array interact 
    interact_count=${#interact[*]}
    local c=0
    for ((i=0; i<interact_count; i++)); do
      s=${interact[$i]:-}
      s=${s##*( )}
      if [[ "$s" ]]; then
        if (( i % 2 == 0 )); then
          # escape_regex s
          interact_in+=( "$s" )
        else
          interact_out+=( "$s" )
          let c++
        fi
      fi
    done
    interact_count=$c

  fi

  if [[ "$succeed_after" ]]; then

    split_to_array succeed_after
    succeed_after_count=${#succeed_after[*]}
    local new_succeed_after=()
    for ((i=0; i < succeed_after_count; i++)); do
      s=${succeed_after[$i]##*( )}
      if [[ "$s" ]]; then
        # escape_regex s
        new_succeed_after+=( "$s" )
      fi
    done
    succeed_after=( "${new_succeed_after[@]}" )

  fi

  if [[ "$fail_after" ]]; then

    split_to_array fail_after
    fail_after_count=${#fail_after[*]}
    local new_fail_after=()
    for ((i=0; i < fail_after_count; i++)); do
      s=${fail_after[$i]##*( )}
      if [[ "$s" ]]; then
        # escape_regex s
        new_fail_after+=( "$s" )
      fi
    done
    fail_after=( "${new_fail_after[@]}" )

  fi

  if [[ ! -p $pipe_out ]]; then
    log_fatal "Invalid FIFO: $pipe_out"
    fail1
  fi

}

flush_background_process() {
  local pipe_in=${pipe}_in pipe_out=${pipe}_out \
    buffering=${buffering:-line} \
    timeout=${timeout:-0} \
    line char

  local log_show_vars='pipe timeout buffering'
  begin_function

    local t=${timeout//./}
    if (( t > 0 )); then
      log_debug "Flushing background output with timeout of ${timeout}s"
    else
      log_debug "Flushing background output with no timeout"
    fi

    line=
    case "$buffering" in
      char)
        while IFS= read -n1 -r -t $timeout -r char || [[ "$line" ]]; do
          if [[ "$char" ]]; then
            line+=$char
          else
            log_debug "Flushing: $line"
            line=
          fi
        done <$pipe_out
        ;;
      line)
        while IFS= read -r -t $timeout -r line; do
          log_debug "Flushing: $line"
        done <$pipe_out
        ;;
      *)
        log_fatal "Invalid buffering type: $buffering. Should be char or line"
        fail1
        ;;
    esac

  end_function
  handle_return
}

# input:
#   pipe             path to pipe to receive commands from
#   to_var           var to write result to
#   timeout          0=never timeout, >0=timeout after that many seconds (may be fractional)
#   fail_after       a newline separated list of regex strings. 
#                      If a line matches any of these, failed will be set to 't', 
#                      processing will stop and the remaining pipe output flushed.
#   succeed_after    a newline separated list of regex strings. If a line matches any of
#                      these. If a line matches any of these, processing will stop and
#                      the remaining pipe output flushed.
#   required_output  A regex string which must be found in the output or failed will be 
#                      set to 't'
#   pretend_out      fake data that gets fed into the reader for testing purposes
# output:
#   timed_out 
#   failed
from_background_process() {
  local pipe_in=${pipe}_in pipe_out=${pipe}_out \
    buffering=${buffering:-line} \
    succeed_after=${succeed_after:-} \
    fail_after=${fail_after:-} \
    required_output=${required_output:-} \
    interact=${interact:-} \
    secret=${secret:-none} \
    pretend_out=${pretend_out:-} \
    pretending=f \
    timeout=${timeout:-0}

  local -n to=$to_var

  local log_vars='pipe interact' \
    log_show_vars='timeout required_output succeed_after fail_after'
  begin_function

    timed_out=f
    failed=f
    succeeded=f
    interacted=f
    if [[ "$pretend_out" ]]; then
      pretending=t
    fi

    local line= char= i \
      interact_in=() interact_out=() \
      succeed_after_count=0 interact_count=0 s \
      requirement_met=f looking_for_something=f

    if [[ "$fail_after" || "$succeed_after" ]]; then
      # TODO: Is this needed?
      looking_for_something=t
    fi

    from_background_process__prep || fail

    log_vars=pipe_out \
      log_debug "Waiting for background job output"

    if [[ $buffering == line ]]; then
      begin_loop

        interacted=f
        if [[ $pretending == t ]]; then
          log_debug "Reading a line"
          if [[ "$pretend_out" ]]; then
            if [[ "$pretend_out" =~ "$NL" ]]; then
              line=${pretend_out%%$NL*}
              pretend_out=${pretend_out#*$NL}
            else
              line=$pretend_out
              pretend_out=
            fi
          else
            line=
          fi
        else
          IFS=$NL read -r -t $timeout line <$pipe_out
          if (( $? > 128 )); then 
            timed_out=t
            break
          fi
        fi

        log_debug "Line read: $line"

        if [[ "$line" ]]; then
          from_background_process__record_line || fail
          from_background_process__check_line || fail
          line=
          if [[ $succeeded == t || $failed == t ]]; then
            break
          fi
        else
          break
        fi

      end_loop
    elif [[ $buffering == char ]]; then
      line=
      begin_loop

        interacted=f
        if [[ $pretending == t ]]; then
          if [[ "$pretend_out" ]]; then
            char=${pretend_out:0:1}
            pretend_out=${pretend_out:1}
          else
            char=
          fi
        else
          IFS= read -N1 -r -t $timeout char <$pipe_out
        fi

        if (( $? > 128 )); then 
          timed_out=t
          break
        fi

        if [[ "$char" ]]; then
          line+=$char
          from_background_process__check_line || fail
          if [[ $succeeded == t || $failed == t ]]; then
            from_background_process__record_line || fail
            line=
            break
          elif [[ $interacted == t ]]; then
            from_background_process__record_line || fail
            line=
          fi
        else
          from_background_process__record_line || fail
          line=
        fi

      end_loop
    else
      log_fatal "Invalid buffering type: $buffering. Should be char or line"
      fail1
    fi

    if [[ $timed_out == t ]]; then
      if [[ "$line" ]]; then
        local remaining_hex="$(echo -n "$line" | hexdump -e '60/1 "%_c " "\n"')"
        log_vars=remaining_hex \
          log_debug "Timed out after $timeout seconds with remaining line:$NL$line" 
      else
        log_debug "Timed out after $timeout seconds"
      fi
    fi

    if [[ "$required_output" && $requirement_met == f ]]; then
      failed=t
    fi

    timeout=0.5 flush_background_process

  end_function
  handle_return
}

# This should be different enough from a default shell prompt so that it
#   can't possibly be confused
magic_shell_prompt='>=-=>'$NL

# input:
#   pipe
#   command
#   timeout
# output: 
#   result
#   command_successful
run_pipe_command() {
  local pipe=$pipe command=$command buffering=${buffering:-line} \
    shell_prompt=${shell_prompt:-$magic_shell_prompt}

  local log_show_vars=command log_vars='pipe shell_prompt buffering'
  begin_function

    timed_out=f failed=f command_successful=f
    from_var=command \
      to_background_process || fail

    escape_regex shell_prompt
    shell_prompt=${shell_prompt%%*($NL| |$TAB)}
    shell_prompt=${shell_prompt##*($NL| |$TAB)}
    to_var=result \
      succeed_after="^0\ $shell_prompt" \
      fail_after=$shell_prompt \
      from_background_process || fail

    if [[ "$timed_out" == t ]]; then
      log_vars=result \
        log_error "Timed out waiting for prompt from remote ssh session"
    elif [[ "$failed" == t ]]; then
      log_vars=result \
        log_error "Failed to execute command on remote ssh session"
    else 
      log_debug "Command was successful"
      command_successful=t
    fi

  end_function
  handle_return
}

up_delegate() {
  local cyto_up_path=$1 # .../.cyto/up/{dep_name}
  local cell_path=${cyto_up_path%/.cyto/up/*} \
    up_lock=$cyto_up_path/chosen/.cyto/lock \
    up_name=${cyto_up_path##*/}
  local log_show_vars='^cyto_up_path ^cell_path up_lock'
  begin_function

    debug_start
    if [[ -e $up_lock ]]; then
      safe_link $up_lock $cell_path/.cyto/up-locks/$up_name || fail
    fi

    local out_item
    out_items=$(find1 $cyto_up_path -not -name ".*") || fail
    begin_for out_item in $out_items; doo
      safe_link $out_item $cell_path/ || fail
    end_for

  end_function
  handle_return
}

