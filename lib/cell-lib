#!/bin/bash
# depends on lib/bash-lib being sourced first to provide needed aliases

[[ -v cell_lib_loaded ]] && return 0
cell_lib_loaded=t

cell_lib_init() {
  # don't let other users read any files written by these scripts
  umask 0077

  empty_member=_ 
  execute_inner=${execute_inner:-${dig:-m}}

  handle_special_vars trace_vars
  handle_special_vars pause_at_vars

  : ${risk_tolerance:=${risk:-0}}
  case "$risk_tolerance" in
    l*)
      risk_tolerance=0
      ;;
    m*)
      risk_tolerance=1
      ;;
    h*)
      risk_tolerance=2
      ;;
    v*)
      risk_tolerance=3
      ;;
    [0-9])
      risk_tolerance=${risk_tolerance:-${risk}}
      ;;
    *)
      log_fatal "Unknown risk level: $risk. Should be one of: low medium high very_high (or 0 1 2 3). Defaults to low."
      fail1
      ;;
  esac

  tee_files=( )
  paused_tee_file=

  parallel_default=f 
  [[ ${debug:-f} == t ]] && parallel_default=f
  parallel_execution=${parallel_execution:-${par:-$parallel_default}}

  # used to detect upstream circular dependencies
  downstream_cell_stack=( ) 
  disable_log=${disable_log:-}

  command_aliases=()
  command_alias_command=()

  trace_dims=${trace_dims:-${trace_dim:-}}
}

handle_special_vars() {
  local -n vars=$1
  local t new_vars=
  for t in $vars; do
    if [[ $t == ^* ]]; then
      t=${t#^}
      new_vars+="p_$t p_${t}s d_$t d_${t}s s_$t s_${t}s "
    else
      new_vars+="$t "
    fi
  done
  vars=${new_vars% }
}

# allocates a unique file optionally based on a given name in the cell tmp_path
# returns tmp_file set to the full path of the file
get_tmp_file() {
  local base=${1:-tmp}
  if [[ ! -e $tmp_path ]]; then
    mkdir $tmp_path || return 1
  fi
  tmp_file=$(mktemp $tmp_path/$base.$$.XXXXXX) || return 1
  defer "rm $tmp_file"
  return 0
}

write_to_context() {
  local context_type=$context_type new_type=$1 
  local -n _content=$2
  begin_function_lo
    last_type=${last_type:-var}
    if [[ $last_type == fun || $new_type == fun ]]; then
      echo >>$context_path-$context_type.new || fail
    fi
    trim_ws _content
    echo "${_content}" >>$context_path-$context_type.new || fail
    last_type=$new_type
    eval "$_content" || {
      if [[ "${var_full_path:-}" ]]; then
        log_fatal "Invalid dna file: $var_full_path"
      else
        log_fatal "Invalid dna file. Contents:"
        log_fatal "$_content"
      fi
      fail1
    }
  end_function
  handle_return
}

write_vars_to_context() {
  local context_type=$context_type vars_to_write=$*
  begin_function_lo
    local var val quoted_val
    begin_for var in $vars_to_write; doo
      local -n val=$var
      if is_array val; then
        array_to_string val quoted_val
      else
        local quoted_val=${val:-}
        shell_quote_var quoted_val
      fi
      local content="$var=$quoted_val"
      write_to_context var content || fail
    end_for
  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_fun_to_code() {
  local full_path=$1 content name=$2
  begin_function_lo
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" =~ ^[a-zA-Z_]+\(\) ]]; then
      code="$content"
    else
      #  can't indent the code because it may contain multiline strings, which this would corrupt
      #content=$(echo -n "$content" | sed 's/^/    /')
      level=_lo
      if [[ $name == update_op ]]; then
        level=
      fi
      code="$name() {
begin_function$level
$content
end_function
handle_return
}"
    fi

  end_function
  handle_return
}

# inputs:
#   item_name 
#   prefix
# outputs:
#   code
load_var_to_code() {
  local full_path=$1 name=$2 content append=f
  begin_function_lo

    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    if [[ "$content" != [\"\']* ]]; then
      shell_quote_var content
    fi

    if [[ $append == t ]]; then
      append_vars[$name]=1
      code="$name+=$content"
    else
      code="$name=$content"
    fi

  end_function
  handle_return
}

# will skip empty / whitespace lines
load_arr_to_code() {
  begin_function_lo

    local full_path=$1 content name=$2 append=f
    content=$(<$full_path)
    trim_ws content

    if [[ "$content" == '+='* ]]; then
      content=${content#'+='}
      append=t
    fi

    code="$name"
    if [[ $append == t ]]; then
      append_vars[$name]=1
      code+="+=("
    else
      code+="=("
    fi

    while IFS= read -r line || [[ "$line" ]]; do
      trim_ws line
      if [[ "$line" ]]; then
        if [[ "$line" != [\"\']* ]]; then
          shell_quote_var line
        fi
        code+=" $line" || fail
      fi
    done < <(echo -n "$content")

    code+=" )"

  end_function
  handle_return
}

# inputs:
#   $1   name of derive table variable
add_derive_table() {
  local name=$1
  begin_function_lo
    derive_tables+=( $name )
    local -n fields=${name}_fields
    local field
    for field in ${fields[*]}; do

      local derive_table_var=${field}_derive_tables
      local -n dim_derive_tables=$derive_table_var

      if [[ "${dim_derive_tables:-}" ]]; then
        if [[ " ${dim_derive_tables[*]} " != *" $name "* ]]; then
          dim_derive_tables+=( $name )
        fi
      else
        if [[ " ${derived_dim_vars[*]} " != *" $derive_table_var "* ]]; then
          derived_dim_vars+=( $derive_table_var )
        fi
        dim_derive_tables+=( $name )
      fi

    done
  end_function
  handle_return
}

# not handling failure here for performance reasons
# should be nearly impossible to fail at this point anyway
maybe_write_newline_to_context() {
  local new_type=$1
  last_type=${last_type:-none}
  if [[ $last_type != none ]]; then
    if [[ $last_type == fun || $new_type == fun \
       || $last_type == tab || $new_type == tab \
       ]]; then
      echo >>$context_path-$context_type.new
    fi
  fi
  last_type=$new_type
}

# this duplicates code from write_dna_tab_to_context on purpose for performance reasons
# inputs:
#   $1     full path to tab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
load_dna_tab() {

  begin_function_lo
    local full_path=$1 name=$2

    # must not indent data in case it's a multi-line string
    eval "$(
    awk '
    NR == 1 { print "'$name'_fields=( " $0 " )"; print "'$name'_data=(" }
    NR > 1 { print $0 }
    END { print ")" }
    ' $full_path
    )" || fail

    if [[ $name == *_derive ]]; then
      add_derive_table $name || fail
    fi

  end_function
  handle_return
}

# this duplicates code from write_dna_vtab_to_context on purpose for performance reasons
# inputs:
#   $1     full path to vtab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
load_dna_vtab() {

  begin_function_lo
    local full_path=$1 name=$2

    local -n fields=${name}_fields data=${name}_data

    fields=( $(awk '{ print $1 }' $full_path) ) || fail
    local field_count=${#fields[*]}
    eval "local array=( $(<$full_path) )" || fail

    local row_offset col_offset data_index array_index current_field_index=0 \
      col_count=$(( ${#array[*]} / field_count )) \

    begin_for (( row_offset = 0; row_offset < ${#array[*]}; row_offset += col_count )); doo
      if [[ "${array[$row_offset]}" != ${fields[$current_field_index]} ]]; then
        log_fatal "Bad data in file $full_path around line $current_field_index"
        fail1
      fi

      begin_for (( col_offset = 1; col_offset < col_count; col_offset++ )); doo
        (( array_index = row_offset + col_offset )) || true
        (( data_index = ( col_offset - 1 ) * field_count + current_field_index ))
        data[$data_index]=${array[$array_index]}
      end_for

      (( current_field_index++ )) || true
    end_for

    if [[ $name == *_derive ]]; then
      add_derive_table $name || fail
    fi

  end_function
  handle_return
}

# inputs:
#   $1     full path to vtab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
write_dna_vtab_to_context() {

  begin_function_lo
    local full_path=$1 name=$2

    load_dna_vtab $full_path $name
    local array_assignment

    make_array_assignment ${name}_fields || fail
    write_to_context var array_assignment || fail

    make_array_assignment ${name}_data || fail
    write_to_context var array_assignment || fail

    if [[ $name == *_derive ]]; then
      add_derive_table $name || fail
    fi

  end_function
  handle_return
}

# inputs:
#   $1     full path to tab file. It is assumed existence check has already happened.
#   $2     target var to store data in (includes prefix)
write_dna_tab_to_context() {

  begin_function_lo
    local full_path=$1 name=$2

    maybe_write_newline_to_context tab
    awk '
    NR == 1 { print "'$name'_fields=( " $0 " )"; print "'$name'_data=(" }
    NR > 1 { print "  " $0 }
    END { print ")" }
    ' $full_path >>$context_path-$context_type.new || fail

    if [[ $name == *_derive ]]; then
      add_derive_table $name || fail
    fi

  end_function
  handle_return
}

# usage: split_ordinal {from_var} {ordinal_part_var} {base_part_var}
split_ordinal() {
  local -n _f=$1 _o=$2 _b=$3
  if [[ $_f =~ ^([0-9]+)-([^/]*)$ ]]; then
    _o=${BASH_REMATCH[1]}
    _b=${BASH_REMATCH[2]}
  else
    _o=9999
    _b=$_f
  fi
  debug_return_vars="$2 $3"
}

# usage: get_simple_name {from var} {ordinal var} {to var}
extract_simple_name() {
  local to_var=$3
  local -n _from=$1 _ord=$2 _to=$to_var
  split_ordinal _from _ord _to
  #_to=${_to//-/_}
  debug_return_vars=$to_var
}

# usage: get_simple_name {from array} {to array}
extract_simple_name_across_array() {
  local -n _from=$1 _to=$2
  local o i f t
  for (( i = 0; i < ${#_from[*]}; i++ )); do
    f=${_from[$i]}
    extract_simple_name f o t
    _to[$i]=$t
  done
  return 0
}

# inputs:
#   $1             full path to dna file
#   prefix         optional prefix
#   context_type   if empty, only loads the variable, if set, records to context
load_dna_item() {
  begin_function_grip
    local var_full_path=$1 prefix=${prefix:-} \
      suffix= \
      file_name \

    last_type=${last_type:-var}

    file_name=${var_full_path##*/}
    if [[ $file_name == *.* ]]; then
      suffix=${file_name##*.}
      file_name=${file_name%.*}
    fi

    local var_name o code= load_type=var is_auto=f
    extract_simple_name file_name o var_name

    if [[ $var_name == auto-* ]]; then
      is_auto=t
      var_name=${var_name#auto-}
    fi

    var_name=${var_name//-/_}

    if [[ $is_auto == t ]]; then
      auto_loads+=( $var_name.$suffix )
    fi

    var_name=$prefix$var_name

    case "$suffix" in
      var)
        load_var_to_code $var_full_path $var_name || fail
      ;;
      arr)
        load_arr_to_code $var_full_path $var_name || fail
      ;;
      fun)
        load_fun_to_code $var_full_path $var_name || fail
        load_type=fun
      ;;
      tab)
        if [[ "${context_type:-}" ]]; then
          write_dna_tab_to_context $var_full_path $var_name || fail
        else
          load_dna_tab $var_full_path $var_name || fail
        fi
      ;;
      vtab)
        if [[ "${context_type:-}" ]]; then
          write_dna_vtab_to_context $var_full_path $var_name || fail
        else
          load_dna_vtab $var_full_path $var_name || fail
        fi
      ;;
      *)
        if [[ $ignore_unknown == f ]]; then
          log_fatal "Unknown dna object: $item."
          fail1
        fi
      ;;
    esac

    if [[ "$code" ]]; then
      if [[ "${context_type:-}" ]]; then
        write_to_context $load_type code || fail
      else
        eval "$code" || fail
      fi
    fi

  end_function
  handle_return
}

make_array_assignment() {
  local arr_name=$1 append=${append:-f}
  local -n arr=${2:-$1}
  begin_function_lo
    if [[ $append == t ]]; then
      array_assignment="$arr_name+=("
    else
      array_assignment="$arr_name=("
    fi
    local v
    for v in "${arr[@]}"; do
      shell_quote_var v
      array_assignment+=" $v"
    done
    array_assignment+=" )"
  end_function
  debug_return_vars=array_assignment
  handle_return
}

# finds the nearest ancestor of the given path which has .dna in it
# will set bottom_cell, which will be empty if no cell cells are found
get_bottom_cell() {
  local subject=$1
  bottom_cell=
  if [[ $subject == /seed/* ]]; then
    log_fatal "Called get_bottom_cell on a seed path"
    return 1
  fi
  while [[ -d "$subject" && "$subject" == /*/* ]]; do
    if [[ -e $subject/.dna ]]; then
      bottom_cell=$subject
      break
    fi
    subject=${subject%/*}
  done
  debug_return_vars=bottom_cell
  return 0
}

build_context_expand_find_members() {
  begin_function

    local branch other_found=f member_paths
    member_paths=$(find1 $seed_path -name "$dim:*" -type d | sort -g) || fail

    begin_for branch in $member_paths; doo
      m=${branch##*/*:}
      if [[ $m == all ]]; then
        log_fatal "Should not have an all as a dim member: $branch"
        fail1
      elif [[ $m == _other ]]; then
        other_found=t
      else
        local member_var_path=$branch/.member
        if [[ -f $member_var_path ]]; then
          m=$(<$member_var_path) || fail
        fi
        members+=( "$m" )
      fi
    end_for

    if [[ "$member_paths" && $other_found == f ]]; then
      has_explicit_member_list=t
    fi

  end_function
  handle_return
}

build_context_expand_handle_default() {
  begin_function_lo
    if [[ -v ${dim_type}_${dim}_default ]]; then

      local -n default=${dim_type}_${dim}_default
      code+="
    '')
      values=( \"$default\" )
    ;;"

    elif [[ -v ${dim_type}_${dim}_default_function ]]; then

      code+="
    '')
    "
      local -n default_fun=${dim_type}_${dim}_default_function
      code+="$(echo "$default_fun" | indent 2)"
      code+="
    ;;"

    else

      code+="
    '')
      problem=\"Missing required parameter: $dim\"
    ;;"

    fi
  end_function
  handle_return
}

build_context_expand_handle_aliases() {
  begin_function_lo
    local a_line first remaining
    for a_line in "${aliases[@]}"; do
      first=${a_line%% *}
      remaining=${a_line#* }
      code+="
    $first)
      values=( $remaining )
    ;;"
    done
  end_function
  handle_return
}

build_context_expand_members_unknown() {
  code+="
    *)
      values=( \"\$value\" )
    ;;
  esac
}"
}

build_context_expand_members_known() {
  begin_function_lo
    local quoted_members= members_with_pipes=${members[*]} need_quotes=f m
    for m in "${members[@]}"; do
      quoted_members+="\"$m\" "
      if [[ $m == *\ * ]]; then
        need_quotes=t
      fi
    done

    if [[ $need_quotes == f ]]; then
      quoted_members="${members[*]}"
    fi

    local members_with_pipes=${members_with_pipes// /\|}

    code+="
    all)
      values=( $quoted_members )
    ;;
    $members_with_pipes)
      values=( \$value )
    ;;
    *)
      problem=\"Invalid $dim: \$value\"
    ;;
  esac
}"
  end_function
  handle_return
}

build_context_expand2() {
  begin_function_lo

    local members=() aliases=() \
      has_explicit_member_list=f fun \

    local member_type_var=${dim_type}_${dim}_member_type
    local -n member_type=$member_type_var

    if [[ -v member_type ]]; then
      case $member_type in
        dynamic|static)
          :
        ;;
        *)
          log_fatal "Invalid member_type variable loaded from dna: $member_type. Must be either dynamic or static."
          fail1
        ;;
      esac
    fi

    if [[ -v ${dim_type}_${dim}_members ]]; then
      eval "members=( \"\${${dim_type}_${dim}_members[@]}\" )" || fail

      if [[ ${#members[*]} -eq 0 ]]; then
        log_fatal "There are no members defined for $dim."
        fail1
      fi

      has_explicit_member_list=t
    #   don't want to pull members from seed, since adding mocks creates an unexpected behavior here
    # else
    #   build_context_expand_find_members
    fi

    if [[ -v ${dim_type}_${dim}_aliases ]]; then
      eval "aliases=( \"\${${dim_type}_${dim}_aliases[@]}\" )" || fail
    fi

    if [[ ! "${member_type:-}" ]]; then
      if [[ $has_explicit_member_list == t ]]; then
        member_type=static
      else
        member_type=dynamic
      fi
    fi

    code="
${dim_type}_${dim}_expand() {
  problem=
  case \"\$value\" in"

    build_context_expand_handle_default || fail

    if (( ${#aliases[*]} > 0 )); then
      build_context_expand_handle_aliases || fail
    fi

    if [[ $has_explicit_member_list == f ]]; then
      build_context_expand_members_unknown || fail
    else
      build_context_expand_members_known || fail
    fi

    write_to_context fun code || fail
    write_vars_to_context $member_type_var || fail

  end_function
  handle_return
}

build_context_expand() {
  begin_function

    if [[ ! -d $seed_path ]]; then
      log_fatal "No configuration in seed at $seed_path"
      fail1
    fi

    local dim dim_type o

    begin_for dim_type in trunk_dims sub_dims control_props data_props; doo
      local -n dims=$dim_type
      begin_for dim in ${dims[*]:-}; doo
        if ! function_exists ${dim_type}_${dim}_expand; then
          build_context_expand2 || fail
        fi
      end_for
    end_for

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more sub coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_tab_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    local line=

    begin_for (( field_index = 0; field_index < c_fields_count; field_index++ )); doo
      field=${c_fields[$field_index]}
      if [[ " $skip_dims " != *" $field "* ]]; then
        line+="$field "
      fi
    end_for
    echo "${line% }" >>$target_file || fail

    for (( row_index = 0; row_index < c_rows; row_index++ )); do
      line=
      for (( field_index = 0; field_index < c_fields_count; field_index++ )); do
        (( data_offset = row_index * c_fields_count + field_index ))
        field=${c_fields[$field_index]}
        if [[ " $skip_dims " != *" $field "* ]]; then
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        fi
      done

      echo "${line% }" >>$target_file || fail
    done

  end_function
  handle_return
}

# writes $coord_type coords to a file, skipping dims specified in skip_dims
# also assumes that there is 1 or more sub coord rows
# inputs:
#   $1          full path of file to write to
#   skip_dims   (optional) dims to skip
write_coordinates_to_vtab_file() {
  local coord_type=$coord_type target_file=$1 skip_dims=${skip_dims:-}
  begin_function

    if [[ -f $target_file ]]; then
      log_fatal "Target file $target_file already exists. It must be deleted before calling this function."
      fail1
    fi

    local value field_index data_offset row_index field

    local -n c_data=${coord_type}_coordinate_data \
      c_fields=${coord_type}_coordinate_fields \

    local c_fields_count=${#c_fields[*]} \
      c_count=${#c_data[*]} \

    local c_rows=$(( c_count / c_fields_count ))

    if [[ ! "{c_fields:-}" || c_rows -eq 0 ]]; then
      log_fatal "There must be at least one ${coord_type} coord row to call write_coordinates_to_tab_file"
      fail1
    fi

    local line

    begin_for (( field_index = 0; field_index < c_fields_count; field_index++ )); doo
      field=${c_fields[$field_index]}
      line=
      if [[ " $skip_dims " != *" $field "* ]]; then
        line+="$field "
        for (( row_index = 0; row_index < c_rows; row_index++ )); do
          (( data_offset = row_index * c_fields_count + field_index ))
          value=${c_data[$data_offset]}
          shell_quote_var value
          line+="$value "
        done
      fi
      echo "${line% }" >>$target_file || fail
    end_for

  end_function
  handle_return
}

# Adds the branch coords (from existing dims) to the given table file
append_coords_to_file() {
  local from=$1 to=$2 coord_type=$coord_type fill_in_the_blanks=${fill_in_the_blanks:-f}
  begin_function
    log_verbose "Appending $coord_type coordinates to $to from $from"
    local old_table type=${to##*.}

    case $type in
      tab)
        load_dna_tab $from old_table || fail
      ;;
      vtab)
        load_dna_vtab $from old_table || fail
      ;;
      *)
        log_fatal "Invalid file type for append_coords_to_file: $type"
        fail1
      ;;
    esac

    seed_table=old_table \
    add_implicit_dims=t \
    seed_coordinates || fail

    if [[ -e $to ]]; then
      rm $to || fail
    fi

    case $type in
      tab)
        write_coordinates_to_tab_file $to || fail
      ;;
      vtab)
        write_coordinates_to_vtab_file $to || fail
      ;;
    esac

  end_function
  handle_return
}

get_plural() {
  local dim=$1
  local target_var=${2:-plural}
  local -n target=$target_var
  if [[ $dim == *s ]]; then
    target=${dim}es
  elif [[ $dim == *y ]]; then
    target=${dim%y}ies
  else
    target=${dim}s
  fi
  debug_return_vars=$target_var
  return 0
}

# inputs:
#   table                  variable name containing the table, without _fields or _data
#   row_index              defaults to 0
#   target_dim_var_type    one of: sdims ddims sdim ddim
# will load nothing if the given row_index doesn't exist in the given table
convert_table_to_dims() {
  local table=$table row_index=${row_index:-0} target_dim_var_type=$target_dim_var_type
  begin_function

    local field fields field_index values=() count field_count data_offset

    local -n c_fields=${table}_fields \
             c_data=${table}_data \

    local c_fields_count=${#c_fields[*]} \

    local c_data_count=0
    if [[ -v c_data ]]; then
      c_data_count=${#c_data[*]}
    fi

    if (( c_data_count >= c_fields_count * (row_index + 1) )); then

      begin_for (( field_index = 0; field_index < c_fields_count; field_index++ )); doo
        field=${c_fields[$field_index]}
        get_plural $field fields

        local -n sdim=s_$field sdims=s_$fields ddim=d_$field ddims=d_$fields

        (( data_offset = c_fields_count * row_index + field_index ))
        case $target_dim_var_type in 
          sdims)
            sdims=${c_data[$data_offset]}
            unset sdim ddim ddims
          ;;
          ddims)
            ddims=${c_data[$data_offset]}
            unset sdim sdims ddim
          ;;
          sdim)
            sdim=${c_data[$data_offset]}
            unset sdims ddim ddims
          ;;
          ddim)
            ddim=${c_data[$data_offset]}
            unset sdim sdims ddims
          ;;
          *)
            log_fatal "Invalid target_dim_var_type: $target_dim_var_type"
            fail1
          ;;
        esac

      end_for

    fi

  end_function
  handle_return
}

# input: dim_var value
# output: values 
expand_dim() {
  begin_function_lo

    local -n dim_type=${dim_var}_dim_type
    if [[ ! -v dim_type ]]; then
      log_fatal "Internal error: Missing ${dim_var}_dim_type"
      fail1
    fi

    values=
    if [[ "${value:-}" && "$value" != \? ]]; then

      if ! function_exists ${dim_type}_${dim_var}_expand; then
        log_fatal "Internal error: Missing ${dim_type}_${dim_var}_expand function, which should have been created by make_context method"
        fail1
      fi

      local problem
      ${dim_type}_${dim_var}_expand || fail
      if [[ "${problem:-}" ]]; then
        log_fatal "$problem"
        fail1
      fi

    fi

  end_function
  handle_return
}

# inputs:
#   $1           array var name which contains the members
#   dim_var      dim being expanded
# outputs:
#   new_values   array of expanded members
expand_dim_members() {
  local -n _members=$1
  local members=( "${_members[@]}" )
  local value values
  new_values=()
  for value in "${members[@]}"; do
    expand_dim || return 1
    if [[ "$values" ]]; then
      new_values+=( "${values[@]}" )
    fi
  done
}

# inputs:
#   $*      list of dims to expand
# expands aliases for the known dims array
# collapses singular and plural dims into plural dims
# should only be used after prep_dims, which means 
#   all dims should be stored in sdim/sdims or ddim/ddims
#   plural dims should always be arrays, not space separated
# ddim is expanded form of sdim, and takes priority over sdim
# this function will generate ddim/ddims where they are not already set based on sdim/sdims
# this function guaranteeds ddims will be set for all known dims
# ddims will be an array after this function
expand_dims() {
  local to_expand=$*
  begin_function_lo

    local dim_var plural dim_type
    for dim_var in $to_expand; do

      local dims_var
      get_plural $dim_var dims_var
      local -n \
        sdim=s_$dim_var sdims=s_$dims_var \
        ddim=d_$dim_var ddims=d_$dims_var \

      if [[ ! "${ddim:-}" && ! "${ddims:-}" && \
            ( "${sdim:-}" || "${sdims:-}" ) ]]; then

        #log_debug "Expanding dim $dim_var"

        local members single=t
        if [[ "${sdims:-}" ]]; then
          members=( "${sdims[@]}" )
          single=f
        else
          members=( "$sdim" )
        fi

        local value new_values
        expand_dim_members members || fail

        if [[ $single == t ]]; then
          if (( ${#new_values[*]} > 1 )); then
            log_fatal "Too many values for $dim_var: ${new_values[*]}"
            fail1
          fi
        fi

        if (( ${#new_values[*]} == 1 )); then
          ddim=${new_values}
          unset ddims sdim sdims
        else
          ddims=( "${new_values[@]}" )
          unset ddim sdim sdims
        fi

      elif [[ ! "${ddims:-}" ]]; then
        if [[ "${ddim:-}" ]]; then
          unset ddims sdim sdims
        else
          unset ddims ddim sdim sdims
        fi
      fi

    done

  end_function
  handle_return
}

# inputs:
#   derive_table            name of var of derive table
#   in_set                  optional, contains possible values of the dim to choose from
#   out_field               which field to read from the table
#   out_set                 which var to write set of valid members to (optional)
#   out_arr                 which var to write array of valid members to
#   stop_after_first_match  optional
#   validate_rows           optional
#   ignore_dims             space separated list of dims to not check
# outputs:
#   out_set        the var out_set points to will contain a set of all matches
#   out_arr        the var out_arr points to will contain an array of all matches
execute_derive_table() {
  local stop_after_first_match=${stop_after_first_match:-f} \
    validate_rows=${validate_rows:-t} \
    ignore_dims=${ignore_dims:-} \

  begin_function_grip
      
    local -A internal_set
    local out_var=${out_set:-$out_arr} \
          out_set=${out_set:-internal_set} \
          out_arr=${out_arr:-} \
          in_set=${in_set:-} \

    local -n derive_fields=${derive_table}_fields \
             derive_data=${derive_table}_data \
             dim_set=$out_set \
             choices=$in_set \

    if [[ "$out_arr" ]]; then
      local -n dim_arr=${out_arr}
    fi

    if ! is_set dim_set; then
      log_fatal "Internal error: execute_derive_table was called with dim_set pointing to a variable that isn't an associative array."
      fail1
    fi

    if [[ ! -v derive_fields ]]; then
      log_fatal "Interal error: Missing ${derive_table}_fields"
      fail1
    fi

    local field_count=${#derive_fields[*]} \
      data_count=${#derive_data[*]} \
      strict_matching=${strict_matching:-f} \
      maybe data_index=0 column_index \
      value= row_result field everything_matches \
      out_field=$out_field \
      invalid=f \

    while (( data_index < data_count )); do
      everything_matches=t

      for (( column_index = 0; column_index < field_count; column_index++ )); do
        field=${derive_fields[$column_index]}
        value=${derive_data[$((data_index + column_index))]}

        log_show_vars='field value'
        fence_grip

        if [[ $field == $out_field ]]; then

          if [[ -v choices && ! "${choices[$value]}" ]]; then
            # don't need to check this row if value isn't in the list of choices
            break
          fi

          if [[ "$value" ]]; then
            row_result=$value
          else
            row_result=$empty_member
          fi

          if [[ $validate_rows == f ]]; then
            break
          fi

        elif [[ " $ignore_dims " != *" $field "* ]]; then

          if [[ $validate_rows == t ]]; then

            local -n dim=d_$field

            if [[ "${dim:-}" ]]; then
              if [[ "$dim" != "$value" && "$value" != all && "$dim" != all ]]; then
                #log_debug "Row doesn't match because dim $field = $dim but table shows $value"
                everything_matches=f
              fi
            else # dim not set
              if [[ $strict_matching == t && "$value" && "$value" != all ]]; then
                #log_debug "Row doesn't match because $field is not set"
                everything_matches=f
                break
              fi
            fi

            if [[ $everything_matches == f && " ${all_dims[*]} " == *" $field "* ]]; then
              local values
              dim_var=$field expand_dim || fail
              if array_contains values $dim; then
                everything_matches=t
              fi
            fi

            if [[ $everything_matches == f ]]; then
              break
            fi

          fi

        fi

      done

      if [[ $everything_matches == t ]]; then
        #log_debug "Matching row found"
        if [[ ! -v dim_set["$row_result"] ]]; then
          dim_set["$row_result"]=1
          if [[ "$out_arr" ]]; then
            dim_arr+=( "$row_result" )
          fi
        fi
        if [[ $stop_after_first_match == t ]]; then
          break
        fi
      else
        #log_debug "No matching row found"
        :
      fi

      (( data_index += field_count ))
    done

    debug_return_vars=$out_var
  end_function
  handle_return
}

# inputs:
#   $1          name of dim to fetch
#   coord_type
# outputs:
#   values      array of dim members
fetch_values_from_coordinates() {
  local dim_var=$1 coord_type=$coord_type
  begin_function
    values=() # must not be set to empty string here
    validate_rows=f \
    out_field=$dim_var \
    out_arr=values \
    derive_table=${coord_type}_coordinate \
    execute_derive_table || fail
    if [[ "${values[*]:-}" ]]; then
      log_debug "$dim_var fetched from coordinates: ${values[*]}"
    else
      log_debug "Failed to fetch $dim_var from coordinates"
    fi
  end_function
  handle_return
}

prep_dims() {
  local dim_types=$*
  begin_function

    local dim_var dim_type dims_var
    for dim_type in $dim_types; do
      local -n dim_array=$dim_type
      local index
      for index in ${!dim_array[*]}; do

        dim_var=${dim_array[$index]}
        get_plural $dim_var dims_var

        local -n \
          ddim=d_$dim_var ddims=d_$dims_var \
          sdim=s_$dim_var sdims=s_$dims_var \
          pdim=p_$dim_var pdims=p_$dims_var \

        # We do not support pulling from simple dim here
        # If we want to set an dim in env vars, it must be set with p_dim form
        sdim=${sdim:-${pdim:-}}

        if [[ ! "${sdims:-}" ]]; then
          if [[ "${pdims:-}" ]]; then
            # Multiple members that have spaces inside are not supported
            # Only single member dims can be used if the value requires spaces or special characters
            sdims=( $pdims )
          else
            sdims=()
          fi
        fi

        # from here on out only sdims and ddims should be used
        # sdims may contain shortcuts, ddims are always expanded (never shortcuts)
        unset p_$dim_var p_$dims_var

        [[ "${sdim:-}" == $empty_member ]] && sdim=
        [[ "${sdims:-}" == $empty_member ]] && sdims=()
        [[ "${ddim:-}" == $empty_member ]] && ddim=
        [[ "${ddims:-}" == $empty_member ]] && ddims=()

        #if [[ ! "${ddims:-}" && ! "${ddim:-}" \
        #   && ! "${sdims:-}" && ! "${sdim:-}" \
        #   && " ${all_if_blank:-} " == *" $dim_var "* ]]; then
        #  sdims=all
        #fi

        all_dims+=( $dim_var )

        local -n is_optional=${dim_type}_${dim_var}_is_optional
        if [[ ${is_optional:-} == t && " $optional_dims " != *" $dim_var "* ]]; then
          optional_dims+=" $dim_var"
          optional_dims=${optional_dims# }
        fi

      done
    done

  end_function
  handle_return
}

# child dims are anchor dims which have not yet been converted into branch dims
# they are dims which will form sub cells, and need to be expanded
load_child_dims() {
  begin_function
    local i

    if [[ ! "${child_dims:-}" ]]; then
      child_dims=()
      local trunk_dim_count=${#trunk_dims[*]}
      if [[ ! "${anchor_dims:-}" ]]; then
        for (( i = branch_dim_count; i < trunk_dim_count; i++ )); do
          child_dims+=( ${trunk_dims[$i]} )
        done
      else
        local anchor_dim branch_dim leftovers=" $anchor_dims "
        
        for branch_dim in ${branch_dims[*]}; do
          remove_word_from_string leftovers $branch_dim
        done

        for anchor_dim in $anchor_dims; do
          if [[ " ${trunk_dims[*]} " != *" $anchor_dim "* ]]; then
            log_fatal "Invalid anchor_dim: $anchor_dim. It does not exist in the list of possible leaf nodes: ${trunk_dims[*]}"
            fail1
          fi
        done
        maybe_break
        
        child_dims=( $leftovers )
      fi

      child_dim_count=${#child_dims[*]}

      if (( child_dim_count > 0 )); then
        cell_is_leaf=f
      else
        cell_is_leaf=t
      fi
    fi

    current_branch_dim=
    if [[ "${child_dims[0]:-}" ]]; then
      current_branch_dim=${child_dims[0]}
    fi

  end_function
  handle_return
}

init_dims() {
  local types=${*:-trunk_dims sub_dims} \
    new_value=${new_value:-} vars=${vars:-ddim}
  begin_function
    begin_for dim_type in $types; doo
      log_debug "Setting $dim_type ${vars// / s and }s to '$new_value'"
      local -n dims=$dim_type
      begin_for dim in ${dims[*]:-}; doo
        local plural
        get_plural $dim
        if [[ " $vars " == *" ddim "* ]]; then
          local -n ddims=d_$plural ddim=d_$dim
          ddim= ddims=$new_value
        fi
        if [[ " $vars " == *" sdim "* ]]; then
          local -n sdims=s_$plural sdim=s_$dim
          sdim= sdims=$new_value
        fi
      end_for
    end_for
  end_function
  handle_return
}

cleanup_derived_from() {
  begin_function

    local dim_var
    for dim_var in ${all_dims[*]}; do

      local -n dim_type=${dim_var}_dim_type
      local -n derived_from=${dim_type}_${dim_var}_derived_from

      if [[ "${derived_from:-}" ]]; then
        local row dim new_derived_from=() row_complete
        for row in "${derived_from[@]}"; do
          row_complete=t
          for dim in $row; do
            if [[ " ${all_dims[*]} " != *" $dim "* ]]; then
              row_complete=f
              break
            fi
          done
          if [[ $row_complete == t ]]; then
            new_derived_from+=( "$row" )
          fi
        done
        derived_from=( "${new_derived_from[@]}" )
      fi

    done

  end_function
  handle_return
}

setup_dims() {
  begin_function

    all_dims=()
    prep_dims trunk_dims sub_dims control_props data_props || fail
    cleanup_derived_from || fail
    load_child_dims || fail
    if [[ $cell_is_leaf == t ]]; then
      expand_dims ${sub_dims[*]:-} ${control_props[*]:-} ${data_props[*]:-} || fail
      load_implicit_dims || fail
    else
      expand_dims ${trunk_dims[*]:-} || fail
    fi

  end_function
  handle_return
}

is_derivable_from_valid_anchors() {
  local dim=$1 row derivable=f is_derivable_skip_dims=${is_derivable_skip_dims:-}
  local -n derived_from=trunk_dims_${dim}_derived_from
  if [[ -v derived_from ]]; then

    if [[ "${is_derivable_skip_dims:-}" ]]; then
      is_derivable_skip_dims+=" $dim"
    else
      is_derivable_skip_dims=$dim
    fi

    for row in "${derived_from[@]}"; do

      derived_from_dims=( $row ) 
      derived_from_count=${#derived_from_dims[*]}

      local valid_count=0 derived_from_dim \
        orig_derived_from_count=$derived_from_count

      if (( derived_from_count > 0 )); then

        for derived_from_dim in ${derived_from_dims[*]}; do

          if [[ " $is_derivable_skip_dims " == *" $derived_from_dim "* ]]; then
            break
          fi

          if [[ "${valid_anchors[$derived_from_dim]:-}" ]] \
             || is_derivable_from_valid_anchors $derived_from_dim; then
            (( valid_count++ ))
          fi

        done

        derived_from_count=$orig_derived_from_count
        if (( valid_count == derived_from_count )); then
          derivable=t
          break
        fi

      fi

    done
  fi
  [[ $derivable == t ]]
}

calculate_default_anchors_check_dims() {
  begin_function

    local derived_dim
    begin_for derived_dim in ${trunk_dims[*]}; doo

      if [[ ! -v valid_anchors[$derived_dim] ]]; then
        continue
      fi

      local row derived_from_count derived_from_dims
      local -n derived_from=trunk_dims_${derived_dim}_derived_from

      if is_derivable_from_valid_anchors $derived_dim; then
        if (( derived_from_count > 0 && derived_from_count < min_derived_from_count )); then
          min_derived_from_count=$derived_from_count
          dim_with_least_deps=$derived_dim
          deps_array=( ${derived_from_dims[*]} )
          if (( derived_from_count == 1 )); then
            # we don't need to keep looking since 1 is the lowest possible number here
            break
          fi
        fi
      fi

    end_for

  end_function
  handle_return
}

calculate_default_anchors_recursive_unset() {
  local dim=$1 recursive_unset_skip=${recursive_unset_skip:-}
  begin_function
    if [[ -v valid_anchors[$dim] && " $recursive_unset_skip " != *" $dim "* ]]; then
      log_debug "Unsetting $dim"
      unset valid_anchors[$dim]
      recursive_unset_skip+=" $dim"
      local -n children=children_of_$dim
      local child
      if is_set children; then
        for child in "${!children[@]}"; do
          unset children[$child]
          calculate_default_anchors_recursive_unset $child || fail 
        done
      fi
    fi
  end_function
  handle_return
}

calculate_default_anchors() {
  begin_function
    local dim 
    local -A valid_anchors removed_anchors

    for dim in ${trunk_dims[*]}; do
      valid_anchors[$dim]=1
    done

    begin_loop; doo

      local min_derived_from_count=1000 dim_with_least_deps= \
        deps_array

      calculate_default_anchors_check_dims || fail

      if (( min_derived_from_count < 1000 )); then
        #log_debug "Removing dim with the least deps: $dim_with_least_deps"
        unset valid_anchors[$dim_with_least_deps]
      else
        break
      fi

    end_loop

    default_anchor_dims=
    begin_for dim in ${trunk_dims[*]}; doo
      if [[ -v valid_anchors[$dim] ]]; then
        default_anchor_dims+="$dim "
      fi
    end_for
    default_anchor_dims=${default_anchor_dims% }
    log_debug "Default anchors calculated: $default_anchor_dims"

  end_function
  handle_return
}

# should make sure load_branch_info was run before calling this
# inputs: 
#   $1  work path to target folder, which may be a cell or a folder of a cell
#   $2  target var to save seed path to, defaults to seed_path
# outputs: seed_path work_path
find_seed_path() {
  local d s=$1 i h dim dim_count
  local -n target=${2:-seed_path} 
  begin_function
    target=

    s=/seed${s#/work}

    while [[ ! -d $s && $s == *:* ]]; do
      s=${s%/*}
    done

    if [[ ${ignore_nonexistent:-f} == t ]]; then
      while [[ ! -d $s && $s == */*/*/* ]]; do
        s=${s%/*}
      done
    fi

    if [[ ! -d $s ]]; then
      log_fatal "Couldn't find seed for $s"
      fail1
    fi

    work_path=/work${s#/seed}

    # go through each seed folder and find matching dim
    local found_branch=t dim_folder
    begin_while [[ $found_branch == t ]]; doo
      
      found_branch=f
      dim_folder=$(find1 $s -name "*:*" -type d | head -n1) || fail
      if [[ "$dim_folder" ]]; then

        local seed_dim=${dim_folder##*/}
        seed_dim=${seed_dim%%:*}

        for (( i = 0; i < branch_dim_count; i++ )); do

          dim=${branch_dims[$i]}
          if [[ $dim == $seed_dim ]]; then
            h=${branch_hashes[$i]}
            if [[ -d $s/$dim:$h ]]; then
              s+=/$dim:$h
              found_branch=t
            elif [[ -d $s/$dim:_other ]]; then
              s+=/$dim:_other
              found_branch=t
            fi
            break
          fi

        done

      fi

    end_while

  end_function

  if [[ "$s" && -d $s ]]; then
    target=$s
  fi

  local log_return_vars='target work_path'
  handle_return
}

get_short_cell() {
  short_cell=${cell_path#/work/*/}
  debug_return_vars=short_cell
}

init_command_vars() {
  cell_command_path=$path_to_commands/$cell_command \
    command_allows_logs=f \
    command_requires_cell=f \
    command_requires_resolved_dims=f \
    command_modifies_context=f \
    command_modifies_upstream=f
}

alias localize='[[ "${localize_dims:-}" ]] && eval "local -I $localize_dims"'

init_context() {
  begin_function

    # required_freshness:
    #   inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
    #   1w means refresh if it's older than a week.
    # shuffle_chance:
    #   chance out of 1000 of not following the computed strategy order
    # min_pause:
    #   number of ms to wait between cycles
    #   this number doubles each time there is nothing to do, until it reaches max_pause
    # reuse_existing_out:
    #   if set to t: 
    #   new output folder won't be created when updating, but the existing one will be used
    #   should set to true when creating a new output folder would be expensive
    #   these cells must detect for themselves whether a change has happened in an
    #     update and set something_changed=t accordingly. 

    # need to make sure that expand functions don't bleed into sub command execution
    local dim_type dim
    for dim_type in trunk_dims sub_dims control_props data_props; do
      local -n dims=$dim_type
      for dim in ${dims[*]:-}; do
        unset ${dim_type}_${dim}_expand
      done
    done

    init_coord branch
    init_coord leaf
    init_coord sub
    #init_coord tree

    auto_loads=() \
    cell_expiration= \
    check_op_var=f \
    child_dims=() \
    control_props=() \
    current_pause=250 \
    data_props=() \
    default_anchor_dims= \
    default_freshness= \
    default_strategies=crl \
    dna_up_files=() \
    implicit_dims=() \
    localize_dims= \
    localize_reverse_dims= \
    lock_timeout=2 \
    max_attempts=1 \
    max_pause=60000 \
    min_pause=250 \
    optional_dims= \
    out_file= \
    out_form_choices='raw simple table json kv' \
    out_path= \
    post_validate=f \
    pre_validate=f \
    refresh_less_than=${refresh_less_than:-1} \
    retry_delay=1 \
    retry_delay_max=10 \
    retry_scale=2 \
    reuse_existing_out=t \
    shuffle_chance=100 \
    sub_dims=() \
    trunk_dims=() \
    up=() \
    update_cost=1 \
    update_risk=3 \

    unset \
      check_op \
      update_op \
      get_op \
      aggregate_op \

    context_path=$cyto_path/context \
    dna_key_path=$dna_path/key \
    down_path=$cyto_path/down \
    job_path=$cyto_path/job \
    key_path=$cyto_path/key \
    req_path=$cyto_path/req \
    status_path=$cyto_path/status \
    tmp_path=$cyto_path/tmp \
    up_path=$cyto_path/up \
    up_chosen_path=$cyto_path/up-chosen \
    reactor_path=$cyto_path/reactors \

    lock_path=$context_path \
    replay_path=$job_path/pipe_replay \

  end_function
  handle_return
}

setup_cell_paths() {
  dna_path=$cell_path/.dna
  cyto_path=$cell_path/.cyto
  init_context
}

branch_local_vars='branch_dims branch_members branch_hashes branch_dim_count trunk_cell short_cell prev_branch_info_cell'
load_branch_info() {
  local cell_path=${1:-$cell_path}

  begin_function

    if [[ "${prev_branch_info_cell:-}" == $cell_path ]]; then
      # already loaded
      abort
    fi
    prev_branch_info_cell=$cell_path

    branch_dims=() \
    branch_members=() \
    branch_hashes=() \

    local c=$cell_path p d m
    begin_while [[ $c == *:* ]]; doo
      p=${c##*/}
      if [[ $p == *:* ]]; then

        d=${p%%:*}

        if [[ " ${branch_dims[*]} " == *" $d "* ]]; then
          log_fatal "Duplicate branch dim found: $d in $cell_path"
          fail1
        fi

        branch_dims=( $d ${branch_dims[*]} )

        m=${p#*:}
        branch_hashes=( $m ${branch_hashes[*]} )

        local member_var_path=$c/.member
        if [[ -f $member_var_path ]]; then
          IFS= read -r -d '' m <$member_var_path
        fi
        branch_members=( "$m" "${branch_members[@]}" )

        local -n dim_var=d_$d
        dim_var=$m

      fi
      c=${c%/*}
    end_while

    trunk_cell=$c
    branch_dim_count=${#branch_dims[*]}

    if (( branch_dim_count > 0 )); then
      cell_is_trunk=f
    else
      cell_is_trunk=t
    fi

    if [[ "${branch_dims:-}" ]]; then
      log_debug "Branch dims found: ${branch_dims[*]}" || fail
    fi

    local x y dim_string= 
    if [[ "${branch_hashes:-}" ]]; then
      dim_string="${branch_hashes[*]}"
      dim_string=:${dim_string// /\/}
    fi
    local short_trunk=${trunk_cell#/*/*/}

  end_function
  handle_return
}

execute_command_prep() {
  begin_function

    get_short_cell
    load_branch_info || fail

    trunk_changed=f
    if [[ $trunk_cell != "${previous_trunk:-}" ]]; then
      trunk_changed=t
      previous_trunk=$trunk_cell
    fi

    setup_cell_paths

    unset default_anchor_dims
    if [[ $top_level_command == f ]]; then
      anchor_dims=
    fi

  end_function
  handle_return
}

# Inputs:
#   $1    cell_path   should be real path
#   $2    command
execute_command() {
  local cell_path=$1 cell_command=$2 \
    log_show_vars='short_cell cell_command'
  begin_function_hi

    case $cell_command in
      dim-*|up-*)
        if [[ $cell_path == /seed/* ]]; then
          cell_path=/work${cell_path#/seed}
        fi
      ;;
      *)
        if [[ $cell_path != /work* ]]; then
          log_fatal "You must run this command from within the workspace (any subfolder of /work)"
          fail1
        fi
      ;;
    esac

    strong_log=t log_verbose "Executing cell command: $short_cell $cell_command" || fail

    if [[ $command_requires_cell == t ]]; then
      if [[ ! -e "$cell_path" ]]; then
        plant_seed $cell_path || {
          log_fatal "Not a cell: $cell_path"
          fail1
        }
      fi

      if [[ ! -e $cell_path/.dna ]]; then
        log_fatal "Invalid cell: $cell_path"
        fail1
      fi
    fi

    if [[ $command_allows_logs == t ]]; then
      disable_log=f
    else
      disable_log=t
    fi

    if [[ $disable_log == t ]]; then
      #log_debug "Logging disabled." || fail
      :
    else
      execute_command_log_prep || fail
    fi

    if [[ $disable_log == f ]]; then
      : ${omni_log_fork_child:=0}
      (( omni_log_fork_child++ ))
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    local omni_log_fork_parent=${omni_log_fork_parent:-}-${omni_log_fork_child:-1} \
      omni_log_fork_child=0
    omni_log_fork_parent=${omni_log_fork_parent#-}

    if [[ " ${command_history:-}" == *" $cell_command $short_cell "* ]]; then
      log_fatal "Circular dependency found: arrived at $cell_command $short_cell a second time."
      fail1
    fi

    local command_history=${command_history:-}
    command_history+="$cell_command $short_cell "

    local cell_command_function=${cell_command//-/_}_command
    if function_exists $cell_command_function; then
      $cell_command_function || fail
    else
      log_fatal "Missing command function $cell_command_function which should be in $cell_command_path"
      fail1
    fi

    if [[ $disable_log == f ]]; then
      cell_close_log_file || fail
    fi

  end_function

  if failed; then
    log_fatal "Failed while executing command: $cell_command in folder $cell_path"
  fi
  handle_return
}

substitute_command_alias() {
  begin_function
    local alias_command parameters
    for (( i = 0; i < ${#command_aliases[*]}; i++ )); do
      if [[ "${command_aliases[$i]}" == "$cell_command" ]]; then
        alias_command=${command_alias_command[$i]}
        cell_command=${alias_command%% *}
        parameters=${alias_command#$cell_command }
        update_original_cmd=f parameters_to_env $parameters
        abort
      fi
    done
  end_function
  handle_return
}

# inputs:
#   $1    cell_path   should be real path
#   $2... commands
execute_commands() {
  local cell_path=$1; shift
  local cell_commands=( $* ) cell_command
  local log_show_vars='^cell_path cell_commands'
  begin_function

    if [[ "$pause_at_cells" ]]; then
      local pac
      for pac in $pause_at_cells; do
        if [[ "$cell_path" == *"$pac"* ]]; then
          handle_user_interrupt "Cell reached (execute_command): $pac."
        fi
      done
    fi

    local top_level_command=${top_level_command_next:-t}

    # so top_level_command is set to t throughout this function, yet if it's called again, it will
    #   be set to f
    top_level_command_next=f

    eval "local $branch_local_vars" || fail
    local previous_trunk=${previous_trunk:-}
    execute_command_prep || fail

    begin_for cell_command in ${cell_commands[*]}; doo

      local original_cell_command=$cell_command
      substitute_command_alias || fail
      init_command_vars || fail

      if [[ -e $cell_command_path.info ]]; then
        source $cell_command_path.info || fail
        handle_questions || fail
      else
        log_warn "Missing file $cell_command_path.info" || fail
      fi

      if [[ ! -d $cell_path/.dna && $command_requires_cell == t ]]; then

        if [[ $top_level_command == t ]]; then
          log_warn "Skipping $cell_path because it is not a cell"
        else
          log_verbose "Skipping $cell_path because it is not a cell"
        fi

      else

        if [[ -e $cell_command_path ]]; then
          source $cell_command_path || fail
        else
          log_fatal "Internal error: Missing $cell_command command in $cell_command_path"
          fail1
        fi

        validate_command_parameters || fail
        execute_command $cell_path $cell_command || fail

        if [[ $command_modifies_context == t \
           || $command_modifies_upstream == t ]]; then
          # make sure cell rebuilds context next time it's updated
          if [[ -e $context_path ]]; then
            rm $context_path* || fail
          fi
        fi

        if [[ $command_modifies_upstream == t ]]; then
          if [[ -e $up_path ]]; then
            rm -rf $up_path || fail
          fi
          if [[ -e $up_chosen_path ]]; then
            rm -rf $up_chosen_path || fail
          fi
        fi

      fi

    end_for

  end_function
  handle_return
}

load_dna_contents_update_cell() {
  local file=$1 original_cell_path=$cell_path cell_path work_path
  begin_function

    local bottom_cell cell_path parent=${file%/*}
    if [[ ! -d "$parent" ]]; then
      ignore_nonexistent=t plant_seed $parent || fail
      cell_path=$work_path
    else
      get_bottom_cell $parent
      if [[ ! "$bottom_cell" ]]; then
        log_fatal "Could not find cell for $file"
        fail1
      fi
      cell_path=$bottom_cell
    fi
    local short_cell
    get_short_cell

    needs_update= \
    fork execute_commands "$cell_path" update || fail

    if [[ ! -f "$file" ]]; then
      log_fatal "Cell $short_cell did not produce file at $file as required by dna of $original_cell_path"
      fail1
    fi

  end_function
  handle_return
}

build_dim_info() {
  begin_function

    local dim_var dim_type dims_var
    localize_dims=
    localize_reverse_dims=
    for dim_type in trunk_dims sub_dims control_props data_props; do
      local -n dim_array=$dim_type

      for dim_var in ${dim_array[*]}; do
        get_plural $dim_var dims_var

        localize_dims+=" d_$dim_var d_$dims_var"
        localize_reverse_dims+=" $dim_var=\${d_$dim_var:-} $dims_var=( \"\${d_$dims_var[@]:-}\" )"

        local -n is_secret=${dim_type}_${dim_var}_is_secret
        if [[ -v is_secret && $is_secret == t ]]; then
          add_word_to_string secret_vars "$dim_var $dims_var d_$dim_var d_$dims_var"
        fi

        local -n d_dim_type=${dim_var}_dim_type
        d_dim_type=$dim_type
        write_vars_to_context ${dim_var}_dim_type || fail
      done

    done

    write_vars_to_context \
      localize_dims localize_reverse_dims \
      secret_vars \
      || fail

  end_function
  handle_return
}

load_dna_contents_handle_dir() {
  begin_function_lo
    if [[ "$current_var" && $item_var != _* ]]; then
      array_content+=( "$item_name" )
      if [[ -L $item || -d $item ]]; then
        result="${current_var}_${item_var}_path=$real_path"
        write_to_context var result || fail
      fi
      array_ord+=( $ord )
    fi

    if [[ ! -d $real_path/.dna ]]; then

      local new_pass_thru=f

      if [[ $item_var != _* ]]; then
        new_prefix+=${item_var}_
      else
        new_pass_thru=t
      fi

      # recursive
      prefix=$new_prefix pass_thru=$new_pass_thru load_dna_contents $item || fail

    fi
  end_function
  handle_return
}
 
# if context_type is not set, then no context will be written
load_dna_contents() {
  local folder=$1 prefix=${prefix:-} \
    pass_thru=${pass_thru:-f} recursive=${recursive:-t} \
    ignore_unknown=${ignore_unknown:-f} \
    context_type=${context_type:-} \

  begin_function

    local items new_items
    items=$(find1 $folder -not -name '.*' -not -name root | sort -g) || fail

    local current_var=${prefix%_} ord item_name item_var= result 
    if [[ $pass_thru == f ]]; then
      local array_content=( )
      local -n array_ord=${current_var}_ord
    fi
    current_var=${current_var//-/_}

    begin_for item in $items; doo

      item_name=${item##*/}

      local dna_prefix=f
      if [[ "$item_name" == dna-* ]]; then
        dna_prefix=t
        item_name=${item_name#dna-}
      fi

      if [[ "$item_name" == *:* ]]; then
        local filter filters=${item_name%:*}
        for filter in ${filters//:/ }; do
          if [[ $cell_path != */"$filter"/* && $cell_path != */"$filter" ]]; then
            continue 2
          fi
        done
        item_name=${item_name##*:}
      fi

      extract_simple_name item_name ord item_name
      item_var=${item_name//-/_}

      local new_prefix= 
      if [[ "$current_var" && $dna_prefix == f ]]; then
        new_prefix=${current_var}_
      fi

      local real_path=$(realpath -m $item)
      if [[ -L $item && $item != */up/* && $item != */reactors/* ]]; then

        local real_path_parent=${real_path%/*}

        if [[ -d $real_path_parent/.dna && $real_path == /work/* ]]; then
          # TODO: build freshness mechanism here to auto-refresh stale data
          dna_up_files+=( "$item" )
          if [[ ! -e $real_path ]]; then
            load_dna_contents_update_cell $real_path || fail
          fi
        fi

      fi

      if [[ -d $item ]]; then
        if [[ $recursive == t ]]; then
          load_dna_contents_handle_dir || fail
        fi
      elif [[ -f $item ]]; then
        prefix=$new_prefix load_dna_item $item || fail
      elif [[ -L $item ]]; then
        log_fatal "Broken link in dna: $item"
        fail1
      fi

    end_for

    if [[ "$current_var" && "${array_content:-}" && $pass_thru == f ]]; then
      local append=f
      local -n v=$current_var
      [[ "${v:-}" ]] && append=t
      make_array_assignment $current_var array_content || fail
      write_to_context var array_assignment || fail
    fi

  end_function
  handle_return
}

build_context_reactors() {
  begin_function_lo
    reactor_groups=
    local ord
    for ord in ${reactors_ord[*]:-}; do
      reactor_groups+="$ord "
    done
    reactor_groups=( $(echo "${reactor_groups% }" | sed 's/ /\n/g' | sort -gu) )
    write_vars_to_context reactor_groups || fail
  end_function
  handle_return
}

load_parent_context() {
  local path=$1
  begin_function
    if [[ "$path" == /*/*/* ]]; then
      load_parent_context ${path%/*}
    fi
    local root_path=$path/.root
    if [[ -e $root_path ]]; then
      log_debug "Appending parent trunk context ${path#/*/*/}"
      echo "$NL# FROM $root_path" >>$context_path-$context_type.new || fail
      if [[ -d $root_path ]]; then
        load_dna_contents $root_path || fail
      elif [[ -f $root_path ]]; then
        cat $root_path >>$context_path-$context_type.new || fail
      fi
    fi
  end_function
  handle_return
}

build_context_trunk_dna() {
  local log_vars=cell_path log_show_vars=short_cell
  begin_function

    local item_name last_part dna_full_item suffix context_type=trunk
    local -A append_vars

    if [[ -e $context_path-$context_type ]]; then
      log_fatal "Internal error: $context_type context already exists. Should have been deleted before calling this function."
      fail1
    fi

    if [[ -d $dna_path ]]; then

      auto_loads=()

      if [[ "$cell_path" == */*/* ]]; then
        load_parent_context ${cell_path%/*} || fail
      fi

      echo "$NL# FROM $dna_path" >>$context_path-$context_type.new || fail
      prefix= load_dna_contents $dna_path || fail

      write_vars_to_context auto_loads || fail

      if [[ "${dna_up_files:-}" ]]; then
        write_vars_to_context dna_up_files || fail
      fi

      build_context_expand || fail
      if [[ ! "${default_anchor_dims:-}" ]]; then
        calculate_default_anchors || fail
        write_vars_to_context default_anchor_dims || fail
      fi

      mv $context_path-$context_type.new $context_path-$context_type.new2 || fail
      echo "#!/usr/env bash" >$context_path-$context_type.new || fail
      local v
      for v in ${!append_vars[*]}; do
        echo "$v=" >>$context_path-$context_type.new || fail
      done

      cat $context_path-$context_type.new2 >>$context_path-$context_type.new || fail
      rm $context_path-$context_type.new2 || fail

      build_context_reactors || fail

    elif [[ -f $dna_path ]]; then
      safe_link $dna_path $context_path-$context_type.new || fail
      source $dna_path || fail
    else
      log_vars=dna_path log_fatal "Internal error: dna not found"
      fail1
    fi

    write_vars_to_context derive_tables || fail

    local ddv
    for ddv in ${derived_dim_vars[*]}; do
      write_vars_to_context $ddv || fail
    done

  end_function
  handle_return
}

build_context_trunk() {
  begin_function

    local context_type=trunk last_type=var \

    log_debug "Building trunk context for $short_cell" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    local derive_tables=() derived_dim_vars=()

    build_context_trunk_dna || fail

    if [[ ! -d $status_path ]]; then
      mkdir -p $status_path || fail
    fi

    build_dim_info || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

build_context_branch() {
  begin_function

    local context_type=branch last_type=var
    log_debug "Building branch context for $short_cell" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    local dim assignment member i members_string=
    begin_for ((i = 0; i < branch_dim_count; i++)); doo
      dim=${branch_dims[$i]}
      member=${branch_members[$i]}
      shell_quote_var member
      assignment="d_$dim=$member"
      members_string+="$member "
      write_to_context var assignment || fail
    end_for

    local content="
branch_dims=( ${branch_dims[*]} )
branch_dim_count=$branch_dim_count
branch_members=( ${members_string% } )
branch_hashes=( ${branch_hashes[*]} )
cell_is_leaf=$cell_is_leaf
"
    write_to_context var content || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

seed_coordinates_prep() {
  begin_function
    if (( ${coordinate_count:-0} > 0 )); then
      log_fatal "Coordinates already have data, can't seed them."
      fail1
    fi

    if [[ $seed_table == auto ]]; then
      local derive_table biggest_table= biggest_size=0
      for derive_table in ${derive_tables[*]}; do
        local -n derive_fields=${derive_table}_fields \
                 derive_data=${derive_table}_data \

        local size=${#derive_data[*]}
        if (( size > biggest_size )); then
          biggest_size=$size
          biggest_table=$derive_table
        fi
      done

      seed_table=$biggest_table

    fi

    if [[ ! "$seed_table" ]]; then
      log_fatal "Missing seed_table"
      fail1
    fi
  end_function
  handle_return
}

check_table_field() {
  local field=$1 expected_value=$expected_value value=${2:-} values=${3:-} fields

  is_valid=t
  if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
    return 0 # this one always matches
  fi

  if [[ ! "$value" || ! "$values" ]]; then

    get_plural $field fields
    local -n ddim=d_$field \
             ddims=d_$fields \
             pdim=p_$field \
             pdims=p_$fields \

    if [[ ! "$value" ]]; then
      value=${ddim:-${pdim:-}}
    fi
      
    if [[ ! "$values" ]]; then
      values=( "${ddims[@]:-${pdims:-}}" )
    fi

  fi
      
  if [[ "${values:-${value}}" == *"*"* ]]; then
    if [[ "$expected_value" != ${values:-${value}} ]]; then
      is_valid=f
    fi
  elif [[ "$value" && "$value" != all && "$value" != $empty_member \
       && "$value" != "$expected_value" ]]; then
    is_valid=f
  elif [[ "$values" && "$values" != all && "$values" != $empty_member \
       && " $values " != *" $expected_value "* ]]; then
    local v
    is_valid=f
    for v in "${values[@]}"; do
      if [[ "$v" == "$expected_value" ]]; then
        is_valid=t
        break
      fi
    done
  fi
  
  return 0
}

# inputs:
#   table_fields       
#   table_data
#   offset       (optional) offset into data structure where row starts
#   row_index    (optional) which row to select from the table
# either offset or row must be set
# outputs:
#   is_valid 
check_table_row() {
  local offset=${offset:-} row_index=${row_index:-} field_count=${#table_fields[*]}
  begin_function_grip
    local f t
    if [[ ! "$offset" ]]; then
      (( offset = row_index * field_count ))
    fi
    is_valid=t
    for (( f = 0; f < field_count; f++ )); do

      log_show_vars=f
      fence_grip

      local field=${table_fields[$f]}
      (( t = offset + f ))
      local expected_value=${table_data[$t]}

      if [[ " ${all_dims[*]} " == *" $field "* ]]; then
        check_table_field $field
      fi

      if [[ $is_valid == f ]]; then
        break
      fi

    done
  end_function
  handle_return
}

# Will add a row to new_coordinate_data based on current ddim values and coordinate_fields
# Should only be called when the row is known to be valid
# inputs:
#   coordinate_fields
#   coordinate_fields_count
#   ignore_missing            (optional)
#   validate_row              (optional)
# outputs:
#   new_coordinate_data
#   total_coord_rows_added
#   row_is_valid
calc_coordinates_add_row() {
  local ignore_missing=${ignore_missing:-f}
  begin_function_lo

    local i new_coords=()
    for (( i = 0; i < coordinate_fields_count; i++ )); do
      local dim_var=${coordinate_fields[$i]}
      local -n dim_value=d_$dim_var
      if [[ ! "${dim_value:-}" ]]; then
        if [[ $ignore_missing == f ]]; then
          log_fatal "Missing dim: $dim_var"
          fail1
        fi
        new_coords+=( "" )
      else
        new_coords+=( "$dim_value" )
      fi
    done

    new_coordinate_data+=( "${new_coords[@]}" )
    log_debug "${coord_type}_coordinate_data+=( ${new_coords[*]} )"
    (( total_coord_rows_added++ ))

  end_function
  handle_return
}

setup_coord_fields() {
  begin_function
    case $coord_type in
      branch)
        coordinate_fields=( ${trunk_dims[*]:-} )
      ;;
      leaf)
        coordinate_fields=( ${control_props[*]:-} ${data_props[*]:-} )
      ;;
      sub)
        coordinate_fields=( ${sub_dims[*]:-} )
      ;;
      tree)
        coordinate_fields=( ${trunk_dims[*]:-} ${sub_dims[*]:-} )
      ;;
      *)
        log_fatal "Internal error: invalid coord_type=$coord_type"
        fail1
      ;;
    esac

    coordinate_fields_count=${#coordinate_fields[*]}
  end_function
  handle_return
}

load_implicit_dims() {
  begin_function_lo
    local d
    implicit_dims=()
    if [[ -e $out_path/output.tab ]]; then
      for d in $(head -n1 $out_path/output.tab); do
        if [[ ! " ${trunk_dims[*]} ${sub_dims[*]} " == *" $d "* ]]; then
          implicit_dims+=( $d )
          all_dims+=( $d )
        fi
      done
    fi
  end_function
  handle_return
}

# initialized coordinatas with a table to speed up coordinate calculation
#   of all possibilities
# won't work if coordinates already has data
# inputs:
#   coord_type: which coordinates to load
#   seed_table: defaults to auto, which will just choose the largest available table
seed_coordinates() {
  local seed_table=${seed_table:-auto} \
    coord_type=$coord_type \
    add_implicit_dims=${add_implicit_dims:-f} \
    fill_in_the_blanks=${fill_in_the_blanks:-f} \

  begin_function
    local -n coordinate_data=${coord_type}_coordinate_data \
      coordinate_fields=${coord_type}_coordinate_fields \

    local coordinate_fields_count=0 \
      coordinate_count=0 \
      coordinate_rows=0 \

    log_debug "Seeding $coord_type coordinates with seed table $seed_table"
    seed_coordinates_prep || fail

    local -n seed_fields=${seed_table}_fields \
             seed_data=${seed_table}_data \

    if [[ ! -v seed_fields ]]; then
      log_fatal "Invalid seed table: $seed_table"
      fail1
    fi

    local seed_field_count=${#seed_fields[*]} \
          seed_data_count=${#seed_data[*]} \
          total_coord_rows_added=0 \

    local seed_table_rows=$(( seed_data_count / seed_field_count ))

    setup_coord_fields || fail
    if [[ $add_implicit_dims == t ]]; then
      local f p
      for f in ${seed_fields[*]}; do
        if ! array_contains coordinate_fields $f; then
          coordinate_fields+=( $f )
          (( coordinate_fields_count++ ))
          all_dims+=( $f )
          get_plural $f p
          localize_dims+=" d_$f d_$p"
        fi
      done
    fi

    local field_index seed_field seed_data_index \
      new_coordinate_data=() \

    local -n \
      field_count=seed_field_count \
      table_fields=seed_fields \
      table_data=seed_data \

    begin_for (( row_index = 0; row_index < seed_table_rows; row_index++ )); doo
      seed_coordinates_handle_row || fail
    end_for

    coordinate_data=( "${new_coordinate_data[@]}" )
    (( coordinate_count = ${#coordinate_data[*]} ))
    (( coordinate_rows = coordinate_count / coordinate_fields_count ))

    if (( coordinate_rows > 1 )); then
      calc_coordinates_dedup || fail
    fi

  end_function
  handle_return
}

attempt_derive_get_derived_from() {
  if [[ "${derived_from:-}" ]]; then
    local one_row_complete=f
    for derived_from_row in "${derived_from[@]}"; do
      if [[ ! "$from_dim" || " $derived_from_row " == *" $from_dim "* ]]; then
        complete_row=t
        for derived_from_dim in $derived_from_row; do
          local -n derive_from_dim_value=d_$derived_from_dim
          # Can't do this: 
          # || $derive_from_dim_value == $empty_member 
          # because we must allow optional vars to resolve before attempting to derive
          if [[ ! "${derive_from_dim_value:-}" ]]; then
            complete_row=f
            break
          fi
        done
        if [[ $complete_row == t ]];then
          one_row_complete=t
          resolved_dependencies+=( "$derived_from_row" )
        fi
      fi
    done
    if [[ $one_row_complete == f ]]; then
      derived_from_incomplete=t
    fi
  fi
}

attempt_derive_check_derive_table() {
  local resolved_row resolved_dim
  for resolved_row in "${resolved_dependencies[@]}"; do
    found=t
    for resolved_dim in $resolved_row; do
      if [[ " ${fields[*]} " != *" $resolved_dim "* ]]; then
        found=f
        break
      fi
    done
    if [[ $found == t ]]; then
      break
    fi
  done
}

# inputs
#   dim    dim to output
#   var    var name containing value of dim
#   $1     message to output
show_trace_dim_message() {
  local var=$var dim=$dim message="$1"
  get_var_value $var
  local show_val=$value
  if [[ "${secret_vars:-}" && " ${secret_vars} " == *" $var "* ]]; then
    show_val='****'
  fi
  echo " ${DIM_DEBUG_COLOR}debug_id=$fork_debug_id $dim=$show_val$RESET $message" >&$fd_original_err
}

attempt_derive_from_function() {
  if function_exists ${dim_type}_${dim}_derive; then
    #log_debug "Trying derive function ${dim_type}_${dim}_derive"

    # This should be set to t in the derive function if requirements are met
    can_derive=f

    ${dim_type}_${dim}_derive || return 1
    if [[ " $trace_dims " == *" $dim "* && "$values" ]]; then
      var=values \
      show_trace_dim_message "Derived from derive function: ${dim_type}_${dim}_derive"
    fi
  fi
  return 0
}

attempt_derive_from_table() {
  if [[ ! "${values:-}" && "${derived_from:-}" ]]; then
    local -A old_values new_values intersected
    if [[ "$old_values_string" ]]; then
      string_to_set old_values_string old_values
    fi
    local derive_table
    local -n derive_tables=${dim}_derive_tables
    for derive_table in ${derive_tables[*]}; do

      local found=f
      local -n fields=${derive_table}_fields

      attempt_derive_check_derive_table

      if [[ $found == f ]]; then
        # we don't need to check this table since it doesn't use enough set dependent dims
        continue
      fi

      can_derive=t

      out_field=$dim \
      out_set=new_values \
      execute_derive_table || return 1

      if [[ ! "${new_values[*]:-}" ]]; then
        log_debug "No derived members found in derive table $derive_table which are valid for this row"
        values=()
        abort
      fi

      if [[ -v old_values[*] && " ${!old_values[*]} " != *" all "* ]]; then
        intersect old_values new_values intersected
        copy_set intersected old_values
      else
        copy_set new_values old_values
      fi

      break

    done
    keys_to_array old_values values

    if [[ " $trace_dims " == *" $dim "* && "${values:-}" ]]; then
      var=values \
      show_trace_dim_message "Derived from derive table: $derive_table"
    fi

  fi
  return 0
}

# inputs:
#   dim             dimension to derive
#   from_dim        optional, will only look for ways to derive 'dim' from 'from_dim'
# output:
#   values          array of members
#   can_derive      whether a derive function or derive table exists for the given dim
attempt_derive() {
  local dim=$1 from_dim=${from_dim:-} \
    old_values_string=${old_values_string:-} \
    stop_after_first_match=${stop_after_first_match:-f} \

  begin_function_grip
    local -n dim_type=${dim}_dim_type
    local -n derived_from=${dim_type}_${dim}_derived_from
    values=()
    can_derive=f

    local derived_from_row derived_from_dim \
      complete_row derived_from_incomplete=f \
      resolved_dependencies=()

    attempt_derive_get_derived_from

    if [[ $derived_from_incomplete == t ]]; then
      #log_debug "Can't derive $dim because it has unresolved dependencies"
      abort
    fi

    attempt_derive_from_function || fail
    attempt_derive_from_table || fail

  end_function
  handle_return
}

# input:
#   dim
#   dim_type
#   $1        target var name
# output:
#   values    array of dim members
read_dim() {
  local -n target=$1
  begin_function_lo
    local -n is_secret=${dim_type}_${dim}_is_secret
    while true; do
      if [[ "${is_secret:-f}" == t ]]; then
        read -u $fd_original_in -p "(? for more info) $dim=" -rs values >&$fd_original_err || fail
        echo '************' >&$fd_original_err
      else
        read -u $fd_original_in -p "(? for more info) $dim=" -r values >&$fd_original_err || fail
      fi
      if [[ "$values" == \?* ]]; then
        command_detail=1 show_dimension $dim || fail
      else
        local problem=
        dim_var=$dim expand_dim_members values || fail
        if [[ "$problem" ]]; then
          echo "$problem" >&$fd_original_err
        else
          # value is valid
          if [[ "${new_values[*]}" != "$values" ]]; then
            echo "Expanded to: ${new_values[*]}" >&$fd_original_err || fail
            values=( "${new_values[@]}" )
          fi
          break
        fi
      fi
    done
  end_function
  handle_return
}

attempt_default() {
  local dim=$1
  begin_function_lo

    local problem
    local -n dim_type=${dim}_dim_type

    if function_exists ${dim_type}_${dim}_default; then
      ${dim_type}_${dim}_default || fail

      if [[ " $trace_dims " == *" $dim "* && "$values" ]]; then
        var=values \
        show_trace_dim_message "Default value taken from default function: ${dim_type}_${dim}_default"
      fi

    fi

    if [[ ! "${values:-}" ]] && function_exists ${dim_type}_${dim}_expand; then
      value= ${dim_type}_${dim}_expand || fail
      already_expanded=t

      if [[ " $trace_dims " == *" $dim "* && "$values" ]]; then
        if [[ -v ${dim_type}_${dim}_default ]]; then
          var=values \
          show_trace_dim_message "Default value taken from default value: ${dim_type}_${dim}_default"
        else
          var=values \
          show_trace_dim_message "Default value taken from expand function: ${dim_type}_${dim}_expand"
        fi
      fi

    fi

    if [[ "${values:-}" == ask ]]; then
      read_dim values || fail
      already_expanded=t
    fi

    if [[ ! "${values:-}" ]]; then

      if [[ " $optional_dims " == *" $dim "* ]]; then
        values=( $empty_member )
      fi
      already_expanded=t

    fi

  end_function
  handle_return
}

calc_coordinates_row_end() {
  begin_function_grip

    if [[ "$optional_dims" ]]; then
      local unknown_dim new_unknown_dims=
      for unknown_dim in ${unknown_dims[*]:-}; do
        if [[ " $optional_dims " != *" $unknown_dim "* ]]; then
          new_unknown_dims+="$unknown_dim "
        fi
      done
      unknown_dims=${new_unknown_dims% }
    fi

    if [[ "${unknown_dims:-}" ]]; then
      log_debug "Skipped row because of unresolvable dims: ${unknown_dims[*]}"
      problem_message="Could not resolve dims: ${unknown_dims[*]}"
      progress_bar_nudge x
    else
      ignore_missing=t \
      calc_coordinates_add_row || fail
      problem_message=
      progress_bar_nudge
    fi

  end_function
  handle_return
}

calc_coordinates_dedup_output_rows() {
  local row_id
  for ((row_id = 0; row_id < coordinate_rows; row_id++ )); do
    (( row_start = row_id * coordinate_fields_count ))
    echo "${coordinate_data[*]:$row_start:$coordinate_fields_count} $row_id"
  done
}

# will remove duplicate coordinates
# inputs:
#   coordinate_rows
#   coordinate_data
#   coordinate_fields_count
calc_coordinates_dedup() {
  begin_function

    local prev_row_count=$coordinate_rows \
      sorted_row_ids row_id row_start \
      prev_coordinate_data=( "${coordinate_data[@]}" ) \

    sorted_row_ids=$(calc_coordinates_dedup_output_rows | tee /tmp/out | sort | sed -E 's/^(.*) ([0-9]+)$/\2 \1/' | tee /tmp/out2 | uniq -f 1 | awk '{print $1}')
    coordinate_data=()
    for row_id in $sorted_row_ids; do
      (( row_start = row_id * coordinate_fields_count ))
      coordinate_data+=( "${prev_coordinate_data[@]:$row_start:$coordinate_fields_count}" )
    done

    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))
    if (( coordinate_rows != prev_row_count )); then
      log_debug "Coord dedup reduced rows: $prev_row_count -> $coordinate_rows"
    fi
    
  end_function
  handle_return
}

# input: dim_type dim
set_cross_dims() {
  begin_function_grip
    local -n member=d_$dim
    if function_exists ${dim_type}_${dim}_cross_dim_expand; then
      # sets conflict={dim} if a conflict is found
      # should set validated_dims for dims which are set
      ${dim_type}_${dim}_cross_dim_expand || fail
    else
      local derive_table=${dim_type}_${dim}_derive
      local -n derive_fields=${derive_table}_fields \
               derive_data=${derive_table}_data \

      if [[ -v derive_fields ]]; then

        local field_count=${#derive_fields[*]} \
          data_count=${#derive_data[*]} \
          row_index data_index=0 column_index \
          value= field \
          found_match=f

        local row_count=$((data_count / field_count))

        for (( row_index = 0; row_index < row_count; row_index++ )); do

          found_match=f
          for (( column_index = 0; column_index < field_count; column_index++ )); do
            field=${derive_fields[$column_index]}
            if [[ $field == $dim ]]; then
              (( data_index = row_index * field_count + column_index ))
              value=${derive_data[$data_index]}
              if [[ "$value" == "$member" ]]; then
                found_match=t
              fi
              break
            fi
          done

          if [[ $found_match == t ]]; then
            for (( column_index = 0; column_index < field_count; column_index++ )); do
              field=${derive_fields[$column_index]}
              local fields
              get_plural $field fields
              if [[ $field != $dim ]]; then
                (( data_index = row_index * field_count + column_index ))
                value=${derive_data[$data_index]}
                local -n field_dim=d_$field \
                  field_dims=d_$fields
                if dim=$field \
                   single_member="${field_dim:-}" \
                   multi_member=d_$fields \
                   target_member="$value" \
                   member_conflicts; then
                  conflict=$field
                  break
                else
                  log_debug "Cross dim set: $field=$value"
                  field_dim=$value
                  validated_dims+=" $field"
                fi
              fi
            done

            break
          fi

        done

      else
        log_warn "is_cross_dim was set, but there is no derive table to use."
      fi
    fi

    if [[ "$conflict" ]]; then
      local conflict_plural
      get_plural $conflict conflict_plural
      local -n conflict_member=d_$conflict \
        conflict_members=d_$conflict_plural
      log_debug "Conflict found between cross-dim $dim = $member and $conflict = ${conflict_members:-${conflict_member:-}}"
    fi

  end_function
  handle_return
}

calc_coordinates_next_unknown_dim_found() {
  begin_function_grip

    resolved_dims+=" $dim"

    local -n \
      sdim=s_$dim \
      sdims=s_$dims \
      ddim=d_$dim \
      ddims=d_$dims \

    unset sdim ddim ddims sdims
    if [[ $already_expanded == f ]]; then
      sdims=( "${values[@]}" )
      expand_dims $dim || fail
    else
      ddims=( "${values[@]}" )
    fi

    local new_unknown_dims=( ${unknown_dims[*]:$((dim_index+1))} ${unknown_dims[*]:0:$dim_index} )

    local member ms
    if [[ "${ddims:-}" ]]; then
      ms=( "${ddims[@]}" )
    else
      ms=( "$ddim" )
    fi

    if (( ${#ms[*]} > 3 )); then

      local derive_table 
      local -A old_values new_values intersected
      array_to_set ms old_values

      debug_start

      local -n derive_tables=${dim}_derive_tables
      begin_for derive_table in ${derive_tables[*]:-}; doo

        out_field=$dim \
        out_set=new_values \
        in_set=old_values \
        execute_derive_table || fail

        old_values=()
        add_to_set new_values old_values
        new_values=()

      end_for

      if (( ${#old_values[*]} < ${#ms[*]} )); thne
        ms=( "${!old_values[@]}" )
      fi

    fi

    log_debug "Resolved $dim with $phase: ${ms[*]:0:30}"

    if [[ "$row_index" ]] && (( ${#ms[*]} > 1 )); then
      log_fatal "Too many dim members for single coordinate row: ${ms[*]}"
      fail1
    fi

    local -n is_cross_dim=${dim_type}_${dim}_is_cross_dim

    unset ddims
    for member in "${ms[@]}"; do
      ddim=$member

      log_show_vars='dim phase member unknown_dims'
      fence_grip
      log_debug "Processing $dim = $member"

      local is_valid=t

      # don't need to validate if in derive phase, since it's already proven valid by the derive
      #   process itself
      if [[ $phase == default && $needs_validation == t ]]; then
        # recursive
        calc_coords_validate_member $dim "$member" || fail
      fi

      if [[ $is_valid == t ]]; then

        conflict=
        if [[ ${is_cross_dim:-f} == t ]]; then

          set_cross_dims || fail

          local d
          for d in $validated_dims; do
            remove_array_element new_unknown_dims $d
          done

        fi

        if [[ ! "$conflict" ]]; then
          unknown_dims="${new_unknown_dims[*]}" \
          calc_coordinates_next_unknown_dim || fail
        else
          log_debug "Row skipped because of cross dim conflict"
        fi

      else
        log_debug "Dim member doesn't fit row contraints: $dim = $member, skipping row"
      fi

    done; maybe_break
    row_ended=t
    unset ddim

  end_function
  handle_return
}

# will end the coordinate row one way or another
# inputs:
#   unknown_dims
#   all other ddims which may be used to derive the unknown dims
calc_coordinates_next_unknown_dim() {
  local log_show_vars=unknown_dims
  begin_function_grip
    local dim dims \
      phase unknown_dims=( ${unknown_dims:-} ) \
      resolved_dims=${resolved_dims:-} \
      row_ended=f \

    if (( coord_limit > 0 && total_coord_rows_added >= coord_limit )); then
      log_warn "Limit of $coord_limit reached, not calculating any further"
      abort
    fi

    local dim_index
    if [[ "${unknown_dims:-}" ]]; then
      log_debug "Attempting to resolve unknowns: ${unknown_dims[*]}"
      for phase in derive default; do
        for (( dim_index = 0; dim_index < ${#unknown_dims[*]}; dim_index++ )); do
          dim=${unknown_dims[$dim_index]}

          local -n dim_type=${dim}_dim_type
          get_plural $dim dims

          log_show_vars='dim phase unknown_dims'
          fence_grip
          log_debug "Finding values for $dim in phase $phase"

          local values= already_expanded=f
          if [[ $phase == derive ]]; then
            attempt_derive $dim || fail
          elif [[ " ${all_if_blank:-} " == *" $dim "* ]]; then
            values=all
          else
            attempt_default $dim || fail
          fi

          if [[ "${values:-}" ]]; then
            calc_coordinates_next_unknown_dim_found || fail
            abort
          fi

        done; maybe_break
      done; maybe_break
    fi

    if [[ $row_ended == f ]]; then
      # whether we resolve all or not, we need to end here
      calc_coordinates_row_end || fail
    fi

  end_function
  handle_return
}

calc_coords_validate_member() {
  local dim=$1 member=$2 log_show_vars='dim member'
  begin_function_lo
    is_valid=t
    conflicting_values=()

    log_debug "Validating $dim = $member"
    local -n dim_type=${dim}_dim_type

    if [[ " $optional_dims " == *" $dim "* && ( ! "$member" || $member == $empty_member ) ]]; then
      abort
    fi

    local values=() can_derive
    attempt_derive $dim || fail
    if [[ $can_derive == t ]]; then
      if [[ ! "${values[0]:-}" ]]; then
        #log_debug "Failed to derive dim $dim when can_derive == t, skipping row"
        is_valid=f
      elif ! array_contains values "$member" && ! array_contains values all; then
        conflicting_values=( "${values[@]}" )
        is_valid=f
      fi
      abort
    fi

    #  should have already been set
    #eval "local d_$dim=\$member"
    local rd
    for rd in $resolved_dims; do
      if [[ $rd == $dim ]]; then
        continue
      fi

      stop_after_first_match=t \
      from_dim=$dim attempt_derive $rd || fail

      if [[ $can_derive == t ]]; then
        if [[ ! "${values:-}" ]]; then
          is_valid=f
        else
          local -n rd_member=d_$rd
          if [[ "${rd_member:-}" ]] && ! array_contains values "$rd_member" && ! array_contains values all; then
            conflicting_values=( "${values[@]}" )
            is_valid=f
          fi
        fi
        abort
      fi
    done
  end_function
  handle_return
}

# inputs:
#   dim            can't be empty
#   single_member  may be empty
#   multi_member   name of array var, may be empty
#   target_member  can't be empty
# outputs:
#   returns 0 if there are conflicts
member_conflicts() {
  begin_function

  if [[ "$single_member" ]]; then
    if [[ "$single_member" != "$target_member" ]]; then
      return 0
    fi
  elif [[ "$multi_member" ]]; then
    local -n members=$multi_member
    if [[ "${members:-}" ]]; then

      local found=f new_values v
      dim_var=$dim expand_dim_members $multi_member || return 0

      for v in "${new_values[@]}"; do
        if [[ "$v" == "$target_member" ]]; then
          found=t
          break
        fi
      done

      if [[ $found == f ]]; then
        return 0
      fi

    fi
  fi
  return 1

  end_function
  handle_return
}

calc_coordinates_next_dim_member() {
  log_show_vars='dim m'
  begin_function_grip
    localize
    local -n member=d_$dim
    member=$m
    log_debug "Processing $dim = $member"
    local validated_dims=${validated_dims:-} conflicting_values=()

    if [[ $needs_validation == t && " $validated_dims " != *" $dim "* ]]; then
      # recursive
      calc_coords_validate_member $dim "$member" || fail
    else
      is_valid=t
    fi

    if [[ $is_valid == t ]]; then

      conflict=
      if [[ ${is_cross_dim:-f} == t ]]; then
        set_cross_dims || fail

        local d
        for d in $validated_dims; do
          remove_word_from_string check_dims $d
        done

      fi
      if [[ ! "$conflict" ]]; then
        # recursive
        calc_coordinates_next_dim || fail
      else
        log_debug "Row skipped because of cross dim conflict"
      fi
    else
      local extra=
      if [[ "$conflicting_values" ]]; then
        extra=" != ${conflicting_values[*]}"
      fi
      log_debug "Dim member doesn't fit row contraints: $dim: $member$extra, skipping row"
    fi
  end_function
  handle_return
}

# calling this will produce and end at least one coordinate row 
# inputs:
#   check_dims (may be empty)
#   coordinate_fields_plural
calc_coordinates_next_dim() {
  begin_function_grip

    local coord_limit=${coord_limit:-0} total_coord_rows_added=${total_coord_rows_added:-0}
    if (( coord_limit > 0 && total_coord_rows_added >= coord_limit )); then
      log_debug "Limit of $coord_limit reached, not calculating any further"
      abort
    fi

    local dim dims \
      row_index=${row_index:-} \
      unknown_dims=${unknown_dims:-} \
      check_dims=${check_dims:-} \
      resolved_dims=${resolved_dims:-} \
      needs_validation=${needs_validation:-t} \

    dim=${check_dims%% *}
    check_dims=${check_dims##$dim*( )}

    if [[ "$dim" ]]; then

      log_debug "Checking dim $dim"
      get_plural $dim dims

      eval "local -I d_$dim d_$dims"
      local -n member=d_$dim \
        members=d_$dims

      if [[ "${member:-}" ]]; then
        
        local is_valid=t m=$member
        resolved_dims+=" $dim"
        unset -n members member

        local -n dim_type=${dim}_dim_type
        if [[ "${dim_type:-}" ]]; then
          local -n is_cross_dim=${dim_type}_${dim}_is_cross_dim
        else
          local is_cross_dim=f
        fi

        #log_debug "Dim known: $dim"
        calc_coordinates_next_dim_member || fail

        abort

      elif [[ "${members:-}" ]]; then

        local is_valid=t m ms=( "${members[@]}" )
        resolved_dims+=" $dim"
        unset members
        unset -n members member

        local -n dim_type=${dim}_dim_type
        if [[ "${dim_type:-}" ]]; then
          local -n is_cross_dim=${dim_type}_${dim}_is_cross_dim
        else
          local is_cross_dim=f
        fi

        if [[ "$row_index" ]] && (( ${#ms[*]} > 1 )); then
          log_fatal "Too many possibilities found for a single coordinate row: ${ms[*]}"
          fail1
        fi

        # can't loop over named vars (local -n vars)
        # so we need to use a simple var and assign to the named one
        for m in "${ms[@]}"; do
          calc_coordinates_next_dim_member || fail
        done; maybe_break

        # if none of the members are valid, we just skip the row
        # if any are valid, they will have added their own rows already
        abort

      else # no members
        log_debug "Dim unknown: $dim"
        unknown_dims+=" $dim"
        calc_coordinates_next_dim || fail
      fi

    else # check_dims is empty, need to proceed to unknowns
      calc_coordinates_next_unknown_dim || fail
    fi

  end_function
  handle_return
}

# internal function
seed_coordinates_handle_row() {
  log_show_vars=row_index
  begin_function_grip
    localize
    local is_valid
    check_table_row
    if [[ $is_valid == t ]]; then
      for field_index in ${!seed_fields[*]}; do
        seed_field=${seed_fields[$field_index]}
        if [[ " ${all_dims[*]} " == *" $seed_field "* ]]; then
          local -n member=d_$seed_field
          (( seed_data_index = row_index * seed_field_count + field_index ))
          member=${seed_data[$seed_data_index]}
        fi
      done

      if [[ $fill_in_the_blanks == t ]]; then
        local check_dims=${all_dims[*]} unknown_dims= dim validated_dims=
        needs_validation=f \
        calc_coordinates_next_dim || fail
      else
        ignore_missing=t calc_coordinates_add_row || fail
      fi

    fi
  end_function
  handle_return
}

# Will not output fields that don't exist
xlr8_get_input_string() {
  local fields_to_export=$*
  begin_function
    for f in $fields_to_export; do
      local -n x=$f
      if [[ -v x ]]; then
        if is_array x; then
          local m
          v="( "
          for m in "${x[@]}"; do
            shell_quote_var m
            v+="$m "
          done
          v+=")"
        else
          v=$x
        fi
        shell_quote_var v
        input_string+="$f=$v$NL"
      fi
    done
  end_function
  handle_return
}

xlr8_execute() {
  begin_function
    case $source_type in
      simple_java)
        java -cp $target_path Main || fail
      ;;
      *)
        log_fatal "Don't know how to execute source type $source_type yet"
        fail1
      ;;
    esac
  end_function
  handle_return
}

xlr8() {
  local function_name=$1; shift
  local fields_to_export=$*
  begin_function

    debug_start

    local xlr8_command_path=/work/xlr8/op/$function_name \
      target_path=$xlr8_command_path/target \
      source_path=$xlr8_command_path/src \
      standard_fields='
        bisect_test
        debug_bisect
        debug_bisect_max
        debug_bisect_min
        debug_exit
        debug_function_old
        debug_id
        debug_id_current
        debug_immediate
        debug_quick_function
        debug_quick_stop_less_than_depth
        debug_restart_command
        debug_step_to_mid_function
        debugging
        fork_debug_id
        fork_id_current
        pause_at_functions
        pause_at_vars
        secret_vars
        show_time
        show_time_prev
        trace_condition
        trace_expression
        trace_fun
        trace_structure
        trace_time
        trace_time_fd
        trace_time_log
        trace_var
        trace_vars
        trace_var_always
        trace_var_old
        trace_var_sub
      '

    if [[ ! -d $xlr8_command_path ]]; then
      log_fatal "Function $function_name doesn't exist in $xlr8_command_path"
      fail1
    fi

    if [[ ! -d $target_path ]]; then
      fork execute_commands "$xlr8_command_path" update || fail
    fi

    if [[ ! -d $target_path ]]; then
      log_fatal "Function $function_name didn't produce a target path"
      fail1
    fi

    if [[ -f $target_path/Main.class ]]; then
      source_type=simple_java
    else
      log_fatal "Can't identify source type of xlr8 op: $xlr8_command_path"
      fail1
    fi

    local input_string= v f
    xlr8_get_input_string $standard_fields $fields_to_export || fail

    result=$(echo "$input_string" | xlr8_execute) || fail
    if [[ "$result" ]]; then
      source "$result" || fail
    fi

  end_function
  handle_return
}

# inputs:
#   check_dims
#   coordinate_data
#   coordinate_count
#   coordinate_rows
#   coordinate_fields_count
calc_coordinates_refine_multi() {
  begin_function_lo
    front_load=6 progress_bar_start $coordinate_rows
    begin_for (( row_index = 0; row_index < coordinate_rows; row_index++ )); doo

      target_dim_var_type=sdims \
      table=${coord_type}_coordinate \
      convert_table_to_dims || fail

      expand_dims $check_dims || fail
      calc_coordinates_next_dim || fail
      progress_bar_next
      log_debug "Finished coordinate row $((row_index+1)) of $coordinate_rows"

    end_for
    progress_bar_stop
  end_function
  handle_return
}

calc_coordinates_slow() {
  begin_function
    local row_index=${row_index:-} \
      check_dims="${coordinate_fields[*]}" \
      validated_dims= \

    local seed_table=to_${coord_type}_coords
    if [[ -v ${seed_table}_fields && $cell_is_leaf == f ]]; then
      seed_coordinates || fail
      fence
    else
      local total_coord_rows_added=0
      if (( coordinate_rows > 0 )); then
        log_debug "Refining existing $coord_type dim coordinates"
        calc_coordinates_refine_multi || fail
      else
        # it is assumed that dims are already expanded before this point, and so ddims will be used
        log_debug "Calculating $coord_type cell coordinates for dims: ${coordinate_fields[*]}"
        front_load=6 progress_bar_start $coordinate_rows
        calc_coordinates_next_dim || fail
        progress_bar_stop
      fi

      coordinate_data=( "${new_coordinate_data[@]}" )
    fi

  end_function
  handle_return
}

xlr8_get_dim_fields() {
  local dims=$*
  begin_function
    local field
    dim_fields=
    for dim in $*; do
      dim_fields+="
        ${dim_type}_${dim}_aliases
        ${dim_type}_${dim}_members
        "
    done
  end_function
  handle_return
}

# inputs:
#   coord_type
#   source       set to dims to load coordinates from existing dims
#                set to coords to using existing coordinates and attempt to fill in blanks
#   all ddims of that type OR existing coords
# assumes ddims are in array form (not space separated)
# assumes all checks were done previously to determine if this is needed
calc_coordinates() {
  local clear_existing_coords=${clear_existing_coords:-t} coord_type=$coord_type \
    coord_limit=${coord_limit:-}
  begin_function

    localize

    local dim_var \
      new_coordinate_data=() \
      problem_message= \

    local -n coordinate_data=${coord_type}_coordinate_data \
      coordinate_fields=${coord_type}_coordinate_fields \

    if [[ $clear_existing_coords == t ]]; then
      coordinate_data=() \
      coordinate_count=0 \
      coordinate_rows=0 \

      setup_coord_fields || fail
    else
      
      local coordinate_fields_count=${#coordinate_fields[*]} \
        coordinate_count=${#coordinate_data[*]} \

      local coordinate_rows=$(( coordinate_count / coordinate_fields_count ))

    fi

    unknown_dims= resolved_dims=

    if [[ ! "${coordinate_fields:-}" ]]; then
      abort
    fi

    if [[ ${xlr8:-f} == t ]]; then
      local -n fields=${coord_type}_coordinate_fields
      local dt dt_fields=
      for dt in ${derive_tables[*]}; do
        dt_fields+="${dt}_fields ${dt}_data "
      done
      local coord_fields="
        coordinate_data
        coordinate_count
        coordinate_rows
        coordinate_fields_count
      "
      local dim_fields
      local dim_type=trunk_dims
      xlr8_get_dim_fields ${trunk_dims[*]}
      xlr8 load_coordinates $coord_fields $dim_fields $fields $dt_fields || fail
    else
      calc_coordinates_slow || fail
    fi

    coordinate_count=${#coordinate_data[*]}
    coordinate_rows=$(( coordinate_count / coordinate_fields_count ))

    if (( coordinate_count == 0 )); then
      case ${handle_no_coords:-error} in
        error)
          if [[ "$problem_message" ]]; then
            log_fatal "$problem_message"
          fi
          log_fatal "Could not calculate any coordinate rows. Try specifying more dims."
          fail1
        ;;
        ignore)
          log_debug "Could not calculate any coordinate rows."
        ;;
        *)
          log_fatal "Invalid value for handle_no_coords: $handle_no_coords"
          fail1
        ;;
      esac
    fi

    if [[ $coord_type == branch && $cell_is_leaf == t ]] && (( coordinate_rows > 1 )); then
      log_fatal "Cell error: found more than one branch coordinate possibility on a leaf cell."
      fail1
    fi

    log_debug "$coordinate_rows $coord_type coordinate rows found" 

  end_function
  handle_return
}

# only run if the cell is actually a leaf
build_context_leaf() {
  begin_function
    local context_type=leaf last_type=var
    log_debug "Building leaf context for $cell_path" || fail

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    local coord_type=branch

    calc_coordinates || fail
    fence

    if [[ "${unknown_dims:-}" ]]; then
      log_fatal "Could not resolve all branch dims in build_context_leaf"
      fail1
    fi

    target_dim_var_type=ddim \
    table=${coord_type}_coordinate \
    convert_table_to_dims || fail

    write_vars_to_context \
      branch_coordinate_data \
      branch_coordinate_fields \
      || fail

    if [[ -e $context_path-$context_type.new ]]; then
      mv $context_path-$context_type.new $context_path-$context_type || fail
    fi

  end_function
  handle_return
}

calc_anchor_dims() {
  begin_function
    # all anchors and non-branch dim calculations are dynamic per command execution
    # and so can't be precalculated and stored in the context
    : ${anchor_dims:=${anchor_dims:-${default_anchor_dims:-}}}
    if [[ "${branch_dims:-}" && "$branch_dims" != "$anchor_dims" ]]; then
      local branch_dim
      for branch_dim in ${branch_dims[*]}; do
        remove_word_from_string anchor_dims $branch_dim
      done
      if [[ "$anchor_dims" ]]; then
        anchor_dims="${branch_dims[*]} $anchor_dims"
      else
        anchor_dims="${branch_dims[*]}"
      fi
    fi
  end_function
  handle_return
}

get_highest_trunk_context_cell() {
  begin_function
    local parent_cell=${cell_path%/*}
    while [[ -e $parent_cell/.cyto/context-trunk ]]; do
      parent_cell=${parent_cell%/*}
    done
    if [[ -e $parent_cell/.cyto/context-trunk ]]; then
      highest_trunk_context_cell=$parent_cell
    fi
  end_function
  handle_return
}

build_context() {
  local cell_path=$1
  begin_function

    if [[ ! -f $context_path-trunk ]]; then
      local trunk_context_path=$trunk_cell/.cyto/context
      if [[ $cell_is_trunk == t || ! -f $trunk_context_path-trunk ]]; then
        context_path=$trunk_cell/.cyto/context \
        build_context_trunk || fail
      else
        source $trunk_context_path-trunk || fail
      fi
      if [[ $cell_is_trunk == f ]]; then
        safe_link $trunk_context_path-trunk $context_path-trunk || fail
      fi
    else
      source $context_path-trunk || fail
    fi
    fence

    calc_anchor_dims || fail
    setup_dims || fail
    if [[ ! -f $context_path-branch ]]; then
      build_context_branch || fail
    else
      source $context_path-branch || fail
    fi
    fence

    if [[ $cell_is_leaf == t ]]; then
      if [[ ! -f $context_path-leaf ]]; then
        build_context_leaf || fail
      else
        source $context_path-leaf || fail
      fi
    fi

    if [[ -e $context_path.new ]]; then
      rm $context_path.new || fail
    fi

    if [[ -e $context_path-trunk ]]; then
      cat $context_path-trunk >>$context_path.new || fail
    fi

    if [[ -e $context_path-branch ]]; then
      cat $context_path-branch >>$context_path.new || fail
    fi

    if [[ -e $context_path-leaf ]]; then
      cat $context_path-leaf >>$context_path.new || fail
    fi

    if [[ -e $context_path.new ]]; then
      mv $context_path.new $context_path || fail
    fi

  end_function
  handle_return
}

# inputs:
#   $1   cell path to search for branches
#   dim  dimension to gather members of
get_members_from_branches() {
  local cell_path=$cell_path dim=$dim
  begin_function
    local branch_folders folder value
    branch_folders=$(find1 $cell_path -name "$dim:*" -type d) || fail
    values=()
    for folder in ${branch_folders}; do
      local member_var_path=$folder/.member
      if [[ -f $member_var_path ]]; then
        value=$(<$member_var_path) || fail
      else
        value=${folder##*:}
      fi
      values+=( "$value" )
    done
  end_function
  handle_return
}

# 'value' is the loop var
parallel_loop() {
  local loop_over_var2=$loop_over_var head2=${head:-} \
    body2=$body tail2=${tail:-} \
    par2=$par fork2=$fork \

  local log_show_vars='loop_over_var=loop_over_var2 par=par2 fork=fork2'
  begin_function_lo

    # Make sure these variables don't get passed into inner loops
    local loop_over_var= head= body= tail= par= fork=
    local -n array=$loop_over_var2

    if [[ ! -v array ]]; then
      log_fatal "Internal error: Variable doesn't exist: $loop_over_var2"
      fail1
    fi

    local parallel=f size=${#array[*]}
    if [[ $size -gt 1 && $parallel_execution == t && $par2 == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi

    local processes= value
    leave_loop=0

    local extra
    if [[ $parallel == t ]]; then
      extra=" in parallel"
    else
      extra=" sequentially"
    fi

    if (( size > 1 )); then
      log_debug "Looping over $size values$extra. body: $body2" || fail
    fi

    begin_for value in "${array[@]}"; doo

      log_debug "Current iteration value=$value" || fail

      if [[ "$head2" ]]; then
        eval "$head2" || fail
      fi

      if [[ $parallel == t ]]; then
        fork_bg "$body2" 
        processes+=" $!"
      else
        if [[ $fork2 == t ]]; then
          fork_fg "$body2" || fail
        else
          eval "$body2" || fail
        fi
      fi

      if [[ "$tail2" ]]; then
        eval "$tail2" || fail
      fi

    end_for

    wait_for_sub_processes || fail

  end_function
  handle_return
}

# input: 
#   $1=dim
#   function=function to execute for each member
#   fork=whether the process should be forked before executing 
#     the function. (optional)
for_each_member() {
  local dim=$1 \
    function=$function leave_loop=${leave_loop:-0} \
    fork=${fork:-t} \
    par=${par:-t} \
    get_members_from=${get_members_from:-coords} \
    cell_path=${cell_path:-} \

  local log_vars='fork par' \
    log_show_vars='dim function'
  begin_function

    local dims values=() member_count=0
    get_plural $dim dims

    case $get_members_from in
      coords)
        coord_type=branch \
        fetch_values_from_coordinates $dim || fail
        if [[ "$values" != *"$NL"* ]]; then
          sort_array values
        fi
      ;;
      existing_dims)
        local -n dims_members=d_$dims dim_members=d_$dim
        values=( "${dims_members[@]:-${dim_members[@]:-}}" )
      ;;
      existing_branches)
        get_members_from_branches || fail
      ;;
      *)
        log_fatal "Internal error: invalid get_members_from value: $get_members_from"
        fail1
      ;; 
    esac

    member_count=${#values[*]}

    if (( member_count > 1 )); then
      # don't refine the upstream link if there would be multiple matches
      local upstream_cell_link=
    fi

    if (( member_count == 0 )); then
      log_fatal "No members found for $dim"
      fail1
    fi

    unset dim_members dims_members
    loop_over_var=values \
      head="local member=\$value dim=$dim command_history=\${command_history:-}
        local d_$dim=\"\$member\"
        local d_$dims
        unset value values
        " \
      body=$function \
      tail='
        if [[ $leave_loop -gt 0 ]]; then
          break
        fi
        ' \
      parallel_loop || fail

  end_function
  handle_return
}

plant_seed_internal() {
  local from=$1 to=$2 contents x x_part deep=${deep:-t} plant_branches=${plant_branches:-f}
  begin_function

    if [[ ! -d $to ]]; then

      log_verbose "Planting seed from $from to $to" || fail

      if [[ $from == /seed/* && -d $from ]]; then
        plant_seed_internal ${from%/*} ${to%/*} || fail
      else
        log_fatal "Seed doesn't exist for $to"
        fail1
      fi

    else

      contents=( $(find1 $from | sort -g) ) || fail
      local dim_found= target
      begin_for x in ${contents[*]}; doo
        x_part=${x##*/}
        target=$to/$x_part
        if [[ -d $x ]]; then
          if [[ ! -e $target ]]; then
            if [[ $x_part == .dna || $x_part == .root ]]; then
              safe_link $(realpath $x) $to/ || fail
            elif [[ $x_part == .mock && "${current_mock:-f}" != f && -d $x/$current_mock ]]; then
              safe_link $(realpath $x)/$current_mock/!(export) $to/ || fail
            elif [[ $x_part == *:* ]]; then
              if [[ $plant_branches == t ]]; then
                log_warn "Branch planting disabled for now."
              fi
              #local new_dim=${x_part%%:*}
              #if [[ ! "$dim_found" ]]; then
              #  dim_found=${x_part%%:*}
              #elif [[ $dim_found != $new_dim ]]; then
              #  log_fatal "Seed has two different dims defined, which is not allowed: $dim_found and $new_dim in $from"
              #  fail1
              #fi
            elif [[ $x_part != .* ]]; then
              mkdir $target || fail
            fi
          fi
          if [[ $x_part != .* && -d $target && $deep == t ]]; then
            plant_seed_internal $x $target || fail
          fi
        elif [[ ! -e $target && $x_part != .* ]]; then
          cp -a $x $to/ || fail
        fi
      end_for

    fi
  end_function
  handle_return
}

# inputs: $1  work path to the cell
plant_seed() {
  local seed_path from=$1 to=${2:-$1} \
    deep=${deep:-t} plant_branches=${plant_branches:-f} \
    ignore_nonexistent=${ignore_nonexistent:-f}

  begin_function

    if [[ ! -d "$to" ]]; then
      log_fatal "plant_seed called on a non-existant work path: $to"
      fail1
    fi

    find_seed_path $from || fail
    if [[ ! "$seed_path" ]]; then
      log_fatal "No seed is associated with this path: $to"
      fail1
    fi

    local dna_path=$seed_path
    if [[ $command_requires_cell == t ]]; then
      while [[ ! -d $dna_path/.dna ]]; do
        dna_path=${dna_path%/*}
        if [[ $dna_path != /*/* ]]; then
          log_fatal "Could not find dna in seed: $seed_path"
          fail1
        fi
      done

      if [[ $dna_path != $seed_path ]]; then
        safe_link $dna_path/.dna $to/ || fail
      fi

    fi

    plant_seed_internal $seed_path $to || fail

  end_function
  handle_return
}

init_coord() {
  local coord_type=$1
  local -n \
    coordinate_data=${coord_type}_coordinate_data \
    coordinate_fields=${coord_type}_coordinate_fields \
    seed_table_fields=to_${coord_type}_coords_fields \
    seed_table_data=to_${coord_type}_coords_data \

  coordinate_data=() \
  coordinate_fields=() \
  seed_table_fields=() \
  seed_table_data=() \

}

load_repo_paths() {
  declare -gA repo_paths
  begin_function
    local repo repos
    repos=$(find1 /repo -not -name '.*' -type d) || fail
    begin_for repo in $repos; doo
      if [[ -d $repo/seed ]]; then
        local module modules
        modules=$(find1 $repo/seed -not -name '.*' -type d) || fail
        begin_for module in $modules; doo
          module=${module##*/}
          repo_paths[$module]=$repo
        end_for
      fi
    end_for
  end_function
  handle_return
}

broken_link_check() {
  begin_function
    local broken_links
    broken_links=( $(find -L $cyto_path -type l -print -o -name ".*" -prune) ) || fail
    if [[ "${broken_links:-}" ]]; then
      log_debug "Broken links found in cyto: $broken_links. Will rebuild cyto."
      problem_found=t
    fi
  end_function
  handle_return
}

link_single() {
  local only_one=${only_one:-f}
  begin_function

    extract_simple_name choice_name o choice_name
    local choice_var=${choice_name//-/_}

    if [[ $only_one == t ]]; then
      local -n choice_path=up_${up_var}_path
    else
      local -n choice_path=up_${up_var}_choices_${choice_var}_path
    fi

    if [[ ! -v choice_path ]]; then
      log_fatal "Missing choice path var"
      fail1
    fi

    if [[ ! -d $choice_path ]]; then
      log_fatal "Missing choice path"
      fail1
    fi

    if [[ $only_one == t ]]; then
      safe_link $choice_path $dep_path || fail
    else
      safe_link $choice_path $dep_path/choices/$choice_name || fail
    fi

  end_function
  handle_return
}

# inputs: dep_path up_name 
link_choices() {
  begin_function
    local choice_var choice_name o
    begin_for choice_name in ${choices[*]}; doo
      link_single || fail
    end_for
  end_function
  handle_return
}

make_cyto_reactors() {
  begin_function
    mkdir $reactor_path || fail
    local reactor_name
    begin_for reactor_name in ${reactors[*]}; doo
      local dep_path=$reactor_path/$reactor_name \
        reactor_var=${reactor_name//-/_}
      local -n path=reactors_${reactor_var}_path
      if [[ ! -v path ]]; then
        log_fatal "Missing reactor path var"
        fail1
      fi
      if [[ ! -d $path ]]; then
        log_fatal "Missing reactor path"
        fail1
      fi
      safe_link $path $dep_path || fail
    end_for
  end_function
  handle_return
}

make_cyto_up_single() {
  local up_name=$1
  begin_function
    local dep_path=$up_path/$up_name \
      up_var
    local up_var=${up_name//-/_}
    local -n choices=up_${up_var}_choices
    if [[ -v choices ]]; then
      mkdir -p $dep_path/choices || fail
      link_choices || fail
    else
      local choice_name=$up_name
      if [[ -d $dep_path ]]; then
        rm -rf $dep_path || fail
      fi
      only_one=t link_single || fail
    fi
  end_function
  handle_return
}

make_cyto_up() {
  begin_function
    if [[ ! -e $up_path ]]; then
      mkdir $up_path || fail
    fi
    local up_name o
    begin_for up_name in ${up[*]}; doo
      make_cyto_up_single $up_name || fail
    end_for
  end_function
  handle_return
}

get_required_freshness() {
  required_freshness=${fresh:-${default_freshness:-}}

  # this can be used in upstream prep functions to pass freshness to upstream
  : ${top_fresh:=$required_freshness}

  return 0
}

calc_coords_branch() {
  begin_function
    local coord_type=branch
    if [[ ! "${branch_coordinate_fields:-}" ]]; then
      calc_coordinates || fail
    fi
  end_function
  handle_return
}

# should only be executed on leaf cells
calc_coords_leaf() {
  begin_function

    local coord_type=leaf
    if [[ ! "${leaf_coordinate_fields:-}" ]]; then
      calc_coordinates || fail
    fi

    local leaf_coordinate_field_count=${#leaf_coordinate_fields[*]}
    local leaf_coordinate_data_count=${#leaf_coordinate_data[*]}
    if (( leaf_coordinate_field_count > 0 && leaf_coordinate_data_count > 0 )); then

      local leaf_coordinate_rows=$(( leaf_coordinate_data_count / leaf_coordinate_field_count ))

      if (( leaf_coordinate_rows == 1 )); then
        target_dim_var_type=ddim \
        table=${coord_type}_coordinate \
        convert_table_to_dims || fail
      fi

    fi

  end_function
  handle_return
}

# should only be executed on leaf cells
calc_coords_sub() {
  begin_function

    local coord_type=sub
    if [[ ! "${sub_coordinate_fields:-}" ]]; then
      calc_coordinates || fail
    fi

    local sub_coordinate_field_count=${#sub_coordinate_fields[*]}
    local sub_coordinate_data_count=${#sub_coordinate_data[*]}
    if (( sub_coordinate_field_count > 0 && sub_coordinate_data_count > 0 )); then

      local sub_coordinate_rows=$(( sub_coordinate_data_count / sub_coordinate_field_count ))

      if (( sub_coordinate_rows == 1 )); then
        target_dim_var_type=ddim \
        table=${coord_type}_coordinate \
        convert_table_to_dims || fail
      fi

    fi

  end_function
  handle_return
}

load_post_context_dynamic_vars() {
  begin_function

    get_required_freshness || fail

    if [[ ! "${seed_path:-}" ]]; then
      find_seed_path $cell_path || fail
    fi

    mock_path=$seed_path/.mock

    current_mock=f
    if [[ -e $cell_path/.mock ]]; then
      current_mock=$(<$cell_path/.mock) || fail
    fi

    if [[ "${force_mock:-}" \
       && ( $force_mock == f || -d $mock_path/$force_mock ) \
       && $current_mock != $force_mock ]]; then
      log_debug "Changing mock: $current_mock -> $force_mock (because of force_mock parameter)"
      current_mock=$force_mock
      echo "$force_mock" >$cell_path/.mock || fail
    elif [[ -f $cell_path/.mock ]]; then
      :
    elif [[ -f $trunk_cell/.mock ]]; then
      local trunk_seed
      find_seed_path $trunk_cell trunk_seed || fail
      #mock_path=$trunk_seed/.mock
    elif [[ "${mock:-}" && -d $mock_path/$mock && $current_mock != $mock ]]; then
      log_debug "Changing mock: $current_mock -> $mock (because of mock parameter)"
      current_mock=$mock
      echo "$mock" >$cell_path/.mock || fail
    else
      current_mock=f
    fi

    if [[ $current_mock != f && $current_mock != disabled && ! -d $mock_path/$current_mock ]]; then
      log_fatal "Invalid mock in $short_cell: $current_mock doesn't exist in $mock_path"
      fail1
    fi

    if [[ "${out_path_relative:-}" ]]; then
      out_path=$cell_path/$out_path_relative
    else
      out_path=$cell_path
    fi

  end_function
  handle_return
}

build_cyto_inner() {
  local cell_path=$1

  begin_function

    log_debug "Building cyto for $short_cell"
    dna_path=$cell_path/.dna \
    cyto_path=$cell_path/.cyto \

    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    if [[ ! -d $status_path ]]; then
      mkdir $status_path || fail
    fi

    init_context || fail
    load_branch_info || fail
    find_seed_path $cell_path || fail

    if [[ ! -f $context_path ]]; then
      build_context $cell_path || fail
    fi

    if [[ "${up:-}" && ! -d $up_path && $cell_is_leaf == t ]]; then
      make_cyto_up || fail
    fi

    if [[ "${reactors:-}" && ! -d $reactor_path && $cell_is_leaf == t ]]; then
      make_cyto_reactors || fail
    fi

  end_function
  handle_return
}

# Can be called on a cell that already has a cyto folder, in which case it will repair missing
#   parts
build_cyto() {
  fork build_cyto_inner "$@"
}

# inputs:
#   $1   cell_path
#   anchor_dims (as a space separated string)
# load_branch_info should be executed BEFORE this
# setup_dims should usually be executed AFTER this
# followed by calc_coords
switch_context() {
  cell_path=$1

  if [[ "${last_context_loaded:-}" != $cell_path ]]; then

    local log_show_vars=^cell_path rebuild_attempted=f
    begin_function

      get_short_cell
      log_debug "Loading context for $short_cell"

      if [[ "$cell_path" == /seed/* ]]; then
        log_fatal "Can't switch contexts to a seed path. Make sure to run this command in a work folder."
        fail1
      fi

      dna_path=$cell_path/.dna \
      cyto_path=$cell_path/.cyto \

      local dna_exists=f
      if [[ -e $dna_path ]]; then
        dna_exists=t
      fi

      if [[ $dna_exists == t ]]; then
        if [[ "$clean_cells" ]]; then
          local cell_to_clean
          cells_already_cleaned=${cells_already_cleaned:-}
          if [[ " $cells_already_cleaned " == *" $cell_path "* ]]; then
            log_debug "Cell already cleaned: $cell_path"
          else
            begin_for cell_to_clean in $clean_cells; doo
              if [[ /$cell_path/ == */$cell_to_clean/* ]]; then
                if [[ -e $cyto_path ]]; then
                  log_info "Cleaning cell ${cell_to_clean#/work/*/} => $short_cell..."
                  rm -rf $cyto_path/!(job) || fail
                else
                  log_info "Cell already clean: $cell_to_clean => $short_cell"
                fi
                #  no we want to clean all matching cells
                #remove_word_from_string clean_cells "$cell_to_clean" 
                cells_already_cleaned+=" $cell_path"
                break
              fi
            end_for
          fi
        fi
      fi

      context_path=$cyto_path/context
      init_context || fail

      seed_path=
      if [[ $dna_exists == t ]]; then
        if [[ ! -f $context_path ]]; then
          build_cyto $cell_path || fail
        fi

        source $context_path || fail
        calc_anchor_dims || fail
        if [[ $cell_is_leaf == t ]]; then
          target_dim_var_type=ddim \
          table=branch_coordinate \
          convert_table_to_dims || fail
        fi

        local problem_found=f
        broken_link_check || fail
        if [[ $problem_found == t ]]; then
          if [[ $rebuild_attempted == f ]]; then
            log_verbose "Problem found, rebuilding context"
            rm -rf $cyto_path/up* $context_path* || fail
            rebuild_attempted=t
            continue
          else
            log_fatal "Context rebuild failed to resolve problem"
            fail1
          fi
        fi
      fi

      load_post_context_dynamic_vars || fail

      if [[ ! -f $context_path-check ]]; then
        context_type=check \
        write_vars_to_context \
          out_file \
          out_path \
          cell_is_leaf \
          check_op_var \
          data_props \
          default_freshness \
          || fail
        mv $context_path-check.new $context_path-check || fail
      fi

      last_context_loaded=$cell_path

      error_if_unresolved=t \
      handle_questions || fail

    end_function
    handle_return

  else
    log_debug "Context already loaded: $short_cell" || fail
  fi

  return 0
}

cell_open_log_file() {
  begin_function
    if [[ ! "${log_path:-}" ]]; then
      # can't log until this is set
      abort
    fi
     
    if [[ "${omni_log_job_id:-0}" != 0 ]]; then

      cell_log_file_stack+=( $logging_to_file )

      omni_log_fork_id=${omni_log_fork_parent:-}-${omni_log_fork_child}
      omni_log_fork_id=${omni_log_fork_id#-}

      local new_log_file=$log_path/$omni_log_job_id:$omni_log_fork_id.olog
      local first_log_path=${new_log_file%/*}/first.olog
      if [[ ! -f $first_log_path ]]; then
        from_must_exist=f \
          safe_link $new_log_file $first_log_path || fail
      fi

      log_function=${FUNCNAME[1]} \
        change_log_file || fail

    fi
  end_function
  handle_return
}

cell_close_log_file() {
  begin_function
    if [[ "${cell_log_file_stack:-}" ]]; then
      local previous_log=${cell_log_file_stack[-1]}
      unset cell_log_file_stack[-1]
      log_function=${FUNCNAME[1]} \
        new_log_file=$previous_log \
        resume_existing_log=t \
        logging_to_file= \
        change_log_file || fail
    fi
  end_function
  handle_return
}

get_job_id() {
  begin_function

    if [[ ! -v job_id_log ]]; then
      log_fatal "Internal error: Missing job_id_log"
      fail1
    fi

    if [[ ! -d ${job_id_log%/*} ]]; then
      mkdir ${job_id_log%/*} || fail
    fi

    timeout=5 lock_path=$job_id_log fd_write_lock || {
      log_fatal "Failed to get lock on $job_id_log" 
      fail1
    }

    if [[ -f "$job_id_log" ]]; then
      local last_id=$(tail -n1 $job_id_log | awk '{print $1}')
      (( omni_log_job_id = last_id + 1 ))
    else
      omni_log_job_id=1
    fi

    if [[ ! "$command_to_log" ]]; then
      log_fatal "Missing command to log."
      fail1
    fi

    echo "$omni_log_job_id $cell_path $command_to_log" >>$job_id_log || fail

    fd_unlock

    log_return_vars=omni_log_job_id
  end_function
  handle_return
}

execute_command_log_prep() {
  begin_function
    local cyto_path=$cell_path/.cyto
    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    local job_path=$cyto_path/job
    if [[ ! -d $job_path ]]; then
      mkdir $job_path || fail
    fi

    if [[ "${omni_log_job_id:-0}" == 0 ]]; then
      job_start_time=${EPOCHREALTIME//./}
      command_to_log="${original_cmd#* }" \
        get_job_id || fail
    fi

    current_job_path=$job_path/$omni_log_job_id
    if [[ ! -d $current_job_path ]]; then
      mkdir $current_job_path || fail
    fi

    # only set this for the first cell in the job, all other cells should 
    #   use the same fork_id log so that they all have unique ids across the job
    if [[ ! "${fork_id_log:-}" ]]; then
      fork_id_log=$current_job_path/fork-id-log
    fi

    log_path=$current_job_path/log
    if [[ ! -d $log_path ]]; then
      mkdir $log_path || fail
    fi

    background_log=$log_path/background
    running_job_path=$job_path/running

    local link_target
    begin_for link_target in $cell_command-attempt attempt; doo
      if [[ -e "$job_path/last-$link_target" ]]; then
        mv $job_path/last-$link_target $job_path/prev-$link_target || fail
      fi
      safe_link $current_job_path $job_path/last-$link_target || fail
    end_for

  end_function
  handle_return
}

validate_command_parameters() {
  begin_function
    local name required type=command
    local -n parameter_names=parameter_names_$type \
      parameter_defaults=parameter_defaults_$type \
      parameter_required=parameter_required_$type \

    if [[ "${parameter_names:-}" ]]; then
      begin_for (( index = 0; index < ${#parameter_names[*]}; index++ )); doo
        name=${parameter_names[$index]}
        required=${parameter_required[$index]}
        local -n parameter_var=$name
        if [[ ! "${parameter_var:-}" && $required == t ]]; then
          while true; do
            choose "Enter required parameter (use ? if you need help): $name=" parameter_var || fail
            if [[ "$parameter_var" == \? ]]; then
              show_parameter_help_single || fail
              continue
            fi
            break
          done
        fi
      end_for
    fi
  end_function
  handle_return
}

prep_fork() {
  begin_function_lo

    change_log2=${change_log:-}
    # Prevents this variable from bleeding through to lower called functions
    change_log=

    if [[ $change_log2 == t && $disable_log == f ]]; then
      previous_log_pos=$omni_log_pos
      cell_open_log_file || fail
      (( previous_log_pos++ ))
    fi

    if [[ "$fork_id_current" ]]; then
      fork_id_current=$fork_id_current.$debug_id_current
    else
      fork_id_current=$debug_id_current
    fi
    debug_id_current=0
    fork_debug_id=$fork_id_current.0

    cleanup_on_exit=
    setup_exit_trap

  end_function
  handle_return
}

reply_to_caller() {
  if [[ "${reply_file:-}" ]]; then
    echo "$*" >>$reply_file || return 1
  fi
  return 0
}

# this should be run in a subshell
fork_inside() {
  begin_function_lo

    local change_log2
    prep_fork || fail

    if [[ "$to_var" ]]; then
      eval "$to_var=\$($fork_command)"; return_code=$?
      reply_to_caller "$to_var='${!to_var}'" || fail
    else
      eval "$fork_command"; return_code=$?
    fi

    if [[ $change_log2 == t ]]; then
      cell_close_log_file || fail
    fi

    if [[ "${debugging:-}" == t ]]; then
      reply_to_caller "debugging=t" || fail
    fi

    if (( return_code != 0 )); then
      reply_to_caller "return_code=$return_code" || fail
      return_value=$return_code
    fi

    if [[ $change_log2 == t ]]; then
      reply_to_caller "omni_log_pos=$previous_log_pos" || fail
    fi

    if [[ "${command_successful:-}" ]]; then
      reply_to_caller "command_successful=$command_successful" || fail
    fi

    if [[ "${debug_log_level_filter:-}" ]]; then
      reply_to_caller "debug_log_level_filter=$debug_log_level_filter" || fail
    fi

    if [[ "${trace_vars:-}" ]]; then
      copy_map trace_var_old trace_var_sub
      local s="unset trace_var_sub; $(declare -p trace_var_sub)" 
      s=${s/ -A / -Ag }
      reply_to_caller "$s" || fail
    fi

    if (( ${progress_bar_nesting:-0} > 0 )); then
      reply_to_caller "progress_bar_total=${progress_bar_total:-}
progress_bar_nesting=${progress_bar_nesting:-}
progress_bar_front_load=${progress_bar_front_load:-}
progress_bar_start_time=${progress_bar_start_time:-}
progress_bar_current=${progress_bar_current:-}
" || fail
    fi

  end_function
  handle_return
}

# run outside of the subshell afterwards
after_fork() {
  begin_function_lo
    if [[ -f "${reply_file:-}" ]]; then
      #pause "Sourcing $reply_file."
      #echo "$(<$reply_file)" >&$fd_original_err
      source $reply_file || fail
      if [[ ${debugging:-f} == t ]]; then
        [[ "${debug_debug:-f}" == t ]] && echo "debugging=$debugging, so starting debugging after fork" >&$fd_original_err

        debug_immediate=f \
        first_run=f \
        debugging=f \
        debug_start

      fi
      if [[ "${debug_log_level_filter:-}" ]]; then
        local log=$debug_log_level_filter
        resolve_log_var
        log_format=default
        log_level_filter_changed
      fi
      rm $reply_file
      reply_file=
    fi
  end_function
  handle_return
}

get_new_reply_file() {
  reply_file=$tmp_folder/reply.$BASHPID
  if [[ -f $reply_file ]]; then
    log_fatal "reply_file already exists: $reply_file"
    return 1
  fi
  return 0
}

before_fork() {
  begin_function_lo

    if [[ ${background:-f} == t ]]; then
      change_log=t
    fi

    : ${omni_log_fork_child:=0}
    (( omni_log_fork_child++ ))

    get_new_reply_file || fail
    defer "rm $reply_file"

  end_function
  handle_return
}

# usage: fork {command to execute}
#  background=f (whether to run as a background process)
#  change_log=f (whether to change the log)
#  to_var       (write output to the given var instead of stdout)
fork() {
  local fork_command=$*
  begin_function_lo
    local reply_file return_code=0 \
      background=${background:-f} \
      change_log=${change_log:-f} \
      to_var=${to_var:-}

    before_fork || fail

    if [[ $background == t ]]; then
      ( fork_inside ) &
    else
      ( fork_inside )
      return_code=$?
      after_fork || (( return_code++ ))
    fi

    return_value=$return_code
  end_function
  handle_return
}

fork_fg() {
  background=f fork "$@"
}

fork_bg() {
  background=t fork "$@"
}

get_is_stale() {
  local status_path=$status_path
  begin_function
    is_stale=t
    if [[ ! "${required_freshness:-}" || "$required_freshness" == inf ]]; then
      is_stale=f
    elif [[ $required_freshness != 0 ]]; then
      local fresh_seconds
      convert_to_seconds $required_freshness fresh_seconds || fail
      local fresh_cutoff=$((EPOCHSECONDS-fresh_seconds)) \
        out_timestamp= 
      is_stale=f
      if [[ -f $status_path/last-good-update-end ]]; then
        out_timestamp=$(date -r $status_path/last-good-update-end +%s)
      fi
      if [[ "$out_timestamp" && $out_timestamp -lt $fresh_cutoff ]]; then
        is_stale=t
      fi
    fi
  end_function
  handle_return
}

wait_for_low_load() {
  local cell_max_load=${cell_max_load:-10}
  local cell_load_wait_timeout=${cell_load_wait_timeout:-600}
  local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
  if [[ $current_load -gt $cell_max_load ]]; then
    log_warn "Load average is too high ($current_load > $cell_max_load)," \
      "waiting until things cool down first." || fail
    local time_waited=0
    while [[ $current_load -gt $cell_max_load ]]; do
      current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
      sleep 5; let time_waited+=5
      if [[ "$cell_load_wait_timeout" -gt 0 && $time_waited -ge $cell_load_wait_timeout ]]; then
        log_fatal "Timed out waiting for cpu load to be low enough. Aborting"
        return 1
      fi
    done
  fi
  return 0
}

reply_file=

# input: parallel processes
wait_for_sub_processes() {
  begin_function
    if [[ "$processes" ]]; then
      log_debug "Waiting for sub processes to complete" || fail
      local process last_err_code= last_failed_process= rc
      for process in $processes; do
        log_debug "Waiting for process $process" || fail
        wait $process &>/dev/null; rc=$?
        if [[ $rc -gt 0 && $rc -lt 127 ]]; then
          if [[ ! "$last_err_code" ]]; then
            last_err_code=$rc
            last_failed_process=$process
          else
            log_fatal "Subprocess $process failed to terminate successfully"
            fail1
          fi
        fi
      done
      after_fork
      if [[ "$last_err_code" ]]; then
        if [[ "$last_err_code" == 1 ]]; then
          log_fatal "Subprocess $last_failed_process failed to terminate successfully"
          fail1
        fi
        return_value=$last_err_code
        break_out=t
        break
      fi
      processes=
    fi
  end_function
  handle_return
}

trace_step_execution=${trace_step_execution:-f}
trace_op=${trace_op:-}

# Usage: execute_op {op name}
# If {op_name}_op_var variable exists, it will be evaluated as the body of the {op_name}_op function
#   and then executed
# Otherwise {op_name}_op function is executed
#
# output
#   missing   set to t if no op found
execute_op() {
  local op_name=$1 op_function= ignore_missing=${ignore_missing:-f}

  local log_vars='cell_path op_name'
  begin_function

    op_function=${op_name}_op
    local -n op_var=${op_name}_op_var

    missing=f
    if [[ "${op_var:-}" == f ]]; then
      missing=t
    else

      if [[ "${op_var:-}" ]]; then
        unset $op_function
        if [[ "${op_var#${op_name}_op()}" != "${op_var}" ]]; then
          eval "$op_var"
        else
          eval "${op_name}_op() {
begin_function
$op_var
end_function
handle_return
}"
        fi
      fi

      if type -t $op_function &>/dev/null; then

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=t
        fi

        $op_function || fail

        if [[ $trace_op == $op_name ]]; then
          trace_step_execution=f
        fi

      else
        missing=t
      fi

    fi

    if [[ $missing == t ]]; then
      if [[ $ignore_missing == t ]]; then
        log_debug "No ${op_name}_op function found, ignoring" || fail
      else
        log_fatal "No ${op_name}_op function found"
        fail1
      fi
    fi

  end_function
  handle_return
}

# inputs: parent_path seed_path member
plant_member() {
  begin_function
    local deep=${deep:-f} repair=${repair:-f}
    get_sane_value "$member" || fail
    member_path=$parent_path/$dim:$sane_value
    if [[ ! -d $member_path || $repair == t ]]; then

      local new_path=$member_path.new

      if [[ -d $new_path ]]; then
        rm -rf $new_path || fail
      fi

      mkdir $new_path || fail
      if [[ "$member" != "$sane_value" ]]; then
        echo -n "$member" >$new_path/.member || fail
      fi

      plant_seed $member_path $new_path || fail

      #if [[ -e $parent_path/.mock ]]; then
      #  if [[ ! -d $new_path/.cyto ]]; then
      #    mkdir $new_path/.cyto || fail
      #  fi
      #  cp $parent_path/.mock $new_path/.mock || fail
      #fi

      if [[ -e $member_path ]]; then
        rm -rf $member_path || fail
      fi
      mv $new_path $member_path || fail

    fi
  end_function
  handle_return
}

# input: $* = cell values in dim order
# output: cell_id = string cell id
get_cell_id() {
  local v
  cell_id=
  for v in "$@"; do
    get_sane_value "$v"
    v=$sane_value
    cell_id+=_$v
  done
  cell_id=${cell_id#_}
}

encrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=$to \
    key=${key:-$user_private_key}

  begin_function

    if [[ "$to" == */ ]]; then
      to+=${from##*/}
    fi

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ -e $to ]]; then
      log_fatal "File already exists: $to"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    setup_tmp_path || fail
    if ! log_and_run openssl pkeyutl -encrypt -inkey $key -in $from -out $to; then
      log_fatal "Failed to encrypt file: $from"
      fail1
    fi

  end_function
  handle_return
}

encrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from \
    to=$to \
    tmp_path=$tmp_path \
    key_path=$key_path \
    user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Encrypting $from to $to" || fail

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to encrypt non-existent file: $from"
      fail1
    fi

    if [[ -f "$to" ]]; then
      log_fatal "Encrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then

      local key_count=$(find -L $key_path -mindepth 1 -maxdepth 1 -name 'key.*' -type f | wc -l)

      if (( key_count > 0 )); then

        log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
        find -L $key_path -name "key.*" >&2
        fail1

      else

        log_debug "There are no keys for this cell yet. Will create a new key." || fail

        # create a new main key
        if ! out_to_file=$tmp_path/main log_and_run openssl rand -base64 40; then
          log_fatal "Failed to generate new main key."
          fail1
        fi
        defer "rm $tmp_path/main"

        # create a compatible public key from the user's private key
        if ! log_and_run openssl pkey -in $user_private_key -out $tmp_path/public -pubout; then 
          log_fatal "Failed to convert private key to public key."
          fail1
        fi

        # encrypt main key with given user key
        if ! log_and_run openssl pkeyutl -encrypt -pubin -inkey $tmp_path/public -in $tmp_path/main -out $key_path/key.$USER; then
          log_fatal "Failed to encrypt main key."
          fail1
        fi

      fi
    else 
      # extract the main key
      if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in $key_path/key.$USER -out $tmp_path/main; then
        log_fatal "Failed to decrypt main key." 
        fail1
      fi

      defer "rm $tmp_path/main"
    fi
      
    # encrypt the file with main key
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -pass file:$tmp_path/main; then
      log_fatal "Failed to create new secret file."
      fail1
    fi

  end_function

  if [[ -f $tmp_path/main ]]; then
    rm $tmp_path/main
  fi

  handle_return

}

handle_secure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    setup_tmp_path || fail
    local unsafe_file=${file%.safe}
    local new_unsafe_file=$tmp_path/$unsafe_file.new
    local old_unsafe_file=$tmp_path/$unsafe_file.old

    if [[ -f $new_unsafe_file ]]; then
      log_fatal "$new_unsafe_file already exists, delete that first if you want to edit $file"
      fail1
    fi

    defer "rm $new_unsafe_file"
    defer "rm $old_unsafe_file"

    if [[ -f $old_file ]]; then
      from=$old_file to=$old_unsafe_file decrypt_file_with_shared_key || fail
      cp $old_unsafe_file $new_unsafe_file || fail
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" >$new_unsafe_file || fail
    else
      $EDITOR $new_unsafe_file || fail
    fi

    if [[ -f $old_unsafe_file ]]; then
      if files_are_different $old_unsafe_file $new_unsafe_file >/dev/null; then
        changed=t
      else
        log_debug "No change" || fail
        rm $new_unsafe_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      from=$new_unsafe_file to=$new_file encrypt_file_with_shared_key || fail
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

handle_insecure_edit() {

  local log_vars= old_file=$file new_file=$file.new
  begin_function_hi

    if [[ -f $old_file ]]; then
      cp $old_file $new_file || fail 
    fi

    if [[ "${content:-}" ]]; then
      echo "$content" | trim_nl >$new_file || fail
    else
      $EDITOR $new_file || fail
    fi

    if [[ -f $old_file ]]; then
      if files_are_different $old_file $new_file >/dev/null; then
        changed=t
      else
        log_debug "No change" || fail
        rm $new_file || fail
      fi
    else
      changed=t
    fi

    if [[ $changed == t ]]; then
      mv $new_file $old_file || fail
      update_modify_times $new_file || fail
    fi

  end_function
  handle_return
}

update_modify_times() {
  local file=$1
  if [[ "$status_path" && -f "$status_path/up-to-date" ]]; then
    rm $status_path/up-to-date || return 1
  fi
  return 0
}

setup_context_defaults() {
  return 0
}

update_cell_value_file() {
  begin_function
    if [[ "${cell_values:-}" && ! -f $cell_path/cell_values ]]; then
      local v s='cell_values=( '
      for v in "${cell_values[@]}"; do
        s+="\"$v\" "
      done
      s+=')'
      echo "$s" >$cell_path/cell_values || fail
    fi
  end_function
  handle_return
}

get_cell() {
  cell_path=$1
  [[ ${#cell_path} -lt 3 ]] && return 1
  [[ -d $cell_path/.dna ]] && return 0
  [[ -d $cell_path/.cyto ]] && return 0
  get_cell ${cell_path%/*} || return 1
  return 0
}

setup_tmp_path() {
  if [[ ! "${tmp_path:-}" ]]; then
    if [[ -d ${cell_path:-}/.cyto/tmp ]]; then
      tmp_path=$cell_path/.cyto/tmp
    elif [[ -d ~/tmp ]]; then
      tmp_path=~/tmp
    else
      tmp_path=/tmp
    fi
  fi
  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || return 1
  fi
  return 0
}

# inputs:
#   from    encrypted file to decrypt
#   to      (optional) file to save decrypted form to
#           if 'to' is missing, then it writes the decrypted value to stdout
decrypt_file() {
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}
  local from=$from \
    to=${to:-} \
    to_var=${to_var:-} \
    key=${key:-$user_private_key}

  local log_show_vars='^from ^to to_var'
  begin_function_hi

    if [[ ! "$to" && ! "$to_var" ]]; then
      log_fatal "decrypt_file: Must set either 'to' or 'to_var'"
      fail1
    fi

    pause_tee

    if [[ ! -f $from ]]; then
      log_fatal "File doesn't exist: $from"
      fail1
    fi
     
    if [[ ! -f $key ]]; then
      log_fatal "Key doesn't exist: $key"
      fail1
    fi
     
    if [[ "$to" ]]; then
      if [[ -e $to ]]; then
        log_fatal "File already exists: $to"
        fail1
      fi
      setup_tmp_path || fail
      if ! openssl pkeyutl -decrypt -inkey $key -in $from -out $to; then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    else
      local -n v=$to_var
      v=$(openssl pkeyutl -decrypt -inkey $key -in $from)
      if (( $? > 0 )); then
        log_fatal "Failed to decrypt file: $from"
        fail1
      fi
    fi
     
    unpause_tee

  end_function
  handle_return
}

# inputs: from to tmp_path current_cell
# will write output to file at $to
decrypt_file_with_shared_key() {

  setup_tmp_path || return 1

  local from=$from
  local to=$to
  local tmp_path=$tmp_path
  local key_path=$key_path
  local user_private_key=${user_private_key:-~/.ssh/id_rsa}

  log_debug "Decrypting $from to $to" || return 1

  local log_vars='from to'
  begin_function_hi

    if [[ ! -f "$from" ]]; then
      log_fatal "Attempting to decrypt non-existent file: $from"
      fail1
    fi

    if [[ -s "$to" ]]; then
      log_fatal "Decrypt: target file already exists: $to"
      fail1
    fi

    if [[ ! -f "$user_private_key" ]]; then
      log_fatal "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
      log_fatal "You may create one using: ssh-keygen -mPEM"
      fail1
    fi

    if [[ ! "$tmp_path" ]]; then
      log_fatal "tmp_path must be set to a directory before calling decrypt_file_with_shared_key."
      fail1
    fi

    if [[ ! -d $tmp_path ]]; then
      mkdir -p $tmp_path || fail
    fi

    if [[ ! -d $key_path ]]; then
      mkdir $key_path || fail
    fi

    if [[ ! -f "$key_path/key.$USER" ]]; then
      log_fatal "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
      find -L $key_path -name "key.*" >&2
      fail1
    fi

    # extract the main key
    if ! log_and_run openssl pkeyutl -decrypt -inkey $user_private_key -in "$key_path/key.$USER" -out $tmp_path/main; then
      log_fatal "Failed to decrypt main key." 
      fail1
    fi
    defer "rm $tmp_path/main"

    # decrypt the secret file
    if ! log_and_run openssl enc -aes256 -pbkdf2 -in $from -out $to -d -pass file:$tmp_path/main; then 
      log_fatal "Failed to decrypt secret file." 
      fail1
    fi

  end_function
  handle_return

}

get_sane_value() {
  local -r value=$1 
  local -n _s=${2:-sane_value}
  if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
    _s=$value
  else
    hash=$(echo -n "$value" | sha1sum | awk '{ print $1 }')
    _s=${hash:0:8}
  fi
  debug_return_vars=_s
  return 0
}

is_cell() {
  [[ -d "$1/.dna" ]]
}

# Used by the help system to describe a command and it's parameters to the user
new_command() {
  local name=$name description=$description
  command_description=$description
  #parameter_names=( )
  #parameter_descriptions=( )
  #parameter_defaults=( )
  #parameter_choices=( )
}

add_parameter() {

  local type=${type:-command} \
    name=$name \
    description=$description \
    default=${default:-} \
    choices=${choices:-} \
    aliases=${aliases:-${alias:-}} \
    required=${required:-f} \
    delay_questions=${delay_questions:-f} \

  local -n parameter_names=parameter_names_$type \
    parameter_descriptions=parameter_descriptions_$type \
    parameter_choices=parameter_choices_$type \
    parameter_defaults=parameter_defaults_$type \
    parameter_aliases=parameter_aliases_$type \
    parameter_delay_questions=parameter_delay_questions_$type \
    parameter_required=parameter_required_$type \

  parameter_names+=( "$name" ) 
  parameter_descriptions+=( "$description" ) 
  parameter_defaults+=( "$default" ) 
  parameter_choices+=( "$choices" )
  parameter_aliases+=( "$aliases" )
  parameter_delay_questions+=( $delay_questions )
  parameter_required+=( $required )

  local a
  for a in ${parameter_aliases[*]:-}; do
    if [[ -v ${a}_append ]]; then
      eval "${name}_append=\$${a}_append"
    fi
    if [[ -v ${a}_prepend ]]; then
      eval "${name}_prepend=\$${a}_prepend"
    fi
    if [[ -v ${a}_remove ]]; then
      eval "${name}_remove=\$${a}_remove"
    fi
  done

}

add_command_alias() {
  local name=$name command=$command
  command_aliases+=( "$name" )
  command_alias_command+=( "$command" )
}

tee_output_to_log() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    exec 1> >(tee -a "$logging_to_file") || return 1
    exec 2>&1 || return 1
    eval "exec $fd_trace>&1" || return 1
    BASH_XTRACEFD=$fd_trace
    tee_files+=( $logging_to_file )
  fi
  return 0
}

untee_output() {
  if [[ "$log_to_file" && "$logging_to_file" && $debugging == f ]]; then
    if [[ "${tee_files:-}" ]]; then
      BASH_XTRACEFD=
      exec 1>&$fd_original_out || return 1
      exec 2>&$fd_original_err || return 1
      eval "exec $fd_trace>&$fd_original_trace" || return 1
      unset tee_files[-1]
    else
      # log_warn "untee was called when nothing was teed"
      :
    fi
  fi
  return 0
}

pause_tee() {
  if [[ "${tee_files:-}" ]]; then
    paused_tee_file=${tee_files[-1]}
    untee_output || return 1
  fi
  return 0
}

unpause_tee() {
  if [[ "$paused_tee_file" ]]; then
    tee_output_to_log $paused_tee_file || return 1
    paused_tee_file=
  fi
  return 0
}

# locks the given cell, or fails if it can't obtain a lock
# may lock an individual file instead if the path given isn't a cell
cell_lock() {

  local cell_path=$1 \
    write_lock=${write_lock:-t} \
    timeout=$timeout \
    lock_fd \
    lock_type=read \
    lock_path

  local log_show_vars="timeout ^cell_path"
  begin_function

    if [[ -e $cell_path/.cyto/context ]]; then
      lock_path=$cell_path/.cyto/context
    else
      log_fatal "Missing context: $cell_path/.cyto/context"
      fail1
    fi

    if [[ $write_lock == t ]]; then
      lock_type=write
    fi

    if [[ -f $lock_path ]]; then
      if [[ $write_lock == t ]]; then
        fd_write_lock || fail
      else
        fd_read_lock || fail
      fi
      cell_locks+=( $lock_fd )
    fi

  end_function
  handle_return

}

# locks the given cell, or fails if it can't obtain a lock
cell_unlock() {
  local lock_fd
  for lock_fd in ${cell_locks[*]:-}; do
    fd_unlock || return 1
  done
  return 0
}

up_delegate() {
  local cyto_up_path=$1 # .../.cyto/up/{dep_name}
  local cell_path=${cyto_up_path%/.cyto/up/*} \
    up_lock=$cyto_up_path/chosen/.cyto/lock \
    up_name=${cyto_up_path##*/}
  local log_show_vars='^cyto_up_path ^cell_path up_lock'
  begin_function_hi

    if [[ -e $up_lock ]]; then
      local locks_folder=$cell_path/.cyto/up-locks
      if [[ ! -d $locks_folder ]]; then
        mkdir $locks_folder || fail
      fi
      safe_link $up_lock $locks_folder/$up_name || fail
    fi

    local out_item
    out_items=$(find1 $cyto_up_path/chosen -not -name ".*") || fail
    begin_for out_item in $out_items; doo
      safe_link $out_item $cell_path/ || fail
    end_for

  end_function
  handle_return
}

# inputs:
#   table_fields variable name holding array of fields
#   table_data   variable name holding array of cells
#   row          which row to select from the table
#   field_count
#   prefix       prefix of variable name to set
#execute_auto_load_add_constraints() {
#  begin_function
#    local f t
#    begin_for (( f = 0; f < field_count; f++ )); doo
#
#      local field=${table_fields[$f]}
#      (( t = row * field_count + f ))
#      expected_value=${table_data[$t]}
#      if [[ "$expected_value" == all || "$expected_value" == "" ]]; then
#        continue # try next field, since this one matches
#      fi
#
#      keys["$field $expected_value"]=1
#
#    end_for
#
#  end_function
#  handle_return
#}

#execute_auto_load_tab() {
#  local table_name=$1 prefix=${prefix:-}
#  begin_function
#    local -n table_fields=${table_name}_fields table_data=${table_name}_data
#    if [[ ! -v table_fields || ! -v table_data ]]; then
#      log_fatal "Missing expected vars: ${table_name}_fields or ${table_name}_data"
#      fail1
#    fi
#    local row \
#      field_count=${#table_fields[*]} data_count=${#table_data[*]}
#    local row_count=$((data_count/field_count))
#    local -A keys
#    begin_for (( row = 0; row < row_count; row++ )); doo
#      check_table_row || fail
#      if [[ $is_valid == t ]]; then
#        execute_auto_load_add_constraints || fail
#      fi
#    end_for
#
#    local value key key_field field value
#    begin_for field in "${table_fields[@]}"; doo
#      local -n target_field=$field
#      if [[ "${target_field:-}" ]]; then
#        continue
#      fi
#      begin_for key in "${!keys[@]}"; doo
#        key_field=${key%% *}
#        if [[ "$key_field" != "$field" ]]; then
#          continue
#        fi
#        value=${key#$key_field }
#        target_field+=( "$value" )
#      end_for
#    end_for
#  end_function
#  handle_return
#}

execute_auto_loads() {
  local auto_loads=( "$@" )
  begin_function
    local table_name prefix i
    begin_for item in "${auto_loads[@]}"; doo
      case $item in
# OLD CODE, should remove if not used soon
#        *.tab)
#          execute_auto_load_tab ${item%.tab} || fail
#        ;;
        *.var)
          local v=${item%.*}
          if [[ -v $v ]]; then
            local quoted=${!v}
            quoted=${quoted//\"/\\\"}
            eval "$v=\"$quoted\""
          fi
        ;;
        *)
          log_fatal "Can't auto load $item"
          fail1
        ;;
      esac
    end_for
  end_function
  handle_return
}

get_trunk_cell() {
  trunk_cell=$1
  while [[ $trunk_cell == */*:* ]]; do
    trunk_cell=${trunk_cell%/*}
  done
  debug_return_vars=trunk_cell
}

# inputs:
#   debug_log    (optional)
#   result_file
#   $1           headers and url to query
http_get() {
  local parameters="$*" timeout=${timeout:-60}
  begin_function

    local curl_command="curl -Lkvgs -m $timeout -w '%{stderr}TIMINGS
      time_namelookup=%{time_namelookup}
      time_connect=%{time_connect}
      time_appconnect=%{time_appconnect}
      time_pretransfer=%{time_pretransfer}
      time_redirect=%{time_redirect}
      time_starttransfer=%{time_starttransfer}
      time_total=%{time_total}
    ' $parameters"
    echo "$curl_command" >$debug_log
    if [[ -e $result_file ]]; then
      rm $result_file || fail
    fi

    err_to_file=${debug_log:-} \
    out_to_file=$result_file \
    log_and_run "$curl_command" || fail

    if log_level_at_least verbose; then
      local timings=$(awk 'BEGIN { flow=0 } flow == 1 { print } /TIMINGS/ { flow=1 }' $debug_log)
      log_verbose "curl timings:$NL$timings"
    fi

    local response_line response_code response_message response_code_message response_error
    response_line=$(grep -E '^< HTTP/[^ ]+ ' $debug_log | tail -n1)
    response_code_description=${response_line#* * }
    response_code=${response_code_description%% *}

    response_error=$(jq -r .error $result_file 2>/dev/null) || true
    if [[ "$response_code" != 200 ]]; then
      if [[ "$response_error" ]]; then
        log_fatal "curl failed: $response_error"
      elif [[ "$response_code_message" ]]; then
        log_fatal "curl failed: $response_code_message"
      else
        log_fatal "curl failed for unknown reason. Check $debug_log or $result_file for more details."
      fi
      fail1
    fi

  end_function
  handle_return
}
