#!/bin/bash

type -t cell_context_load >/dev/null && return 0

# don't let other users read any files written by these scripts
umask 0077

readonly failed_but_can_retry=2 skip=2 \
  somethings_wrong=1 everythings_fine=0 \
  empty_member=_ wild_sub_path=_ 

parallel_default=t 
[[ $debug == t ]] && parallel_default=f
parallel_execution=${parallel_execution:-${par:-$parallel_default}}

cell_context_load() {
local vars=cell; begin_function

  if [[ ! -e $cell/.dna ]]; then
    err "$cell is not a cell"
    fail1
  fi

  last_context_loaded=${last_context_loaded:-}
  if [[ "$last_context_loaded" != $cell ]]; then

    last_context_loaded=$cell
    init_context || fail

    cyto_path=$cell/.cyto
    sub_path=$cell/.dna/sub
    local context_path=$cyto_path/context
    if [[ ! -e $cyto_path ]]; then
      if [[ -d $sub_path ]]; then
        plant_seed $sub_path $cell || fail
      fi
      make_cyto $cell || fail
    else
      [[ -f "$context_path" ]] && { source $context_path || fail; } 
    fi

    setup_dims $cell || fail
    setup_cell_path_vars $cell || fail

  fi

end_function
handle_return
}

plant_seed() {
local from=$1 to=$2 contents x x_part
begin_function_flat
  contents=( $(find1 $from -not -name "$wild_sub_path") ) || fail
  begin_for x in ${contents[*]}; doo
    x_part=${x##*/}
    if [[ ! -e $to/$x_part ]]; then
      if [[ -f $x || $x == */.dna ]]; then
        ln -s $(realpath $x) $to/ || fail
      elif [[ -d $x ]]; then
        mkdir $to/$x_part || fail
        plant_seed $x $to/$x_part || fail
      fi
    fi
  end_for
end_function_flat
handle_return
}

# This is run if cell hasn't been initialized = missing .cyto folder
make_cyto() {
local cell=$1 new_cyto=$cell/.cyto.new
begin_function_flat

  if [[ -e $cell/.cyto ]]; then
    err "$cell/.cyto already exists. make_cyto should not be called unless it doesn't."
    stack_trace
    fail1
  fi

  if [[ -e $new_cyto ]]; then
    rm -rf $new_cyto || fail
  fi
  mkdir -p $new_cyto || fail

  record_context $cell || fail

  get_top_cell $cell || fail
  if [[ "$top_cell" != $cell ]]; then
    if [[ $top_cell/.dna/command ]]; then
      ln -s $top_cell/.dna/command $new_cyto/command || fail
    else
      err "Top cell doesn't have a command folder ($top_cell/.dna/command missing)"
      fail1
    fi
    if [[ $top_cell/.dna/lib ]]; then
      ln -s $top_cell/.dna/lib $new_cyto/lib || fail
    fi
  fi

  #   older more powerful, but more fragile way
  # mkdir -p $new_cyto/command || fail
  # mkdir -p $new_cyto/lib || fail
  # inherit_lib $cell || fail

  local context_path=$new_cyto/context
  if [[ -f "$context_path" ]]; then
    source $context_path || fail
  fi
  setup_features || fail

  mv $new_cyto $cell/.cyto || fail

end_function_flat
handle_return
}

record_context() {
local cell=$1
local parent=${cell%/*}
local new_context=$new_cyto/context

if [[ ${#parent} -gt 1 ]]; then
  record_context_before $parent || return 1
fi

local context_local_path=$cell/.dna/context-local
local dna_path=$cell/.dna

if [[ -f $context_local_path ]]; then
  echo "# generated from: $context_local_path" >>$new_context || return 1
  echo | cat $context_local_path - >>$new_context || return 1
elif [[ -f $dna_path ]]; then
  echo "# generated from: $dna_path" >>$new_context || return 1
  echo | cat $dna_path - >>$new_context || return 1
fi

if [[ ${#parent} -gt 1 ]]; then
  record_context_after $parent || return 1
fi

return 0
}

record_context_before() {
local cell=$1
local parent=${cell%/*}
if [[ ${#parent} -gt 1 ]]; then
  record_context_before $parent || return 1
fi
local context_before_path=$cell/.dna/context-before
if [[ -f $context_before_path ]]; then
  echo "# generated from: $context_before_path" >>$new_context || return 1
  echo | cat $context_before_path - >>$new_context || return 1
fi
}

record_context_after() {
local cell=$1
local parent=${cell%/*}
local context_after_path=$cell/.dna/context-after
if [[ -f $context_after_path ]]; then
  echo "# generated from: $context_after_path" >>$new_context || return 1
  echo | cat $context_after_path - >>$new_context || return 1
fi
if [[ ${#parent} -gt 1 ]]; then
  record_context_after $parent || return 1
fi
}

inherit_lib() {
local cell_from=$1
local parent=${cell_from%/*}
begin_function_flat
  if [[ "${#parent}" -gt 1 ]]; then
    # recursive
    inherit_lib $parent || fail
  fi
  if [[ -d $cell_from/.dna ]]; then
    local lib
    if [[ -d $cell_from/.dna/lib ]]; then
      inherit_lib_folder $cell_from/.dna/lib $new_cyto/lib || fail
    fi
    if [[ -d $cell_from/.dna/command ]]; then
      inherit_lib_folder $cell_from/.dna/command $new_cyto/command || fail
    fi
  fi
end_function_flat
handle_return
}

inherit_lib_folder() {
local from=$1 to=$2
begin_function_flat
  local folder_name lib
  mkdir -p $to || fail
  begin_for lib in $(find1 $from -not -name '.*'); doo
    if [[ -f $lib ]]; then
      local source_path=${lib%/*} target_file=${lib##*/} base prefix
      if [[ ! $target_file =~ ([0-9]+)-(.*) ]]; then
        base=$target_file
        found=( $(find1 $to -regex '[0-9]+-'$base'$' | sort -g) ) || fail
        if [[ "${found:-}" ]]; then
          target_file=$found
          if [[ "${#found[*]}" -gt 1 ]]; then
            warn "Found more than one match for $lib in $to. Will use $target_file."
          fi
        fi
      fi
      ln -sf $lib $to/$target_file || fail
    elif [[ -d $lib ]]; then
      folder_name=${lib##*/}
      inherit_lib_folder $lib $to/$folder_name || fail
    fi
  end_for
end_function_flat
handle_return
}

setup_features() {
begin_function_flat

  local feature
  if [[ "${cell_features:-}" ]]; then
    begin_for feature in "${cell_features[@]}"; doo
      case $feature in
        req)
          mkdir -p $new_cyto/$feature/new || fail
        ;;
        log|job|status)
          mkdir -p $new_cyto/$feature || fail
        ;;
        *)
          err "Unknown feature $feature"
          fail1
        ;;
      esac
    end_for
  fi

end_function_flat
handle_return
}

create_sub_cells() {
if [[ "$sub_path" ]]; then
  create_sub_cells2 $cell_path '' || return 1
fi
return 0
}

# seed must not be empty here
create_sub_cells2() {
local seed=$1 relative_path=$2 sub_full sub 
[[ "$relative_path" ]] && relative_path=/$relative_path
local sub_path=$seed/.dna/sub$relative_path
local subs=$(find1 $sub_path -not -name ".*" -not -name "$wild_sub_path" | sort -g) || return 1
for sub_full in $subs; do
  sub=${sub_full##*/}
  if [[ -f $sub_full ]]; then
    ln -sf $(realpath $sub_full) $seed$relative_path/$sub || return 1
  elif [[ -d $sub_full ]]; then
    create_sub_cell $seed $seed$relative_path/$sub || return 1
    if [[ "$relative_path" ]]; then
      create_sub_cells2 $seed ${relative_path#/}/$sub || return 1
    else
      create_sub_cells2 $seed $sub || return 1
    fi
  fi
done
}

create_sub_cell() {
# seed is allowed to be empty, meaning no seed exists at this location
local seed=$1 sub_cell=$2
local vars=sub_cell; begin_function

  if [[ "$sub_cell" =~ .dna ]]; then
    err "Internal error: Invalid sub_cell $sub_cell."
    err "We should not be creating a sub cell inside of a dna folder"
    fail1
  fi

  if [[ ! -d $sub_cell ]]; then

    if [[ -d $sub_cell.new ]]; then
      rm -rf $sub_cell.new || fail
    fi

    local parent=${sub_cell%/*}
    if [[ "$parent" == "$sub_cell" ]]; then
      err "Can't create sub cells in a cell without parents: $sub_cell"
      stack_trace
      fail1
    fi

    local parent_part=${parent##*/}
    if [[ "$parent_part" == .dim ]]; then
      create_sub_branch_or_leaf $sub_cell.new || fail
    else
      mkdir -p $sub_cell.new || fail
      find_seed_dna ${seed:-$parent} ${sub_cell#$parent/} || fail
      if [[ "$seed_dna" ]]; then
        ln -sf $(realpath $seed_dna) $sub_cell.new/.dna || fail
      fi
    fi
    mv $sub_cell.new $sub_cell || fail
  fi
end_function
handle_return
}

create_sub_branch_or_leaf() {
local cell=$1
begin_function_flat
  if [[ -d $cell ]]; then
    err "Cell already exists $cell"
    fail1
  fi
  mkdir $cell || fail
  local sub_dna_path=$cell/.dna super_dims
  mkdir $sub_dna_path || fail
  super_dims=( $(find1 $sub_dna_path/dim -not -name '.*' | sort -g) ) || fail
  if [[ "$super_dims" ]]; then
    local super_dim_count=${#super_dims[*]} 
    if [[ "$super_dim_count" -gt 1 ]]; then
      create_sub_branch || fail
    else
      create_sub_leaf || fail
    fi
  fi
end_function_flat
handle_return
}

create_sub_branch() {
begin_function_flat
  mkdir $sub_dna_path/dim || fail
  begin_for ((i=1; i<super_dim_count; i++)); doo
    local from_dim=${super_dims[$i]}
    local to_dim=$sub_dna_path/dim/${from_dim##*/}
    ln -s $(realpath $from_dim) $to_dim || fail
  end_for
  # TODO link .dna to this branch, but prefer seed info vs. shortcuts
end_function_flat
handle_return
}

create_sub_leaf() {
begin_function_flat
  local trunk_cell
  find_trunk_cell $cell || {
    err "Could not find trunk cell for $cell"
    fail1
    }
  # TODO link .dna to this branch, but prefer seed info vs. shortcuts
  local op_leaf=$trunk_cell/.dna/op-leaf
  if [[ -d $op_leaf ]]; then
    ln -s $op_leaf $sub_dna_path/op || fail
  fi
  if [[ -d $trunk_cell/.dna/up ]]; then
    mkdir $sub_dna_path/up || fail
    local uptream_cell leaf_cell upstream_name
    local upstream_cells=$(find1 $trunk_cell/.dna/up \
      -not -name '.*' \
      -not -name '*.prep' \
      | sort -g) || fail
    begin_for upstream_cell in $upstream_cells; doo
      upstream_name=${upstream_cell##*/}
      get_upstream_leaf_cell $trunk_cell $upstream_cell || fail
      ln -s $(realpath $leaf_cell) $sub_dna_path/up/$upstream_name || fail
    end_for
  fi
end_function_flat
handle_return
}

# given a cell, find the nearest seed searching it's ancestors
# returns: seed
find_seed() {
local cell=$1
seed=
if [[ -d $cell/.dna/sub ]]; then
  seed=$cell
else
  local parent=${cell%/*}
  if [[ "${#parent}" -gt 1 && "$parent" != $cell ]]; then
    find_seed $parent || return 1
  fi
fi
return 0
}

# returns seed_dna
find_seed_dna() {
local seed=$1
local parent=${seed%/*}
local path_to_cell=$2
path_to_cell=${path_to_cell%.new}
seed_dna=$seed/.dna/sub/$path_to_cell/.dna
if [[ ! -e $seed_dna ]]; then
  seed_dna=
  if [[ -d $seed/.dna/sub ]]; then
    seed_dna=$seed/.dna/sub
    local path_array=( ${path_to_cell//\// } ) \
      failed=f
    for path_part in "${path_array[@]}"; do
      if [[ -d $seed_dna/$path_part ]]; then
        seed_dna+=/$path_part
      elif [[ -d $seed_dna/$wild_sub_path ]]; then
        seed_dna+=/$wild_sub_path
      else
        failed=t
        break
      fi
    done
    seed_dna+=/.dna
    if [[ $failed == t || ! -d $seed_dna ]]; then
      seed_dna=
    fi
  elif [[ ${#parent} -gt 1 ]]; then
    # recursive
    find_seed_dna $parent ${seed#$parent/}/$path_to_cell || return 1
  fi
fi
return 0
}

find_trunk_cell() {
local cell=$1
local parent=${cell%/*}
local parent_part=${parent##*/}
if [[ $parent_part == .dim ]]; then
  local grandparent=${parent%/*}
  if [[ "$grandparent" != "$parent" ]]; then
    # recursive
    find_trunk_cell $grandparent || return 1
  else
    return 1
  fi
elif [[ ! -e $cell/.dna ]]; then
  if [[ "$parent" != "$cell" ]]; then
    # recursive
    find_trunk_cell $parent || return 1
  else
    return 1
  fi
else
  trunk_cell=$cell
fi
return 0
}

# usage: get_upstream_leaf_cell {trunk cell} {upstream cell}
# returns leaf_cell
get_upstream_leaf_cell() {
local trunk_cell=$1 upstream_cell=$2
begin_function_flat
  if [[ "$localize_dim_vars" ]]; then
    eval "$localize_dim_vars" || fail
  fi
  local prep_file=$upstream_cell.prep
  if [[ -f $prep_file ]]; then
    source $prep_file || fail
    prep || fail
  fi
  setup_dims $upstream_cell || fail
  # do this again for the upstream cell, in case it has different dims
  if [[ "$localize_dim_vars" ]]; then
    eval "$localize_dim_vars" || fail
  fi
  local dim member
  leaf_cell=$upstream_cell
  begin_for dim in ${leaf_dims[*]}; doo
    member=${!dim} || fail
    if [[ ! "$member" ]]; then
      err "Missing member for $dim"
      fail1
    fi
    get_sane_value "$member" || fail
    leaf_cell+=/.dim/$sane_value
  end_for
end_function_flat
handle_return
}

trace_step_execution=${trace_step_execution:-f}
trace_op=${trace_op:-}

# Usage: execute_op {op name}
execute_op() {
local op_name=$1 op found_op=f ignore_missing=${ignore_missing:-f}
local vars='cell_path op_name'; begin_function
  begin_for op in $op_path/$op_name $op_path/$op_name.*; doo
    if [[ -e $op ]]; then
      found_op=t
      if [[ $trace_op == $op_name ]]; then
        trace_step_execution=t
      fi
      execute_command_step $op || fail
      if [[ $trace_op == $op_name ]]; then
        trace_step_execution=f
      fi
      break
    fi
  end_for
  if [[ $found_op == f && $ignore_missing == f ]]; then
    err "No $op_name operation found in $op_path"
    fail1
  fi
end_function
handle_return
}

execute_command() {
local cell=$1 command=$2
local vars='cell command'; begin_function
  cell_context_load || {
    err "Context failed to load for $cell"
    fail1
    }
  if type -t $command &>/dev/null; then
    $command || fail
  else
    local command_path=$cell/.cyto/command/$command
    if [[ -e $command_path ]]; then
      execute_command_step $command_path || fail
    else
      err "Command $command doesn't exist in $command_path or as a function"
      fail1
    fi
  fi
end_function
handle_return
}

# executes a step of the folder language
# folder language
#   {cell}                update the given cell with the current coordinates
#   choose-{n}-{name}     multi-path, stopping after {n} choices are successful. {name} is optional
#   each-{var}-in-{vars}  loop over {vars} storing current value in {var}
#                         can be file or folder
#                         executes each element in parallel
#   each-{var}            loop over {vars} (adds 's' to index var)
#   loop-{var}-in-{vars}  same as each, except executes sequentially
#   {file}.go             execute go code
#                         should define a single method named after the file which will be executed
#   {file}.py             execute python script
#   {file}.js             execute js code
#   {file}.java           execute java code
#   {file}.bash           execute bash code
#   {folder}              go through each item in folder and execute according to folder language
# should be run in a subshell to avoid messing up parent vars
execute_command_step() {
local step=$1
local vars=step; begin_function
  local step_name=${step##*/} prefix= base

  if [[ $step_name =~ [0-9]+-([^/]*)$ ]]; then
    base=${BASH_REMATCH[1]}
  else
    base=$step_name
  fi
  
  if [[ -d $step/.dna ]]; then
    # recursive
    ( change_log_file; execute_command $step update ) || { after_fork; fail1; }
    after_fork
    ln -sf $step $cell_source_path/$base || fail
  elif [[ -d $step ]]; then
    if [[ $base =~ ^choose-.* ]]; then
      # TODO ...
      incomplete
      ln -sf $choice $cell_source_path/$last_part || fail
    elif [[ $base =~ ^loop-.* ]]; then
      serial=t execute_command_step_loop || fail
    elif [[ $base =~ ^each-.* ]]; then
      serial=f execute_command_step_loop || fail
    else
      execute_command_step_plain_folder || fail
    fi
  elif [[ -f $step ]]; then
    execute_command_step_file $step || fail
  else 
    err "I don't know how to process this step: $step"
    fail1
  fi
end_function
handle_return
}

execute_command_step_file() {
local vars=step; begin_function
  case $base in
    *.py)
      err "Python steps not implemented yet"
      fail1
    ;;
    *.js)
      err "JavaScript steps not implemented yet"
      fail1
    ;;
    *.go)
      err "GoLang steps not implemented yet"
      fail1
    ;;
    *.java)
      err "Java steps not implemented yet"
      fail1
    ;;
    *.bash)
      source $step || fail
      local function_name=${base%.bash}
      function_name=${function_name##*/}
      function_name=${function_name//-/_}
      local function_exists=$(type -t $function_name &>/dev/null && echo true)
      if [[ "$function_exists" ]]; then
        if [[ $trace_step_execution == t ]]; then
          start_tracing
        fi
        $function_name || fail
        if [[ $trace_step_execution == t ]]; then
          stop_tracing
        fi
      else
        err "Step $step requires that a function named $function_name be defined in that file."
        fail1
      fi
    ;;
    *)
      err "Unknown file format for $step. Can't execute."
      fail1
    ;;
  esac
end_function
handle_return
}

execute_command_step_loop() {
local serial=$serial
begin_function_flat

  # leave early if the folder of instructions is empty
  dir_is_empty $step && succeed

  local ref= ref_group=

  setup_default_each_handler || fail
  local before_block_files=( $(find1 $step -regex '.*/block-before.*' | sort -g) ) || fail
  local before_block_file
  begin_for before_block_file in "${before_block_files[@]}"; doo
    # recursive
    execute_command_step "$before_block_file" || fail
  end_for

  if [[ ! "$ref_group" ]]; then

    if [[ $base =~ (each|loop)-([^-]+)-in-([^-]+) ]]; then
      ref=${BASH_REMATCH[2]}
      ref_group=${BASH_REMATCH[3]}
    elif [[ $base =~ (each|loop)-([^-]+) ]]; then
      ref=${BASH_REMATCH[2]}
      ref_group=${ref}s
      if [[ ! "${!ref_group:-}" ]]; then
        ref_group=${ref}es
      fi
      if [[ ! "${!ref_group:-}" ]]; then
        ref_group=${ref%?}ies
      fi
      if [[ ! "${!ref_group:-}" ]]; then
        ref_group=
      fi
    fi

    # if [[ "$ref_group" && ! "${!ref_group:-}" ]]; then
    #   err "Problem executing step $step"
    #   err "Could not find ref group for $ref. Should be named either ${ref}s, ${ref}es, or ${ref%?}ies, "
    #   err "or override it with a different folder name."
    #   err "Or if this is a custom loop with a block-before file in it, set ref_group= (to nothing) in that file."
    #   fail1
    # fi

  fi

  # This can be overridden in a prep_code_file to provide custom looping
  handle_step_loop || fail

  # NOT USED YET
  # local after_block_files=( $(find1 $step -regex '.*/after-block.*') ) || fail
  # local after_block_file
  # begin_for after_block_file in "${after_block_files[@]}"; doo
  #   # recursive
  #   execute_command_step "$after_block_file" || fail
  # end_for

end_function_flat
handle_return
}

setup_default_each_handler() {
  handle_step_loop() {

  begin_function_flat

    if [[ ! -v $ref_group ]]; then
      # nothing to do if there are no values
      succeed
    fi

    local v a
    eval "a=( \"\${$ref_group[@]:-}\" )"

    if [[ ! "$a" ]]; then
      # nothing to do if there are no values
      succeed
    fi

    local parallel=f
    if [[ "${#a[*]}" -gt 1 ]]; then
      if [[ "$parallel_execution" == t && $serial == f ]]; then
        parallel=t
        wait_for_low_load || fail
      fi
    fi

    local processes= leave_loop=0
    begin_for v in "${a[@]}"; doo
      eval "$ref=\$v" || fail
      if [[ $parallel == t ]]; then
        execute_command_step_plain_folder &
        after_fork
        processes+=" $!"
      else
        execute_command_step_plain_folder || fail
        if [[ $leave_loop -gt 0 ]]; then
          let leave_loop-- || true
          break
        fi
      fi
    end_for

    wait_for_sub_processes || fail

  end_function_flat 
  handle_return

  }
}

# may be run in a subshell
execute_command_step_plain_folder() {
local step=$step
vars=step; begin_function

  local contents=( $(find1 $step -not -name ".*" -not -name "*-before*" -not -name "after-block*" | sort -g) ) || fail 
  local files i=0 file_index
  [[ ! "${contents:-}" ]] && succeed

  begin_loop

    files=( ${contents[$i]} )
    if [[ $files =~ ([0-9]+)-[^/]*$ ]]; then
      file_index=${BASH_REMATCH[1]}
    else
      file_index=-1
    fi

    gather_files_with_same_index || fail

    local parallel=f
    if [[ "${#files[*]}" -gt 1 ]]; then
      if [[ "$parallel_execution" == t ]]; then
        parallel=t
        wait_for_low_load || fail
      fi
    fi

    local processes= leave_loop=0
    begin_for step in "${files[@]}"; doo
      if [[ $parallel == t ]]; then
        # recursive
        execute_command_step $step &
        after_fork
        processes+=" $!"
      else
        # recursive
        execute_command_step $step || fail
        if [[ $leave_loop -gt 0 ]]; then
          break
        fi
      fi
    end_for

    wait_for_sub_processes || fail

    let i++ || true
    [[ $i -ge ${#contents[*]} ]] && break

    if [[ $leave_loop -gt 0 ]]; then
      let leave_loop-- || true
      break
    fi

  end_loop

end_function
handle_return
}

gather_files_with_same_index() {
begin_function_flat
  local next_file_index=$file_index next_file n=$i
  begin_loop
    let n++ || true
    [[ $n -ge ${#contents[*]} ]] && break
    next_file=${contents[$n]}
    if [[ $next_file =~ ([0-9]+)-[^/]*$ ]]; then
      next_file_index=${BASH_REMATCH[1]}
    else
      next_file_index=-1
    fi
    if [[ $next_file_index == $file_index ]]; then
      files+=( $next_file )
      let i++ || true
    else
      break
    fi
  end_loop
end_function_flat
handle_return
}

# input: $* = cell values in dim order
# output: cell_node = string path to cell from cell path
get_cell_node() {
local v i=0 d
cell_node=
for v in "$@"; do
  d=${cell_dims[$i]}
  get_sane_value "$v"
  v=$sane_value
  cell_node+=/dim/$d/$v
  let i++ || true
done
}

# input: $* = cell values in dim order
# output: cell_id = string cell id
get_cell_id() {
local v
cell_id=
for v in "$@"; do
  get_sane_value "$v"
  v=$sane_value
  cell_id+=_$v
done
cell_id=${cell_id#_}
}

get_cell_path() {
local subject=$1
cell_path=
if [[ -d $subject/.cyto || -d $subject/.dna ]]; then
  cell_path=$subject
else
  subject=${subject%/*}
  if [[ "$subject" =~ / ]]; then
    get_cell_path $subject
  fi
fi
}

handle_secure_edit() {
local vars=; begin_function

  local unsafe_file=${file%.safe}
  local new_unsafe_file=$tmp_path/$unsafe_file.new
  local old_unsafe_file=$tmp_path/$unsafe_file.old

  if [[ -f $new_unsafe_file ]]; then
    err "$new_unsafe_file already exists, delete that first if you want to edit $file"
    fail1
  fi

  defer "rm $new_unsafe_file"
  defer "rm $old_unsafe_file"

  if [[ -f $old_file ]]; then
    from=$old_file to=$old_unsafe_file decrypt_file || fail
    cp $old_unsafe_file $new_unsafe_file || fail
  fi

  if [[ "$content" ]]; then
    echo "$content" >$new_unsafe_file || fail
  else
    $EDITOR $new_unsafe_file || fail
  fi

  if [[ -f $old_unsafe_file ]]; then
    if files_are_different $old_unsafe_file $new_unsafe_file >/dev/null; then
      changed=t
    else
      trace $log_trace "No change"
      rm $new_unsafe_file || fail
    fi
  else
    changed=t
  fi

  if [[ $changed == t ]]; then
    from=$new_unsafe_file to=$new_file encrypt_file || fail
    mv $new_file $old_file || fail
    update_modify_times "${new_file%/*}" "${current_cell}" || fail
  fi

end_function
handle_return
}

handle_insecure_edit() {
local vars=; begin_function

  if [[ -f $old_file ]]; then
    cp $old_file $new_file || fail 
  fi

  if [[ "$content" ]]; then
    echo "$content" | trim_nl >$new_file || fail
  else
    $EDITOR $new_file || fail
  fi

  if [[ -f $old_file ]]; then
    if files_are_different $old_file $new_file >/dev/null; then
      changed=t
    else
      trace 0 "No change"
      rm $new_file || fail
    fi
  else
    changed=t
  fi

  if [[ $changed == t ]]; then
    mv $new_file $old_file || fail
    update_modify_times "${new_file%/*}" "$cell_path" || fail
  fi

end_function
handle_return
}

# will set top_cell, which will be empty if no cell cells are found
get_top_cell() {
local subject=$1
top_cell=
get_top_cell2 $subject || return 1
return 0
}

get_top_cell2() {
local subject=$1
local parent=${subject%/*}
if [[ -e $subject/.dna ]]; then
  top_cell=$subject
fi
if [[ ${#parent} -gt 1 ]]; then
  # recursive
  get_top_cell2 $parent || return 1
fi
return 0
}

# will set bottom_cell, which will be empty if no cell cells are found
get_bottom_cell() {
local subject=$1
bottom_cell=
get_bottom_cell2 $subject || return 1
return 0
}

get_bottom_cell2() {
local subject=$1
local parent=${subject%/*}
if [[ -e $subject/.dna ]]; then
  bottom_cell=$subject
elif [[ ${#parent} -gt 1 ]]; then
  # recursive
  get_bottom_cell2 $parent || return 1
fi
return 0
}

init_context() {

  # required_freshness:
  #   inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
  #   1w means refresh if it's older than a week.
  # shuffle_chance:
  #   chance out of 1000 of not following the computed strategy order
  # min_pause:
  #   number of ms to wait between cycles
  #   this number doubles each time there is nothing to do, until it reaches max_pause

  default_freshness=${default_freshness:-} \
  required_freshness=${required_freshness:-${fresh:-$default_freshness}} \
  retry_max=1 \
  retry_delay=1 \
  retry_scale=2 \
  cell_expiration= \
  cell_is_persistent=f \
  default_strategies=crl \
  shuffle_chance=100 \
  lock_timeout=${lock_timeout:-30} \
  pre_validate=f \
  post_validate=f \
  min_pause=250 \
  current_pause=250 \
  max_pause=60000 \
  in_path= \
  out_path= 
}

# input must be a folder
setup_cell_path_vars() {
cell_path=$1
begin_function_flat

  if [[ ! "${top_cell:-}" ]]; then
    get_top_cell $cell_path || fail
  fi

  dna_path=$cell_path/.dna \
    cyto_path=$cell_path/.cyto \
    short_cell=${cell_path#$top_cell/} \
    command_path=$cyto_path/command

  if [[ -d $dna_path/key ]]; then
    key_path=$dna_path/key
  else
    key_path=
  fi

  op_path=$dna_path/op

  up_path=$dna_path/up
  if [[ ! -d $up_path ]]; then
    up_path=
  fi

  down_path=$cyto_path/down
  if [[ ! -d $down_path ]]; then
    down_path=
  fi

  sub_path=$dna_path/sub
  if [[ ! -d $sub_path ]]; then
    sub_path=
  fi

  # context can override these as needed
  # could be a relative path
  in_path=${in_path:-}
  if [[ "$in_path" && "$in_path" != /* ]]; then
    in_path=$cell_path/$in_path
  fi

  out_path=${out_path:-}
  if [[ "$out_path" && "$out_path" != /* ]]; then
    out_path=$cell_path/$out_path
  fi

  status_path=$cyto_path/status
  if [[ ! -d $status_path ]]; then
    status_path=
  fi

  debug_path=$cyto_path/debug
  if [[ ! -d $debug_path ]]; then
    debug_path=
  fi

  req_path=$cyto_path/req
  if [[ ! -d $req_path ]]; then
    req_path=
  fi

  log_path=$cyto_path/log
  if [[ ! -d $log_path ]]; then
    log_path=
  fi

  job_path=$cyto_path/job
  if [[ ! -d $job_path ]]; then
    job_path=
  else
    log_path=$job_path/current/log
  fi

  cell_tmp_path=$cyto_path/tmp
  if [[ ! -d $cell_tmp_path ]]; then
    cell_tmp_path=
  fi

end_function_flat
handle_return
}

update_cell_value_file() {
begin_function_flat
  if [[ "${cell_values:-}" && ! -f $cell_path/cell_values ]]; then
    local v s='cell_values=( '
    for v in "${cell_values[@]}"; do
      s+="\"$v\" "
    done
    s+=')'
    echo "$s" >$cell_path/cell_values || fail
  fi
end_function_flat
handle_return
}

get_cell() {
cell_path=$1
[[ ${#cell_path} -lt 3 ]] && return 1
[[ -d $cell_path/.dna ]] && return 0
[[ -d $cell_path/.cyto ]] && return 0
get_cell ${cell_path%/*} || return 1
return 0
}

setup_tmp_path() {
if [[ ! "$tmp_path" ]]; then
  err "Missing tmp_path. Maybe you needed to run setup_cell_path_vars first"
  return 1
fi
if [[ ! -d $tmp_path ]]; then
  mkdir -p $tmp_path || return 1
fi
return 0
}

# params: $1 (subject)
# output: workspace
get_workspace() {
local subject=$1
workspace=
while [[ ${#subject} -gt 1 && $subject =~ / ]]; do
  if [[ "$subject" == "$top_cell"/* ]]; then
    workspace=$subject
    break
  fi
  subject=${subject%/*}
done
[[ "$workspace" ]]
}

get_tmp_path() {
local current_cell=$1
if [[ -d $current_cell/tmp ]]; then
  tmp_path=$current_cell/tmp
elif [[ -d ~/tmp ]]; then
  tmp_path=~/tmp
else
  tmp_path=/tmp
fi
return 0
}

# inputs: from to tmp_path current_cell
# will write output to file at $to
decrypt_file() {

local from=$from
local to=$to
local tmp_path=$tmp_path
local key_path=$key_path
local user_private_key=${user_private_key:-~/.ssh/id_rsa}

trace $log_trace "Decrypting $from to $to"
local vars=; begin_function

  if [[ ! -f "$user_private_key" ]]; then
    err "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
    err "You may create one using: ssh-keygen -mPEM"
    fail1
  fi

  if [[ ! "$tmp_path" ]]; then
    err "tmp_path must be set to a directory before calling decrypt_file."
    fail1
  fi

  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || fail
  fi

  if [[ ! -d "$key_path" ]]; then
    err "key_path must be set before calling decrypt_file"
    fail1
  fi

  if [[ ! -d $key_path ]]; then
    mkdir $key_path || fail
  fi

  if [[ ! -f "$key_path/key.$USER" ]]; then
    err "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
    find -L $key_path -name "key.*" >&2
    fail1
  fi

  # extract the main key
  if ! openssl pkeyutl -decrypt -inkey $user_private_key -in "$key_path/key.$USER" -out $tmp_path/main; then
    err "Failed to decrypt main key." 
    fail1
  fi
  defer "rm $tmp_path/main"

  # decrypt the secret file
  if ! openssl enc -aes256 -pbkdf2 -in $from -out $to -d -pass file:$tmp_path/main; then 
    err "Failed to decrypt secret file." 
    fail1
  fi

end_function
handle_return

}

encrypt_file() {

local from=$from
local to=$to
local tmp_path=$tmp_path
local key_path=$key_path
local user_private_key=${user_private_key:-~/.ssh/id_rsa}

trace $log_trace "Encrypting $from to $to"
local vars=; begin_function

  if [[ ! -f "$user_private_key" ]]; then
    err "Private key is missing. Set path to it with user_private_key env var, or put it here: $user_private_key"
    err "You may create one using: ssh-keygen -mPEM"
    fail1
  fi

  if [[ ! "$tmp_path" ]]; then
    err "tmp_path must be set to a directory before calling decrypt_file."
    fail1
  fi

  if [[ ! -d $tmp_path ]]; then
    mkdir -p $tmp_path || fail
  fi

  if [[ ! -d "$key_path" ]]; then
    err "key_path must be set before calling decrypt_file"
    fail1
  fi

  if [[ ! -d $key_path ]]; then
    mkdir $key_path || fail
  fi

  if [[ ! -f "$key_path/key.$USER" ]]; then

    local key_count=$(find -L $key_path -mindepth 1 -maxdepth 1 -name 'key.*' -type f | wc -l)

    if [[ $key_count -gt 0 ]]; then

      err "You don't have a key for this cell ($USER). Ask someone who does to add you. Existing keys:" 
      find -L $key_path -name "key.*" >&2
      fail1

    else

      trace $log_info "There are no keys for this cell yet. Will create a new key."

      # create a new main key
      if ! openssl rand -base64 40 >$tmp_path/main; then
        err "Failed to generate new main key."
        fail1
      fi
      defer "rm $tmp_path/main"

      # create a compatible public key from the user's private key
      if ! openssl pkey -in $user_private_key -out $tmp_path/public -pubout; then 
        err "Failed to convert private key to public key."
        fail1
      fi

      # encrypt main key with given user key
      if ! openssl pkeyutl -encrypt -pubin -inkey $tmp_path/public -in $tmp_path/main -out $key_path/key.$USER; then
        err "Failed to encrypt main key."
        fail1
      fi

    fi
  else 
    # extract the main key
    if ! openssl pkeyutl -decrypt -inkey $user_private_key -in $key_path/key.$USER -out $tmp_path/main; then
      err "Failed to decrypt main key." 
      fail1
    fi

    defer "rm $tmp_path/main"
  fi
    
  # encrypt the file with main key
  if ! openssl enc -aes256 -pbkdf2 -in $from -out $to -pass file:$tmp_path/main; then
    err "Failed to create new secret file."
    fail1
  fi

end_function
handle_return

}

# input: 
#   $1=dim
#   function=function to execute for each member
#   fork_function=whether the process should be forked before executing 
#     the function. (optional)
for_each_member() {
local dim=$1 parallel=f multi_cell=f \
  member sane_value processes= \
  function=$function finished=f \
  fork_function=${fork_function:-t}

local vars=dim; begin_function

  expand_values || fail

  if [[ "${#values[*]}" -gt 1 ]]; then
    multi_cell=t
    if [[ "$parallel_execution" == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi
  fi

  begin_for member in "${values[@]}"; doo

    eval "local $dim='$member' d_$dim='$member'"

    if [[ $parallel == t ]]; then
      $function &
      after_fork
      processes+=" $!"
    else
      if [[ $fork_function == t ]]; then
        ( $function ) || { after_fork; fail1; }
        after_fork
      else
        $function || fail
      fi
    fi

    if [[ $finished == t ]]; then
      break
    fi

  end_for

  wait_for_sub_processes || fail

end_function
handle_return
}

# dim vars and functions should be set before this is called
# will construct cell_values array with current set of values of the
#   cell dims, which can be used in branch or leaf functions
for_each_cell() {

local leaf_function=${leaf_function:-} \
  branch_function=${branch_function:-} \
  fork_leaves=${fork_leaves:-t} \
  cell_values=( ) \
  multi_cell=${multi_cell:-f} \
  multi_cell=${multi_cell:-f} \
  remaining_cell_dims=( "$@" ) 

if [[ "${remaining_cell_dims:-}" ]]; then
  local finished=f
  cell_pivot "${remaining_cell_dims[@]}" || return 1
else
  if [[ "$leaf_function" ]]; then
    if [[ $fork_leaves == t ]]; then
      ( $leaf_function ) || { after_fork; return 1; }
      after_fork
    else
      $leaf_function || return 1
    fi
  fi
  if [[ "$branch_function" ]]; then
    $branch_function || return 1
  fi
fi
}

# check if the dim exists before calling this
# other inputs: function
# *sometimes* runs as a subshell
cell_pivot() {

local -r remaining_cell_dims=( "$@" ) 
local -r dim=$remaining_cell_dims
local values=() \
  cell_values=( "${cell_values[@]}" ) \
  processes= 

begin_function_flat

  expand_values || fail
  cell_pivot_values || fail

end_function_flat
handle_return

}

# input: dim
# output: values 
expand_values() {
begin_function_flat

  local dims=${dim}s \
        new_value_list= new_values= value \
        has_member_expand_function=f

  values=( ${!dim:-} )
  type -t ${dim}_member_expand >/dev/null && has_member_expand_function=t

  if [[ ! "${values:-}" ]]; then
    expand_values_plural || fail
  else
    expand_values_single || fail
  fi

  values=( $new_value_list )

end_function_flat
handle_return
}

expand_values_single() {

begin_function_flat

  if [[ "${#values[*]}" -gt 1 ]]; then
    err "Too many values for a singular dim $dim." \
      "Use plural dim $dims if you intend to have multiple values."
    fail1
  fi

  if [[ $has_member_expand_function == t ]]; then
    value=$values ${dim}_member_expand || fail
    if [[ ! "${values:-}" ]]; then
      err "Dim $dim has invalid value '$value'"
      fail1
    fi
    if [[ "${#values[*]}" -gt 1 ]]; then
      err "Too many values for a singular dim $dim." \
        "Use plural dim $dims if you intend to have multiple values."
      fail1
    fi
  fi

  new_value_list="$values"

end_function_flat
handle_return

}

expand_values_plural() {

begin_function_flat

  values=( ${!dims:-} )

  if [[ ! "${values:-}" ]]; then

    if [[ $has_member_expand_function == t ]]; then
      value= ${dim}_member_expand || fail
      new_values=( "${values[@]}" )
    else
      err "Missing value for dimension: $RESET$dim"
      fail1
    fi

  else

    if [[ $has_member_expand_function == t ]]; then
      begin_for value in "${values[@]}"; doo
        value=$value ${dim}_member_expand || fail
        if [[ ! "${values:-}" ]]; then
          err "Dim $dims has invalid value '$value'"
          fail1
        fi
        new_values+=( "${values[@]}" )
      end_for
    else
      new_values=( "${values[@]}" )
    fi

  fi

  # remove duplicate values
  local new_value
  for new_value in "${new_values[@]}"; do
    if [[ ! $new_value_list =~ \ $new_value\  ]]; then
      new_value_list+=" $new_value "
    fi
  done

end_function_flat
handle_return
}

# input: values (array)
cell_pivot_values() {
begin_function_flat

  local parallel=f \
        go_deeper=t 
  if [[ "${#values[*]}" -gt 1 ]]; then
    multi_cell=t
    if [[ "$parallel_execution" == t ]]; then
      parallel=t
      wait_for_low_load || fail
    fi
  fi

  local value sane_value processes=

  cell_values+=( only )

  begin_for value in "${values[@]}"; doo

    eval "local $dim='$value' d_$dim='$value'"
    cell_values[-1]=$value

    if [[ "$branch_function" ]]; then
      $branch_function || fail
    fi

    if [[ $finished == t ]]; then
      break
    fi

    if [[ ${#remaining_cell_dims[*]} -gt 1 
       && $go_deeper == t
       ]]; then

      if [[ $parallel == t ]]; then
        # recursive
        cell_pivot "${remaining_cell_dims[@]:1}" &
        after_fork
        processes+=" $!"
      else
        # recursive
        cell_pivot "${remaining_cell_dims[@]:1}" || fail
      fi

    else

      if [[ "$leaf_function" ]]; then
        if [[ $parallel == t ]]; then
          $leaf_function &
          after_fork
          processes+=" $!"
        else
          if [[ $fork_leaves == t ]]; then
            ( $leaf_function ) || { after_fork; fail1; }
            after_fork
          else
            $leaf_function || fail
          fi
        fi
      fi

    fi

  end_for

  wait_for_sub_processes || fail

end_function_flat
handle_return
}

get_sane_value() {
local -r value=$1
if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
  sane_value=$value
else
  hash=$(echo "$value" | cksum -a md5 | awk '{ print $4 }')
  sane_value=${hash:0:8}
fi
return 0
}

# input: parallel processes
wait_for_sub_processes() {
if [[ "$processes" ]]; then
  trace $log_info "Waiting for sub processes to complete"
  local process last_err_code= last_failed_process= rc
  for process in $processes; do
    trace $log_trace "Waiting for process $process"
    wait $process &>/dev/null; rc=$?
    if [[ $rc -gt 0 && $rc -lt 127 ]]; then
      if [[ ! "$last_err_code" ]]; then
        last_err_code=$rc
        last_failed_process=$process
      else
        trace $log_warn "Subprocess $process failed to terminate successfully"
        return 1
      fi
    fi
  done
  if [[ "$last_err_code" ]]; then
    if [[ "$last_err_code" == 1 ]]; then
      trace $log_warn "Subprocess $last_failed_process failed to terminate successfully"
      return 1
    fi
    return $last_err_code
  fi
  processes=
fi
return 0
}

wait_for_low_load() {
local cell_max_load=${cell_max_load:-10}
local cell_load_wait_timeout=${cell_load_wait_timeout:-600}
local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
if [[ $current_load -gt $cell_max_load ]]; then
  trace $log_warn "Load average is too high ($current_load > $cell_max_load)," \
    "waiting until things cool down first."
  local time_waited=0
  while [[ $current_load -gt $cell_max_load ]]; do
    current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
    sleep 5; let time_waited+=5
    if [[ "$cell_load_wait_timeout" -gt 0 && $time_waited -ge $cell_load_wait_timeout ]]; then
      err "Timed out waiting for cpu load to be low enough. Aborting"
      return 1
    fi
  done
fi
return 0
}

is_cell() {
[[ -d "$1/.dna" ]]
}

is_inside_of_cell() {
local c=$1
if [[ $c == "$top_cell"/* ]]; then
  while [[ $c == "$top_cell"/* ]]; do
    if [[ -d $c/.dna ]]; then
      return 0
    fi
    c=${c%/*}
  done
else
  while [[ $c == /*/* ]]; do
    if [[ -d $c/.dna ]]; then
      return 0
    fi
    c=${c%/*}
  done
fi
return 1
}

setup_dims() {
local dim dim_var dim_var_plural cell=$1
leaf_dims=( )
localize_dim_vars=
if [[ -d $cell/.dna/dim ]]; then
  for dim in $(find1 $cell/.dna/dim -not -name ".*" | sort -g); do
    source $dim || return 1
    dim_var=${dim##*/}
    if [[ $dim_var =~ [0-9]+-(.*) ]]; then
      dim_var=${BASH_REMATCH[1]}
    fi
    dim_var_plural=${dim_var}s
    leaf_dims+=( $dim_var )
    localize_dim_vars+="local $dim_var=\${$dim_var:-} $dim_var_plural=\${$dim_var_plural:-}; "
  done
fi

sub_dims=( )
if [[ -d $cell/.dna/sub-dim ]]; then
  for dim in $(find1 $cell/.dna/cell-dim -not -name ".*" | sort -g); do
    source $dim || return 1
    dim_var=${dim##*/}
    if [[ $dim_var =~ [0-9]+-(.*) ]]; then
      dim_var=${BASH_REMATCH[1]}
    fi
    dim_var_plural=${dim_var}s
    sub_dims+=( $dim_var )
    localize_dim_vars+="local $dim_var=\${$dim_var:-} $dim_var_plural=\${$dim_var_plural:-}; "
  done
fi
}

load_parent_context() { 
local cell=$1
local parent=${cell%/*}
if [[ ${#parent} -gt 1 ]]; then
  load_parent_context $parent || return 1
fi
if [[ -f $cell/.dna/context ]]; then
  source $cell/.dna/context || return 1
fi
return 0
}

# Used by the help system to describe a command and it's parameters to the user
new_command() {
local name=$name description=$description
command_description=$description
parameter_names=( )
parameter_descriptions=( )
parameter_defaults=( )
}

add_parameter() {
local name=$name description=$description default=${default:-}
parameter_names+=( "$name" ) 
parameter_descriptions+=( "$description" ) 
parameter_defaults+=( "$default" ) 
}

after_fork() {
let log_id+=100 || true
let debug_id+=1000 || true
}

dir_is_empty() {
local content=( "$1"/* )
[[ ! -e $content ]]
}

