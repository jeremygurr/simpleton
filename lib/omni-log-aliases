#!/usr/bin/env bash

debug_id_current=0
debug_id_inc() {
  (( debug_id_current++ ))
  if [[ ${debug_id_out:-f} == t ]]; then
    out " $CYAN(debug_id=$debug_id_current)$RESET"
  fi
  if [[ "${debug_id:-}" && $debug_id != t && $debug_id_current -ge $debug_id ]]; then
    if [[ "${debug_debug:-}" == t ]]; then
      log_debug_debug "debug_id matched: $debug_id" >&$fd_original_err
    fi
    debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_id=t
    debug_immediate=t
    debug_start 
  elif [[ "${debug_quick_function:-}" && $debug_quick_function == ${FUNCNAME[1]} ]]; then
    if [[ "${debug_debug:-}" == t ]]; then
      log_debug_debug "debug_quick_function matched: $debug_quick_function" >&$fd_original_err
      show_array FUNCNAME
    fi
    debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_quick_function=
    debug_immediate=t
    debug_start 
  fi
}

setup_log_block_aliases() {

  alias begin_function_hi='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=2
    write_to_log_and_save 
    (( log_depth_current++ ))
    log_vars= log_show_vars=
    warm_stack+=( "${FUNCNAME[0]} debug_id=$((debug_id_current+1))" )
    debug_id_inc
    while true; do
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
  '

  alias begin_function='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=1
    warm_stack+=( "${FUNCNAME[0]} debug_id=$((debug_id_current+1))" )
    debug_id_inc
    while true; do
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
  '
    
  alias begin_function_lo='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=0
    warm_stack+=( "${FUNCNAME[0]} debug_id=$((debug_id_current+1))" )
    debug_id_inc
    while true; do
  '

  alias end_function='
    (( no_trace_depth++ ))
    break; done;
    unset warm_stack[-1]
    debug_id_inc
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
  '

  alias handle_return='
    (( no_trace_depth++ ))
    case $function_level in
      2)
        load_log_vars_and_write_to_log
        (( log_depth_current-- ))
      ;;
      0)
        if (( no_trace_depth-- <= 0 )); then 
          no_trace_depth=0
        fi
      ;;
    esac
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
    return $return_value
  '

  alias begin_while='break_out=f; while'
  alias   begin_for='break_out=f; for'
  alias  begin_loop='break_out=f; while true; do'
  alias   end_while='debug_id_inc; done; [[ $break_out == t ]] && break'
  alias     end_for='debug_id_inc; done; [[ $break_out == t ]] && break'
  alias    end_loop='debug_id_inc; done; [[ $break_out == t ]] && break'

  alias handle_exit='exit $return_value'

}

setup_log_block_aliases

