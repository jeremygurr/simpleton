#!/usr/bin/env bash

debug_id_current=0
debug_id_inc() {
  (( debug_id_current++ ))
  if [[ ${debug_id_out:-f} == t ]]; then
    out " $CYAN(debug_id=$debug_id_current)$RESET"
  fi
  if [[ "${trace_var:-}" ]]; then
    local v
    if [[ -v $trace_var ]]; then
      v=${!trace_var}
    else
      v='(unbound)'
    fi
    if [[ "${trace_var_old:-}" != "$v" ]]; then
      echo "${CYAN}debug_id=$debug_id_current $trace_var=$v$RESET" >&$fd_original_err
    fi
    trace_var_old=$v
  fi
  if [[ "${debug_id:-}" && $debug_id != t && $debug_id_current -ge $debug_id ]]; then
    if [[ "${debug_debug:-}" == t ]]; then
      log_debug_debug "debug_id matched: $debug_id" >&$fd_original_err
    fi
    debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_id=t
    debug_immediate=t
    debug_start 
  elif [[ "${debug_quick_function:-}" && $debug_quick_function == ${FUNCNAME[1]} ]]; then
    if [[ "${debug_debug:-}" == t ]]; then
      log_debug_debug "debug_quick_function matched: $debug_quick_function" >&$fd_original_err
      show_array FUNCNAME
    fi
    debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_quick_function=
    debug_immediate=t
    debug_start 
  fi
}

setup_log_block_aliases() {

  alias begin_function_hi='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=2
    write_to_log_and_save 
    (( log_depth_current++ ))
    log_vars= log_show_vars=
    warm_stack+=( "${FUNCNAME[0]} debug_id=$((debug_id_current+1))" )
    debug_id_inc
    while true; do
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
  '

  alias begin_function='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=1
    warm_stack+=( "${FUNCNAME[0]} debug_id=$((debug_id_current+1))" )
    debug_id_inc
    while true; do
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
  '
    
  alias begin_function_lo='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=0
    warm_stack+=( "${FUNCNAME[0]} debug_id=$((debug_id_current+1))" )
    debug_id_inc
    while true; do
  '

  alias end_function='
    (( no_trace_depth++ ))
    break; done;
    unset warm_stack[-1]
    debug_id_inc
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
  '

  alias handle_return='
    (( no_trace_depth++ ))
    case $function_level in
      2)
        load_log_vars_and_write_to_log
        (( log_depth_current-- ))
      ;;
      0)
        if (( no_trace_depth-- <= 0 )); then 
          no_trace_depth=0
        fi
      ;;
    esac
    (( --no_trace_depth == 0 && tracing_depth > 0 )) && set -x
    return $return_value
  '

  alias begin_while='break_out=f; while'
  alias   begin_for='break_out=f; for'
  alias  begin_loop='break_out=f; while true'
  alias   end_while='done; debug_id_inc; [[ $break_out == t ]] && break'
  alias     end_for='done; debug_id_inc; [[ $break_out == t ]] && break'
  alias    end_loop='done; debug_id_inc; [[ $break_out == t ]] && break'

  alias handle_exit='exit $return_value'

  # to avoid bash syntax parsing problems, and provide a hook for loop beginning
  alias         doo='do debug_id_inc;'

}

setup_log_block_aliases

