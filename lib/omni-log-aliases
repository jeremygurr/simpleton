#!/usr/bin/env bash

debug_id_current=0
debug_id_inc() {
  (( no_trace_depth++ ))
  (( debug_id_current++ ))
  if [[ ${show_debug_id:-f} == a ]]; then
    out -n " $CYAN$debug_id_current$RESET"
  fi
  if [[ "${trace_var:-}" ]]; then
    local v
    if [[ ! $trace_var =~ ^[a-zA-Z_0-9]+$ ]]; then
      set +u
      eval "v=$trace_var"
      set -u
    elif is_array $trace_var; then
      eval "v=\"( \${$trace_var[*]:0:10} )\""
    elif [[ -v $trace_var ]]; then
      v=${!trace_var}
    else
      v='(unbound)'
    fi
    if [[ "${trace_var_old:-}" != "$v" ]]; then
      echo "${CYAN}debug_id=$debug_id_current $trace_var=$v$RESET" >&$fd_original_err
    fi
    trace_var_old=$v
  fi
  if [[ "${debug_id:-}" && $debug_id != t && $debug_id_current -ge $debug_id ]]; then
    if [[ "${debug_debug:-}" == t ]]; then
      log_debug_debug "debug_id matched: $debug_id" >&$fd_original_err
    fi
    debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_id=t
    debug_start o
  elif [[ "${debug_quick_function:-}" && $debug_quick_function == ${FUNCNAME[1]} ]]; then
    if [[ "${debug_debug:-}" == t ]]; then
      log_debug_debug "debug_quick_function matched: $debug_quick_function" >&$fd_original_err
      show_array FUNCNAME
    fi
    debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_function_old=$debug_quick_function
    debug_quick_function=
    debug_immediate=t
    debug_start o
  fi
  (( no_trace_depth-- ))
}

trace_time_summarize() {
  eval "exec $trace_time_fd>&-"
  trace_time_fd=
  echo "$hbar_equals"
  echo "trace_time summary by function instance sorted by name:$NL"
  sort -k2 $trace_time_log

  echo "$hbar_equals"
  echo "trace_time summary by function instance sorted by time:$NL"
  sort -n $trace_time_log
}

setup_log_block_aliases() {

  : ${trace_time:=f}

  alias trace_time_open='
    if [[ $trace_time == t ]]; then
      if [[ ! ${trace_time_fd:-} ]]; then
        : ${trace_time_log:=/tmp/trace_time.log}
        exec {trace_time_fd}<>$trace_time_log
      fi
      trace_time_start=${EPOCHREALTIME/./}
    fi
  '

  alias trace_time_close='
    if [[ $trace_time == t && "${trace_time_fd:-}" ]]; then
      local trace_time_stop=${EPOCHREALTIME/./} d
      (( d = trace_time_stop - trace_time_start ))
      echo "$d$TAB$FUNCNAME${TAB}${TAB}debug_id=$debug_id_current" >&$trace_time_fd
    fi
  '

  alias begin_function_hi='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=2 trace_time_start
    write_to_log_and_save 
    (( log_depth_current++ ))
    log_vars= log_show_vars=
    warm_stack+=( "raw_stack_id=${#BASH_SOURCE[*]} debug_id=$((debug_id_current+1)) function=${FUNCNAME[0]}" )
    trace_time_open
    debug_id_inc
    while true; do
    (( no_trace_depth-- ))
  '

  alias begin_function='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=1 trace_time_start
    warm_stack+=( "raw_stack_id=${#BASH_SOURCE[*]} debug_id=$((debug_id_current+1)) function=${FUNCNAME[0]}" )
    trace_time_open
    debug_id_inc
    while true; do
    (( no_trace_depth-- ))
  '
    
  alias begin_function_lo='
    (( no_trace_depth++ ))
    local return_value=0 break_out=f function_level=0
    warm_stack+=( "raw_stack_id=${#BASH_SOURCE[*]} debug_id=$((debug_id_current+1)) function=${FUNCNAME[0]}" )
    debug_id_inc
    while true; do
  '

  alias end_function='
    (( no_trace_depth++ ))
    break; done;
    local log_return_vars=
    unset warm_stack[-1]
    debug_id_inc
    (( no_trace_depth-- ))
  '

  alias handle_return='
    (( no_trace_depth++ ))
    case $function_level in
      1|2)
        trace_time_close
        if [[ $function_level == 2 ]]; then
          load_log_vars_and_write_to_log
          (( log_depth_current-- ))
        fi
      ;;
      0)
        if (( no_trace_depth-- <= 0 )); then 
          no_trace_depth=0
        fi
      ;;
    esac
    debug_return_vars=$log_return_vars
    (( no_trace_depth-- ))
    return $return_value
  '

  alias begin_while='break_out=f; while'
  alias   begin_for='break_out=f; for'
  alias  begin_loop='break_out=f; while true'
  alias   end_while='done; debug_id_inc; [[ $break_out == t ]] && break'
  alias     end_for='done; debug_id_inc; [[ $break_out == t ]] && break'
  alias    end_loop='done; debug_id_inc; [[ $break_out == t ]] && break'

  # end_while or end_for or end_loop should usually be used instead of this.
  # This is helpful though if the done part needs to be separated from the break part
  alias maybe_break='debug_id_inc; [[ $break_out == t ]] && break'

  alias handle_exit='exit $return_value'

  # to avoid bash syntax parsing problems, and provide a hook for loop beginning
  alias         doo='do debug_id_inc;'

  # This performs the same debug_id advancement that begin_function and others do,
  #   except unlike begin_function this may be placed anywhere within a function,
  #   providing a stopping point for debugging of larger blocks of code that otherwise
  #   can't be split up.
  alias fence='(( no_trace_depth++ )); debug_id_inc; (( no_trace_depth-- ))'
    
  log_var_entries_stack=()
  log_var_show_vars_stack=()

}

setup_log_block_aliases

