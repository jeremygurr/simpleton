#!/usr/bin/env bash

type -t grow_lib_loaded >/dev/null && return 0
grow_lib_loaded=t

check_foundation() {
  begin_function
    if [[ -f $dna_path/cell_is_foundation.var && ! -v cell_is_foundation ]]; then
      context_type= \
      prefix= \
      load_dna_item $dna_path/cell_is_foundation.var || fail
    fi

    if [[ $cell_path != */foundation/* 
       && -d $module_path/foundation/all 
       && ! -d $module_path/foundation/all/.cyto
       && ${cell_is_foundation:-f} == f
       ]]; then
      log_fatal "Foundation cells have not been updated, so update can't proceed. Update $module_path/foundation/all before attempting to update other cells."
      fail1
    fi
  end_function
  handle_return
}

# inputs:
#   lib_dim_path
#   cache_path
make_dim_cache() {
  begin_function

    log_debug "Generating dim cache for $lib_dim_path"

    if [[ -f $cache_path.new ]]; then
      rm $cache_path.new || fail
    fi

    local dim_paths dim_path dim context_file=$cache_path.new
    local -A dim_group=()
    dim_paths=$(find1 $lib_dim_path -type d -not -name ".*" | sort) || fail

    for dim_path in $dim_paths; do
      dim=${dim_path##*/}
      if [[ $dim == _* ]]; then
        local group_dims=
        get_group_dims $dim_path || fail
        dim_group[$dim]="$group_dims"
      else
        build_dim_info_single $dim_path || fail
      fi
    done

    write_vars_to_context \
      dim_group \
      secret_vars \
      all_dims \
      || fail

    mv $cache_path.new $cache_path || fail

  end_function
  handle_return
}

load_dim_caches() {
  local work_path=$1
  begin_function

    if [[ $work_path == /*/*/* ]]; then
      load_dim_caches ${work_path%/*} || fail
    fi

    local lib_dim_path=$work_path/.lib/dim

    if [[ -d $lib_dim_path ]]; then
      local dt files links link type is_generated \
        cache_path=$work_path/.lib/dim-cache \
        real_path real_path_parent \

      dim_caches+="$cache_path "

      if [[ ! -f $cache_path ]]; then
        fork make_dim_cache || fail
      fi

      source $cache_path || fail

    fi

  end_function
  handle_return
}

add_derive_from() {
  local required_dims=$required_dims optional_dims=${optional_dims:-} result

  result=$required_dims
  if [[ "$optional_dims" ]]; then
    result+="/$optional_dims"
  fi
  derive_from+=( "$tool $result" )
}

make_derive_cache_handle_function() {
  begin_function

    load_fun_to_code $derive_path derive_function_$name || fail
    eval "$code" || fail
    derive_functions+=( $name )
    write_to_context fun code || fail

    local fields=() derive_paths=()

    action=info \
    derive_function_$name || fail

    local derived_dim
    for derived_dim in ${fields[*]}; do

      local -n derive_from=dim_${derived_dim}_derived_from \
        key_functions=dim_${derived_dim}_key_functions \

      local is_key=f key_field_group
      for key_field_group in ${derive_paths[*]}; do

        local required_dims=$key_field_group \
          optional_dims= \
          target_dims= \

        if [[ "$required_dims" == *'->'* ]]; then
          target_dims=${required_dims#*->}
          required_dims=${required_dims%->*}
        else
          log_fatal "Wrong derive_path format: $key_field_group . This is generated in the info function in the file derive_$name.fun in the .lib/derive folder"
          log_fatal "The add_derive_path function should be being called in that info function to add the necessary paths."
          fail1
        fi

        if [[ "$required_dims" == */* ]]; then
          optional_dims=${required_dims#*/}
          required_dims=${required_dims%/*}
        fi

        if [[ ",${required_dims}," != *",$derived_dim,"* \
           && ",${optional_dims}," != *",$derived_dim,"* \
           && ",${target_dims},"   == *",$derived_dim,"* \
           ]]; then

          tool=${name}.fun \
          add_derive_from || fail

        fi

        if [[ "$required_dims" == "$derived_dim" \
           && ! "$optional_dims" \
           ]]; then
          is_key=t
        fi

      done

      if [[ $is_key == t ]]; then
        key_functions+=( $name )
      fi

    done

  end_function
  handle_return
}

# inputs:
#   lib_dt_path
#   cache_path
make_derive_cache() {
  begin_function

    log_verbose "Generating derive cache for $lib_dt_path"
    deriving_dims=t

    if [[ -f $cache_path.new ]]; then
      rm $cache_path.new || fail
    fi

    local context_file=$cache_path.new \
      type files \

    begin_for type in fun tab; doo

      if [[ $type == fun ]]; then
        files=$(find -L $lib_dt_path \( -type f -or -type l \) -not -name '.*' -name '*.fun' | sort -g) || fail
      else
        files=$(find -L $lib_dt_path \( -type f -or -type l \) -not -name '.*' -name '*.*tab' | sort -g) || fail
      fi

      local name code derive_path
      begin_for derive_path in $files; doo
        name=${derive_path##*/}
        name=${name%.*}
        name=${name#derive_}
        if [[ $type == fun ]]; then
          make_derive_cache_handle_function || fail
        else
          make_derive_cache_handle_table || fail
        fi
      end_for
    end_for

    write_vars_to_context derive_tables derive_functions || fail

    local dim
    for dim in ${!all_dims[*]}; do

      ignore_missing=t \
      write_vars_to_context \
        dim_${dim}_key_tables \
        dim_${dim}_key_functions \
        dim_${dim}_derived_from \
        dim_${dim}_narrowed_from \
        || fail

#        dim_${dim}_card_table \

      local -n member_type=dim_${dim}_member_type \
        dim_members=dim_${dim}_members \
        dim_derive_tables=dim_${dim}_derive_tables \

      if [[ ! -v dim_members ]]; then
        calc_missing_members || fail
      fi

      case ${member_type:-unset} in
        static|dynamic)
          :
        ;;
        unset)
          if [[ "${dim_members:-}" || "${dim_derive_tables:-}" ]]; then
            member_type=static
          else
            member_type=dynamic
          fi
        ;;
        *)
          log_fatal "Invalid value for member_type: $member_type defined for dim $dim"
          fail1
        ;;
      esac

      write_vars_to_context dim_${dim}_member_type || fail
       
    done

    if [[ -f $cache_path.new ]]; then
      mv $cache_path.new $cache_path || fail
    fi
    unset deriving_dims

  end_function
  handle_return
}
 
load_derive_caches() {
  local work_path=$1
  begin_function

    if [[ $work_path == /*/*/* ]]; then
      load_derive_caches ${work_path%/*} || fail
    fi

    local lib_dt_path=$work_path/.lib/derive

    if [[ -d $lib_dt_path ]]; then

      local dt files links link type is_generated \
        cache_path=$work_path/.lib/derive-cache \
        real_path real_path_parent \

      derive_caches+="$cache_path "

      if [[ ! -f $cache_path ]]; then
        fork make_derive_cache || fail
      fi

      source $cache_path || fail

    fi

  end_function
  handle_return
}

build_context() {
  local cell_path=$1
  begin_function

    load_dim_caches $cell_path || fail
    load_derive_caches $cell_path || fail

    if [[ ! -f $context_path-trunk ]]; then
      local trunk_context_path=$trunk_cell/.cyto/context
      if [[ $cell_is_trunk == t || ! -f $trunk_context_path-trunk ]]; then
        context_path=$trunk_cell/.cyto/context \
        build_context_trunk || fail
      else
        source $trunk_context_path-trunk || fail
      fi
      if [[ $cell_is_trunk == f ]]; then
        safe_link $trunk_context_path-trunk $context_path-trunk || fail
      fi
    else
      source $context_path-trunk || fail
    fi

    #  maybe not needed any more
    #setup_dims || fail

    if [[ ! -f $context_path-branch ]]; then
      build_context_branch || fail
    else
      source $context_path-branch || fail
    fi

    #  disabling seeding for now
    #if [[ "${trunk_dims_expanded:-}" ]]; then
    #  if [[ ! -f $context_path-branch-coords ]]; then
    #    build_branch_seed_coords || fail
    #  else
    #    source $context_path-branch-coords || fail
    #  fi
    #fi

    #  unused at the moment
    #if [[ $cell_is_leaf == t ]]; then
    #  if [[ ! -f $context_path-leaf ]]; then
    #    build_context_leaf || fail
    #  else
    #    source $context_path-leaf || fail
    #  fi
    #fi

    if [[ -e $context_path.new ]]; then
      rm $context_path.new || fail
    fi

    local dim_cache derive_cache

    begin_for dim_cache in ${dim_caches:-}; doo
      cat $dim_cache >>$context_path.new || fail
    end_for

    begin_for derive_cache in ${derive_caches:-}; doo
      cat $derive_cache >>$context_path.new || fail
    end_for

    if [[ -e $context_path-trunk ]]; then
      cat $context_path-trunk >>$context_path.new || fail
    fi

    local dim_type dim
    for dim_type in trunk_dims sub_dims control_props data_props; do
      local -n dim_array=${dim_type}_expanded
      for dim in ${dim_array[*]}; do
        get_unplural $dim dim
        local -n dt=dim_${dim}_type
        dt=$dim_type
        write_vars_to_context dim_${dim}_type || fail
      done
    done

    if [[ -e $context_path-branch ]]; then
      cat $context_path-branch >>$context_path.new || fail
    fi

    if [[ -e $context_path-leaf ]]; then
      cat $context_path-leaf >>$context_path.new || fail
    fi

    if [[ -e $context_path.new ]]; then
      mv $context_path.new $context_path || fail
    fi

  end_function
  handle_return
}

build_cyto() {
  local cell_path=$1

  begin_function

    log_debug "Building cyto for $short_cell"
    dna_path=$cell_path/.dna \
    cyto_path=$cell_path/.cyto \

    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    if [[ ! -d $status_path ]]; then
      mkdir $status_path || fail
    fi

    load_branch_info || fail
    find_seed_path $cell_path || fail

    if [[ ! -f $context_path ]]; then
      build_context $cell_path || fail
    fi

    local context_check_var_eval= c
    if [[ "${context_check_vars:-}" ]]; then
      for c in $context_check_vars; do
        local -n v=$c
        if [[ "${v:-}" ]]; then
          shell_quote_var v
          context_check_var_eval+="$c=$v"
        fi
      done
    fi

    if [[ ! -f $context_path-check ]]; then
      context_type=check \
      write_vars_to_context \
        out_file \
        out_path \
        check_op_var \
        data_props_expanded \
        default_freshness \
        context_check_vars \
        context_check_var_eval \
        || fail
      mv $context_path-check.new $context_path-check || fail
    fi

  end_function
  handle_return
}

grow_context() {
  cell_path=$1
  module_path=${cell_path#/*/*/}
  module_path=${cell_path%/$module_path}

  if [[ "${last_context_loaded:-}" != $cell_path ]]; then

    local log_show_vars=^cell_path rebuild_attempted=f
    begin_function

      get_short_cell
      log_debug "Growing context for $short_cell"

      if [[ "$cell_path" == /seed/* ]]; then
        log_fatal "Can't switch contexts to a seed path. Make sure to run this command in a work folder."
        fail1
      fi

      dna_path=$cell_path/.dna \
      cyto_path=$cell_path/.cyto \

      local dna_exists=f
      if [[ -e $dna_path ]]; then
        dna_exists=t
      fi

      if [[ $dna_exists == t ]]; then
        if [[ "${regrow_cells:-}" ]]; then
          local cell_to_regrow
          cells_already_regrown=${cells_already_regrown:-}
          if [[ " $cells_already_regrown " == *" $cell_path "* ]]; then
            log_debug "Cell already regrown: $cell_path"
          else
            begin_for cell_to_regrow in $regrow_cells; doo
              if [[ $cell_path == *$cell_to_regrow* ]]; then
                if [[ -e $cyto_path ]]; then
                  log_info "Cleaning cell ${cell_to_regrow#/work/*/} => $short_cell..."
                  rm -rf $cell_path/!(.*) $cyto_path || fail
                else
                  log_info "Cell already regrown: $cell_to_regrow => $short_cell"
                fi
                cells_already_regrown+=" $cell_path"
                break
              fi
            end_for
          fi
        fi
      fi

      context_path=$cyto_path/context
      init_context || fail

      seed_path=
      if [[ $dna_exists == t ]]; then

        #check_foundation || fail

        if [[ ! -f $context_path ]]; then
          fork build_cyto $cell_path || fail
        fi

        source $context_path || fail

        setup_dims || fail

        if [[ $cell_is_leaf == t && ! -d $up_path ]]; then

          local up_cell_type up_name
          begin_for up_cell_type in up validator reactor; doo
            local -n upstream_var=$up_cell_type
            if [[ -v upstream_var ]]; then
              make_cyto_up || fail
            fi
          end_for

        fi

        local problem_found=f
        broken_link_check || fail
        if [[ $problem_found == t ]]; then
          if [[ $rebuild_attempted == f ]]; then
            log_verbose "Problem found, rebuilding context"
            rm -rf $cyto_path/up* $context_path* || fail
            rebuild_attempted=t
            continue
          else
            log_fatal "Context rebuild failed to resolve problem"
            fail1
          fi
        fi
      fi

      load_post_context_dynamic_vars || fail

      last_context_loaded=$cell_path

      error_if_unresolved=t \
      handle_questions || fail

    end_function
    handle_return

  else
    log_debug "Context already loaded: $short_cell"
  fi

  return 0
}

plant_seed_internal() {
  local from=$1 to=$2 contents x x_part deep=${deep:-t} \
    cell_is_leaf=${cell_is_leaf:-t} key_path=${key_path:-} \

  begin_function

    if [[ ! -d $to ]]; then

      log_verbose "Planting seed from $from to $to"

      if [[ $from == /seed/* && -d $from ]]; then
        plant_seed_internal ${from%/*} ${to%/*} || fail
      else
        log_fatal "Seed doesn't exist for $to"
        fail1
      fi

    else

      contents=( $(find1 $from | sort -g) ) || fail
      local target
      begin_for x in ${contents[*]}; doo
        x_part=${x##*/}
        target=$to/$x_part
        if [[ -d $x ]]; then
          if [[ ! -e $target ]]; then

            # remove broken links
            if [[ -L $target ]]; then
              rm $target || fail
            fi

            if [[ $x_part == .dna || $x_part == .root ]]; then
              safe_link $(realpath $x) $to/ || fail
            elif [[ $x_part == .key ]]; then
              key_path=$x || fail
            elif [[ $x_part == .lib ]]; then
              mkdir $target || fail
              safe_link $(realpath $x)/* $target/ || fail
            elif [[ $x_part == .mock && "${current_mock:-f}" != f && -d $x/$current_mock ]]; then
              safe_link $(realpath $x)/$current_mock/!(export) $to/ || fail
            elif [[ $x_part == *:* ]]; then

              if [[ "${branch_coordinate_fields:-}" ]]; then
                local dim_part=${x_part%%:*} \
                  mem_part=${x_part#*:}

                if [[ ! $dim_part =~ ^[a-zA-Z0-9_]+$ ]]; then
                  log_fatal "Invalid dim name: $dim_part, found in $x"
                  fail1
                fi

                local values
                coord_type=branch \
                dim=$dim_part \
                fetch_values_from_coordinates $dim_part || fail

                local value_count=${#values[*]}

                # Hashed members currently not supported
                # Not too hard to implement, but isn't likely to be needed
                if (( value_count == 1 )) && [[ "$values" == "$mem_part" ]]; then
                  plant_seed_internal $x $to || fail
                fi
              fi

            elif [[ $x_part != .* ]]; then
              mkdir $target || fail
            fi
          fi
          if [[ $x_part != .* && -d $target && $deep == t ]]; then
            plant_seed_internal $x $target || fail
          fi
        elif [[ $cell_is_leaf == t && ! -e $target && $x_part != .* ]]; then
          if [[ $x == *.safe ]]; then
            ignore_failure=t \
            cell_decrypt_file $x ${target%.safe} || fail
          else
            cp -a $x $to/ || fail
          fi
        fi
      end_for

    fi
  end_function
  handle_return
}

# inputs: $1  work path to the cell
plant_seed() {
  local seed_path from=$1 to=${2:-$1} \
    deep=${deep:-t} \
    ignore_nonexistent=${ignore_nonexistent:-f}

  begin_function

    if [[ ! -d "$to" ]]; then
      log_fatal "plant_seed called on a non-existant work path: $to"
      fail1
    fi

    find_seed_path $from || fail
    if [[ ! "$seed_path" ]]; then
      log_fatal "No seed is associated with this path: $to"
      fail1
    fi

    local dna_path=$seed_path
    if [[ $command_requires_cell == t ]]; then
      while [[ ! -d $dna_path/.dna ]]; do
        dna_path=${dna_path%/*}
        if [[ $dna_path != /*/* ]]; then
          log_fatal "Could not find dna in seed: $seed_path"
          fail1
        fi
      done

      if [[ $dna_path != $seed_path ]]; then
        safe_link $dna_path/.dna $to/ || fail
      fi

    fi

    plant_seed_internal $seed_path $to || fail

  end_function
  handle_return
}

# inputs: parent_path seed_path member dim
plant_member() {
  begin_function
    local deep=${deep:-f} repair=${repair:-f}
    get_sane_value "$member" || fail
    member_path=$parent_path/$dim:$sane_value
    if [[ ! -d $member_path || $repair == t ]]; then

      local new_path=$member_path.new

      if [[ -d $new_path ]]; then
        rm -rf $new_path || fail
      fi

      mkdir $new_path || fail
      if [[ "$member" != "$sane_value" ]]; then
        echo -n "$member" >$new_path/.member || fail
      fi

      local cell_is_leaf=t
      if [[ ${child_dims:-} ]] && (( ${#child_dims[*]} > 1 )); then
        cell_is_leaf=f
      fi
      plant_seed $member_path $new_path || fail

      if [[ -e $member_path ]]; then
        rm -rf $member_path || fail
      fi
      mv $new_path $member_path || fail

    fi
  end_function
  handle_return
}

create_sub_cell() {
  local sub_cell=$sub_cell \
    parent_cell=$parent_cell \
    parent_seed=$parent_seed

  local log_show_vars='^sub_cell'
  begin_function

    log_debug "Creating sub cell $cell_path"

    if [[ "$sub_cell" == */.dna* ]]; then
      log_fatal "Internal error: Invalid sub_cell $sub_cell."
      log_fatal "We should not be creating a sub cell inside of a dna folder"
      fail1
    fi

    if [[ "$parent_cell" == "$sub_cell" ]]; then
      log_fatal "Can't create sub cells in a cell without parents: $sub_cell"
      stack_trace
      fail1
    fi

    deep=t \
    parent_path=$parent_cell \
    seed_path=$parent_seed \
    member=$member \
    repair=t \
    plant_member || fail

  end_function
  handle_return
}

grow_member() {
  local sane_value member_path \
    log_show_vars=member \
    upstream_cell_link=${upstream_cell_link:-} \
    cell_path=$cell_path \
    original_cell_path=$cell_path \
    anchor_dims=${anchor_dims:-} \
    dim=$dim \

  begin_function

    get_sane_value "$member" || fail
    member_path=$cell_path/$dim:$sane_value

    log_debug "Updating member $dim:$sane_value"

    local needs_update=
    if [[ ! -d $member_path/.dna ]]; then
      parent_cell=$cell_path \
      parent_seed=$seed_path \
      sub_cell=$member_path \
      create_sub_cell || fail
      needs_update=t
    else
      cell_path=$member_path
      get_needs_update $member_path || fail
    fi

    if [[ "${upstream_cell_link:-}" ]]; then
      cell_path=$member_path update_downstream || fail
    fi

    if [[ $needs_update == t ]]; then

      if (( member_count > 1 )); then
        log_debug "More than one member found ($member_count), not passing upstream_cell_link."
        upstream_cell_link=
      elif [[ "$upstream_cell_link" ]]; then
        log_debug "Only one member found, passing upstream_cell_link: $upstream_cell_link"
      fi

      fork execute_commands $member_path update || fail

      if [[ $update_successful == f ]]; then
        #log_error "Failed to update member cell $member_path"
        reply_to_caller "update_successful=f" || fail
      else 
        update_successful=t
      fi
    fi

    if (( member_count == 1 )); then
      upstream_cell_link=
    fi
  end_function
  handle_return
}

grow_members() {
  begin_function

    local dim=${child_dims[0]}
    update_successful=t
    par=t fork=f function=grow_member for_each_member $dim || fail

  end_function
  handle_return
}

# inputs:
#   target_cell
#   prefix
load_upstream_vars() {
  begin_function

    if [[ ! -d "${target_cell:-}" ]]; then
      log_fatal "Internal error: missing target_cell $target_cell"
    fi

    local export_path=$target_cell/export \
      out_path=$target_cell \
      prefix=${prefix:-}${target_cell##*/}_ \
      dna_roots= \
      context_type= \

    prefix=${prefix//-/_}

    pass_thru=t \
    recursive=f \
    ignore_unknown=t \
    auto_load_tab_vars=t \
    load_dna_contents $out_path || fail

    if [[ -d $export_path ]]; then
      ignore_unknown=t \
      pass_thru=t \
      load_dna_contents $export_path || fail
    fi

  end_function

  if failed; then
    update_successful=f
  fi

  handle_return
}

grow_up_inner() {
  begin_function

    local prep_function=${up_cell_type}_prep
    if function_exists $prep_function; then
      log_debug "Executing $up_cell_type prep function: $prep_function"
      $prep_function || fail
    fi

    # other preps are only run if there isn't a specific prep function for the upstream
    local other_prep_function=${up_cell_type}_other_prep
    prep_function=${up_cell_type}_${up_var}_prep
    if function_exists $prep_function; then
      log_debug "Executing prep function: $prep_function"
      $prep_function || fail
    elif function_exists $other_prep_function; then
      log_debug "Executing other prep function: $other_prep_function"
      $other_prep_function || fail
    fi

    local up_cell_path \
      short_cell \
      upstream_cell_link \
      downstream_cell_name \

    if [[ $needs_update == t ]]; then
      
      maybe_fix_up || fail

      upstream_cell_link=$up_cell
      get_short_cell $cell_path

      if [[ $up_cell_type == up ]]; then
        downstream_cell_name=${short_cell//\//_}
      else
        downstream_cell_name=
      fi

      up_cell_path=$(realpath $up_cell) || fail
      if [[ $up_cell_path == */.cyto/* ]]; then
        log_fatal "Internal error: up_cell_path is in cyto: $up_cell_path"
        fail1
      fi

      needs_update=

      #  Don't clear anchor_dims because it might be set by prep
      #local anchor_dims=
      get_needs_update $up_cell_path || fail

      if [[ $needs_update == t ]]; then
        execute_commands "$up_cell_path" update || fail
      fi

    else
      log_verbose "Skipping update of upstream $up_name because prep function set needs_update=f"
      reply_to_caller "update_skipped=t"
    fi

    #    not sure why this is here
    # reply_to_caller "needs_update=$needs_update"

  end_function
  handle_return
}

# inputs:
#   up_cell_type
#   up_cell
grow_up() {
  begin_function
    if [[ ! "${up_cell:-}" ]]; then
      log_fatal "Internal error: up_cell was not passed into execute_up"
      fail1
    fi

    if [[ ! "${up_cell_type:-}" ]]; then
      log_fatal "Internal error: up_cell_type was not passed into execute_up"
      fail1
    fi

    local up_name=${up_cell##*/}
    log_debug "Growing $up_cell_type $up_name"

    local needs_update=t \
      up_var=${up_name//-/_} \

    update_skipped=f
    fork grow_up_inner || fail

    validation_says_already_done=

    local post_function=${up_cell_type}_post
    if function_exists $post_function; then
      log_debug "Executing all post function: $post_function"
      $post_function || fail
    fi

    # other posts are only run if there isn't a specific post function for the upstream
    local other_post_function=${up_cell_type}_other_post
    post_function=${up_cell_type}_${up_var}_post
    if function_exists $post_function; then
      log_debug "Executing post function: $post_function"
      $post_function || fail
    elif function_exists $other_post_function; then
      log_debug "Executing other post function: $other_post_function"
      $other_post_function || fail
    fi
    
  end_function
  handle_return
}

grow_upstream() {

  local original_cell_path=${cell_path:-} \
    upstream=$1 \
    up_cell_type=$up_cell_type \

  local log_show_vars=^upstream 
  begin_function

    local upstream_cell_link= \
      anchor_dims= \
      grow_history=${grow_history:-} \
      upstream_var=${upstream_name//-/_} \

    local cell_path=${upstream%/.cyto/up/$upstream_name}
    if [[ $cell_path == $upstream ]]; then
      log_fatal "Invalid upstream: $upstream, it should be within .cyto/up"
      fail1
    fi

    local cyto_path=$cell_path/.cyto
    local up_path=$cyto_path/up

    localize

    up_cell=$upstream \
    grow_up || fail

  end_function
  handle_return
}

grow_command() {
  begin_function

    local leave_loop=0 \
      something_changed=f \
      needs_update=${needs_update:-} \
      needs_inner=f \
      grow_successful=t \

    grow_context $cell_path || fail
    fence

    if [[ "${upstream_cell_link:-}" ]]; then
      update_downstream || fail
    fi

    calc_coords_branch || fail
    fence

    if [[ -v branch_coordinate_data ]]; then
      show_coordinates || fail
    fi

    if [[ $cell_is_leaf == t ]]; then

      # this isn't directly needed to calculate the cell branches,
      # but it may be used in upstream prep functions to figure out the
      # branches of upstream cells
      handle_no_coords=ignore \
      calc_coords_leaf || fail
      grip_fence

      # make sure convert_table_to_dims doesn't try to hit any other row
      local row_index=0

      if [[ -v branch_coordinate_fields ]]; then
        table=branch_coordinate \
        target_dim_var_types='ddim ddims' \
        convert_table_to_dims || fail
      fi

      if [[ -v leaf_coordinate_fields ]]; then
        table=leaf_coordinate \
        target_dim_var_types='ddim ddims' \
        convert_table_to_dims || fail
      fi

      local can_agg=f
      deep=t plant_seed_internal "$seed_path" "$cell_path" || fail

      if [[ $cell_is_leaf == f ]]; then
        if [[ "${child_dims:-}" ]]; then
          grow_members || fail
          if [[ $grow_successful == f ]]; then
            log_error "Some members of $short_cell failed to update successfully."
          fi
        else
          log_fatal "Internal error: cell is not a leaf, yet it doesn't have child dims?"
          fail1
        fi
      else

        # grow upstreams
        begin_for upstream_name in "${up[@]}"; doo
          upstream=$up_path/$upstream_name \
          up_cell_type=up \
          grow_upstream $upstream || fail
        end_for

        # grow validators
        begin_for upstream_name in "${validator[@]}"; doo
          upstream=$validator_path/$upstream_name \
          up_cell_type=validator \
          grow_upstream $upstream || fail
        end_for

        # grow reactors
        begin_for upstream_name in "${reactor[@]}"; doo
          upstream=$reactor_path/$upstream_name \
          up_cell_type=reactor \
          grow_upstream $upstream || fail
        end_for

      fi

    else
      grow_successful=t
      abort
    fi

  end_function

  command_successful=${grow_successful:-f}
  reply_to_caller "command_successful=${command_successful:-}"

  handle_return
}

