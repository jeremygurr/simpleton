#!/usr/bin/env bash

type -t grow_lib_loaded >/dev/null && return 0
grow_lib_loaded=t

check_foundation() {
  begin_function
    if [[ -f $dna_path/cell_is_foundation.var && ! -v cell_is_foundation ]]; then
      context_type= \
      prefix= \
      load_dna_item $dna_path/cell_is_foundation.var || fail
    fi

    if [[ $cell_path != */foundation/* 
       && -d $module_path/foundation/all 
       && ! -d $module_path/foundation/all/.cyto
       && ${cell_is_foundation:-f} == f
       ]]; then
      log_fatal "Foundation cells have not been updated, so update can't proceed. Update $module_path/foundation/all before attempting to update other cells."
      fail1
    fi
  end_function
  handle_return
}

write_to_context() {
  local context_type=${context_type:-} new_type=$1 context_file=${context_file:-}
  local -n _content=$2
  begin_function_lo
    if [[ "$context_type" || "$context_file" ]]; then
      if [[ ! "$context_file" ]]; then
        context_file=$context_path-$context_type.new
      fi

      last_type=${last_type:-var}
      if [[ $last_type == fun || $new_type == fun ]]; then
        echo >>$context_file || fail
      fi
      trim_ws _content
      echo "${_content}" >>$context_file || fail
      last_type=$new_type
      eval "$_content" || {
        if [[ "${var_full_path:-}" ]]; then
          log_fatal "Invalid dna file: $var_full_path"
        else
          log_fatal "Invalid dna file. Contents:"
          log_fatal "$_content"
        fi
        fail1
      }
    fi
  end_function
  handle_return
}

# inputs:
#   either context_type or context_file
#   $*    vars to write to context file
write_vars_to_context() {
  local vars_to_write=$* ignore_missing=${ignore_missing:-f}
  begin_function_lo
    local var val quoted_val
    for var in $vars_to_write; do
      local -n val=$var
      local is_set=f
      if is_set val; then
        set_to_string val quoted_val
        is_set=t
      elif is_array val; then
        array_to_string val quoted_val
      elif [[ $ignore_missing == t && ! -v $var ]]; then
        continue
      else
        local quoted_val=${val:-}
        shell_quote_var quoted_val
      fi
      local content="$var=$quoted_val"
      if [[ $is_set == t ]]; then
        content="declare -Ag $content"
      fi
      write_to_context var content || fail
    done; maybe_break
  end_function
  handle_return
}

# inputs:
#   lib_dim_path
#   cache_path
make_dim_cache() {
  begin_function

    log_debug "Generating dim cache for $lib_dim_path"

    if [[ -f $cache_path.new ]]; then
      rm $cache_path.new || fail
    fi

    local dim_paths dim_path dim context_file=$cache_path.new
    local -A dim_group=()
    dim_paths=$(find1 $lib_dim_path -type d -not -name ".*" | sort) || fail

    for dim_path in $dim_paths; do
      dim=${dim_path##*/}
      if [[ $dim == _* ]]; then
        local group_dims=
        get_group_dims $dim_path || fail
        dim_group[$dim]="$group_dims"
      else
        build_dim_info_single $dim_path || fail
      fi
    done

    write_vars_to_context \
      dim_group \
      secret_vars \
      all_dims \
      || fail

    mv $cache_path.new $cache_path || fail

  end_function
  handle_return
}

load_dim_caches() {
  local work_path=$1
  begin_function

    if [[ $work_path == /*/*/* ]]; then
      load_dim_caches ${work_path%/*} || fail
    fi

    local lib_dim_path=$work_path/.lib/dim

    if [[ -d $lib_dim_path ]]; then
      local dt files links link type is_generated \
        cache_path=$work_path/.lib/dim-cache \
        real_path real_path_parent \

      dim_caches+="$cache_path "

      if [[ ! -f $cache_path ]]; then
        fork make_dim_cache || fail
      fi

      source $cache_path || fail

    fi

  end_function
  handle_return
}

add_derive_from() {
  local required_dims=$required_dims optional_dims=${optional_dims:-} result

  result=$required_dims
  if [[ "$optional_dims" ]]; then
    result+="/$optional_dims"
  fi
  derive_from+=( "$tool $result" )
}

make_derive_cache_handle_function() {
  begin_function

    load_fun_to_code $derive_path derive_function_$name || fail
    eval "$code" || fail
    derive_functions+=( $name )
    write_to_context fun code || fail

    local fields=() derive_paths=()

    action=info \
    derive_function_$name || fail

    local derived_dim
    for derived_dim in ${fields[*]}; do

      local -n derive_from=dim_${derived_dim}_derived_from \
        key_functions=dim_${derived_dim}_key_functions \

      local is_key=f key_field_group
      for key_field_group in ${derive_paths[*]}; do

        local required_dims=$key_field_group \
          optional_dims= \
          target_dims= \

        if [[ "$required_dims" == *'->'* ]]; then
          target_dims=${required_dims#*->}
          required_dims=${required_dims%->*}
        else
          log_fatal "Wrong derive_path format: $key_field_group . This is generated in the info function in the file derive_$name.fun in the .lib/derive folder"
          log_fatal "The add_derive_path function should be being called in that info function to add the necessary paths."
          fail1
        fi

        if [[ "$required_dims" == */* ]]; then
          optional_dims=${required_dims#*/}
          required_dims=${required_dims%/*}
        fi

        if [[ ",${required_dims}," != *",$derived_dim,"* \
           && ",${optional_dims}," != *",$derived_dim,"* \
           && ",${target_dims},"   == *",$derived_dim,"* \
           ]]; then

          tool=${name}.fun \
          add_derive_from || fail

        fi

        if [[ "$required_dims" == "$derived_dim" \
           && ! "$optional_dims" \
           ]]; then
          is_key=t
        fi

      done

      if [[ $is_key == t ]]; then
        key_functions+=( $name )
      fi

    done

  end_function
  handle_return
}

# inputs:
#   lib_dt_path
#   cache_path
make_derive_cache() {
  begin_function

    log_verbose "Generating derive cache for $lib_dt_path"
    deriving_dims=t

    if [[ -f $cache_path.new ]]; then
      rm $cache_path.new || fail
    fi

    local context_file=$cache_path.new \
      type files \

    begin_for type in fun tab; doo

      if [[ $type == fun ]]; then
        files=$(find -L $lib_dt_path \( -type f -or -type l \) -not -name '.*' -name '*.fun' | sort -g) || fail
      else
        files=$(find -L $lib_dt_path \( -type f -or -type l \) -not -name '.*' -name '*.*tab' | sort -g) || fail
      fi

      local name code derive_path
      begin_for derive_path in $files; doo
        name=${derive_path##*/}
        name=${name%.*}
        name=${name#derive_}
        if [[ $type == fun ]]; then
          make_derive_cache_handle_function || fail
        else
          make_derive_cache_handle_table || fail
        fi
      end_for
    end_for

    write_vars_to_context derive_tables derive_functions || fail

    local dim
    for dim in ${!all_dims[*]}; do

      ignore_missing=t \
      write_vars_to_context \
        dim_${dim}_key_tables \
        dim_${dim}_key_functions \
        dim_${dim}_derived_from \
        dim_${dim}_narrowed_from \
        || fail

#        dim_${dim}_card_table \

      local -n member_type=dim_${dim}_member_type \
        dim_members=dim_${dim}_members \
        dim_derive_tables=dim_${dim}_derive_tables \

      if [[ ! -v dim_members ]]; then
        calc_missing_members || fail
      fi

      case ${member_type:-unset} in
        static|dynamic)
          :
        ;;
        unset)
          if [[ "${dim_members:-}" || "${dim_derive_tables:-}" ]]; then
            member_type=static
          else
            member_type=dynamic
          fi
        ;;
        *)
          log_fatal "Invalid value for member_type: $member_type defined for dim $dim"
          fail1
        ;;
      esac

      write_vars_to_context dim_${dim}_member_type || fail
       
    done

    if [[ -f $cache_path.new ]]; then
      mv $cache_path.new $cache_path || fail
    fi
    unset deriving_dims

  end_function
  handle_return
}
 
load_derive_caches() {
  local work_path=$1
  begin_function

    if [[ $work_path == /*/*/* ]]; then
      load_derive_caches ${work_path%/*} || fail
    fi

    local lib_dt_path=$work_path/.lib/derive

    if [[ -d $lib_dt_path ]]; then

      local dt files links link type is_generated \
        cache_path=$work_path/.lib/derive-cache \
        real_path real_path_parent \

      derive_caches+="$cache_path "

      if [[ ! -f $cache_path ]]; then
        fork make_derive_cache || fail
      fi

      source $cache_path || fail

    fi

  end_function
  handle_return
}

# inputs:
#   $1        start_path
#   dim
# outputs:
#   dim_path    will not be set if it's not found
get_dim_path() {

  local start_path=$1 lib_dim_path

  lib_dim_path=$start_path/.lib/dim
  if [[ -d $lib_dim_path/$dim ]]; then
    dim_path=$lib_dim_path/$dim
  elif [[ $start_path == /*/*/* ]]; then
    get_dim_path ${start_path%/*}
  fi

}

# inputs:
#   $1      dim path
# 
build_dim_info_single() {
  local log_show_vars=dim_path \
    dim_path=$1 dim

  begin_function

    local dims dim=${dim_path##*/}

    if [[ -v all_dims[$dim] ]]; then
      log_fatal "Dim $dim has already been built"
      fail1
    fi

    all_dims[$dim]=1

    if [[ ! "$dim" =~ ^[a-zA-Z0-9][a-zA-Z0-9_]+$ ]]; then
      log_fatal "Invalid dim name: $dim. Dims must consist of alphanumeric characters or underscores."
      fail1
    fi

    get_plural $dim dims

    prefix=dim_${dim}_ \
    load_dna_contents $dim_path || fail

    local -n is_secret=dim_${dim}_is_secret
    if [[ -v is_secret && $is_secret == t ]]; then
      add_word_to_string secret_vars "$dim $dims s_$dim s_$dims d_$dim d_$dims"
    fi

    local -n members=dim_${dim}_members

    if ! function_exists expand_function; then
      build_context_expand || fail
    fi

  end_function
  handle_return
}

# inputs:
#   dim
#   dim_derived_from
#   next_level_row
build_context_support_dims_find_related() {
  local log_show_vars=dim

  begin_function

    local row object type
    begin_for row in "${dim_derived_from[@]}"; doo
      local row_array=( $row )
      object=${row_array[0]}
      type=${row_array[1]}

      local canopy=${row_array[1]} \
        up_dim \
        new_shortest \
        old_shortest \

      canopy=${canopy//\// }
      canopy=${canopy//,/ }

      begin_for up_dim in $canopy; doo

        new_shortest=( $next_level_row )

        if [[ ! -v tried[$up_dim] ]]; then

          log_debug "Found reference to derived dim $up_dim (from $dim via $object)"

          if [[ ! -v all_dims[$up_dim] ]]; then
            log_fatal "Missing dim $up_dim"
            fail1
          fi

          local new_next_level_row=$next_level_row d
          for d in $canopy; do
            if [[ " $new_next_level_row " != *" $d "* && $d != $up_dim ]]; then
              new_next_level_row+=" $d"
            fi
          done
          new_next_level_row+=" $up_dim"

          tried[$up_dim]=1 \
          related_dims_set[$up_dim]=1 \
          next_level_dims[$new_next_level_row]=1 \

        fi

      end_for
    end_for

  end_function
  handle_return
}

build_context_related_dims() {
  begin_function

    local dim dim_parents next_level_row \
      support_dim_depth=0 down_dim \
      maybe_compound_dim \
      anchors=${anchor_dims:-${default_anchor_dims[*]:-}} \

    local -A related_dims_set=() \
      support_dims_set=() \
      tried=() \
      next_level_dims=() \
      current_level_dims=() \
      target_dims=() \

    array_to_set trunk_dims_expanded    target_dims
    array_to_set sub_dims_expanded      target_dims
    array_to_set control_props_expanded target_dims
    array_to_set data_props_expanded    target_dims

    local -A new_target_dims
    begin_for maybe_compound_dim in ${!target_dims[*]}; doo
      get_singular_dim $maybe_compound_dim dim
      if [[ ! -v tried[$dim] ]]; then
        tried[$dim]=1
        next_level_dims[$dim]=1
      fi
    end_for

    begin_while (( ${#next_level_dims[*]} > 0 )); doo
      current_level_dims=()
      add_to_set next_level_dims current_level_dims
      next_level_dims=()
      begin_for next_level_row in "${!current_level_dims[@]}"; doo
        dim=${next_level_row##* }
        dim_parents=${next_level_row% *}
        if [[ "$dim" == "$dim_parents" ]]; then
          dim_parents=
        fi
        local -n dim_derived_from=dim_${dim}_derived_from
        if [[ -v dim_derived_from ]]; then
          log_debug "Finding related dims of $dim"
          build_context_support_dims_find_related || fail
        fi
      end_for
    end_while

    fence

    related_dims_expanded=( ${!related_dims_set[*]} )
    sort_array related_dims_expanded

    if [[ "${related_dims_expanded:-}" ]]; then
      log_debug "Related dims found: ${related_dims_expanded[*]}"
    fi

    write_vars_to_context related_dims_expanded || fail

  end_function
  handle_return
}

build_dim_info_expand_group() {
  local dim=$1
  begin_function

    local dim_path=
    get_dim_path $cell_path || fail

    if [[ ! "$dim_path" ]]; then
      log_fatal "Could not find dim $dim of $dim_type"
      fail1
    fi

    local dim_folders dim_folder
    dim_folders=$(find1 $dim_path | sort -g) || fail

    for dim_folder in $dim_folders; do
      local dim=${dim_folder##*/}
      dim=${dim##+([0-9])-}
      if [[ $dim == _* ]]; then
        build_dim_info_expand_group $dim || fail
      else
        expanded_array+=( $dim )
      fi
    done

  end_function
  handle_return
}

build_dim_info() {
  begin_function

    local dim dim_type
    localize_dims=
    localize_reverse_dims=

    expand_dim_array trunk_dims sub_dims control_props data_props || fail
    begin_for dim_type in trunk_dims sub_dims control_props data_props; doo 
      write_vars_to_context ${dim_type}_expanded || fail
    end_for

    build_context_related_dims || fail

    local dim dims
    compound_dims=()
    for dim_type in trunk_dims related_dims sub_dims control_props data_props; do

      local -n dim_array=${dim_type}_expanded

      local compound_dim
      for compound_dim in "${dim_array[@]}"; do

        get_singular_dim $compound_dim dim
        local -n dt=dim_${dim}_type

        if [[ "${dt:-}" ]]; then
          log_fatal "Dim $dim was defined as a $dim_type, but it is also defined as a $dt. A dim can only be of one type. Fix the dna definition for this cell."
          fail1
        fi

        if [[ $compound_dim != $dim ]]; then
          compound_dims[$dim]=1
        fi

        dt=$dim_type

        get_plural $dim dims
        localize_dims+=" d_$dim d_$dims"
        localize_reverse_dims+=" $dim=\${d_$dim:-} $dims=( \"\${d_$dims[@]:-}\" )"
        write_vars_to_context dim_${dim}_type || fail

        local shorter_dim=$dim shorter_dims

        dim_shorts[$dim]=$dim
        while [[ $shorter_dim == *_* ]]; do

          shorter_dim=${shorter_dim#*_}
          get_plural $shorter_dim shorter_dims
          if [[ ! -v dim_shorts[$shorter_dim] ]]; then
            dim_shorts[$shorter_dim]=$dim
            dim_shorts[$shorter_dims]=$dims
          else
            # Allow exact dim name to override all abbreviations
            if [[ "${dim_shorts[$shorter_dim]}" != $shorter_dim ]]; then
              dim_shorts[$shorter_dim]+=" $dim"
              dim_shorts[$shorter_dims]+=" $dims"
            fi
          fi

        done

      done

    done

    write_vars_to_context compound_dims localize_dims localize_reverse_dims dim_shorts || fail

  end_function
  handle_return
}

load_dna_contents_handle_dir() {
  begin_function_lo
    if [[ "$current_var" && $item_var != _* ]]; then
      array_content+=( "$item_name" )
      if [[ -L $item || -d $item ]]; then
        result="${current_var}_${item_var}_path=$real_path"
        write_to_context var result || fail
      fi
      array_ord+=( $ord )
    fi

    if [[ ! -d $real_path/.dna ]]; then

      local new_pass_thru=f

      if [[ $item_var != _* ]]; then
        new_prefix+=${item_var}_
      else
        new_pass_thru=t
      fi

      # recursive
      prefix=$new_prefix pass_thru=$new_pass_thru load_dna_contents $item || fail

    fi
  end_function
  handle_return
}
 
# if context_type is not set, then no context will be written
# inputs:
#   $1                  folder to load dna objects from
#   prefix              prefix to append all var names with
#   recursive           whether to descend into sub dirs
#   ignore_unknown      if set to 'f', then unknown dna objects will throw an error
#   context_type        which context file to write the variable to. If empty, no context file will be written
#   auto_load_tab_vars  if set to 't', and a table is loaded with only one row, the fields of that row get loaded as variables also
load_dna_contents() {
  local folder=$1 prefix=${prefix:-} \
    pass_thru=${pass_thru:-f} recursive=${recursive:-t} \
    ignore_unknown=${ignore_unknown:-f} \
    context_type=${context_type:-} \
    auto_load_tab_vars=${auto_load_tab_vars:-f} \

  begin_function

    local items new_items
    items=$(find1 $folder -not -name '.*' -not -name root | sort -g) || fail

    local current_var=${prefix%_} ord item_name item_var= result 
    if [[ $pass_thru == f ]]; then
      local array_content=( )
      local -n array_ord=${current_var}_ord
    fi
    current_var=${current_var//-/_}

    begin_for item in $items; doo

      item_name=${item##*/}

      local dna_prefix=f
      if [[ "$item_name" == dna-* ]]; then
        dna_prefix=t
        item_name=${item_name#dna-}
      fi

      if [[ "$item_name" == *:* && $item != */.dna/* ]]; then
        local filter filters=${item_name%:*}
        for filter in ${filters//:/ }; do
          if [[ $cell_path != */"$filter"/* && $cell_path != */"$filter" ]]; then
            continue 2
          fi
        done
        item_name=${item_name##*:}
      fi

      extract_simple_name item_name ord item_name
      item_var=${item_name//-/_}
      item_var=${item_var%%,*}
      item_var=${item_var%%:*}

      local new_prefix= 
      if [[ "$current_var" && $dna_prefix == f ]]; then
        new_prefix=${current_var}_
      fi

      local real_path=$(realpath -m $item)

      if [[ -d $item ]]; then
        if [[ $recursive == t ]]; then
          load_dna_contents_handle_dir || fail
        fi
      elif [[ -f $item ]]; then
        prefix=$new_prefix load_dna_item $item || fail
      elif [[ -L $item ]]; then
        log_fatal "Broken link in dna: $item"
        fail1
      fi

    end_for

    if [[ "$current_var" && "${array_content:-}" && $pass_thru == f ]]; then
      local append=f
      local -n v=$current_var
      [[ "${v:-}" ]] && append=t
      make_array_assignment $current_var array_content || fail
      write_to_context var array_assignment || fail
    fi

  end_function
  handle_return
}

load_parent_context() {
  local path=$1
  begin_function
    if [[ "$path" == /*/*/* ]]; then
      load_parent_context ${path%/*}
    fi
    local root_path=$path/.root
    if [[ -e $root_path ]]; then
      log_debug "Appending parent trunk context ${path#/*/*/}"
      echo "$NL# FROM $root_path" >>$context_path-$context_type.new || fail
      if [[ -d $root_path ]]; then
        load_dna_contents $root_path || fail
      elif [[ -f $root_path ]]; then
        cat $root_path >>$context_path-$context_type.new || fail
      fi
    fi
  end_function
  handle_return
}

# Unused now?
build_dim_expand_functions() {
  begin_function
    local dim
    for dim in ${!all_dims[*]}; do
      local -n expand_function=dim_${dim}_expand
      if ! function_exists expand_function; then
        build_context_expand || fail
      fi
    done; maybe_break
  end_function
  handle_return
}

# inputs:
#   name
#   derive_path
#   cache_path
make_derive_cache_handle_table() {
  begin_function

    local -n dtp=derive_table_${name}_path
    dtp=$derive_path

    load_derive_table $name || fail
    derive_tables+=( $name )

    write_vars_to_context \
      derive_table_${name}_path \
      derive_table_${name}_fields \
      derive_table_${name}_data \
      || fail

    grip_fence

    table=derive_table_${name} \
    make_table_index || fail

    table=derive_table_${name} \
    write_index_to_context $cache_path.new || fail

    grip_fence

    local -n table_fields=derive_table_${name}_fields \
      table_data=derive_table_${name}_data \
      key_fields=derive_table_${name}_key_fields \

    local field_count=${#table_fields[*]} \
      data_count=${#table_data[*]} \

    local row_count
    (( row_count = data_count / field_count ))

    load_derive_table_simple_keys || fail
    load_derive_table_compound_keys || fail

    write_vars_to_context derive_table_${name}_key_fields || fail

    tab_get_derive_from || fail

  end_function
  handle_return
}

# inputs:
#   all_dims
#   dim_*_derive_tables
# outputs:
#   dim_*_refine_tables
build_refine_tables() {
  begin_function

    local dim dt dts

    for dim in ${!all_dims[*]}; do

      local -n refine_tables=dim_${dim}_refine_tables \
        dts=dim_${dim}_derive_tables \
        members=dim_${dim}_members \

      if [[ -v dts && -v members ]]; then

        refine_tables=()
        local member_count=${#members[*]}

        for dt in $dts; do
          local -n index=derive_table_${dt}_index_$dim
          if (( ${#index[*]} == member_count )); then
            refine_tables+=( $dt )
          fi
        done

        if [[ "${refine_tables:-}" ]]; then
          log_debug "Refine tables found for $dim: ${refine_tables[*]}"
        fi

        write_vars_to_context dim_${dim}_refine_tables || fail

      fi

    done

  end_function
  handle_return
}

# inputs:
#   dim
calc_missing_members() {
  begin_function

    local members_array 
    log_debug "Calculating missing dim members for $dim"

    local -n dts=dim_${dim}_derive_tables

    local -A found_members=()

    local dt v
    if [[ -v dts ]]; then

      local -n members=dim_${dim}_members
      members=()

      for dt in $dts; do
        local -n index=derive_table_${dt}_index_$dim
        for v in ${!index[*]}; do
          found_members[$v]=1
        done
      done
      members=( "${!found_members[@]}" )
      sort_array members

      log_debug "Found ${#found_members[*]} members for $dim"

      if [[ ! "${found_members[*]}" ]]; then
        log_fatal "No members were found for this dim $dim. Check the derive tables or explicitly make a members list in the dim folder."
        fail1
      fi

      write_vars_to_context dim_${dim}_members || fail

    else
      log_debug "No derive tables found for $dim, and no explicit members are defined, so it must be a dynamic dim"
    fi

  end_function
  handle_return
}

build_context_branch() {
  begin_function

    local context_type=branch last_type=var
    log_debug "Building branch context for $short_cell"

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    local dim assignment member i members_string=
    begin_for ((i = 0; i < branch_dim_count; i++)); doo
      dim=${branch_dims[$i]}
      member=${branch_members[$i]}
      shell_quote_var member
      assignment="d_$dim=$member"
      members_string+="$member "
      write_to_context var assignment || fail
    end_for

    local content="
branch_dims=( ${branch_dims[*]} )
branch_dim_count=$branch_dim_count
branch_members=( ${members_string% } )
branch_hashes=( ${branch_hashes[*]} )
"
    write_to_context var content || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

build_context_trunk_dna() {
  local log_vars=cell_path log_show_vars=short_cell
  begin_function

    local item_name last_part dna_full_item suffix context_type=trunk
    local -A append_vars

    if [[ -d $dna_path ]]; then

      auto_loads=()

      if [[ "$cell_path" == */*/* ]]; then
        load_parent_context ${cell_path%/*} || fail
      fi

      echo "$NL# FROM $dna_path" >>$context_path-$context_type.new || fail
      prefix= load_dna_contents $dna_path || fail

      write_vars_to_context auto_loads || fail

      if [[ ! "${default_anchor_dims:-}" ]]; then
        default_anchor_dims="${trunk_dims_expanded[*]:-}"
        write_vars_to_context default_anchor_dims || fail
      fi

      mv $context_path-$context_type.new $context_path-$context_type.new2 || fail
      echo "#!/usr/env bash" >$context_path-$context_type.new || fail
      local v
      for v in ${!append_vars[*]}; do
        echo "$v=" >>$context_path-$context_type.new || fail
      done

      cat $context_path-$context_type.new2 >>$context_path-$context_type.new || fail
      rm $context_path-$context_type.new2 || fail

    elif [[ -f $dna_path ]]; then
      safe_link $dna_path $context_path-$context_type.new || fail
      source $dna_path || fail
    else
      log_vars=dna_path log_fatal "Internal error: dna not found"
      fail1
    fi

  end_function
  handle_return
}

build_context_trunk() {
  begin_function

    local context_type=trunk last_type=var

    log_debug "Building trunk context for $short_cell"

    if [[ -e $context_path-$context_type.new ]]; then
      rm $context_path-$context_type.new || fail
    fi

    build_context_trunk_dna || fail

    if [[ "${trunk_dims[0]:-}${sub_dims[0]:-}${control_props[0]:-}${data_props[0]:-}" ]]; then

      local dims_missing_members=

      write_vars_to_context derive_tables derive_functions derive_caches || fail

      build_dim_info || fail

      if [[ "$dims_missing_members" ]]; then
        calc_missing_members || fail
      fi

      build_refine_tables || fail

    fi

    if [[ ! -d $status_path ]]; then
      mkdir -p $status_path || fail
    fi

    get_key_path || fail
    write_vars_to_context key_path || fail

    mv $context_path-$context_type.new $context_path-$context_type || fail

  end_function
  handle_return
}

build_context() {
  local cell_path=$1
  begin_function

    load_dim_caches $cell_path || fail
    load_derive_caches $cell_path || fail
    grip_fence

    if [[ ! -f $context_path-trunk ]]; then
      local trunk_context_path=$trunk_cell/.cyto/context
      if [[ $cell_is_trunk == t || ! -f $trunk_context_path-trunk ]]; then
        context_path=$trunk_cell/.cyto/context \
        build_context_trunk || fail
      else
        source $trunk_context_path-trunk || fail
      fi
      if [[ $cell_is_trunk == f ]]; then
        safe_link $trunk_context_path-trunk $context_path-trunk || fail
      fi
    else
      source $context_path-trunk || fail
    fi

    #  maybe not needed any more
    #setup_dims || fail

    if [[ ! -f $context_path-branch ]]; then
      build_context_branch || fail
    else
      source $context_path-branch || fail
    fi

    #  disabling seeding for now
    #if [[ "${trunk_dims_expanded:-}" ]]; then
    #  if [[ ! -f $context_path-branch-coords ]]; then
    #    build_branch_seed_coords || fail
    #  else
    #    source $context_path-branch-coords || fail
    #  fi
    #fi

    #  unused at the moment
    #if [[ $cell_is_leaf == t ]]; then
    #  if [[ ! -f $context_path-leaf ]]; then
    #    build_context_leaf || fail
    #  else
    #    source $context_path-leaf || fail
    #  fi
    #fi

    if [[ -e $context_path.new ]]; then
      rm $context_path.new || fail
    fi

    local dim_cache derive_cache

    begin_for dim_cache in ${dim_caches:-}; doo
      cat $dim_cache >>$context_path.new || fail
    end_for

    begin_for derive_cache in ${derive_caches:-}; doo
      cat $derive_cache >>$context_path.new || fail
    end_for

    if [[ -e $context_path-trunk ]]; then
      cat $context_path-trunk >>$context_path.new || fail
    fi

    local dim_type dim
    for dim_type in trunk_dims sub_dims control_props data_props; do
      local -n dim_array=${dim_type}_expanded
      for dim in ${dim_array[*]}; do
        get_singular_dim $dim dim
        local -n dt=dim_${dim}_type
        dt=$dim_type
        write_vars_to_context dim_${dim}_type || fail
      done
    done

    if [[ -e $context_path-branch ]]; then
      cat $context_path-branch >>$context_path.new || fail
    fi

    if [[ -e $context_path-leaf ]]; then
      cat $context_path-leaf >>$context_path.new || fail
    fi

    if [[ -e $context_path.new ]]; then
      mv $context_path.new $context_path || fail
    fi

  end_function
  handle_return
}

build_cyto() {
  local cell_path=$1

  begin_function

    log_debug "Building cyto for $short_cell"
    dna_path=$cell_path/.dna \
    cyto_path=$cell_path/.cyto \

    if [[ ! -d $cyto_path ]]; then
      mkdir $cyto_path || fail
    fi

    if [[ ! -d $status_path ]]; then
      mkdir $status_path || fail
    fi

    load_branch_info || fail
    find_seed_path $cell_path || fail

    if [[ ! -f $context_path ]]; then
      build_context $cell_path || fail
    fi

    local context_check_var_eval= c
    if [[ "${context_check_vars:-}" ]]; then
      for c in $context_check_vars; do
        local -n v=$c
        if [[ "${v:-}" ]]; then
          shell_quote_var v
          context_check_var_eval+="$c=$v"
        fi
      done
    fi

    if [[ ! -f $context_path-check ]]; then
      context_type=check \
      write_vars_to_context \
        out_file \
        out_path \
        check_op_var \
        data_props_expanded \
        default_freshness \
        context_check_vars \
        context_check_var_eval \
        || fail
      mv $context_path-check.new $context_path-check || fail
    fi

  end_function
  handle_return
}

grow_context() {
  cell_path=$1
  module_path=${cell_path#/*/*/}
  module_path=${cell_path%/$module_path}

  if [[ "${last_context_loaded:-}" != $cell_path ]]; then

    local log_show_vars=^cell_path rebuild_attempted=f
    begin_function

      get_short_cell
      log_debug "Growing context for $short_cell"

      if [[ "$cell_path" == /seed/* ]]; then
        log_fatal "Can't switch contexts to a seed path. Make sure to run this command in a work folder."
        fail1
      fi

      dna_path=$cell_path/.dna \
      cyto_path=$cell_path/.cyto \

      local dna_exists=f
      if [[ -e $dna_path ]]; then
        dna_exists=t
      fi

      if [[ $dna_exists == t ]]; then
        if [[ "${regrow_cells:-}" ]]; then
          local cell_to_regrow
          cells_already_regrown=${cells_already_regrown:-}
          if [[ " $cells_already_regrown " == *" $cell_path "* ]]; then
            log_debug "Cell already regrown: $cell_path"
          else
            begin_for cell_to_regrow in $regrow_cells; doo
              if [[ $cell_path == *$cell_to_regrow* ]]; then
                if [[ -e $cyto_path ]]; then
                  log_info "Cleaning cell ${cell_to_regrow#/work/*/} => $short_cell..."
                  rm -rf $cell_path/!(.*) $cyto_path || fail
                else
                  log_info "Cell already regrown: $cell_to_regrow => $short_cell"
                fi
                cells_already_regrown+=" $cell_path"
                break
              fi
            end_for
          fi
        fi
      fi

      context_path=$cyto_path/context
      init_context || fail

      seed_path=
      if [[ $dna_exists == t ]]; then

        #check_foundation || fail

        if [[ ! -f $context_path ]]; then
          fork build_cyto $cell_path || fail
        fi

        source $context_path || fail

        setup_dims || fail

        if [[ $cell_is_leaf == t && ! -d $up_path ]]; then

          local up_cell_type up_name
          begin_for up_cell_type in up validator reactor; doo
            local -n upstream_var=$up_cell_type
            if [[ -v upstream_var ]]; then
              make_cyto_up || fail
            fi
          end_for

        fi

        local problem_found=f
        broken_link_check || fail
        if [[ $problem_found == t ]]; then
          if [[ $rebuild_attempted == f ]]; then
            log_verbose "Problem found, rebuilding context"
            rm -rf $cyto_path/up* $context_path* || fail
            rebuild_attempted=t
            continue
          else
            log_fatal "Context rebuild failed to resolve problem"
            fail1
          fi
        fi
      fi

      load_post_context_dynamic_vars || fail

      last_context_loaded=$cell_path

      error_if_unresolved=t \
      handle_questions || fail

    end_function
    handle_return

  else
    log_debug "Context already loaded: $short_cell"
  fi

  return 0
}

plant_seed_internal() {
  local from=$1 to=$2 contents x x_part deep=${deep:-t} \
    cell_is_leaf=${cell_is_leaf:-t} key_path=${key_path:-} \

  begin_function

    if [[ ! -d $to ]]; then

      log_verbose "Planting seed from $from to $to"

      if [[ $from == /seed/* && -d $from ]]; then
        plant_seed_internal ${from%/*} ${to%/*} || fail
      else
        log_fatal "Seed doesn't exist for $to"
        fail1
      fi

    else

      contents=( $(find1 $from | sort -g) ) || fail
      local target
      begin_for x in ${contents[*]}; doo
        x_part=${x##*/}
        target=$to/$x_part
        if [[ -d $x ]]; then
          if [[ ! -e $target ]]; then

            # remove broken links
            if [[ -L $target ]]; then
              rm $target || fail
            fi

            if [[ $x_part == .dna || $x_part == .root ]]; then
              safe_link $(realpath $x) $to/ || fail
            elif [[ $x_part == .key ]]; then
              key_path=$x || fail
            elif [[ $x_part == .lib ]]; then
              mkdir $target || fail
              safe_link $(realpath $x)/* $target/ || fail
            elif [[ $x_part == .mock && "${current_mock:-f}" != f && -d $x/$current_mock ]]; then
              safe_link $(realpath $x)/$current_mock/!(export) $to/ || fail
            elif [[ $x_part == *:* ]]; then

              if [[ "${branch_coordinate_fields:-}" ]]; then
                local dim_part=${x_part%%:*} \
                  mem_part=${x_part#*:}

                if [[ ! $dim_part =~ ^[a-zA-Z0-9_]+$ ]]; then
                  log_fatal "Invalid dim name: $dim_part, found in $x"
                  fail1
                fi

                local values
                coord_type=branch \
                dim=$dim_part \
                fetch_values_from_coordinates $dim_part || fail

                local value_count=${#values[*]}

                # Hashed members currently not supported
                # Not too hard to implement, but isn't likely to be needed
                if (( value_count == 1 )) && [[ "$values" == "$mem_part" ]]; then
                  plant_seed_internal $x $to || fail
                fi
              fi

            elif [[ $x_part != .* ]]; then
              mkdir $target || fail
            fi
          fi
          if [[ $x_part != .* && -d $target && $deep == t ]]; then
            plant_seed_internal $x $target || fail
          fi
        elif [[ $cell_is_leaf == t && ! -e $target && $x_part != .* ]]; then
          if [[ $x == *.safe ]]; then
            ignore_failure=t \
            cell_decrypt_file $x ${target%.safe} || fail
          else
            cp -a $x $to/ || fail
          fi
        fi
      end_for

    fi
  end_function
  handle_return
}

# inputs: $1  work path to the cell
plant_seed() {
  local seed_path from=$1 to=${2:-$1} \
    deep=${deep:-t} \
    ignore_nonexistent=${ignore_nonexistent:-f}

  begin_function

    if [[ ! -d "$to" ]]; then
      log_fatal "plant_seed called on a non-existant work path: $to"
      fail1
    fi

    find_seed_path $from || fail
    if [[ ! "$seed_path" ]]; then
      log_fatal "No seed is associated with this path: $to"
      fail1
    fi

    local dna_path=$seed_path
    if [[ $command_requires_cell == t ]]; then
      while [[ ! -d $dna_path/.dna ]]; do
        dna_path=${dna_path%/*}
        if [[ $dna_path != /*/* ]]; then
          log_fatal "Could not find dna in seed: $seed_path"
          fail1
        fi
      done

      if [[ $dna_path != $seed_path ]]; then
        safe_link $dna_path/.dna $to/ || fail
      fi

    fi

    plant_seed_internal $seed_path $to || fail

  end_function
  handle_return
}

# inputs: parent_path seed_path member dim
plant_member() {
  begin_function
    local deep=${deep:-f} repair=${repair:-f}
    get_sane_value "$member" || fail
    member_path=$parent_path/$dim:$sane_value
    if [[ ! -d $member_path || $repair == t ]]; then

      local new_path=$member_path.new

      if [[ -d $new_path ]]; then
        rm -rf $new_path || fail
      fi

      mkdir $new_path || fail
      if [[ "$member" != "$sane_value" ]]; then
        echo -n "$member" >$new_path/.member || fail
      fi

      local cell_is_leaf=t
      if [[ ${child_dims:-} ]] && (( ${#child_dims[*]} > 1 )); then
        cell_is_leaf=f
      fi
      plant_seed $member_path $new_path || fail

      if [[ -e $member_path ]]; then
        rm -rf $member_path || fail
      fi
      mv $new_path $member_path || fail

    fi
  end_function
  handle_return
}

create_sub_cell() {
  local sub_cell=$sub_cell \
    parent_cell=$parent_cell \
    parent_seed=$parent_seed

  local log_show_vars='^sub_cell'
  begin_function

    log_debug "Creating sub cell $cell_path"

    if [[ "$sub_cell" == */.dna* ]]; then
      log_fatal "Internal error: Invalid sub_cell $sub_cell."
      log_fatal "We should not be creating a sub cell inside of a dna folder"
      fail1
    fi

    if [[ "$parent_cell" == "$sub_cell" ]]; then
      log_fatal "Can't create sub cells in a cell without parents: $sub_cell"
      stack_trace
      fail1
    fi

    deep=t \
    parent_path=$parent_cell \
    seed_path=$parent_seed \
    member=$member \
    repair=t \
    plant_member || fail

  end_function
  handle_return
}

grow_member() {
  local sane_value member_path \
    log_show_vars=member \
    upstream_cell_link=${upstream_cell_link:-} \
    cell_path=$cell_path \
    original_cell_path=$cell_path \
    anchor_dims=${anchor_dims:-} \
    dim=$dim \

  begin_function

    get_sane_value "$member" || fail
    member_path=$cell_path/$dim:$sane_value

    log_debug "Updating member $dim:$sane_value"

    local needs_update=
    if [[ ! -d $member_path/.dna ]]; then
      parent_cell=$cell_path \
      parent_seed=$seed_path \
      sub_cell=$member_path \
      create_sub_cell || fail
      needs_update=t
    else
      cell_path=$member_path
      get_needs_update $member_path || fail
    fi

    if [[ "${upstream_cell_link:-}" ]]; then
      cell_path=$member_path update_downstream || fail
    fi

    if [[ $needs_update == t ]]; then

      if (( member_count > 1 )); then
        log_debug "More than one member found ($member_count), not passing upstream_cell_link."
        upstream_cell_link=
      elif [[ "$upstream_cell_link" ]]; then
        log_debug "Only one member found, passing upstream_cell_link: $upstream_cell_link"
      fi

      fork execute_commands $member_path update || fail

      if [[ $update_successful == f ]]; then
        #log_error "Failed to update member cell $member_path"
        reply_to_caller "update_successful=f" || fail
      else 
        update_successful=t
      fi
    fi

    if (( member_count == 1 )); then
      upstream_cell_link=
    fi
  end_function
  handle_return
}

grow_members() {
  begin_function

    local dim=${child_dims[0]}
    update_successful=t
    par=t fork=f function=grow_member for_each_member $dim || fail

  end_function
  handle_return
}

# inputs:
#   target_cell
#   prefix
load_upstream_vars() {
  begin_function

    if [[ ! -d "${target_cell:-}" ]]; then
      log_fatal "Internal error: missing target_cell $target_cell"
    fi

    local export_path=$target_cell/export \
      out_path=$target_cell \
      prefix=${prefix:-}${target_cell##*/}_ \
      dna_roots= \
      context_type= \

    prefix=${prefix//-/_}

    pass_thru=t \
    recursive=f \
    ignore_unknown=t \
    auto_load_tab_vars=t \
    load_dna_contents $out_path || fail

    if [[ -d $export_path ]]; then
      ignore_unknown=t \
      pass_thru=t \
      load_dna_contents $export_path || fail
    fi

  end_function

  if failed; then
    update_successful=f
  fi

  handle_return
}

grow_up_inner() {
  begin_function

    local prep_function=${up_cell_type}_prep
    if function_exists $prep_function; then
      log_debug "Executing $up_cell_type prep function: $prep_function"
      $prep_function || fail
    fi

    # other preps are only run if there isn't a specific prep function for the upstream
    local other_prep_function=${up_cell_type}_other_prep
    prep_function=${up_cell_type}_${up_var}_prep
    if function_exists $prep_function; then
      log_debug "Executing prep function: $prep_function"
      $prep_function || fail
    elif function_exists $other_prep_function; then
      log_debug "Executing other prep function: $other_prep_function"
      $other_prep_function || fail
    fi

    local up_cell_path \
      short_cell \
      upstream_cell_link \
      downstream_cell_name \

    if [[ $needs_update == t ]]; then
      
      maybe_fix_up || fail

      upstream_cell_link=$up_cell
      get_short_cell $cell_path

      if [[ $up_cell_type == up ]]; then
        downstream_cell_name=${short_cell//\//_}
      else
        downstream_cell_name=
      fi

      up_cell_path=$(realpath $up_cell) || fail
      if [[ $up_cell_path == */.cyto/* ]]; then
        log_fatal "Internal error: up_cell_path is in cyto: $up_cell_path"
        fail1
      fi

      needs_update=

      #  Don't clear anchor_dims because it might be set by prep
      #local anchor_dims=
      get_needs_update $up_cell_path || fail

      if [[ $needs_update == t ]]; then
        execute_commands "$up_cell_path" update || fail
      fi

    else
      log_verbose "Skipping update of upstream $up_name because prep function set needs_update=f"
      reply_to_caller "update_skipped=t"
    fi

    #    not sure why this is here
    # reply_to_caller "needs_update=$needs_update"

  end_function
  handle_return
}

# inputs:
#   up_cell_type
#   up_cell
grow_up() {
  begin_function
    if [[ ! "${up_cell:-}" ]]; then
      log_fatal "Internal error: up_cell was not passed into execute_up"
      fail1
    fi

    if [[ ! "${up_cell_type:-}" ]]; then
      log_fatal "Internal error: up_cell_type was not passed into execute_up"
      fail1
    fi

    local up_name=${up_cell##*/}
    log_debug "Growing $up_cell_type $up_name"

    local needs_update=t \
      up_var=${up_name//-/_} \

    update_skipped=f
    fork grow_up_inner || fail

    validation_says_already_done=

    local post_function=${up_cell_type}_post
    if function_exists $post_function; then
      log_debug "Executing all post function: $post_function"
      $post_function || fail
    fi

    # other posts are only run if there isn't a specific post function for the upstream
    local other_post_function=${up_cell_type}_other_post
    post_function=${up_cell_type}_${up_var}_post
    if function_exists $post_function; then
      log_debug "Executing post function: $post_function"
      $post_function || fail
    elif function_exists $other_post_function; then
      log_debug "Executing other post function: $other_post_function"
      $other_post_function || fail
    fi
    
  end_function
  handle_return
}

grow_upstream() {

  local original_cell_path=${cell_path:-} \
    upstream=$1 \
    up_cell_type=$up_cell_type \

  local log_show_vars=^upstream 
  begin_function

    local upstream_cell_link= \
      anchor_dims= \
      grow_history=${grow_history:-} \
      upstream_var=${upstream_name//-/_} \

    local cell_path=${upstream%/.cyto/up/$upstream_name}
    if [[ $cell_path == $upstream ]]; then
      log_fatal "Invalid upstream: $upstream, it should be within .cyto/up"
      fail1
    fi

    local cyto_path=$cell_path/.cyto
    local up_path=$cyto_path/up

    localize

    up_cell=$upstream \
    grow_up || fail

  end_function
  handle_return
}

grow_command() {
  begin_function

    local leave_loop=0 \
      something_changed=f \
      needs_update=${needs_update:-} \
      needs_inner=f \
      grow_successful=t \

    grow_context $cell_path || fail
    fence

    if [[ "${upstream_cell_link:-}" ]]; then
      update_downstream || fail
    fi

    calc_coords_branch || fail
    fence

    if [[ -v branch_coordinate_data ]]; then
      show_coordinates || fail
    fi

    if [[ $cell_is_leaf == t ]]; then

      # this isn't directly needed to calculate the cell branches,
      # but it may be used in upstream prep functions to figure out the
      # branches of upstream cells
      handle_no_coords=ignore \
      calc_coords_leaf || fail
      grip_fence

      # make sure convert_table_to_dims doesn't try to hit any other row
      local row_index=0

      if [[ -v branch_coordinate_fields ]]; then
        table=branch_coordinate \
        target_dim_var_types='ddim ddims' \
        convert_table_to_dims || fail
      fi

      if [[ -v leaf_coordinate_fields ]]; then
        table=leaf_coordinate \
        target_dim_var_types='ddim ddims' \
        convert_table_to_dims || fail
      fi

      local can_agg=f
      deep=t plant_seed_internal "$seed_path" "$cell_path" || fail

      if [[ $cell_is_leaf == f ]]; then
        if [[ "${child_dims:-}" ]]; then
          grow_members || fail
          if [[ $grow_successful == f ]]; then
            log_error "Some members of $short_cell failed to update successfully."
          fi
        else
          log_fatal "Internal error: cell is not a leaf, yet it doesn't have child dims?"
          fail1
        fi
      else

        # grow upstreams
        begin_for upstream_name in "${up[@]}"; doo
          upstream=$up_path/$upstream_name \
          up_cell_type=up \
          grow_upstream $upstream || fail
        end_for

        # grow validators
        begin_for upstream_name in "${validator[@]}"; doo
          upstream=$validator_path/$upstream_name \
          up_cell_type=validator \
          grow_upstream $upstream || fail
        end_for

        # grow reactors
        begin_for upstream_name in "${reactor[@]}"; doo
          upstream=$reactor_path/$upstream_name \
          up_cell_type=reactor \
          grow_upstream $upstream || fail
        end_for

      fi

    else
      grow_successful=t
      abort
    fi

  end_function

  command_successful=${grow_successful:-f}
  reply_to_caller "command_successful=${command_successful:-}"

  handle_return
}

