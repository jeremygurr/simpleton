#!/usr/bin/env bash

##########################################################
# BASH-LIFTED
# A bash library of functions to increase debugability of bash scripts.
# depends on: omni-log bash-debugger bash-lib 
##########################################################

type -t bash_lifted_init >/dev/null && return 0
declare -A trace_var_old trace_var_sub lifted_breaker_time lifted_breaker_open

handle_special_vars() {
  local -n vars=$1
  local t new_vars=
  for t in $vars; do
    if [[ ! "${t#^}" =~ ^[a-zA-Z0-9_]+$ ]]; then
      echo "Invalid var name: ${t#^}" >&$fd_original_err
      vars=
      return 1
    fi
  done
  vars=${new_vars% }
}

# Run this near the top of scripts using this functionality, after the commandline parameters 
#   have been processed
bash_lifted_init() {

  set -u +Hm -o pipefail
  shopt -s expand_aliases extglob dotglob globstar huponexit
  umask 0077  # to make created files readable only by the user by default

  if [[ ! -v fd_original_in ]]; then
	exec {fd_original_in}<&0
	exec {fd_original_out}>&1
	exec {fd_original_err}>&2
  fi

  # don't actually need the fds, only need the allocated descriptor numbers
  exec 10<&0
  exec 11>&1
  exec 12>&2

  debug_id_current=0

  # this is empty, meaning we haven't forked yet. the top level process having a blank id
  fork_id_current=
  fork_debug_id=0

  autorepair_level=${autorepair_level:-${repair:-1}}
  log_var_entries_stack=()
  log_var_show_vars_stack=()

  trace_vars=${trace_vars:-${trace_var:-${traces:-${trace:-}}}}

  handle_special_vars trace_vars || return 1

  DEBUG_COLOR=$CYAN
  DIM_DEBUG_COLOR=$DIM_CYAN
  trace_structure=${trace_structure:-${trace_struct:-}}
  trace_stack=${trace_stack:-}
  if [[ "$trace_stack" == t ]]; then
    trace_stack=0
  fi

  default_grip=1000
  grip=${grip:-$default_grip}
  if [[ $grip == t ]]; then
    grip=100
  fi

  slow_down=${slow_down:-${slow:-}}
  if [[ $slow_down == t ]]; then
    slow_down=0.1
  fi

  if [[ "${no_debug:-f}" == t ]]; then
    echo "${DEBUG_COLOR}Disabling all debug features to boost speed to max" >&2
  fi

  parameter_questions=() 

  # Make sure that Control-C exits this script, even if running a subcommand which doesn't handle Control-C properly.
  trap '
	trap - INT # restore default INT handler
	kill -s INT "$$"
  ' INT

  # some required defaults
  export tmp_folder="${tmp_folder:-/tmp}"
  export EDITOR=${EDITOR:-vim}

  export tracing_depth=${tracing_depth:-0}
  export no_trace_depth=${no_trace_depth:-0}

  NL=$'\n'
  CR=$'\r'
  TAB=$'\t'
  ESC=$'\e'
  DQ='"'
  SQ="'"
  CONTROL_N=$'\xe'
  CONTROL_O=$'\xf'

	   DIM_RED=$'\033[0;31m'
		   RED=$'\033[1;31m'
	 DIM_GREEN=$'\033[0;32m'
		 GREEN=$'\033[1;32m'
	DIM_YELLOW=$'\033[0;33m'
		YELLOW=$'\033[1;33m'
	  DIM_BLUE=$'\033[0;34m'
		  BLUE=$'\033[1;34m'
	DIM_PURPLE=$'\033[0;35m'
		PURPLE=$'\033[1;35m'
	  DIM_CYAN=$'\033[0;36m'
		  CYAN=$'\033[1;36m'
	 DIM_WHITE=$'\033[0;37m'
		 WHITE=$'\033[1;37m'
	 DIM_BLACK=$'\033[0;38m'
		 BLACK=$'\033[1;38m'
		 RESET=$'\033[0m'
	CLEAR_LINE=$'\033[2K\r'
		 CLEAR=$'\033[2J'
  CLEAR_SCREEN=$'\033[2J\r\033[H'
	 CURSOR_UP=$'\033[1A'
	   REVERSE=$'\033[7m'
	 HIGHLIGHT=$'\033[1;37m'

  COL0=$'\n\e[A\e[0G'     COL5=$'\n\e[A\e[5G'     COL10=$'\n\e[A\e[10G'
  COL15=$'\n\e[A\e[15G'   COL20=$'\n\e[A\e[20G'   COL25=$'\n\e[A\e[25G'
  COL30=$'\n\e[A\e[30G'   COL35=$'\n\e[A\e[35G'   COL40=$'\n\e[A\e[40G'
  COL45=$'\n\e[A\e[45G'   COL50=$'\n\e[A\e[50G'   COL55=$'\n\e[A\e[55G'
  COL60=$'\n\e[A\e[60G'   COL65=$'\n\e[A\e[65G'   COL70=$'\n\e[A\e[70G'
  COL75=$'\n\e[A\e[75G'   COL80=$'\n\e[A\e[80G'   COL85=$'\n\e[A\e[85G'
  COL90=$'\n\e[A\e[90G'   COL95=$'\n\e[A\e[95G'   COL100=$'\n\e[A\e[100G'
  COL110=$'\n\e[A\e[110G' COL120=$'\n\e[A\e[120G' COL130=$'\n\e[A\e[130G'
  COL140=$'\n\e[A\e[140G' COL150=$'\n\e[A\e[150G' COL160=$'\n\e[A\e[160G'
  COL170=$'\n\e[A\e[170G' COL180=$'\n\e[A\e[180G' COL190=$'\n\e[A\e[190G'
  COL200=$'\n\e[A\e[200G'

  eval "printf -v hbar_tilde '%.s~' {1..${COLUMNS:-80}}"
  eval "printf -v hbar_equals '%.s=' {1..${COLUMNS:-80}}"
  eval "printf -v hbar_minus '%.s-' {1..${COLUMNS:-80}}"

  pretend_filter=
  case "${pretend:-}" in
	a|'')
	  pretend=ask
	;;
	f|t|ask)
	;;
	*)
	  pretend_filter=$pretend
	  pretend=f
	;;
  esac

  setup_exit_trap

  if (( BASH_VERSINFO < 5 )); then
	echo "You must run this script with at least bash version 5." >&2
	echo "If you already have a correct version of bash in your path, you may need to put:" >&2
	echo "  #!/usr/bin/env bash" >&2
	echo "at the top of your script that you want debugged" >&2
	exit 1
  fi

  original_cmd=${original_cmd:-"$0 $*"}

  local first_run=${first_run:-t}

  debug_output=${debug_output:-f} \
  debug_ignore=${debug_ignore:-} \
  tracing_depth=${tracing_depth:-0} \
  tmp_folder=${tmp_folder:-/tmp} \
  debug_state_file=$tmp_folder/debug-state-$$ \
  debug_id_current=0 \
  debugger_available=t \
  debug_list_stack_pos=0 \
  debug_bisect_min= \
  debug_bisect_max= \
  fork_id_current= \
  fork_debug_id=0 \

  debug_ignore+="
    debug
    debug_id_inc
    debug_load_state
    debug_start
    get_var_value
    handle_user_interrupt
    is_array
    is_set
    load_log_vars_and_write_to_log
    log_debug
    log_error
    log_fatal
    log_info
    log_level_at_least
    log_quick
    log_trace
    log_verbose
    log_warn
    micro_time_diff
    pause_tee
    reached_debug_id
    shell_quote_var
    show_trace_vars
    show_time_update
    snapshot_source_location
    unpause_tee
    write_to_log
    write_to_log_console_out
    write_to_log_log_var
    write_to_log_process_vars
    write_to_log_update_cooked
    " 
  debug_ignore=( $debug_ignore )
  debug_ignore="${debug_ignore[*]}"

  if [[ "$first_run" == t ]]; then
    rm $tmp_folder/debug-* $tmp_folder/side-log-* &>/dev/null || true
  fi

  # used to debug complex debugger internal issues
  side_log_file=$tmp_folder/side-log-$$

  COLUMNS=${COLUMNS:-120}

  if [[ ! "${debug_highlight:-}" ]]; then
    if which source-highlight >/dev/null; then
      debug_highlight=t
    else
      debug_highlight=f
    fi
  fi

  if [[ $debug_highlight == t ]]; then
    if ! which source-highlight >/dev/null; then
      fatal "You set debug_highlight=t, but are missing the highlight command."
      fatal "You can use 'brew install highlight' to install it if you want."
      exit 1
    fi

    rm -rf $tmp_folder/debug_highlight &>/dev/null
    mkdir -p $tmp_folder/debug_highlight || exit 1
  fi

  debug_setup
}

# Used to pass vars to parent of forked processes
# Must set reply_file to a valid location for this to work
reply_to_caller() {
  if [[ "${reply_file:-}" ]]; then
    echo "$*" >>$reply_file || return 1
  fi
  return 0
}

resolve_log_var() {
  case $log in
    o|f|e|w|i|v|t|a)
      log_level_filter=$log
      ;;
    off|fatal|error|warn|info|verbose|trace|all)
      log_level_filter=$log
      ;;
    d|debug)
      log_level_filter=debug
      #show_debug_id=${show_debug_id:-t}
      ;;
    d2|debug2)
      log_level_filter=debug
      show_debug_id=a
      ;;
    file)
      # default behavior
      ;;
    id)
      show_debug_id=${show_debug_id:-t}
      ;;
    id2)
      show_debug_id=a
      ;;
  esac
  case $log_level_filter in
    n)
      log_level_filter=none
    ;;
    f)
      log_level_filter=fatal
    ;;
    e)
      log_level_filter=error
    ;;
    w)
      log_level_filter=warn
    ;;
    i)
      log_level_filter=info
    ;;
    v)
      log_level_filter=verbose
    ;;
    d)
      log_level_filter=debug
    ;;
    t)
      log_level_filter=trace
    ;;
    a)
      log_level_filter=all
    ;;
  esac
}

handle_user_interrupt() {
  local c silent=f prompt=${1:-Paused.}
  echo >&$fd_original_err
  while true; do
    if [[ $silent == t ]]; then
      read -u $fd_original_in -sr -N 1 c >&$fd_original_err
    else
      read -u $fd_original_in -sr -N 1 -p "${YELLOW}$prompt${RESET} (r)esume, (l)og level change, (d)ebug, (t) stack trace, (q)uit? " c >&$fd_original_err
    fi
    silent=f
    case "$c" in
      d)
        echo "debug" >&$fd_original_err
        debug_immediate=t
        unignore_this_function=3 \
        debug_skip_breakpoints=f \
        debug_start n
      ;;
      l)
        echo "log level change" >&$fd_original_err
        local log=
        read -u $fd_original_in -e -p "New log level: " log >&$fd_original_err
        if [[ "$log" ]]; then
          resolve_log_var
          log_format=default
          log_level_filter_changed
          debug_log_level_filter=$log
          reply_to_caller "debug_log_level_filter=$debug_log_level_filter"
          echo "Log level changed to $log_level_filter" >&$fd_original_err
        else
          continue
        fi
      ;;
      q)
        echo "quit" >&$fd_original_err
        exit 100
      ;;
      r)
        echo "resume" >&$fd_original_err
        :
      ;;
      t)
        medium_stack_trace
      ;;
      $NL)
        silent=t
        continue
      ;;
      *)
        echo "invalid key, try again" >&$fd_original_err
        continue
      ;;
    esac
    break
  done
}

# input:
#   $1   previous timestamp (in microseconds, as from EPOCHREALTIME
#   $2   next timestamp
#   $3   var name to write result to, writes time in seconds with .
micro_time_diff() {
  local before=$1 after=$2
  local -n to_var=$3
  local diff=$((after-before)) p1 p2
  diff="000000$diff"
  p1=${diff%%??????}
  p2=${diff#$p1}
  p1=${p1##*(0)}
  to_var="${p1:-0}.$p2"
}

show_time_update() {
  if [[ "${show_time:-f}" == t* && ${showed_something:-f} == f ]]; then
    local new_time=${EPOCHREALTIME/./}
    if [[ $show_time == ts ]]; then
      prefix="$new_time "
    elif [[ "${show_time_prev:-}" ]]; then
      micro_time_diff $show_time_prev $new_time prefix
      prefix="${prefix%???} "
    fi
    showed_something=t
    show_time_prev=$new_time
  fi
}

show_trace_vars() {
  local indent=0 prefix= showed_something=f 

  if [[ ${show_debug_id:-f} == a ]]; then
    show_time_update
    echo -n " $prefix$DIM_DEBUG_COLOR$fork_debug_id$RESET" >&$fd_original_err
    showed_something=t
  fi

  if [[ ${trace_structure:-f} == t && "${struct_type:-}" ]]; then
    show_time_update
    echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id$RESET $current_function ${struct_type:-}" >&$fd_original_err
    showed_something=t
  fi

  if [[ "${trace_stack:-}" && "${struct_type:-}" ]]; then
    show_time_update
    local linear_stack= part i size=${#FUNCNAME[*]}
    if (( size - 1 > trace_stack + 2 )); then
      for (( i = size - 1 - trace_stack; i >= 2; i-- )); do
        linear_stack+="${FUNCNAME[$i]} -> "
      done
      echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id$RESET ${linear_stack%% -> } ${struct_type:-}" >&$fd_original_err
      showed_something=t
    fi
  fi

  if [[ "${trace_fun:-}" ]]; then
    local fun
    for fun in $trace_fun; do
      if [[ "${struct_type:-}" == *" $fun" ]]; then
        show_time_update
        echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id $current_function ${struct_type:-}$RESET" >&$fd_original_err
        showed_something=t
      fi
    done
  fi

  stack_detail[$stack_pos]=
  if [[ "${log_show_vars:-}" ]]; then
    local var value show_vars
    for var in $log_show_vars; do
      value=
      local real_var=${var#^}
      real_var=${real_var#*=}
      get_var_value $real_var
      show_vars+="$real_var=$value "
    done
    stack_detail[$stack_pos]+="${show_vars% } "
  fi

  if [[ "${trace_vars:-}" ]]; then
    local var value
    for var in $trace_vars; do
      get_var_value $var
      local show_val=$value
      if [[ "${secret_vars:-}" && " ${secret_vars} " == *" $var "* ]]; then
        show_val='****'
      fi
      stack_detail[$stack_pos]+="$var=$show_val "
      if [[ -v trace_var_sub[$var] ]]; then
        if [[ "${trace_var_sub[$var]}" != "$value" ]]; then
          show_time_update
          echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id ${YELLOW}$var=$show_val$RESET" >&$fd_original_err
          showed_something=t
          if [[ " $pause_at_vars " == *" $var "* ]]; then
            handle_user_interrupt "Var changed: $var."
          fi
        fi
        unset trace_var_sub[$var]
        trace_var_old[$var]=$value
      elif [[ "${trace_var_old[$var]:-}" != "$value" || ${trace_var_always:-f} == t ]]; then
        if [[ $fork_debug_id != 1 || "$value" != '(unset)' ]]; then
          show_time_update
          echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id_minus_one $var=$show_val$RESET" >&$fd_original_err
          showed_something=t
          if [[ " $pause_at_vars " == *" $var "* ]]; then
            handle_user_interrupt "Var changed: $var."
          fi
        fi
        unset trace_var_sub[$var]
        trace_var_old[$var]=$value
      fi
    done
  fi
  if [[ "${trace_condition:-}" ]]; then
    local result
    set +u
    eval "if $trace_condition; then result='${GREEN}TRUE'; else result='${RED}FALSE'; fi"
    set -u
    if [[ "${trace_var_old:-}" != "$result" ]]; then
      show_time_update
      echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id $trace_condition is $result$RESET" >&$fd_original_err
      showed_something=t
      trace_var_old=$result
    fi
  fi
  if [[ "${trace_expression:-}" ]]; then
    local result
    set +u
    eval "result=$trace_expression"
    set -u
    if [[ "${trace_var_old:-}" != "$result" ]]; then
      show_time_update
      echo " $prefix${DIM_DEBUG_COLOR}debug_id=$fork_debug_id expression=$result$RESET" >&$fd_original_err
      showed_something=t
      trace_var_old=$result
    fi
  fi
  stack_detail[$stack_pos]="${stack_detail[$stack_pos]% }"
}

reached_debug_id() {
  local r1 r2 p1 p2 i=0
  OIFS=$IFS
  IFS=. r1=( $fork_debug_id ) r2=( $1 )
  IFS=$OIFS
  while true; do
    p1=${r1[$i]:-} p2=${r2[$i]:-}
    (( i++ ))
    if [[ "$p1" ]]; then
      if [[ "$p2" ]]; then
        if (( p1 < p2 )); then
          return 1
        elif (( p1 > p2 )); then
          return 0
        fi
      else
        return 0
      fi
    else
      if [[ "$p2" ]]; then
        return 1
      else
        return 0
      fi
    fi
  done
}

debug_id_inc() {
  (( no_trace_depth++ )) || true

  local allow_breaker_update=${allow_breaker_update:-t}

  if [[ -v lifted_breaker_open[$current_function] ]]; then
    #echo "Skipping $current_function because breaker is open" >&2
    (( no_trace_depth-- )) || true
    return 0
  fi

  local debug_id_inc_start=${EPOCHREALTIME//./} diff
  if [[ -v lifted_breaker_time[$current_function] && $allow_breaker_update == t ]]; then
    (( diff = debug_id_inc_start - lifted_breaker_time[$current_function] )) || true
    if (( diff < grip )); then
      #if (( grip < default_grip )); then
      #  echo "Opening breaker for $current_function because two events happened less than $grip microseconds apart: $diff" >&$fd_original_err
      #fi
      lifted_breaker_open[$current_function]=t
      #echo "Breakers open: ${!lifted_breaker_open[*]}"
      (( no_trace_depth-- )) || true
      return 0
    fi
  fi
  lifted_breaker_time[$current_function]=$debug_id_inc_start

  local debug_id_prev=$debug_id_current

  (( debug_id_current++ )) || true

  fork_debug_id=$debug_id_current
  fork_debug_id_minus_one=$debug_id_prev
  if [[ "$fork_id_current" ]]; then
    fork_debug_id=$fork_id_current.$fork_debug_id
    fork_debug_id_minus_one=$fork_id_current.$fork_debug_id_minus_one
  fi

  if read -u $fd_original_in -t 0; then
    local c
    read -u $fd_original_in -sr -N 1 c
    if [[ "$c" == "$NL" ]]; then
      handle_user_interrupt
    fi
  fi
  show_trace_vars

  if [[ "$slow_down" ]]; then
    sleep $slow_down
  fi

  if [[ "${struct_type:-}" && "${pause_at_functions:-}" \
     && " $pause_at_functions " == *" ${FUNCNAME[1]} "* \
     && $struct_type == start \
     ]]; then
    handle_user_interrupt "Reached $current_function ${struct_type:-}."
  fi

  if [[ "${pause_at_debug_id:-}" ]] && reached_debug_id $pause_at_debug_id; then
    handle_user_interrupt "Reached ${pause_at_debug_id:-}."
  elif [[ "${debug_id:-}" && $debug_id != t ]] && reached_debug_id $debug_id; then
    if [[ "${debug_bisect_min:-}" ]]; then
      local response new_bisect
      if [[ "${bisect_test:-}" ]]; then
        eval "$bisect_test"
      fi
      prompt_ynq "${NL}Debug bisect: Did the problem happen?" response
      case $response in
        y)
          new_bisect=${debug_bisect_min}..${debug_id}
        ;;
        n)
          new_bisect=$(( debug_id + 1 ))..${debug_bisect_max}
        ;;
        q)
          exit 1
        ;;
      esac
      debug_get_new_bisect
      debug_restart_command=$new_command debug_exit=t debugging=
      exit 100
    else # debug_id matched
      debug_id=t
      if [[ "$debug" ]]; then
        debug_handle_resolve_next
      else
        debug_immediate=t
        unignore_this_function=2 \
        debug_skip_breakpoints=f \
        debug_start n
      fi
    fi
  elif [[ "${debug_quick_function:-}" && $debug_quick_function == ${FUNCNAME[1]} ]]; then
    #debug_ignore_remove ${FUNCNAME[*]:1:4}
    debug_function_old=$debug_quick_function
    debug_quick_function=
    if [[ "$debug" ]]; then
      debug_handle_resolve_next
    else
      #debug_debug=t
      #trace_debugger=t
      debug_immediate=t
      unignore_this_function=2 \
      debug_skip_breakpoints=f \
      debug_start n
    fi
  fi

  if [[ "${debug_quick_stop_less_than_depth:-}" ]] && \
     (( ${#FUNCNAME[*]} <= debug_quick_stop_less_than_depth )); then
    debug_quick_stop_less_than_depth=
    debug_immediate=t
    unignore_this_function=2 \
    debug_skip_breakpoints=f \
    debug_start n
  fi

  #   for performance testing
  #debug_id_inc_diff=$(( ${EPOCHREALTIME//./} - debug_id_inc_start ))
  #echo "debug_id_inc_diff($current_function) = $debug_id_inc_diff" >&2

  (( no_trace_depth-- )) || true
}

trace_time_summarize() {
  eval "exec $trace_time_fd>&-"
  trace_time_fd=

  if [[ ! "$trace_time_log" ]]; then
    echo "Internal error: Missing trace_time_log" >&$fd_original_err
    return 1
  fi

  echo "$NL$hbar_equals" >&$fd_original_err
  echo "trace_time summary by function instance in chronological order:$NL" >&$fd_original_err
  { echo "duration(µs) function id_start id_end"; 
    awk '
    /^[0-9]/ { 
      x=$3; gsub("\\.", " ", x)
      y=x
      gsub("[^ ]", "", y)
      result=($1 " " $2 " " $3 " " $4 " " x)
      for(i=6-length(y); i>1; i--) {
        result=(result " 0")
      }
      print result
    }
    ' $trace_time_log | sort -n -k5 -k6 -k7 -k8 -k9 -k10 \
    | awk '{ print $1, $2, $3, $4 }' \
    | field=0 format_number_stream \
    | field=4 format_number_stream;
  } | column -t >&$fd_original_err

#  echo "$NL$hbar_equals"
#  echo "trace_time summary by function instance sorted by name:$NL"
#  { echo "duration(µs) function id_start id_end"; sort -k2 $trace_time_log } \
#    | field=0 format_number_stream | field=4 format_number_stream | column -t 
#
#  echo "$NL$hbar_equals"
#  echo "trace_time summary by function instance sorted by time:$NL"
#  { echo "duration(µs) function id_start id_end"; sort -n $trace_time_log } \
#    | field=0 format_number_stream | field=4 format_number_stream | column -t 

  echo "$NL$hbar_equals" >&$fd_original_err
  echo "trace_time summary by function sorted by time:$NL" >&$fd_original_err
  { echo "duration(µs) function executions"; sort -k2 $trace_time_log \
    | awk '
  BEGIN {
    prev=""
  }
  prev != $2 {
    if ( prev != "" && total > 0 ) print total " " prev " x" count
    prev=$2
    total=0
    count=0
  }
  {
    total+=$1
    count+=1
  }
  END {
    if ( prev != "" && total > 0 ) print total " " prev " x" count
  }
  ' | sort -n | field=0 format_number_stream; } \
  | column -t >&$fd_original_err

}

: ${trace_time:=f}

alias timebox_open='
  (( no_trace_depth++ )) || true
  timebox_stack+=( $timebox )
  if [[ $trace_time == t ]]; then
    trace_time_open
  fi
  (( no_trace_depth-- )) || true
'

alias timebox_close='
  (( no_trace_depth++ )) || true
  trace_time_close
  unset timebox_stack[-1]
  timebox=${timebox_stack[-1]}
  (( no_trace_depth-- )) || true
'

alias trace_time_open='
  if [[ ! ${trace_time_fd:-} ]]; then
    : ${trace_time_log:=/tmp/trace_time.log}
    [[ -e $trace_time_log ]] && rm $trace_time_log
    exec {trace_time_fd}<>$trace_time_log
  fi
  trace_time_start=${EPOCHREALTIME/./}
  trace_time_start_debug_id=$fork_debug_id
'

alias trace_time_close='
  if [[ $trace_time == t && "${trace_time_fd:-}" ]]; then
    trace_time_stop=${EPOCHREALTIME/./}
    (( time_dur = trace_time_stop - trace_time_start )) || true
    echo "$time_dur $timebox $trace_time_start_debug_id $fork_debug_id" >&$trace_time_fd
  fi
'

if [[ "${no_debug:-f}" == f ]]; then

# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
alias begin_function_hi='
  (( no_trace_depth++ )) || true
  local return_value=0 break_out=f function_level=2 repair_attempted=f current_function=${function_override:-${FUNCNAME:-unknown}} function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
  (( log_depth_current++ )) || true
  if [[ $trace_time == t ]]; then
    trace_time_open
  fi
  struct_type=start debug_id_inc
  log_vars= log_show_vars=
  stack_debug_id[$stack_pos]=$fork_debug_id
  stack_high_level[$stack_pos]=1
  while true; do
  if [[ ${debug_step_to_hi_function:-f} == t || ${debug_step_to_mid_function:-f} == t ]]; then
    debug_id=t
    debug_immediate=t
    debug_skip_breakpoints=f
    debug_start n
  fi
  (( no_trace_depth-- )) || true
'

else

alias begin_function_hi='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=0 repair_attempted=f current_function= function_override= timebox_stack= trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=
  while true; do
  (( no_trace_depth-- )) || true
'

fi
  
if [[ "${no_debug:-f}" == f ]]; then

# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
alias begin_function='
  (( no_trace_depth++ )) || true
  local return_value=0 break_out=f function_level=1 repair_attempted=f current_function=${function_override:-$FUNCNAME} function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
  if [[ $trace_time == t ]]; then
    trace_time_open
  fi
  struct_type=start debug_id_inc
  log_vars= log_show_vars=
  stack_debug_id[$stack_pos]=$fork_debug_id
  while true; do
  if [[ ${debug_step_to_mid_function:-f} == t ]]; then
    debug_id=t
    debug_immediate=t
    debug_skip_breakpoints=f
    debug_start n
  fi
  (( no_trace_depth-- )) || true
'

else

alias begin_function='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=0 repair_attempted=f current_function= function_override= timebox_stack= trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=
  while true; do
  (( no_trace_depth-- )) || true
'

fi
  
if [[ "${no_debug:-f}" == f ]]; then

# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
# This one switches between a low level and a mid level function, based on the grip variable
alias begin_function_grip='
  (( no_trace_depth++ )) || true
  local return_value=0 break_out=f function_level=0 repair_attempted=f current_function=${function_override:-$FUNCNAME} function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
  if (( grip < default_grip )); then
    function_level=1
    if [[ $trace_time == t ]]; then
      trace_time_open
    fi
    struct_type=start debug_id_inc
    log_vars= log_show_vars=
    stack_debug_id[$stack_pos]=$fork_debug_id
  fi
  while true; do
  if (( grip < default_grip )); then
    if [[ ${debug_step_to_mid_function:-f} == t ]]; then
      debug_id=t
      debug_immediate=t
      debug_skip_breakpoints=f
      debug_start n
    fi
  fi
  (( no_trace_depth-- )) || true
'
  
else

alias begin_function_grip='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=0 repair_attempted=f current_function= function_override= timebox_stack= trace_time_start trace_time_start_debug_id trace_time_stop time_dur stack_pos=
  while true; do
  (( no_trace_depth-- )) || true
'

fi
  
# The local vars in this alias MUST be on the same line (no \ separators) or debugging doesn't have correct line numbers
alias begin_function_lo='
  (( no_trace_depth++ ))
  local return_value=0 break_out=f function_level=0 repair_attempted=f function_override= timebox_stack=( $FUNCNAME ) trace_time_start trace_time_start_debug_id trace_time_stop time_dur log_show_vars= log_vars=
  while true; do
  (( no_trace_depth-- )) || true
'

alias end_function='
  (( no_trace_depth++ )) || true
  break
  done
  local log_return_vars=
  if (( function_level > 0 )); then
    stack_pos=$(( ${#FUNCNAME[*]} - 1 ))
    struct_type=end debug_id_inc
    unset stack_debug_id[$stack_pos] stack_detail[$stack_pos] stack_high_level[$stack_pos]
  fi
  (( no_trace_depth-- )) || true
'

alias handle_return='
  (( no_trace_depth++ )) || true
  case $function_level in
    2)
      timebox=$FUNCNAME
      trace_time_close
      load_log_vars_and_write_to_log
      (( log_depth_current-- )) || true
    ;;
    1)
      timebox=$FUNCNAME
      trace_time_close
    ;;
    0)
      if (( no_trace_depth-- <= 1 )); then 
        no_trace_depth=1
      fi
    ;;
  esac
  debug_return_vars=${log_return_vars:-}
  no_trace_depth=$((no_trace_depth-1)) || true
  return $return_value
'

alias begin_while='break_out=f; while'
alias   begin_for='break_out=f; for'
alias  begin_loop='break_out=f; while true'
alias   end_while='done; [[ $break_out == t ]] && break'
alias     end_for='done; [[ $break_out == t ]] && break'
alias    end_loop='done; [[ $break_out == t ]] && break'

# end_while or end_for or end_loop should usually be used instead of this.
# This is helpful though if the done part needs to be separated from the break part
alias maybe_break='[[ $break_out == t ]] && break'

alias handle_exit='exit $return_value'

# to avoid bash syntax parsing problems, and provide a hook for loop beginning
alias         doo=do

#  instead of this, just put a fence at beginning of loop if an extra debug step is needed
#alias         doo='do debug_id_inc;'

# This performs the same debug_id advancement that begin_function and others do,
#   except unlike begin_function this may be placed anywhere within a function,
#   providing a stopping point for debugging of larger blocks of code that otherwise
#   can't be split up.
if [[ "${no_debug:-f}" == f ]]; then

alias fence='allow_breaker_update=f debug_id_inc; log_show_vars='
alias grip_fence='(( grip < default_grip )) && allow_breaker_update=f debug_id_inc; log_show_vars='
# Same as fence, but denotes that it is intended to be only for a brief debug session and should be removed before committing
alias zombie_fence='allow_breaker_update=f debug_id_inc; log_show_vars='
alias zombie_pause=pause_qd

else

alias fence=
alias fence_grip=
alias zombie_fence=
alias zombie_pause=

fi

# used after a direct command which may fail: cd /somewhere || fail
alias fail='{ return_value=$?; (( return_value < 100 )) && attempt_autorepair $FUNCNAME && { repair_attempted=t; continue; }; break_out=t; break; }'
alias fail_later='{ return_value=$?; break_out=t; }'
alias fail_later1='{ return_value=1; break_out=t; }'

# reverses a failure state
alias unfail='return_value=0; break_out=f;'

# used as a standalone command triggering the failed state and exiting the block
alias fail1='{ return_value=1; attempt_autorepair $FUNCNAME && { repair_attempted=t; continue; }; break_out=t; break; }'
alias fail2='{ return_value=2; attempt_autorepair $FUNCNAME && { repair_attempted=t; continue; }; break_out=t; break; }'
alias succeed='{ return_value=100; break_out=t; break; }'

# used to check if something failed: failed && break
alias failed='(( return_value > 0 && return_value < 100 ))'
alias abort='{ return_value=0; break_out=t; break; }'
alias succeeded='(( return_value == 0 || return_value >= 100 ))'
alias handle_break='[[ $break_out == t ]] && break'

attempt_autorepair() {
  local repair_successful=f func_name=$1

  if [[ "${debug_quick_function:-}" == fail ]]; then
    debug_immediate=t
    debug_skip_breakpoints=f \
    debug_start
  fi

  if [[ $autorepair_level > 0 && ${repair_attempted:-f} == f ]] \
    && declare -pf repair_$func_name &>/dev/null
    then
    log_debug "Attempting auto-repair of $func_name"
    repair_$func_name

    if [[ $repair_successful == t ]]; then
      log_debug "Autorepair of $func_name successful."
      return_value=0 break_out=f
    else
      log_debug "Autorepair of $func_name failed."
    fi

  fi

  [[ $repair_successful == t ]]
}

parameters_to_env() {
  local term OIFS k v update_original_cmd=${update_original_cmd:-t}
  real_params=( )
  if [[ $update_original_cmd == t ]]; then
    original_cmd=$0
  fi

  for term; do

    if [[ $update_original_cmd == t ]]; then
      if [[ "$term" == *[\ \$]* ]]; then
        if [[ "$term" =~ ^([a-zA-Z0-9_]+)=(.*)$ ]]; then
          original_cmd+=" ${BASH_REMATCH[1]}='${BASH_REMATCH[2]}'"
        else
          original_cmd+=" \"$term\""
        fi
      else
        original_cmd+=" $term"
      fi
    fi

    if [[ "$term" =~ ^([a-zA-Z0-9_]+)=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      if [[ "$v" == :: ]]; then
        read -p "$k=" -rs v || return 1
        echo '************'
      elif [[ "$v" == : ]]; then
        read -p "$k=" -r v || return 1
      elif [[ "$v" == \? ]]; then
        parameter_questions+=( $k )
        v=
      elif [[ "$v" == \?\? ]]; then
        parameter_questions+=( $k )
        (( command_detail++ ))
        v=
      fi
      k=${k,,}
      eval "$k='$v'"
      eval "p_$k='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "$k='$v'"
        eval "p_$k='$v'"
      fi
    elif [[ "$term" =~ ^([a-zA-Z0-9_]+)\+=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      k=${k,,}
      eval "${k}_append='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "${k}_append='$v'"
      fi
    elif [[ "$term" =~ ^([a-zA-Z0-9_]+)\^=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      k=${k,,}
      eval "${k}_prepend='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "${k}_prepend='$v'"
      fi
    elif [[ "$term" =~ ^([a-zA-Z0-9_]+)-=(.*)$ ]]; then
      k=${BASH_REMATCH[1]}
      v=${BASH_REMATCH[2]}
      v=${v//\'/\'\\\'\'}
      k=${k,,}
      eval "${k}_remove='$v'"
      if [[ -v ${k}_alias_of ]]; then
        eval "k=\$${k}_alias_of"
        eval "${k}_remove='$v'"
      fi
    else
      real_params+=( "$term" )
    fi
  done
}

# usage: required_function {function(s) to check...}
# fails if the function doesn't exist
require_function() {
  local i
  for i; do
    if ! type -t $i &>/dev/null; then
      echo "Missing function: $i" >&2
      exit 1
    fi
  done
}

# usage: optional_var {variable} {default}
# fails if any variable doesn't exist
optional_var() {
  local v="$2"
  v="${v//\"/\\\"}"
  eval "export $1=\${$1:-$v}"
}

# usage: require_var {variable(s) to check...}
# fails if any variable doesn't exist
require_var() {
  local i
  for i; do
    [[ -v $i ]] || {
      echo "Required variable is not defined: $i" >&2
      if type -t stack_trace &>/dev/null; then
        stack_trace
      fi
      exit 1
    }
    #eval "export $i"
  done
}

# usage: require_var {variable(s) to check...}
# fails if none of the variables exist
require_var_any() {
  local i found inputs
  for i ; do
    inputs="$inputs $i"
    declare -p $i &>/dev/null && found=t
    #eval "export $i"
  done
  if [ ! "${found:-}" ]; then
    echo "Missing required var. At least one of these must be defined:$inputs" >&2
    exit 1
  fi
  return 0
}

# usage: require_var_or_ask {var name} {question if missing}
require_var_or_ask() {
  local v new_value var_name="$1"
  shift
  local description="$1"

  v=`eval echo "$"$var_name`
  while true; do
    if [ -z "$v" ]; then
      v=`eval echo "$"{#$var_name[*]}`
      if [ "$v" == "0" ]; then
        IFS= read -ep "${description}? ${var_name}=" new_value
        if [ "$new_value" ]; then
          eval "var_name=\"${new_value}\""
          break
        else
          echo "You must enter a valid value to continue."
        fi
      fi
    else
      break
    fi
  done
}

# usage: require_command {command_name} [{hint}]
require_command() {
  local command_name=$1; shift
  local hint=$1

  if ! which $command_name &>/dev/null; then
    echo "Couldn't find required command $command_name on your path." >&2
    [ "$hint" ] && echo "Possible solution: $hint" >&2
    exit 1
  fi

  return 0
}

# use this to make vars local which are computed by another function call
alias local_vars='[[ "${to_local_vars:-}" ]] && eval "local $to_local_vars"'

# some parts of bash require a statement, but in some cases there's nothing to be
# done, so this serves as a clear indication that nothing needs to be done, and yet
# satisfies the requirement that a statement be there. 
alias nothing=':;'

alias start_tracing='(( tracing_depth++ == 0 )) && set -x'
alias stop_tracing='(( --tracing_depth <= 0 )) && { set +x; tracing_depth=0; }'

# used in if condition to be more clear.
# instead of:
#   if ! diff $f1 $f2; then ...
# write:
#   if are_different $f1 $f2; then ...
alias files_are_different='! diff >/dev/null'
alias files_are_same='diff >/dev/null'

alias incomplete='echo "Not implemented yet." >&2; start_frame=1 stack_trace; fail1'

micros_to_minute() {
  local -n _t=$1
  (( _t = _t / 1000000 / 60 ))
}

# input:
#   $1   path to file with wildcard in it
# output:
#   returns true (0) if at least one file exists matching the pattern
wild_file_exists() {
  local pattern=$1
  [[ "$pattern" != *'*'* ]]
}

# assumes input is plural
get_unplural() {
  local word=$1
  local target_var=${2:-unplural}
  local -n target=$target_var
  if [[ $word == *ies ]]; then
    target=${word%ies}
  elif [[ $word == *es ]]; then
    target=${word%es}
  else
    target=${word%s}
  fi
  debug_return_vars=$target_var
  return 0
}

# assumes input is singular
get_plural() {
  local word=$1
  local target_var=${2:-plural}
  local -n target=$target_var
  if [[ $word == *s ]]; then
    target=${word}es
  elif [[ $word == *y && ! $word =~ [aeiou]y$ ]]; then
    target=${word%y}ies
  else
    target=${word}s
  fi
  debug_return_vars=$target_var
  return 0
}

log_level_at_least() {
  local level=$1
  if [[ ! -v log_level_num_map[$level] ]]; then
    log_fatal "Invalid log level: $level"
    fail1
  fi
  local level_num=${log_level_num_map[$level]} \
    log_level_num=${log_level_num_map[${log_level_filter:-all}]}
  (( log_level_num >= level_num ))
}

progress_bar_start() {
  local new_progress_bar_size=${1:-0} front_load=${front_load:-3} below_log=${below_log:-debug}
  if ! log_level_at_least $below_log && [[ "${trace_structure:-f}" == f ]]; then
    progress_bar_total=${progress_bar_total:-0}
    progress_bar_nesting=${progress_bar_nesting:-0}
    progress_bar_front_load=${progress_bar_front_load:-$front_load}
    (( progress_bar_total += new_progress_bar_size ))
    (( progress_bar_nesting++ ))
    progress_bar_start_time=${progress_bar_start_time:-${EPOCHREALTIME/./}}
    progress_bar_current=0
    
    if (( progress_bar_total > 2 )); then
      echo -n "0% complete" >&$fd_original_err
#    else
#      echo -n "..." >&$fd_original_err
    fi
  fi
}

progress_bar_next() {
  local amount_to_add=${1:-1} percentage
  if (( ${progress_bar_nesting:-0} > 0 )); then
    (( progress_bar_current += amount_to_add ))
    if (( progress_bar_total > 2 )); then
      (( percentage = 100 * progress_bar_current / progress_bar_total ))
      local time_taken_micro total_micro remaining_micro extra= remaining_min current_time=${EPOCHREALTIME/./}
      (( time_taken_micro = current_time - progress_bar_start_time ))
      (( total_micro = time_taken_micro * progress_bar_total / progress_bar_current ))
      (( remaining_micro = total_micro - time_taken_micro ))

      remaining_min=$remaining_micro
      (( percentage < 25 )) && (( remaining_min *= progress_bar_front_load ))
      micros_to_minute remaining_min
      if (( remaining_min > 0 )); then
        extra=" ($remaining_min minute(s) left)"
      fi

      if [[ "${progress_bar_last_percentage:-}" != $percentage ]]; then
        echo -n "$CLEAR_LINE" >&$fd_original_err
        echo -n "...$percentage% complete$extra" >&$fd_original_err
      fi
      progress_bar_last_percentage=$percentage
    else # too few total items in progress bar to show %
      local out
      eval "printf -v out '%.s.' {1..$amount_to_add}"
      echo -n "$out"
    fi
  fi
}

progress_bar_nudge() {
  local output_char=${1:-.}
  if (( ${progress_bar_nesting:-0} > 0 )); then
    echo -n "$output_char" >&$fd_original_err
  fi
}

progress_bar_stop() {
  if (( ${progress_bar_nesting:-0} > 0 )); then
    (( progress_bar_nesting-- ))
    if (( progress_bar_nesting == 0 )); then
      local time_taken current_time=${EPOCHREALTIME/./}
      (( time_taken = current_time - progress_bar_start_time ))
      micros_to_minute time_taken
      if (( time_taken > 0 )); then
        echo "...Completed in $time_taken minutes." >&$fd_original_err
      else
        echo -n "${CLEAR_LINE}" >&$fd_original_err
      fi
      unset progress_bar_total progress_bar_nesting \
            progress_bar_front_load progress_bar_start_time \
            progress_bar_current
    fi
  fi
}

remove_empty_parents() {
  local dir=$1 contents recursive=${recursive:-f}
  contents=( $(find1 "$dir") ) || return 1
  if (( ${#contents[*]} == 0 )); then
    rm -r $dir || return 1
    if [[ $recursive == t && "$dir" == /*/*/* ]]; then
      remove_empty_parents "${dir%/*}" || return 1
    fi
  fi
}

valid_var_name() { 
  [[ "$1" =~ [a-zA-Z0-9_]+ ]]
}

# used for temporary logging to debug issues. Uses of this should be removed before
#   committing changes. 
zombie_log() {
  local s=${BASH_SOURCE[1]:-(no source)} \
    f=${FUNCNAME[1]:-(no func)}
  s=${s##*/}
  echo "$CYAN$EPOCHREALTIME debug_id=${fork_debug_id:-} $f $s:${BASH_LINENO[0]} $*$RESET" >&$fd_original_err
}

zombie_lap_reset() {
  zombie_lap_total=0
  unset zombie_lap_time
  declare -Ag zombie_lap_time
  unset zombie_lap_count
  declare -Ag zombie_lap_count
}

# used for temporary debugging of performance issues
# will aggregate time spent between each lap and show percentages and totals
# calls to this should be removed before committing code
# usage: zombie_lap "message..."
zombie_lap() {
  local current=$* ts=${EPOCHREALTIME/./} diff=0 p p1 p2 m

  if [[ "${zombie_lap_prev:-}" ]]; then
    m="$zombie_lap_prev -> $current"
  else
    m=$current
  fi
  zombie_lap_prev=$current

  if [[ "${zombie_lap_last_ts:-}" ]]; then
    (( diff = ts - zombie_lap_last_ts ))
  else
    zombie_lap_reset
  fi

  zombie_lap_last_ts=$ts
  : ${zombie_lap_time[$m]:=0} ${zombie_lap_count[$m]:=0} \
    ${zombie_lap_detail:=f} ${zombie_lap_max_diff:=10000000}
  local extra=

  if (( diff > 0 )); then
    if (( diff < $zombie_lap_max_diff )); then
      (( zombie_lap_time[$m] += diff ))
      (( zombie_lap_count[$m] += 1 ))
      (( zombie_lap_total += diff ))
      if [[ $zombie_lap_detail == f ]]; then
        return 0
      fi
      (( percent = zombie_lap_time[$m] * 10000 / zombie_lap_total ))
      percent="00$percent"
      p1=${percent%??}
      p2=${percent#$p1}
      p1=${p1##*(0)}
      percent="${p1:-0}.$p2"
      extra="[diff=$diff sum=${zombie_lap_time[$m]} $percent%] "
    else
      extra="[exceeded zombie_lap_max_diff $diff > $zombie_lap_max_diff] "
    fi
  fi

  if [[ $zombie_lap_detail == t ]]; then
    echo "$CYAN$EPOCHREALTIME zombie_lap: $extra$m$RESET" >&2
  fi
}

zombie_lap_summary() {
  local key val count percent p1 p2
  echo "TIME${TAB}PERCENT${TAB}COUNT${TAB}NAME" >&2
  for key in "${!zombie_lap_time[@]}"; do
    val=${zombie_lap_time[$key]}
    count=${zombie_lap_count[$key]}
    if [[ "$val" && "$val" -gt 0 ]]; then
      (( percent = val * 10000 / zombie_lap_total ))
      percent="00$percent"
      p1=${percent%??}
      p2=${percent#$p1}
      p1=${p1##*(0)}
      percent="${p1:-0}.$p2"
      echo "$val$TAB$percent%$TAB$count$TAB$key"
    fi
  done | sort -gr >&2
  echo "Total: $zombie_lap_total" >&2
}

# calls to this should be converted to normal evals before committing code
zombie_eval() {
  local s=${BASH_SOURCE[1]:-(no func)}
  s=${s##*/}
  echo "$CYAN$EPOCHREALTIME $s:${BASH_LINENO[0]} $*$RESET" >&2
  eval "$*"
}

array_contains() {
  local -n __array=$1
  local look_for=$2 i found=f
  if [[ -v __array ]]; then
    for (( i = 0; i < ${#__array[*]}; i++ )); do
      if [[ ${__array[$i]} == "$look_for" ]]; then
        found=t
        break
      fi
    done
  fi
  [[ $found == t ]]
}

dedup_array() {
  local -n from=$1 to=$2
  local -A already_copied
  local e
  for e in "${from[@]}"; do
    if [[ ! "${already_copied[$e]:-}" ]]; then
      to+=( "$e" )
      already_copied["$e"]=1
    fi
  done
}

# does not work if members of array contain newlines
# will remove duplicate values
sort_array() {
  local -n _v=$1
  local v OIFS=$IFS
  IFS=$NL
  _v=( $(
  for v in "${_v[@]}"; do
    echo "$v"
  done | sort -u) )
  IFS=$OIFS
}

# assumes _unioned is declared as an associative array (local -A ...)
union() {
  local old_values_var=$1 new_values_var=$2 unioned_var=${3:-$2} v
  local -n _old_values=$1 _new_values=$2 _unioned=${3:-$2}
  if [[ $unioned_var != $new_values_var ]]; then
    for v in "${!_new_values[@]}"; do
      _unioned[$v]=1
    done
  fi
  if [[ $unioned_var != $old_values_var ]]; then
    for v in "${!_old_values[@]}"; do
      _unioned[$v]=1
    done
  fi
  debug_return_vars=$unioned_var
}

intersect_lists() {
  local -n _from=$1 _to=$2
  local v1 v2 result=()
  for v1 in "${from[@]}"; do
    for v2 in "${to[@]}"; do
      if [[ "$v1" == "$v2" ]]; then
        result+=( "$v1" )
        continue 2
      fi
    done
  done
  _to=( "${result[@]}" )
}

# assumes _intersected is declared as an associative array (local -A ...)
intersect() {
  local old_values_var=$1 new_values_var=$2 intersected_var=$3 v
  local -n _old_values=$1 _new_values=$2 _intersected=$3
  if [[ $old_values_var == $intersected_var ]]; then
    for v in "${!_intersected[@]}"; do
      if [[ ! -v _new_values[$v] ]]; then
        unset _intersected[$v]
      fi
    done
  elif [[ $new_values_var == $intersected_var ]]; then
    for v in "${!_intersected[@]}"; do
      if [[ ! -v _old_values[$v] ]]; then
        unset _intersected[$v]
      fi
    done
  else
    for v in "${!_old_values[@]}"; do
      if [[ -v _new_values[$v] ]]; then
        _intersected[$v]=1
      fi
    done
  fi
  debug_return_vars=$intersected_var
}

# will use 'all' as a special member of either set, which means
# all members of that set. Intersecting a set with all with another set
# will return the second set.
# assumes _intersected is declared as an associative array (local -A ...) and already empty
# intersected may be the same var as one of the inputs
intersect_with_all() {
  local old_values_var=$1 new_values_var=$2 intersected_var=$3 v
  local -n _old_values=$1 _new_values=$2 _intersected=$3
  if [[ $old_values_var == $intersected_var ]]; then
    if [[ -v _old_values[all] ]]; then
      clear_set $intersected_var
      add_to_set $new_values_var $intersected_var
    elif [[ -v _new_values[all] ]]; then
      : # intersected already holds correct values
    else
      for v in "${!_intersected[@]}"; do
        if [[ ! -v _new_values[$v] ]]; then
          unset _intersected[$v]
        fi
      done
    fi
  elif [[ $new_values_var == $intersected_var ]]; then
    if [[ -v _new_values[all] ]]; then
      clear_set $intersected_var
      add_to_set $old_values_var $intersected_var
    elif [[ -v _old_values[all] ]]; then
      : # intersected already holds correct values
    else
      for v in "${!_intersected[@]}"; do
        if [[ ! -v _old_values[$v] ]]; then
          unset _intersected[$v]
        fi
      done
    fi
  else
    if [[ -v _old_values[all] ]]; then
      add_to_set $new_values_var $intersected_var
    elif [[ -v _new_values[all] ]]; then
      add_to_set $old_values_var $intersected_var
    else
      for v in "${!_old_values[@]}"; do
        if [[ -v _new_values[$v] ]]; then
          _intersected[$v]=1
        fi
      done
    fi
  fi
  debug_return_vars=$3
}

clear_set() {
  local -n _x=$1
  _x=()
}

# will NOT wipe out what's already in target var
add_to_set() {
  local -n _from=$1 _to=$2
  local from_var=$1 to_var=$2
  if [[ $from_var != $to_var ]]; then
    local v
    for v in "${!_from[@]}"; do
      _to[$v]=1
    done
  fi
  debug_return_vars=$to_var
}

# will NOT wipe out what's already in target var
add_to_map() {
  local -n _from=$1 _to=$2
  local v
  for v in "${!_from[@]}"; do
    _to[$v]=${_from[$v]}
  done
  debug_return_vars=$2
}

# inputs:
#   $1   name of variable containing string to add
#   $2   name of variable to add string to
add_to_string_if_missing() {
  local -n element=$1 target_string=$2
  if [[ ! -v target_string ]]; then
    target_string=
  fi
  if [[ " $target_string " != *" $element "* ]]; then
    if [[ "${target_string:-}" ]]; then
      target_string+=" $element"
    else
      target_string+="$element"
    fi
  fi
  debug_return_vars=$2
}

# variable should be checked to see if it is set first
is_array() {
  local -n _array=$1
  local rc
  if [[ ! -v _array[*] ]]; then
    return 1
  fi
  set +u
  [[ ${_array@a} == a ]]; rc=$?
  set -u
  return $rc
}

# variable should be checked to see if it is set first
is_set() {
  local -n _set=$1
  local rc
  if [[ ! -v _set[*] ]]; then
    return 1
  fi
  set +u
  [[ ${_set@a} == A ]]; rc=$?
  set -u
  return $rc
}

split_to_array() {
  local -n from_var=$1;
  local -n to_var=${2:-$1}
  local separator=${separator:-$'\n'}
  local IFS=$separator
  to_var=( $from_var )
}

set_to_string() {
  local -n _from_array=$1 _to_string=$2
  local k v
  _to_string="("
  for k in "${!_from_array[@]}"; do
    quotes=single shell_quote_var k
    v=${_from_array[$k]}
    quotes=single shell_quote_var v
    _to_string+=" [$k]=$v"
  done
  _to_string+=" )"
}

array_to_string() {
  local -n _from_array=$1 _to_string=$2
  local v
  _to_string="( "
  for v in "${_from_array[@]}"; do
    quotes=single shell_quote_var v
    _to_string+="$v "
  done
  _to_string+=")"
}

string_to_array() {
  local -n _from_string=$1 _to_array=$2
  local from=$_from_string part
  local separator=${separator:-${sep:-' '}}
  _to_array=()
  while [[ "$from" == *"$separator"* ]]; do
    part=${from%%$separator*}
    _to_array+=( "$part" )
    from=${from#$part$separator}
  done
  if [[ "$from" ]]; then
    _to_array+=( "$from" )
  fi
}

# assumes to_set is empty
array_to_set() {
  local -n _from_array=$1 _to_set=$2
  local v
  for v in "${_from_array[@]:-}"; do
    if [[ "$v" ]]; then
      _to_set[$v]=1
    fi
  done
  debug_return_vars=$2
}

string_to_set() {
  local -n _from_string=$1 _to_set=$2
  local v
  for v in ${_from_string:-}; do
    _to_set[$v]=1
  done
  debug_return_vars=$2
}

# WILL wipe out target var, and replace with source
copy_set() {
  clear_set $2
  add_to_set $1 $2
}

# WILL wipe out target var, and replace with source
copy_map() {
  clear_set $2
  add_to_map $1 $2
}

# inputs:
#   $1   var name which is a set (associative array) to read from
#   $2   var name which is an array to write the keys of the set to
set_to_array() {
  local -n key_set=$1 out_array=$2
  local rc
  set +u
  if [[ ${key_set@a} == A ]]; then
    if (( ${#key_set[*]} > 0 )); then
      out_array=( "${!key_set[@]}" )
    fi
  else
    out_array=()
  fi
  set -u
  debug_return_vars=$2
}

get_value_from_table() {
  local -n data=${table_var}_data fields=${table_var}_fields
  local field=$field row=${row:-0} offset i field_count=${#fields[*]} data_count=${#data[*]}

  value=
  (( offset = field_count * row ))
  for (( i = 0; i < field_count; i++ )); do
    if [[ ${fields[$i]} == $field ]]; then
      value=${data[$(( offset + i ))]}
      break
    fi
  done
}

# get input from the user to select from a given set of possibilities and assign
# the result to the given variable.
# usage: choose {prompt string} {var} {choices...}
# prompt string: prompt to show user
# var: variable to assign choice to
# choices: space separated list of options
choose() {
  local prompt=$1; shift
  local var_name=$1; shift
  local -n var=$var_name
  
  if (( $# > 0 )); then
    local PS3=$prompt
    select var; do break; done
    if [[ "$var" ]]; then
      return 0
    else
      return 1
    fi
  else
    if [[ "${secret_vars:-}" && " $secret_vars " == *\ $var_name\ * ]]; then
      read -sr -p "$prompt" $var_name >&2 || return 1
      echo "********" >&2
    else
      read -r -p "$prompt" $var_name >&2 || return 1
    fi
  fi
  return 0
}

out_wrap() {
  local message="$@" indent=${indent:-0} pad
  trim_ws message
  message=${message//$NL/}
  message=${message//+( )/ }
  printf -v pad %${indent}s
  echo "$message" | fold -s -w $((COLUMNS-1)) | sed "s/^/$pad/"
}

out() {
  local indent=${indent:-0} pad
  printf -v pad %${indent}s
  echo "$@" | sed "s/^/$pad/"
}

out_no_nl() {
  local message="$*" indent=${indent:-0} pad
  printf -v pad %${indent}s
  echo -n "$message" | sed "s/^/$pad/"
}

err() {
  #echo "$RED$*$RESET" >&2
  echo "$*" >&$fd_original_err
}

warn() {
  echo "$YELLOW$*$RESET" >&2
}

# indents an input stream by the given number of spaces (defaults to 2 spaces)
indent() {
  local amount=${1:-2} pad
  printf -v pad %${amount}s
  sed "s/^/$pad/"
}

function_exists() {
  declare -pf $1 &>/dev/null
}

execute_if_exists() {
  local function_name=$1 full_command=$*
  if declare -pf $function_name &>/dev/null; then
    $full_command || return 1
  fi
  return 0
}

ansi_filter_stream() {
  local line
  local IFS=
  while read -r line || [[ "$line" ]]; do
    printf '%s\n' "${line//$ESC[\[(]*([0-9;])[@-n]/}"
  done
}

ansi_filter_var() {
  local -n var=$1
  var="${var//$ESC[\[(]*([0-9;])[@-n]/}"
  var="${var//$ESC[?????l/}"
}

plural() {
  local count=$1 word=$2
  if [[ $count -eq 1 ]]; then
    echo "$count $word"
  else
    echo "$count ${word}s"
  fi
}

find1() {
  if [[ ! -d "${1:-}" ]]; then
    echo "find1: directory missing: ${1:-}" >&$fd_original_err
    return 1
  fi
  local path=$1; shift
  find -L "$path" -mindepth 1 -maxdepth 1 "$@"
  return 0
}

hydrate_template() {
  if [[ "$line" =~ \$ ]]; then
    line="${line//\"/\\\"}"
    eval "echo \"$line\"" || return 1
  else
    echo "$line"
  fi
}

# prompt_ynsq {message} {var to save result into}
# Allows: (y)es (n)o (q)uit
prompt_ynq() {
  local message=$1 var=$2
  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&2
  fi

  while true; do
    read -s -n 1 -p "${GREEN:-}$message${RESET:-} (y/n/q) " $var >&2
    case ${!var} in
      y)
        echo "Yes" >&2  
        ;;
      n)
        echo "No" >&2 
        ;;
      q)
        echo "Quit" >&2 
        ;;
      *)
        err "Pick one of: (y)es (n)o (q)uit"
        continue
        ;;
    esac
    break
  done
}

# should pass in a single command or a { } block of commands
# will run this command after script terminates (whether successfully or in error)
defer() {
  if [[ "${cleanup_on_exit:-}" != *"$1"* ]]; then
    eval "cleanup_on_exit+='$1 &>/dev/null;'"
  fi
}

undefer() {
  local command=$1
  cleanup_on_exit=${cleanup_on_exit/"$command &>/dev/null;"/}
  eval "$command"
}

# usage: random {p=number of possibilities}
#   sets r={random number between 0 and p-1}
#   it will be fairly evenly distributed below about 1000, but will become more biased as it gets higher
random() {
  local p=$1
  r=$((RANDOM % p))
}

# usage: random_sleep {min} {max}
#   will sleep for a random interval between min and max
random_sleep() {
  local min=$1; shift
  local max=$1
  random $((max-min))
  sleep $((min+r))
}

escape_regex_single() {
  local -n internal_var=$1
  internal_var=${internal_var//\"/\\\"}
  internal_var=${internal_var// /\\ }
  internal_var=${internal_var//\(/\\\(}
  internal_var=${internal_var//)/\\)}
  internal_var=${internal_var//\?/\\\?}
  internal_var=${internal_var//\$/\\\$}
}

escape_regex() {
  local -n var=$1
  local trim=${trim:-f} var_array

  if [[ $trim == t ]]; then
    var_array=$var
    var=
    split_to_array var_array
    local i e size=${#var_array[*]}
    for (( i = 0; i < size; i++ )); do
      e=${var_array[$i]}
      e=${e##*( )}
      e=${e%%*( )}
      escape_regex_single e
      var+=$e
      if (( i < size - 1 )); then
        var+=$NL
      fi
    done
  else
    escape_regex_single var
  fi
}

literal_to_regex() {
  local -n var=$1
  var=${var//\\/\\\\}
  var=${var//\$/\\\$}
  var=${var//^/\\^}
  var=${var//\[/\\\[}
  var=${var//\]/\\\]}
  var=${var//./\\.}
}

shell_quote_var() {
  local var_name=$1
  local -n var=$var_name
  local quotes=${quotes:-single} # can be single, double, or dollar
  local newlines=${newlines:-preserved} # can be escaped or preserved
  local quote_empty=${quote_empty:-t}

  if [[ ! -v var ]]; then
    log_fatal "shell_quote_var called on unset var: $1"
    return 1
  fi

  if [[ "$var" =~ \<|\>|\(|\)|\"|\'|\\|\ |\$|$NL ]]; then
    if [[ $quotes == single ]]; then
      var=${var//\'/\'\"\'\"\'}
      var="'$var'"
    elif [[ $quotes == dollar ]]; then
      var=${var//\'/\\x27}
      var=${var//$NL/\\n}
      var="\$'$var'"
    else
      var=${var//\\/\\\\}
      var=${var//\"/\\\"}
      var=${var//\$/\\\$}
      var="$DQ$var$DQ"
    fi
  elif [[ ! "$var" && $quote_empty == t ]]; then
    if [[ $quotes == single ]]; then
      var="''"
    elif [[ $quotes == dollar ]]; then
      var="\$''"
    else
      var='""'
    fi
  fi

  if [[ "$newlines" == escaped ]]; then
    var=${var//$NL/\\n}
  fi

  return 0
}

dir_is_empty() {
  local content=( "$1"/* )
  [[ ! -e $content ]]
}

# will remove duplicate whitespace and trim leading and trailing
# do not use for large strings, it is too inefficient
compress_ws() {
  local -n v=$1
  v=${v//+([ $NL$TAB])/ }
  v=${v##*([ $NL$TAB])}
  v=${v%%*([ $NL$TAB])}
}

# usage: trim_ws {var name}
# will remove trailing and leading whitespace
trim_ws() {
  local -n _x=$1
  if (( ${#_x} > 1000 )); then
    _x=$(echo -n "$_x" | awk '
      BEGIN { after_first_line = 1 }
      NR == 1 { sub("^ +", "") }
      after_first_line == 1 { print line }
      { line = $0 }
      END { sub(" +$", "", line); if (NR > 0) print line }')
  else
    _x=${_x##*([$NL $TAB])}
    _x=${_x%%*([$NL $TAB])}
  fi
}

# usage: echo -e "\n\n blah  \n\n" | trim_stream_nl
# will trim empty lines from beginning and end of given string
# will leave exactly one trailing newline at the end
trim_stream_nl() {
  local block
  read -r -d '' block
  block=${block##*($NL)}
  block=${block%%*($NL)}
  echo "$block"
}

# usage: echo " blah   " | trim
# will trim whitespace from beginning and end of each line in the given input
trim_stream() {
  sed -E -e 's/^[[:space:]]+//' -e 's/[[:space:]]+$//' | grep -v '^$'
}

declare -A apad_size apad_min apad_max

apad_clear() {
  apad_size=()
  apad_min=()
  apad_max=()
}

# append a string to another string + padding according to the class of item being added
# Usage: apad {base var name} [{class of append string} {append string}]...
# The base var will be directly appended to with the append string and maybe padding
# You should include spaces in the append string itself if you want to guarantee a minimum
#   amount of space.
# You may define explicit min/maxes for various classes by adding entries to the apad_min and
#   apad_max maps, and can setup initial sizes with the apad_size map
apad() {
  local -n base=$1; shift
  local class append append_size class_size class_min class_max pad pad_size
  while (( $# > 1 )); do

    class=$1 append=$2; shift 2
    append_size=${#append}

    if [[ ! -v apad_min[$class] ]]; then
      apad_min[$class]=0
    fi
    class_min=${apad_min[$class]}

    if [[ ! -v apad_size[$class] ]]; then
      apad_size[$class]=$class_min
    fi
    class_size=${apad_size[$class]}

    if [[ ! -v apad_max[$class] ]]; then
      apad_max[$class]=1000
    fi
    class_max=${apad_max[$class]} 

    if (( append_size > class_size && class_size < class_max )); then
      apad_size[$class]=$append_size
      if (( class_size > class_max )); then
        apad_size[$class]=$class_max
      fi
    fi

    pad_size=0
    if (( class_size > append_size )); then
      (( pad_size = class_size - append_size ))
    fi

    base+=$append

    if (( pad_size > 0 )); then
      printf -v pad %${pad_size}s
      base+=$pad
    fi

  done
}

# Usage: apad_calc [{class of append string} {append string}]...
# similar to apad, except that it doesn't write to a var, it only calculates boundaries
apad_calc() {
  local class append append_size class_size class_min class_max pad pad_size
  while (( $# > 1 )); do

    class=$1 append=$2; shift 2
    append_size=${#append}

    if [[ ! -v apad_min[$class] ]]; then
      apad_min[$class]=0
    fi
    class_min=${apad_min[$class]}

    if [[ ! -v apad_size[$class] ]]; then
      apad_size[$class]=$class_min
    fi
    class_size=${apad_size[$class]}

    if [[ ! -v apad_max[$class] ]]; then
      apad_max[$class]=1000
    fi
    class_max=${apad_max[$class]} 

    if (( append_size > class_size && class_size < class_max )); then
      apad_size[$class]=$append_size
      if (( class_size > class_max )); then
        apad_size[$class]=$class_max
      fi
    fi

  done
}

# For debugging: shows the current apad padding information
apad_info() {
  local k
  for k in "${!apad_size[@]}"; do
    echo "$k: size=${apad_size[$k]} min=${apad_min[$k]} max=${apad_max[$k]}"
  done
}

upper_first_char() {
  local string=$1
  local first=${string:0:1}
  first=$(echo -n "$first" | tr '[:lower:]' '[:upper:]')
  echo -n "$first${string:1}"
}

to_human_number() {

  local from_var=$1
  local -n _from=$from_var
  local -n _to=${2:-$from_var}

  if [[ ! "$_from" =~ ^[0-9]+$ ]]; then
    _to=invalid
    return 0
  fi

  if (( _from < 9000 )); then
    _to=${_from}
  elif (( _from < 9000 * 1000 )); then
    _to=${_from%???}K
  elif (( _from < 9000 * 1000 * 1000 )); then
    _to=${_from%??????}M
  elif (( _from < 9000 * 1000 * 1000 * 1000 )); then
    _to=${_from%??????}G
  elif (( _from < 9000 * 1000 * 1000 * 1000 * 1000 )); then
    _to=${_from%?????????}T
  else
    _to=too-big
  fi
}

# usage: convert_to_seconds {from time period} {to var name}
convert_to_seconds() {
  local from=$1
  local -n _to=$2
  case "$from" in
    *s)
      _to=${from%s}
    ;;
    *m)
      _to=$((${from%m}*60))
    ;;
    *h)
      _to=$((${from%h}*60*60))
    ;;
    *d)
      _to=$((${from%d}*24*60*60))
    ;;
    *w)
      _to=$((${from%w}*7*24*60*60))
    ;;
    *y)
      _to=$((${from%y}*365*24*60*60))
    ;;
    inf)
      _to=9999999999999
    ;;
    *)
      if [[ "$from" =~ ^[0-9]+$ ]]; then
        # default to seconds
        _to=$from
      else
        log_fatal "Unknown time format, use something like: 4h, 3d, 5m"
        return 1
      fi
    ;;
  esac
  return 0
}

# usage: convert_to_seconds {from seconds} {to var name}
convert_from_seconds() {
  local from=$1
  local -n _to=$2
  if (( from < 120 )); then
    _to=${from}s
  elif (( from < 120 * 60 )); then
    _to=$(( from / 60 ))m
  elif (( from < 48 * 60 * 60 )); then
    _to=$(( from / 60 / 60 ))h
  else
    _to=$(( from / 60 / 60 / 24 ))d
  fi
}

get_overlap() {
  local i
  result=
  for ((i=0; i<${#1}; i++)); do
    [[ "${1:$i:1}" != "${2:$i:1}" ]] && break
    result+=${1:$i:1}
  done
}

# inputs: 
#   from    directory to link to target
#   to      target to link to
#   timeout how long to wait in miliseconds
# if timeout is not given, then attempt will immediately fail if it can not get the lock right away
#   otherwise it will keep trying until the timeout is reached or the lock is obtained.
link_lock() {
  local from=$from
  local to=$to
  local timeout=${timeout:-}
  local pid_file=${pid_file:-$to/pid}

  local log_vars='from to timeout'
  begin_function_hi

    if [[ ! -e "$from" ]]; then
      log_fatal "$from doesn't exist, can't link lock it"
      fail1
    fi
    
    if [[ -L "$to" ]]; then

      log_debug "Lock link exists already: $to"
      local pid=

      if [[ -f "$pid_file" ]]; then
        pid=$(<"$pid_file")
        if [[ "$pid" == $$ ]]; then
          log_debug "This process already owns the lock, so we are done."
          abort
        fi
      fi

      # check to see if the process is still running
      if [[ ! "$pid" ]] || ! ps $pid &>/dev/null; then
        rm "$to" || fail
        log_debug "Removed stale lock: $to with pid: $pid"
      fi

    elif [[ -e "$to" ]]; then
      log_fatal "$to already exists and it's not a link. Can't obtain lock."
      fail1
    fi

    local parent=${to%/*}
    if [[ ! -d "$parent" ]]; then
      log_fatal "Target of link lock isn't in a folder ($to)"
      fail1
    fi

    local timeleft
    let timeleft=timeout
    local delay=250
    local success=f
    begin_while true; doo
      ln -sn "$from" "$to" &>/dev/null && success=t
      if [[ $success == t ]]; then
        echo $$ >"$pid_file" || fail
        break
      fi

      if [ ! "$timeout" ]; then
        break
      fi

      local seconds_to_wait=$(dc -e "2 k $delay 1000 / p")
      log_debug "Failed to obtain lock. Waiting $seconds_to_wait seconds before trying again."
      sleep $seconds_to_wait
      timeleft=$((timeleft-delay))

      let delay*=2
      if (( delay > 10000 )); then
        delay=10000
      fi

      if (( timeleft <= 0 )); then
        log_warn "Timeout reached. Couldn't obtain the lock in time."
        break
      fi

    end_while

    if [[ $success == f ]]; then
      log_debug "Failed to obtain lock."
      fail1
    fi

    defer "rm '$pid_file' '$to' &>/dev/null"

    # lock obtained
    log_debug "Succeeded in obtaining lock."

  end_function
  handle_return
}

link_unlock() {
  local to=$to
  local pid_file=${pid_file:-$to/pid}

  if [[ -f "$pid_file" ]]; then
    rm "$pid_file" || return 1
  fi

  if [[ -L "$to" ]]; then
    rm "$to" || return 1
  elif [[ -e "$to" ]]; then
    log_fatal "$to is not a link, can't unlock it"
    return 1
  fi

  return 0
}

# inputs: folder_to_lock timeout pid_file
# if timeout is not given, then attempt will immediately fail if it can't get the lock right away
#   otherwise it will keep trying until the timeout is reached or the lock is obtained.
folder_lock() {
  local folder_to_lock=${folder_to_lock}
  local timeout=${timeout:-$lock_timeout}
  local pid_file=${pid_file:-$folder_to_lock/pid}
  local remove_folder_when_unlocked=${remove_folder_when_unlocked:-f}

  local log_vars='folder_to_lock timeout'
  begin_function_hi

    if [[ -d "$folder_to_lock" ]]; then

      log_debug "Lock folder exists already: $folder_to_lock"
      local pid=

      if [[ -f "$pid_file" ]]; then
        pid=$(<"$pid_file")
        if [[ "$pid" == $$ ]]; then
          log_debug "This process already owns the lock, so we are done."
          abort
        fi
      fi

      # check to see if the process is still running
      if [[ ! "$pid" ]] || ! ps $pid &>/dev/null; then
        rm -rf "$folder_to_lock" || fail
        log_debug "Removed stale lock: $folder_to_lock with pid: $pid"
      fi

    fi

    local timeleft
    let timeleft=timeout*1000
    local delay=250
    local success=f
    local parent=${folder_to_lock%/*}
    if [[ -d "$parent" ]]; then
      begin_while true; doo
        mkdir "$folder_to_lock" &>/dev/null && success=t
        if [[ $success == t ]]; then
          echo $$ >"$pid_file" || fail
          break
        fi

        if [ ! "$timeout" ]; then
          break
        fi

        local seconds_to_wait=$(dc -e "2 k $delay 1000 / p")
        log_debug "Failed to obtain lock. Waiting $seconds_to_wait seconds before trying again."
        sleep $seconds_to_wait
        timeleft=$((timeleft-delay))
        let delay*=2
        if [ "$timeleft" -le 0 ]; then
          log_warn "Timeout reached. Couldn't obtain the lock in time."
          break
        fi
      end_while
    else
      log_fatal "Attempting to obtain a folder lock when it's parent doesn't exist: $parent"
      fail1
    fi

    if [[ $success == f ]]; then
      log_debug "Failed to obtain lock."
      fail1
    fi

    if [[ $remove_folder_when_unlocked == t ]]; then
      defer "rm -r '$pid_file' '$folder_to_lock' &>/dev/null"
    fi

    log_debug "Succeeded in obtaining lock."

  end_function
  handle_return
}

folder_is_locked() {
  local folder_to_lock=$folder_to_lock
  local pid_file=${pid_file:-$folder_to_lock/pid}
  local is_locked=f
  if [[ -d "$folder_to_lock" ]]; then
    if [[ -f "$pid_file" ]]; then
      pid=$(<"$pid_file")
      if [[ "$pid" ]] && ps $pid &>/dev/null; then
        is_locked=t
      fi
    fi
  fi
  [[ "$is_locked" == t ]]
}

# inputs: folder_to_unlock pid_file
folder_unlock() {
  local folder_to_unlock=$folder_to_unlock
  local pid_file=${pid_file:-$folder_to_unlock/pid}
  local remove_folder_when_unlocked=${remove_folder_when_unlocked:-f}

  if [[ ! "$folder_to_unlock" ]]; then
    log_fatal "Usage: folder_to_unlock=... folder_unlock "
    return 1
  fi

  if [[ -d "$folder_to_unlock" && $remove_folder_when_unlocked == t ]]; then
    rm -r "$folder_to_unlock" || return 1
  fi

  if [[ -f "$pid_file" ]]; then
    rm "$pid_file" || return 1
  fi

  return 0
}

fd_read_lock() {
  local lock_path=$lock_path timeout=$timeout
  if [[ ! -d "${lock_path%/*}" ]]; then
    log_fatal "Bad lock path: $lock_path. It must either exist, or point to a file in a folder that exists."
    return 1
  fi
  if [[ ! -e "$lock_path" ]]; then
    touch "$lock_path" || return 1
  fi
  exec {lock_fd}<>$lock_path
  #zombie_log "Locking $lock_path write_lock=f timeout=$timeout fd=$lock_fd"
  flock -s -w $timeout $lock_fd || {
    log_fatal "Failed to get read lock for $lock_path within $timeout seconds"
    return 1
    }
}

fd_write_lock() {
  local lock_path=$lock_path timeout=$timeout
  if [[ ! -d "${lock_path%/*}" ]]; then
    log_fatal "Bad lock path: $lock_path. It must either exist, or point to a file in a folder that exists."
    return 1
  fi
  if [[ ! -e "$lock_path" ]]; then
    touch "$lock_path" || return 1
  fi
  exec {lock_fd}<>$lock_path
  flock -e -w $timeout $lock_fd || {
    log_fatal "Failed to get write lock for $lock_path within $timeout seconds"
    return 1
    }
}

fd_unlock() {
  flock -u $lock_fd
}

get_next_fd() {
  next_fd=$(ls -1 /proc/self/fd | tail -n1)
  let next_fd++
}

is_dir_empty() {
  eval "local contents=( $1/* )"
  local first=${contents[0]}
  [[ "${first%\*}" != "$first" ]]
}

maybe() {
  local command_to_execute="$*"
  local execute

  case $pretend in
    f)
      execute=t
    ;;
    t)
      echo "Pretending: $command_to_execute" >&2
      execute=f
    ;;
    ask)
      local response
      echo "Will execute: $command_to_execute" >&2
      sleep 0.5
      read -p 'Are you sure? [yes/no/All/None/quit] ' -s -n1 response >&2
      case $response in
        y)
          echo "yes" >&2
          execute=t
        ;;
        A)
          echo "all" >&2
          pretend=f
          execute=t
        ;;
        N)
          echo "none" >&2
          pretend=t
          execute=f
        ;;
        q)
          echo "quit" >&2
          exit 1
        ;;
        *)
          echo "no" >&2
          execute=f
        ;;
      esac
    ;;
    *)
      log_fatal "Invalid pretend setting: $pretend. Must be one of: t f ask"
      return 1
    ;;
  esac

  if [[ $execute == t ]]; then
    log_info "Executing: $command_to_execute"
    eval "$command_to_execute" || return $?
  fi

  return 0
}

min() {
  result=$1
  if [[ $1 == inf || $2 -lt $1 ]]; then
    result=$2
  fi
}

max() {
  result=$1
  if [[ $2 == inf || $2 -gt $1 ]]; then
    result=$2
  fi
}

# input: $1 (name of array variable which was already populated 
#   with string values)
enum() {
  local -n array=$1
  local i count var
  count=${#array[*]}
  for ((i=0; i < count; i++)); do
    local -n var=${array[$i]}
    var=$i
  done
}

safe_link() {
  local from_all="$*" from to \
    force=${force:-f} \
    from_must_exist=${from_must_exist:-t} \
    ignore_existing=${ignore_existing:-f} \

  to=${from_all##* }
  from_all=${from_all% $to}

  local log_show_vars="^from_all ^to" log_vars="force from_must_exist"
  begin_function

    # log_debug "Linking $from_all to $to"

    if [[ "$to" == "$from_all" ]]; then
      log_fatal "Invalid parameters for safe_link: $*"
      fail1
    fi

    if [[ $to != */ ]]; then
      if [[ -L $to ]]; then
        rm "$to" || fail
      elif [[ -e $to ]]; then
        if [[ $ignore_existing == t ]]; then
          abort
        fi
        log_fatal "safe_link: target already exists: $to. If you want to make a link inside of this folder, make the target $to/ instead."
        fail1
      fi
    fi

    local files parent extra
    begin_for from in $from_all; doo

      if [[ "$from" == */\* || "$from" == *!* ]]; then
        extra= parent=${from%/*}
        if [[ "$from" == *!* ]]; then
          extra=${from##*/}
          extra=${extra#!}
          extra=${extra#(}
          extra=${extra%)}
          extra=" -not -name \"$extra\""
        fi
        files=$(find1 $parent -not -name ".*" $extra) || fail
        if [[ "$files" ]]; then
          safe_link $files $to || fail
        fi
        continue
      fi

      if [[ $from_must_exist == t && ! -e "$from" ]]; then
        log_fatal "Internal error: Source of link doesn't exist: $from"
        fail1
      fi

      local to_parent=${to%/*}
      local full_to=$to
      if [[ $to == */ ]]; then
        full_to+=${from##*/}
      fi

      if [[ ! -d "$to_parent" ]]; then
        log_fatal "Missing target folder for link: $to_parent"
      fi

      if [[ $force == t ]]; then
        ln -sfn "$from" "$full_to" || fail
      else
        if [[ -e "$full_to" ]]; then
          if [[ $ignore_existing ]]; then
            continue
          else
            log_fatal "Target of link operation already exists: $full_to"
            fail1
          fi
        fi
        ln -sn "$from" "$full_to" || fail
      fi

    end_for

  end_function
  debug_return_vars='from_all to'
  handle_return
}

# inputs:
#   $1               optional message to display at pause prompt
# outputs:
#   pause_response   contains key pressed (which is usually ignored)
pause() {
  if function_exists handle_user_interrupt; then
    handle_user_interrupt "Paused. "
  else
    local extra=
    if [[ "${fork_debug_id:-}" ]]; then
      extra=" at $fork_debug_id"
    fi
    echo >&$fd_original_err
    read -sp "$WHITE** PAUSED$extra ** ${1:-Press any key}$RESET" -n 1 pause_response >&$fd_original_err || true
    echo >&$fd_original_err
    echo >&$fd_original_err
  fi
}

# inputs:
#   $1               optional message to display at pause prompt
pause_qd() {
  local extra=
  if [[ "${fork_debug_id:-}" ]]; then
    extra=" at $fork_debug_id"
  fi
  local pause_response
  echo >&$fd_original_err
  read -sp "$WHITE** PAUSED$extra ** ${1:-} Press q to quit, D to debug here or any other key to continue.$RESET" -n 1 pause_response >&$fd_original_err || true
  echo >&$fd_original_err
  case $pause_response in 
    D)
      debug_stepping=t
      debug_start o
    ;;
    q)
      echo "Quitting..." >&$fd_original_err
      debug_exit=1 debugging=t
      if [[ "$reply_file" ]]; then
        echo "debugging=t" >$reply_file
      fi
      exit 1
    ;;
  esac
  echo >&$fd_original_err
  return 0
}

# resolves relative paths but does not resolve symlinks
# should run in a subprocess so dir change doesn't affect caller
# normal usage: x=$(unrealpath "$some_path")
unrealpath() {
  local p=$PWD x=$1
  shift
  local flags=$*
  if [[ "$x" != /* ]]; then
    x="$p/$x"
  fi
  realpath $flags "$x" || {
    log_fatal "Internal error: could not resolve $x"
    return 1 
    }
  return 0
}

# inputs: 
#   $1: var       name of var to add to
#   $2: add_value
# var will have trailing and leading spaces
add_word_to_string() {
  local var_name=$1 add_value=$2
  local -n var=$1
  if [[ -v var ]]; then
    if [[ "$var" != *" $add_value "* ]]; then
      var+="$add_value "
    fi
  else
    var=" $add_value "
  fi
}

# var must have trailing and leading spaces
remove_word_from_string() {
  local -n var=$1
  local remove_value=$2
  while [[ " ${var:-} " == *" $remove_value "* ]]; do
    var=" $var "
    local left=${var%%+( )$remove_value *}
    local right=${var#$left}
    right=${right#* $remove_value+( )}
    if [[ "$left" ]]; then
      if [[ "$right" ]]; then
        var="${left##+( )} ${right%%+( )}"
      else
        var="${left##+( )}"
      fi
    else
      if [[ "$right" ]]; then
        var="${right%%+( )}"
      else
        var=
      fi
    fi
  done
}

# inputs:
#   $1    name of array
#   $2    element to remove
# will remove any elements that match, but those indexes will be removed also
remove_array_element() {
  local -n array=$1
  local element=$2 i
  for (( i = 0; i < ${#array[*]}; i++ )); do
    if [[ "${array[$i]:-}" == "$element" ]]; then
      unset array[$i]
    fi
  done
}

show_array() {
  local -n _array=$1
  local i size char_array=f

  set +u
  size=${#_array[*]}
  set -u

  echo "size=$size" >&$fd_original_err
  for i in "${!_array[@]}"; do
    if [[ ! -v _array[$i] ]]; then
      echo "$i: << MISSING >>" >&$fd_original_err
    else
      echo "$i: ${_array[$i]:-}" >&$fd_original_err
    fi
  done
}

rcp() {
  local shell="ssh"
  if [ "${port:-}" ]; then
      shell="ssh -p $port"
  fi
  RSYNC_RSH="$shell" rsync -a --append --inplace --partial --progress "$@"
}

# usage: convert_time_to_timestamp {time}
#   time can be something like this:
#   -10m
#   now
#   -30h@d      30 hours ago rounded to the previous day
#   2 weeks ago
#   25 Dec      the next time 25 Dec happens
#   2025/1/5 08:34:20
# output:
#   timestamp
convert_time_to_timestamp() {
  local time=$1
  local rounding_unit=s rounding_multiple=1 offset=0
  if [[ "$time" =~ @([0-9]*)([smhdwMy])$ ]]; then
    local o=${BASH_REMATCH[1]} u=${BASH_REMATCH[2]}
    if [[ "$o" ]]; then
      rounding_multiple=$o
    fi
    rounding_unit=$u
    time=${time%${BASH_REMATCH[0]}}
  fi

  if [[ "$time" =~ ^-([0-9]+)([smhdwMy])$ ]]; then
    local o=${BASH_REMATCH[1]} u=${BASH_REMATCH[2]}
    case $u in
      s)
        time="now - $o seconds"
      ;;
      m)
        time="now - $o minutes"
      ;;
      h)
        time="now - $o hours"
      ;;
      d)
        time="now - $o days"
      ;;
      w)
        time="now - $o weeks"
      ;;
      M)
        time="now - $o months"
      ;;
      y)
        time="now - $o years"
      ;;
      *)
        log_fatal "Invalid time unit: $u in $time"
        return 1
      ;;
    esac
  fi

  if [[ "$time" =~ ^[0-9]+$ ]]; then
    timestamp=$time
  else
    local d
    d=$(date -d "$time" +%s) || {
      log_fatal "Invalid time format: $time"
      return 1
    }
    timestamp=$d
  fi

  if [[ $rounding_unit != s || $rounding_multiple != 1 ]]; then
    local y M d h m s
    read y M d h m s < <(date -d @$timestamp +'%Y %m %d %H %M %S')
    case $rounding_unit in
      s)
        (( s = s / $rounding_multiple * $rounding_multiple ))
      ;;
      m)
        if (( rounding_multiple > 1 )); then
          (( m = m / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
      ;;
      h)
        if (( rounding_multiple > 1 )); then
          (( h = h / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
      ;;
      h)
        if (( rounding_multiple > 1 )); then
          (( h = h / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
      ;;
      d)
        if (( rounding_multiple > 1 )); then
          (( d = d / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
        h=0
      ;;
      M)
        if (( rounding_multiple > 1 )); then
          (( M = M / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
        h=0
        d=1
      ;;
      y)
        if (( rounding_multiple > 1 )); then
          (( y = y / $rounding_multiple * $rounding_multiple ))
        fi
        s=0
        m=0
        h=0
        d=1
        M=1
      ;;
      *)
        log_fatal "Internal error in time conversion. Bad rounding unit: $rounding_unit"
        return 1
      ;;
    esac
    timestamp=$(date -d "$y/$M/$d $h:$m:$s" +%s) || return 1
  fi
}

# calculate the difference between two timestamps
# input: 
#   $1      start time
#   $2      end time
# output:
#   result  {end time} - {start time}
ts_diff() {
  local start=$1 end=$2
  result=$(dc -e "6k $end $start - p")
  #start=${start//./} end=${end//./}
  # (( result = end - start ))
  # local ipart=${result%??????}
  # result=${ipart}.${result#ipart}
}

debug_timer_start() {
  debug_counter_count=${debug_counter_count:-0}
  if (( debug_counter_count++ )); then nothing fi
  reply_to_caller "debug_counter_count=$debug_counter_count"
  debug_timer_start=$EPOCHREALTIME
  #echo "DEBUG TIMER $debug_counter_count started" >&$fd_original_err
}

debug_timer_end() {
  local result
  ts_diff $debug_timer_start $EPOCHREALTIME
  echo "DEBUG TIMER $debug_counter_count ended: $result" >&$fd_original_err
}

debug_counter() {
  debug_counter_count=${debug_counter_count:-0}
  if (( debug_counter_count++ )); then nothing fi
  reply_to_caller "debug_counter_count=$debug_counter_count"
  echo "DEBUG COUNTER: $debug_counter_count" >&$fd_original_err
}

# usage: cat {some file} | format_number_stream
# will format all numbers found in the stream
format_number_stream() {
  local field=${field:-all}
  if [[ $field == all ]]; then
    perl -wpe '1 while s/(\d+)(\d\d\d)/$1,$2/;'
  else
    perl -ae '1 while $F['$field'] =~ s/(\d+)(\d\d\d)/$1,$2/; print join(" ",@F) . "\n";'
  fi
}

# inputs:
#   $1    form
#   $2    var name
format_var() {
  local form=$1 var_name=$2
  local -n _value=$var_name
  case $form in
    number)
      local int=${_value%%.*}
      local frac=${_value#$int} 
      local i c=0
      _value=
      for (( i = ${#int} - 1; i >= 0; i-- )); do
        (( c++ )) || true
        _value=${int:$i:1}$_value
        if (( c % 3 == 0 )); then
          _value=,$_value
        fi
      done
      _value=${_value#,}
    ;;
    *)
      # unknown form, do nothing
      :
    ;;
  esac
}

# input:
#   pid   process to check for
# output:
#   process_running  boolean
check_process() {
  if ps $pid &>/dev/null; then
    log_debug "Process $pid exists"
    process_running=t
  else
    log_debug "Process $pid doesn't exist"
    process_running=f
  fi
}

# make sure we clean up after ourselves whether we've launched a background job or allocated resources
# this needs to be run again whenever forking to a subprocess
setup_exit_trap() {
  failure_handler_state_file=$tmp_folder/failure-state-$$
  failure_handler_already_dumped_stack=f
  trap '
    rc=$?
    #echo "EXIT TRAP $BASHPID, BASH_SUBSHELL=$BASH_SUBSHELL" >&$fd_original_err
    if [[ ${debug_on_exit:-} == t ]]; then
      exiting=t
      debug_start
    fi
    if (( rc > 0 && rc < 100 )); then
      if [[ -e $failure_handler_state_file ]]; then
        source $failure_handler_state_file &>/dev/null
        if (( BASH_SUBSHELL == 0 )); then
          rm $failure_handler_state_file &>/dev/null
        fi
      fi
      if [[ $failure_handler_already_dumped_stack == f ]]; then
        if [[ $trace_time == t ]]; then
          trace_time_summarize
        fi
        extra=
        #if [[ ${show_debug_id:-f} != f ]]; then
        if [[ "${fork_debug_id:-}" ]]; then
          extra=" ${DEBUG_COLOR}debug_id=$fork_debug_id$RESET"
        fi
        echo "$extra ${RED}Exited with failure code $rc"
        #if log_level_at_least debug; then
        #  stack_trace
        #fi
        echo "failure_handler_already_dumped_stack=t" >>$failure_handler_state_file
      fi
    fi
    trap - DEBUG ERR EXIT RETURN QUIT &>/dev/null
    #echo "Cleaning up: $cleanup_on_exit" >&$fd_original_err
    eval "${cleanup_on_exit:-}" &>/dev/null
    if (( rc > 0 )); then
      jobs="$(jobs -p)"
      #echo "Killing jobs $jobs" >&$fd_original_err
      if [[ "$jobs" ]]; then
        { kill $jobs; } 2>/dev/null || true
      fi
    fi
    set +TeuExv
    #echo "debug_restart_command=$debug_restart_command" >&$fd_original_err
    if [[ "${debug_restart_command:-}" ]]; then
      if [[ $BASH_SUBSHELL == 0 ]]; then
        eval "exec $debug_restart_command"
      else
        quotes=single shell_quote_var debug_restart_command
        #echo "Passing up debug_restart_command=$debug_restart_command" >&$fd_original_err
        reply_to_caller "debug_restart_command=$debug_restart_command"
      fi
    fi
    ' EXIT

  # trap '
  #   zombie_log "ERR $BASH_COMMAND"
  #   trap - DEBUG ERR EXIT RETURN QUIT &>/dev/null
  #   set +TeuExv
  #   if [[ ${debug_on_err:-} == t ]]; then
  #     debug_start
  #     echo "Debugging..."
  #   fi
  #   ' ERR

  # trap '
  #   zombie_log "HUP $BASH_COMMAND"
  #   ' HUP

  # trap '
  #   zombie_log "ILL $BASH_COMMAND"
  #   ' ILL

  # trap '
  #   zombie_log "TRAP $BASH_COMMAND"
  #   ' TRAP

  # trap '
  #   zombie_log "TERM $BASH_COMMAND"
  #   ' TERM

  # trap '
  #   zombie_log "ALRM $BASH_COMMAND"
  #   ' ALRM

  # trap '
  #   zombie_log "SEGV $BASH_COMMAND"
  #   ' SEGV

  # trap '
  #   zombie_log "USR1 $BASH_COMMAND"
  #   ' USR1

  # trap '
  #   zombie_log "KILL $BASH_COMMAND"
  #   ' KILL

  # trap '
  #   zombie_log "FPE $BASH_COMMAND"
  #   ' FPE

  # trap '
  #   zombie_log "BUS $BASH_COMMAND"
  #   ' BUS

  # trap '
  #   zombie_log "ABRT $BASH_COMMAND"
  #   ' ABRT

  # trap '
  #   zombie_log "QUIT $BASH_COMMAND"
  #   ' QUIT
  # trap '
  #   zombie_log "RETURN $BASH_COMMAND"
  #   f=( "${FUNCNAME[@]:1}" )
  #   show_array f
  #   ' RETURN
}

hide_secrets() {
  local -n text=$1
  local secret_var 
  for secret_var in ${secret_vars:-}; do
    local -n secret=$secret_var
    if [[ "${secret:-}" && "$secret" != $empty_member ]]; then
      text=${text//$secret/****}
    fi
  done
}

save_log_vars() {
  local entry entries= var value quoted_value
  for var in ${log_vars:-} ${log_show_vars:-}; do
    value=
    var=${var#^}
    var=${var##*=}
    if [[ -v $var && "${!var:-}" ]]; then
      value=${!var}
      shell_quote_var value
    fi
    entries+=" $var=$value"
  done
  entries=${entries# }
  hide_secrets entries
  log_var_entries_stack+=( "$entries" ) 
  log_var_show_vars_stack+=( "$log_show_vars" ) 
}

snapshot_source_location_locals="log_function log_source_file log_source_line"
snapshot_source_location() {
  local offset=${offset:-1} offset1= offset2=
  (( 
    offset1 = offset + 1
  , offset2 = offset + 2
  , log_source_line = BASH_LINENO[offset]
  , log_source_line2 = BASH_LINENO[offset1]
  )) 
  log_function=${FUNCNAME[$offset1]}
  log_source_file=${BASH_SOURCE[$offset1]}
  log_source_file2=${BASH_SOURCE[$offset2]}
  log_stack_index=$(( ${#FUNCNAME[*]} - offset2 ))
}

auto_shorten() {
  local -n shorten_var=$1
  local extra length
  if [[ "$shorten_var" =~ /.*/.*/.*/.*/ ]]; then
    extra=${shorten_var%/*/*/*/*}
    shorten_var=${shorten_var#$extra/}
  fi

  length="${#shorten_var}"
  if (( length > 80 )); then
    shorten_var=${shorten_var:0:78}..
  fi
}

log_quick() {
  #begin_function_grip
    local m=
    if [[ $show_debug_id != f ]]; then
      if [[ "${strong_log:-}" == t ]]; then
        m="${DEBUG_COLOR}"
      else
        m="${DIM_DEBUG_COLOR}"
      fi
      m+="debug_id=$fork_debug_id$RESET "
    fi
    if [[ "${strong_log:-}" == t ]]; then
      m+="$HIGHLIGHT$*$RESET"
    else
      m+="$*"
    fi
    if [[ "${secret_vars:-}" ]]; then
      hide_secrets m
    fi
    local prefix= showed_something=f
    show_time_update
    echo " $prefix$m" >&$fd_original_err
    if [[ "${debug_log:-}" && "$m" == *"$debug_log"* ]]; then
      debug_immediate=t
      unignore_this_function=3 \
      debug_skip_breakpoints=f \
      debug_start
    fi
  #end_function
  #handle_return
}

log_trace() {
  if log_level_at_least trace; then
    log_quick "$*"
  fi
}

log_debug() {
  if log_level_at_least debug; then
    log_quick "$*"
  fi
}

log_verbose() {
  if log_level_at_least verbose; then
    log_quick "$*"
  fi
}

log_info() {
  if log_level_at_least info; then
    log_quick "$*"
  fi
}

log_warn() {
  if log_level_at_least warn; then
    log_quick "$*"
  fi
}

log_error() {
  if log_level_at_least error; then
    log_quick "$*"
  fi
}

log_fatal() {
  if log_level_at_least fatal; then
    log_quick "$*"
  fi
}

log_and_run() {

  local command=$* \
    out_to_file=${out_to_file:-} \
    err_to_file=${err_to_file:-} \
    level=${level:-verbose} \
    log_path=${log_path:-${cell_path:-/tmp}/log}

  case $level in
    off|fatal|error|warn|info|verbose|debug|trace|all)
    ;;
    *)
      level=verbose
    ;;
  esac

  if [[ "$out_to_file" ]]; then
    command+=" >>$out_to_file"
  fi

  if [[ "$err_to_file" ]]; then
    command+=" 2>>$err_to_file"
  fi

  log_$level "$command"

  eval "$command" || return 1
  if [[ "${!:-}" ]]; then
    pid=$!
  fi

  return 0
}

declare -A log_level_num_map=( 
  [off]=0
  [fatal]=1 
  [error]=2 
  [warn]=3 
  [info]=4 
  [verbose]=5 
  [debug]=6 
  [trace]=7 
  [all]=8
  )

declare -A log_level_color_map=( 
  [all]= 
  [trace]= 
  [debug]= 
  [verbose]= 
  [info]=
  [warn]=$YELLOW
  [error]=$RED 
  [fatal]=$RED 
  [off]=
  )

######################################################
# BASH Debugger
# At beginning of script you wish to debug: 
#   source this file. example: source /home/my_user/repos/bash-debugger
#   intialize debugger in your source: debugger_init
#   execute debug in the code where you wish to begin debugging.
# press '?' for list of commands while debugging
# If you want to get syntax highlighting working, install source-highlight
#   example for mac: brew install source-highlight
######################################################

alias debug_once='[[ ! "${debug_once_triggered:-}" ]] && { debug_once_triggered=t; debug_start; }'

get_var_value() {
  local __var_name=$1 __val_name=${2:-value}

  if [[ ! "$__var_name" =~ ^[a-zA-Z0-9_]+$ ]]; then
    echo "Invalid variable name: $__var_name" >&$fd_original_err
    return 1
  fi

  if [[ ! "$__val_name" =~ ^[a-zA-Z0-9_]+$ ]]; then
    echo "Invalid variable name: $__val_name" >&$fd_original_err
    return 1
  fi

  local -n _var=$__var_name _val=$__val_name || return 1
  _val='(unset)'
  if [[ "$__var_name" == *\[* ]]; then
    if is_set ${__var_name%%\[*} && [[ -v $__var_name ]]; then
      eval "_val=\${$__var_name}"
    fi
  elif is_set _var; then
    local c=0 k v
    _val="( "
    for k in "${!_var[@]}"; do
      v=${_var[$k]}
      if [[ "${v:-}" ]]; then
        _val+="$k=$v "
      else
        _val+="$k=(empty) "
      fi
      (( c++ ))
      if (( c > 20 )); then
        _val+="... "
        break
      fi
    done
    _val+=")"
  elif is_array _var; then
    #if [[ "${_var:-}" ]] && (( ${#_var[*]} > 20 )); then
    #  _val="( ${_var[*]:0:20} ... )"
    #else
    #  _val="( ${_var[*]:-} )"
    #fi
    local v
    _val="( "
    if (( "${#_var[*]}" > 0 )); then
      for v in "${_var[@]}"; do
        quotes=single shell_quote_var v
        _val+="$v "
      done
    fi
    _val+=")"
  elif [[ -v _var ]]; then
    _val=$_var
    newlines=preserved quotes=single shell_quote_var _val
  fi
}

side_log() {
  echo "$*" >>$side_log_file
}

debug_expansion_clean() {
  local line shortest= plusses code plus_length from=$1 show
  while read -rs line >&$fd_original_err || true; do
    if [[ "$line" =~ ^(\++)\ (.*) ]]; then
      plusses=${BASH_REMATCH[1]}
      code=${BASH_REMATCH[2]}
      plus_length=${#plusses}
      show=f

      if [[ ! "$shortest" ]]; then
        shortest=$((plus_length-1))
        show=t
      elif [[ $plus_length == $shortest || $debug_expansion -ge 2 ]]; then
        show=t
      fi

      if [[ $show == t ]]; then
        local new_plus=${plusses:$((shortest-1))}
        if [[ "$code" == "return 0" ]]; then
          :
        elif [[ "$code" != "set +x" \
           && "$code" != "set -x" \
           && "$code" != *"no_trace_depth"* \
           && "$code" != "break_out=f" \
           && "$code" != "debug_id_inc" \
           ]]; then
          echo "$new_plus $code"
        fi
      fi

    elif [[ "$line" ]]; then
      echo "$line"
    else
      break
    fi
  done < <(cat "$from")
  return 0
}

debug_output_reversed_line() {
  echo -n "$REVERSE" >&$fd_original_err
  local line=$(sed -E -n "${debug_line_num}p;${debug_line_num}q" "$raw_debug_path_to_source_file")
  local pad_size line_length=${#line}
  (( pad_size = COLUMNS - line_length ))
  echo -n "$line" >&$fd_original_err
  printf %${pad_size}s >&$fd_original_err
  echo "$RESET" >&$fd_original_err
}

debug_source_update() {
  debug_path_to_source_file=$raw_debug_path_to_source_file
  if [[ $debug_path_to_source_file == /dev/fd/* ]]; then
    debug_path_to_source_file=none
  fi

  if [[ $debug_full_path == t ]]; then
    debug_source_file=$debug_path_to_source_file
  else
    debug_source_file=${debug_path_to_source_file##*/}
  fi
}

debug_source_update_hl() {
  if [[ $debug_highlight == t && $debug_path_to_source_file != none ]]; then

    debug_path_to_source_file=$(cd "$debug_dir"; cd ${debug_path_to_source_file%/*}; pwd)/${debug_path_to_source_file##*/} || { debug_exit=1; exit 1; }
    local highlighted_source=$tmp_folder/debug_highlight/${debug_path_to_source_file#/}
    if [ ! -f "$highlighted_source" ]; then
      mkdir -p "${highlighted_source%/*}"
      #cat "$debug_path_to_source_file" | highlight -S shellscript -O ansi >"$highlighted_source"
      cat "$debug_path_to_source_file" | source-highlight -s bash -f esc >"$highlighted_source"
    fi
    debug_path_to_source_file=$highlighted_source

  fi
}

debug_source_line_update() {

  local i=$((debug_list_stack_pos))
  raw_debug_path_to_source_file=${saved_bash_source[$i]}

  if [[ ! "$raw_debug_path_to_source_file" ]]; then
    echo "Internal error: missing raw_debug_path_to_source_file" >&$fd_original_err
    echo "debug_list_stack_pos=$debug_list_stack_pos" >&$fd_original_err
    echo "Array saved_bash_source:" >&$fd_original_err
    show_array saved_bash_source
    debug_exit=1
    exit 1
  fi

  if (( debug_list_stack_pos > 0 )); then
    debug_line_num=${saved_bash_lineno[$((i - 1))]}
  else
    debug_line_num=$saved_lineno
  fi

  if [[ ! "$debug_line_num" ]]; then
    echo "Internal error: missing debug_line_num" >&$fd_original_err
    debug_exit=1
    exit 1
  fi

  debug_current_function=${saved_funcname[$i]:-}

  if [[ ! "$debug_current_function" ]]; then
    echo "Internal error: missing debug_current_function" >&$fd_original_err
    debug_exit=1
    exit 1
  fi

}

debug_display_source() {
  local skip_source_update=${skip_source_update:-f}

  if [[ $skip_source_update == f ]]; then
    debug_source_line_update
    debug_source_update
    debug_source_update_hl
  fi

  if [[ "$debug_path_to_source_file" == none ]]; then
    return 0
  fi
  local debug_start_line=$((debug_list_offset+debug_line_num))
  if (( debug_start_line < 1 )); then
    (( debug_list_offset += -debug_start_line + 1 ))
    debug_start_line=1
  fi
  local debug_end_line=$((debug_start_line+debug_list_window-1))

  if (( debug_start_line <= debug_line_num && debug_line_num <= debug_end_line )); then
    if (( debug_start_line < debug_line_num )); then
      sed -n "$debug_start_line,$((debug_line_num-1))p;$((debug_line_num-1))q" "$debug_path_to_source_file" >&$fd_original_err
    fi
    debug_output_reversed_line
    if (( debug_line_num < debug_end_line )); then
      sed -n "$((debug_line_num+1)),${debug_end_line}p;${debug_end_line}q" "$debug_path_to_source_file" >&$fd_original_err
    fi
  else
    sed -n "$debug_start_line,${debug_end_line}p;$((debug_end_line))q" "$debug_path_to_source_file" >&$fd_original_err
  fi
}

debug_load_state() {
  if [[ -f "$debug_state_file" && "${debug_needs_to_load_state:-t}" == t ]]; then
    [[ ${debug_debug:-f} == t ]] && echo "${CYAN}Loading state from $debug_state_file${RESET}" >&$fd_original_err
    #pause_qd "Loading state"
    debug_needs_to_load_state=f
    source "$debug_state_file" || return 1
    if [[ "${debug_log_level_filter:-}" ]]; then
      log_level_filter=$debug_log_level_filter
    fi
  fi
  return 0
}

debug_save_state() {
  # We don't need to save the state if there are no parent shells to recall that state
  if [[ $BASH_SUBSHELL -gt 0 || ${force_save:-f} == t ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Saving debug_state_file${RESET}" >&$fd_original_err
    echo "
debug_buffered_commands='$debug_buffered_commands'
debug_condition='$debug_condition'
debug_condition_old='$debug_condition_old'
debug_display='$debug_display'
debug_exit='$debug_exit'
debug_expanded_search='$debug_expanded_search'
debug_expansion='$debug_expansion'
debug_expression='$debug_expression'
debug_follow_source='$debug_follow_source'
debug_function='$debug_function'
debug_function_old='$debug_function_old'
debug_highlight='$debug_highlight'
debug_ignore='$debug_ignore'
debug_line='$debug_line'
debug_line_old='$debug_line_old'
debug_log_level_filter='$debug_log_level_filter'
debug_max_depth='$debug_max_depth'
debug_original_log_level='${debug_original_log_level:-}'
debug_original_tracefd='$debug_original_tracefd'
debug_prev_command='${debug_prev_command//\'/\'\"\'\"\'}'
debug_prev_function='$debug_prev_function'
debug_prev_line='$debug_prev_line'
debug_prev_source_file='$debug_prev_source_file'
debug_restart_command='$debug_restart_command'
debug_search='$debug_search'
debug_search_deep='$debug_search_deep'
debug_search_old='$debug_search_old'
debug_show_time='$debug_show_time'
debug_silent_command='$debug_silent_command'
debug_start_ts='${debug_start_ts:-}'
debug_trace_time='$debug_trace_time'
debug_skip_ignore='$debug_skip_ignore'
debug_step_to_later_line='$debug_step_to_later_line'
debug_step_to_next_line='$debug_step_to_next_line'
debug_step_to_next_file='$debug_step_to_next_file'
debug_step_to_next_function='$debug_step_to_next_function'
debug_step_to_hi_function='$debug_step_to_hi_function'
debug_step_to_mid_function='$debug_step_to_mid_function'
debug_stepping='$debug_stepping'
debug_stop_at='$debug_stop_at'
debug_subshell='$debug_subshell'
debug_var_regex='$debug_var_regex'
debug_watch='$debug_watch'
PS4='$PS4'" >"$debug_state_file" || return 1
  fi
  return 0
}

debug_ignore_remove() {
  local remove_functions="$*"
  local x
  for x in $remove_functions; do
    [[ ${debug_debug:-f} == t ]] && echo "${CYAN}debug_debug: Removing $x from debug_ignore${RESET}" >&$fd_original_err
    remove_word_from_string debug_ignore "$x"
  done
}

debug_display_command_expansion_status() {
  case $debug_expansion in
    0)
      debugger_out "# Command expansion off"
    ;;
    1)
      debugger_out "# Command expansion basic"
    ;;
    2)
      debugger_out "# Command expansion deep"
    ;;
    3)
      debugger_out "# Command expansion unfiltered"
    ;;
  esac
}

debug_output_stop() {
  if [[ $debug_recording_trace == t && -e $debug_out_path ]]; then
    debug_recording_trace=f
    BASH_XTRACEFD=$debug_original_tracefd
    eval "exec $fd_bash_trace>&-"
    if [[ -e $debug_out_path  ]]; then
      rm $debug_out_path
    fi
    [[ $debug_debug == t ]] && echo "${CYAN}debug_debug: Stopping debug output expansion${RESET}" >&$fd_original_err
  fi
}

debug_output_expansion() {
  if (( debug_expansion > 0 )) && [[ -f "$debug_out_path" ]]; then
    if [[ $debug_silent_command == f ]]; then
      if (( debug_expansion > 2 )); then
        cat $debug_out_path >&$fd_original_err
      elif (( debug_expansion > 1 || debug_current_depth <= debug_max_depth )); then
        debug_expansion_clean $debug_out_path >&$fd_original_err
      fi
    fi
    debug_output_stop
  fi
}

# input:
#   new_bisect
# output:
#   new_command
debug_get_new_bisect() {
  new_command=$original_cmd
  local pre post
  if [[ "$new_command" =~ ^(.*)\ (debug_)?bisect=[^\ ]+(\ .*)?$ ]]; then
    pre=${BASH_REMATCH[1]}
    post=${BASH_REMATCH[3]}
    new_command="$pre$post"
  fi
  debug_bisect_min=${new_bisect%..*}
  debug_bisect_max=${new_bisect#*..}
  if (( debug_bisect_min == debug_bisect_max )); then
    new_command+=" debug=$((debug_bisect_max - 1))"
    echo "${YELLOW}Bisect complete, debugging just before issue occurs: ${RESET}$new_command" >&$fd_original_err
  else
    new_command+=" bisect=$new_bisect"
    echo "${CYAN}Starting next bisect: ${RESET}$new_command" >&$fd_original_err
  fi
}

debug_get_new_command() {
  new_command=$original_cmd
  local pre post
  if [[ "$new_command" =~ ^(.*)\ debug(_id)?=[^\ ]+(\ .*)?$ ]]; then
    pre=${BASH_REMATCH[1]}
    post=${BASH_REMATCH[3]}
    new_command="$pre$post"
  fi
  new_command+=" debug=$rewind_debug_id"
  echo "Starting over command: $new_command" >&$fd_original_err
}

debug_reset_stack_pos() {
  (( debug_list_offset = -debug_list_window / 2 + 1 ))
  debug_list_stack_pos=0
  debug_display_source
  debug_list_dir=forwards
  (( debug_list_offset += debug_list_window ))
}

debug_move_down_stack() {
  local index=$(( debug_list_stack_pos - 1 ))

  if (( index < 0 )); then

    debugger_out "# Already at bottom of stack"

  elif (( index == 0 )); then

    debug_reset_stack_pos

  else

    debugger_out "# Move down the stack"

    (( debug_list_stack_pos = index ))
    #local debug_id=
    #if [[ -v stack_debug_id[$index] ]]; then
    #  debug_id=${stack_debug_id[$index]}
    #fi

    local raw_stack_size=${#saved_bash_source[*]}
    (( debug_list_offset = -debug_list_window * 2 / 3 + 1 ))
    debug_source_line_update

    debug_display_source
    debug_list_dir=forwards
    (( debug_list_offset += debug_list_window ))

  fi
}

debug_move_up_stack() {
  local index=$(( debug_list_stack_pos + 1 ))

  if (( index >= stack_size )); then

    debugger_out "# Already at top of stack"

  else

    debugger_out "# Move up the stack"

    (( debug_list_stack_pos = index ))
    #local debug_id=
    #if [[ -v stack_debug_id[$index] ]]; then
    #  debug_id=${stack_debug_id[$index]}
    #fi
    
    local raw_stack_size=${#saved_bash_source[*]}
    (( debug_list_offset = -debug_list_window * 2 / 3 + 1 ))
    debug_source_line_update

    debug_display_source
    debug_list_dir=forwards
    (( debug_list_offset += debug_list_window ))

  fi
}

get_effective_debug_id() {

  if (( debug_list_stack_pos == 0 )); then
    effective_debug_id=$fork_debug_id
  else
    local i=$((stack_size - debug_list_stack_pos)) debug_id=
    if (( i >= stack_size )); then
      (( i = stack_size - 1 ))
    fi

    while [[ ! "$debug_id" ]]; do

      if [[ -v stack_debug_id[$i] ]]; then
        debug_id=${stack_debug_id[$i]}
        break
      fi

      (( i-- ))
      if (( i < 0 )); then
        break
      fi

    done

    if [[ "$debug_id" ]]; then
      effective_debug_id=$debug_id
    else
      effective_debug_id=1
    fi

  fi

}

debug_set_watch() {
  local new_watch=$1 add=f

  if [[ "$new_watch" == +* ]]; then
    new_watch=${new_watch#+}
    add=t
  fi

  if [[ $add == t ]]; then
    debug_watch+=" $new_watch"
  else
    debug_watch=$new_watch
  fi
}

stack_trace_inner() {
  local extra= debug_id= p n r l \
    stack_level=${stack_level:-0} count=${#FUNCNAME[*]} \
    before= after= start_frame=${start_frame:-1} \
    short_source=${short_source:-t} \

  echo "${WHITE}FUNCTION DEBUG_ID SOURCE DETAILS$RESET"
  for ((n = count - 1; n >= start_frame; n--)) ; do
    (( p = n - 1 ))
    (( r = count - n - 1 ))
    debug_id= before= after=

    l=0
    if [[ -v stack_debug_id[$r] ]]; then
      debug_id=${stack_debug_id[$r]}
      l=1
    else
      debug_id=-
    fi

    if [[ -v stack_detail[$r] ]]; then
      after+="${stack_detail[$r]}"
    fi

    if [[ -v stack_high_level[$r] ]]; then
      l=2
      before+=$WHITE
    fi

    local bash_source="${BASH_SOURCE[$n]:-(no source)}"
    if [[ $short_source == t ]]; then
      local prefix=${bash_source%/*/*/*/*}
      if [[ "$prefix" != "$bash_source" ]]; then
        bash_source="${bash_source#$prefix/}"
      fi
    fi
    bash_source+=":${BASH_LINENO[$p]:-(no line)}"

    if (( l >= stack_level )); then
      echo "$RESET$before${FUNCNAME[$n]:-(no func)} $debug_id $bash_source $after"
    fi

  done

  return 0
}

stack_trace() {
  local start_frame=${start_frame:-2} stack_level=${stack_level:-0}

  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&$fd_original_err
  fi

  echo "Full call stack:" >&$fd_original_err
  stack_trace_inner | column -W4 -l4 -t >&$fd_original_err

  return 0
}

medium_stack_trace() {
  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&$fd_original_err
  fi

  if [[ "${stack_debug_id[*]}" ]]; then
    local start_frame=${start_frame:-1}

    if [ ${tracing_midline:-f} == t ]; then
      tracing_midline=f
      echo >&$fd_original_err
    fi

    echo "Mid call stack:" >&$fd_original_err
    stack_level=1 stack_trace_inner | column -W4 -l4 -t >&$fd_original_err
  else
    echo "No medium stack available." >&$fd_original_err
  fi
  return 0
}

high_stack_trace() {
  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&$fd_original_err
  fi

  if [[ "${stack_detail[*]}" ]]; then
    local start_frame=${start_frame:-1}

    if [ ${tracing_midline:-f} == t ]; then
      tracing_midline=f
      echo >&$fd_original_err
    fi

    echo "High call stack:" >&$fd_original_err
    stack_level=2 stack_trace_inner | column -W4 -l4 -t >&$fd_original_err
  else
    echo "No high stack available." >&$fd_original_err
  fi
  return 0
}

debug_shell() {
  if [[ ! -v debugging ]]; then
    debugger_init || return 1
  fi
  local c
  echo "Debug shell started. " >&$fd_original_err
  echo "Use q to exit debug shell and resume execution of the script. " >&$fd_original_err
  echo "Use 'exit' to abort all further code execution. " >&$fd_original_err
  echo "You have access to the full execution environment (variables and functions). " >&$fd_original_err
  while true; do
    read -u $fd_original_in -e -p "debug ${CYAN}\$${RESET} " c >&$fd_original_err
    case $c in
      q|quit)
        echo "Leaving debug shell." >&$fd_original_err
        break
        ;;
      *)
        eval "$c" || { rc=$?; echo; echo "Command failed ($rc)"; }
        ;;
    esac
  done
}

debug_show_var() {
  local display_var=$1 val=
  if [[ "$display_var" == \[\[* || "$display_var" == \(\(* ]]; then
    eval "$display_var"
    local result=$?
    if (( result == 0 )); then
      echo "TRUE (0)" >&$fd_original_err
    else
      echo "FALSE ($result)" >&$fd_original_err
    fi
  elif [[ "$display_var" =~ ^[][a-zA-Z_0-9]+$ ]]; then
    get_var_value $display_var val
    echo "$val" >&$fd_original_err 
  elif [[ "$display_var" == @@* ]]; then
    display_var=${display_var%_data}
    display_var=${display_var%_fields}
    show_table ${display_var#@@}
  elif [[ "$display_var" == @* ]]; then
    show_array ${display_var#@}
  elif [[ "$display_var" == ^* ]]; then
    local var dim dims
    dim=${display_var#^}
    get_plural $dim dims
    for var in $dim $dims p_$dim p_$dims s_$dim s_$dims d_$dim d_$dims; do
      if [[ -v $var ]]; then
        get_var_value $var val
        echo "$var=$val" >&$fd_original_err 
      fi
    done
  elif [[ "$display_var" == \** ]]; then
    eval "declare -p | grep '${display_var#\*}' | grep -Ev 'declare -a BASH_ARGV|declare -- _=|declare -- debug_display=|declare -n derive_fields=|declare -- display_var=|.*trace_var.*|.*debug_.*|.*cooked_stack.*|.*stack_detail.*|.*watch_output.*|.*debug_watch.*|.*original_cmd.*|.*localize_.*dims.*|.*watch_var.*'" >&$fd_original_err
  elif [[ "${display_var:-}" == \$* ]]; then
    eval 'echo "'${display_var}'"' >&$fd_original_err
  else
    echo "Invalid var name" >&$fd_original_err
  fi
}

debugger_out() {
  if [[ $debug_silent_command == f ]]; then
    echo "$@" >&$fd_original_err
  fi
}

debug_command_loop() {
  local debug_c no_follow_once=f

  debug_r=-1
  local time_diff=

  if [[ $debug_show_time == t && "${debug_start_ts:-}" ]]; then
    local ts=${EPOCHREALTIME/./}
    micro_time_diff $debug_start_ts $ts time_diff
  fi

  while [[ $debug_r == -1 ]]; do

    local current_source_line_without_comment=none
    if [[ $debug_path_to_source_file != none ]]; then
      current_source_line_without_comment=$(sed -E -n "${debug_line_num}p;${debug_line_num}q" "$raw_debug_path_to_source_file" \
        | sed -E 's/^ *(.*) *$/\1/' \
        | sed -E 's/#.*//'
        )
    fi
    if [[ $debug_follow_source == t && "$current_source_line_without_comment" && ! "$debug_buffered_commands" ]]; then
      if [[ $no_follow_once == t ]]; then
        no_follow_once=f
      else
        echo "$hbar_tilde" >&$fd_original_err
        (( debug_list_offset = -debug_list_window / 2 + 1 )) 
        debug_display_source
        debug_list_dir=forwards
        (( debug_list_offset += debug_list_window - 1 ))
      fi
    fi

    if [[ "$debug_watch" && ! "$debug_buffered_commands" ]]; then
      set +u
      local watch_var watch_output='+ ' __value
      for watch_var in $debug_watch; do
        if [[ "$watch_var" == *\$* ]]; then
          eval "__value=\"$watch_var\""
        else
          get_var_value $watch_var __value
        fi
        watch_output+="$watch_var=$__value "
      done
      echo "$watch_output" >&$fd_original_err
    fi

    if [[ "${return_value:-0}" != 0 ]]; then
      echo "+ ${YELLOW}return_value == $return_value$RESET"
    fi

    if [[ ! "$debug_buffered_commands" ]]; then
      local debug_prefix=
      if [[ $BASH_SUBSHELL -gt 0 ]]; then
        debug_prefix+="$YELLOW$BASH_SUBSHELL:$BASHPID "
      fi
      if [[ "$time_diff" ]]; then
        debug_prefix+="${WHITE}+$time_diff "
        debug_start_ts=
      fi
      if [[ "$fork_debug_id" ]]; then
        get_effective_debug_id
        debug_prefix+="${CYAN}debug_id=$effective_debug_id "
      fi
      if [[ $debug_source_file != none ]]; then
        echo -n "$debug_prefix$RED$debug_source_file:$debug_line_num" >&$fd_original_err
      fi
      echo -n " $GREEN$debug_current_function $RESET:" >&$fd_original_err
      echo -n " $debug_command " >&$fd_original_err
    fi

    debug_long_command=f
    local got_user_input=f
    if [[ "$debug_buffered_commands" ]]; then
      debug_c=
      while [[ "$debug_buffered_commands" ]]; do
        debug_c=${debug_buffered_commands:0:1}
        debug_buffered_commands=${debug_buffered_commands:1}
        if [[ "$debug_c" != ' ' ]]; then
          break
        fi
      done
    else
      read -rs -n1 -u $fd_original_in debug_c >&$fd_original_err 2>&1
      debug_silent_command=f
      got_user_input=t
    fi

    if [[ "$debug_c" != l && "$debug_c" != L ]]; then
      debug_list_offset=0
      debug_list_dir=none
    fi

    BASH_REMATCH=( "${debug_rematch[@]}" )

    case "$debug_c" in
      b)
        get_effective_debug_id
        local rewind_debug_id
        rewind_debug_id=$effective_debug_id
        debugger_out "# Going back to debug_id=$rewind_debug_id..."
        local new_command
        debug_get_new_command
        debug_restart_command=$new_command
        debug_exit=0
        debugging=t
        debug_save_state
        exit 0
        ;;
      B)
        get_effective_debug_id
        local rewind_debug_id prefix suffix
        suffix=${effective_debug_id##*.}
        prefix=${effective_debug_id%.$suffix}
        rewind_debug_id=$prefix.$((suffix-1))
        debugger_out "# Going back to debug_id=$rewind_debug_id..."
        local new_command
        debug_get_new_command
        debug_restart_command=$new_command
        debug_exit=0
        debugging=t
        debug_save_state
        exit 0
        ;;
      c)
        if [[ $debug_path_to_source_file == none ]]; then
          debugger_out "# Source not available"
        else
          echo "$NL" >&$fd_original_err
          debug_reset_stack_pos
          no_follow_once=t
        fi
        ;;
      C)
        debugger_out "# Continuing..."
        debug_r=0
        debug_long_command=t
        debugging=f
        debug_untrap=t
        debug_save_state
        ;;
      d)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Display: " debug_display >&$fd_original_err
        set +u 
        if [[ "$debug_display" =~ ^\$?[0-9]+ ]]; then
          set -- "${debug_saved_params[@]}"
          eval "echo \$${debug_display#\$}" >&$fd_original_err
        else
          debug_show_var "$debug_display"
        fi
        no_follow_once=t
        ;;
      D)
        if [[ "${debug_display:-}" ]]; then
          debugger_out "# Showing $debug_display"
          set +u
          if [[ "$debug_display" =~ ^\$?[0-9]+ ]]; then
            set -- "${debug_saved_params[@]}"
            eval "echo \$${debug_display#\$}" >&$fd_original_err
          else
            debug_show_var "$debug_display"
          fi
        else
          debugger_out "# No previous display var."
        fi
        no_follow_once=t
        ;;
      e)
        echo >&$fd_original_err
        read -u $fd_original_in -er -p "Eval: " debug_expression >&$fd_original_err
        set +u -- "${debug_saved_params[@]}"
        eval "$debug_expression" >&$fd_original_err
        no_follow_once=t
        ;;
      E)
        if [[ "$debug_expression" ]]; then
          debugger_out "# Evaluating $debug_expression"
          set +u -- "${debug_saved_params[@]}"
          eval "$debug_expression" >&$fd_original_err
        else
          debugger_out "# No previous expression to evaluate"
        fi
        no_follow_once=t
        ;;
      /)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Deep Find: " debug_search >&$fd_original_err
        if [[ "${debug_search:-}" ]]; then
          if [[ "$debug_search" == ~* ]]; then
            # use unescaped to support regex if expression starts with ~
            debug_search=${debug_search#~}
          else
            debug_search=${debug_search//\\/\\\\}
            debug_search=${debug_search//\$/\\\$}
            debug_search=${debug_search//[/\\[}
          fi
          debug_search_old=$debug_search
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_stepping=f
          debug_save_state
        fi
        ;;
      f)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Shallow Find: " debug_search >&$fd_original_err
        if [[ "${debug_search:-}" ]]; then
          if [[ "$debug_search" == ~* ]]; then
            # use unescaped to support regex if expression starts with ~
            debug_search=${debug_search#~}
          else
            debug_search=${debug_search//\\/\\\\}
            debug_search=${debug_search//\$/\\\$}
            debug_search=${debug_search//[/\\[}
          fi
          debug_search_old=$debug_search
          debug_search_deep=f
          debug_r=0
          debug_long_command=t
          debug_save_state
        fi
        ;;
      F)
        if [[ "${debug_search_old:-}" ]]; then
          debugger_out "# Repeating search for $debug_search_old"
          debug_search=${debug_search_old:-}
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_stepping=f
          debug_save_state
        else
          debugger_out "# No previous search."
          no_follow_once=t
        fi
        ;;
      g)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Go until function: " debug_quick_function >&$fd_original_err
        if [[ "${debug_quick_function:-}" ]]; then
          debug_r=0
          debug_long_command=t
          debug_function_old=$debug_quick_function
          if [[ "${debug_quick_function:-}" == /* ]]; then
            debug_function=${debug_quick_function#/}
            debug_quick_function=
            debug_subshell=t
          else
            debug_untrap=t
            debugging=f
          fi
          debug_save_state
        fi
        ;;
      G)
        if [[ "${debug_function_old:-}" ]]; then
          debug_quick_function=$debug_function_old
          debugger_out "# Continuing until we reach function $debug_quick_function"
          debug_r=0
          debug_long_command=t
          if [[ "${debug_quick_function:-}" == /* ]]; then
            debug_function=${debug_quick_function#/}
            debug_quick_function=
            debug_subshell=t
          else
            debug_untrap=t
            debugging=f
          fi
          debug_save_state
        fi
        ;;
      h)
        if [[ $debug_highlight == t ]]; then
          debugger_out "# Syntax highlighting is now off"
          debug_path_to_source_file=$raw_debug_path_to_source_file
          debug_highlight=f
        else
          debugger_out "# Syntax highlighting is now on"
          # debug_path_to_source_file=$highlighted_source
          debug_highlight=t
        fi
        debug_save_state
        no_follow_once=t
        ;;
      i)
        debugger_out "# Stepping in"
        debug_r=0
        (( debug_max_depth += 10 ))
        debug_step_to_next_line=t
        debug_skip_ignore=t
        debug_subshell=t
        debug_save_state
        export -n debug
        ;;
      l)
        if [[ $debug_path_to_source_file == none ]]; then
          debugger_out "# Source not available"
        else
          if [[ $debug_list_dir != none ]]; then
            echo -n "$CLEAR_LINE" >&$fd_original_err
            if [[ "$debug_watch" ]]; then
              echo -n "$CURSOR_UP$CLEAR_LINE" >&$fd_original_err
            fi
          fi

          [[ $debug_list_dir == none ]] && echo >&$fd_original_err
          [[ $debug_list_dir == backwards ]] && (( debug_list_offset += debug_list_window ))
          debug_display_source
          (( debug_list_offset += debug_list_window ))
          debug_list_dir=forwards
          no_follow_once=t
        fi
        ;;
      L)
        if [[ $debug_path_to_source_file == none ]]; then
          debugger_out "# Source not available"
        else
          echo -n "$CLEAR_SCREEN" >&$fd_original_err
          [[ $debug_list_dir == forwards ]] && (( debug_list_offset -= debug_list_window ))
          (( debug_list_offset -= debug_list_window * 15 / 10 ))
          debug_display_source
          debug_list_dir=backwards
          no_follow_once=t
        fi
        ;;
      n)
        if (( no_trace_depth > 0 )); then
          no_trace_depth=0
          debugger_out "# Resetting no_trace_depth to 0"
        fi
        debugger_out "# Stepping over"
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=t
        debug_subshell=t
        debug_save_state
        export -n debug
        ;;
      N)
        debugger_out "# Stepping until next line is reached"
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_later_line=t
        debug_long_command=t
        debug_save_state
        ;;
      $CONTROL_N)
        debugger_out "# Quick stepping over"
        debug_r=0
        debug_untrap=t
        debugging=f
        debug_long_command=t
        debug_quick_stop_less_than_depth=$debug_current_depth
        debug_save_state
        ;;
      o)
        debugger_out "# Stepping out"
        debug_max_depth=$((debug_current_depth - 1))
        debug_r=0
        debug_long_command=t
        debug_stepping=t
        debug_save_state
        ;;
      $CONTROL_O)
        debugger_out "# Quick stepping out"
        debug_r=0
        debug_untrap=t
        debugging=f
        debug_long_command=t
        debug_quick_stop_less_than_depth=$((debug_current_depth - 1))
        debug_save_state
        ;;
      p)
        echo >&$fd_original_err
        local fixed_command
        fixed_command=${debug_command}
        fixed_command=${fixed_command//\\/**BS**}
        fixed_command=${fixed_command//\\\$/\\\\\$}
        # temporarily hide this so we can keep $(( but transform $(
        fixed_command=${fixed_command//\$((/{{{}
        fixed_command=${fixed_command//\$(/\\\$(}
        # restore {{{ to $((
        fixed_command=${fixed_command//{{{/\$((}
        fixed_command=${fixed_command//\"/\\\"}
        fixed_command=${fixed_command//\*\*BS\*\*/\\}
        if [[ "${debug_saved_params:-}" ]]; then
          set "${debug_saved_params[@]}"
        fi
        set +u
        eval "echo \"$fixed_command\"" >&$fd_original_err
        set -u
        no_follow_once=t
        ;;
      P)
        echo >&$fd_original_err
        local fixed_command
        fixed_command=${debug_command}
        fixed_command=${fixed_command//\\/**BS**}
        fixed_command=${fixed_command//\\\$/\\\\\$}
        fixed_command=${fixed_command//\[\[ /~~dbo~~}
        fixed_command=${fixed_command// \]\]/~~dbc~~}
        fixed_command=${fixed_command//\[ /\$(\[ }
        fixed_command=${fixed_command// ]/ ] && echo true || echo false)}
        fixed_command=${fixed_command//~~dbo~~/\$(\[\[ }
        fixed_command=${fixed_command//~~dbc~~/ ]] \&\& echo true || echo false)}
        fixed_command=${fixed_command//\*\*BS\*\*/\\}
        eval "echo \"$fixed_command\"" >&$fd_original_err
        no_follow_once=t
        ;;
      q) 
        debugger_out "# Quitting (debug state: $debug_state_file)"
        force_save=t debug_save_state
        debug_exit=1
        debug_save_state
        if [[ "${reply_file:-}" ]]; then
          echo "debugging=t" >$reply_file
        fi
        debug_r=0
        exit 1
        ;;
      r)
        debugger_out "# Show low call stack"
        start_frame=5 stack_trace
        no_follow_once=t
        ;;
      R)
        debugger_out "# Rewinding..."
        debug_rewind=t
        debug_stepping=t
        debug_r=0
        ;;
      s)
        debugger_out "# Stepping over small"
        debug_r=0
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=f
        debug_subshell=t
        debug_stepping=t
        debug_save_state
        ;;
      S)
        debugger_out "# Stepping in small"
        debug_r=0
        (( debug_max_depth += 10 ))
        debug_step_to_next_line=f
        debug_skip_ignore=t
        debug_subshell=t
        debug_stepping=t
        debug_save_state
        export -n debug
        ;;
      t)
        debugger_out "# Show medium call stack"
        medium_stack_trace
        no_follow_once=t
        ;;
      T)
        debugger_out "# Show high call stack"
        high_stack_trace
        no_follow_once=t
        ;;
      u)
        echo >&$fd_original_err
        local f
        read -u $fd_original_in -e -p "Unignore function: " f >&$fd_original_err
        if [[ "${f:-}" ]]; then
          debug_ignore_remove $f
        fi
        ;;
      U)
        debugger_out "# Unignore all functions"
        debug_ignore=
        no_follow_once=t
        ;;
      v)
        echo >&$fd_original_err
        debug_original_log_level=${debug_original_log_level:-$log_level_filter}
        local log=
        echo "Current log level: $log_level_filter" >&$fd_original_err
        read -u $fd_original_in -e -p "New log level: " log >&$fd_original_err
        if [[ "$log" ]]; then
          if function_exists resolve_log_var; then
            resolve_log_var
          else
            log_level_filter=$log
          fi
          log_format=default
          if function_exists log_level_filter_changed; then
            log_level_filter_changed
          fi
          debug_log_level_filter=$log_level_filter
          debugger_out "# Log level changed to $log_level_filter"
        fi
        no_follow_once=t
        ;;
      V)
        debug_original_log_level=${debug_original_log_level:-$log_level_filter}
        debugger_out "# Restored log level to $debug_original_log_level"
        log_level_filter=$debug_original_log_level
        log_format=default
        if function_exists log_level_filter_changed; then
          log_level_filter_changed
        fi
        debug_log_level_filter=$log_level_filter
        no_follow_once=t
        ;;
      w)
        echo >&$fd_original_err
        local new_watch w
        read -u $fd_original_in -e -p "Watch: " new_watch >&$fd_original_err
        debug_set_watch "$new_watch"
        debug_save_state
        no_follow_once=t
        ;;
      x)
        echo >&$fd_original_err
        local _v=
        read -u $fd_original_in -e -p "Hex Display: " _v >&$fd_original_err
        if [[ "$_v" ]]; then
          eval 'echo -n "$'${_v#\$}'" | xxd' >&$fd_original_err
        fi
        no_follow_once=t
        ;;
      \!)
        debugger_out "# resetting bind vars"
        bind "$debug_bind_vars"
        ;;
      \()
        (( debug_expansion-- ))
        if (( debug_expansion < 0 )); then
          debug_expansion=0
        fi
        debug_display_command_expansion_status
        debug_save_state
        no_follow_once=t
        ;;
      \))
        if (( no_trace_depth > 0 )); then
          no_trace_depth=0
          debugger_out "# Resetting no_trace_depth to 0"
        else
          (( debug_expansion++ ))
          if (( debug_expansion > 3 )); then
            debug_expansion=3
          fi
          debug_display_command_expansion_status
        fi
        debug_save_state
        no_follow_once=t
        ;;
      -)
        debug_move_up_stack
        no_follow_once=t
        ;;
      _)
        debug_move_down_stack
        no_follow_once=t
        ;;
      =)
        debugger_out "# Running until this line in the same depth is reached again"
        debug_stop_at="$raw_debug_path_to_source_file $debug_line_num"
        debug_r=0
        debug_long_command=t
        debug_subshell=t
        debug_max_depth=$debug_current_depth
        debug_step_to_next_line=f
        debug_save_state
        ;;
      +)
        debugger_out "# Running until this line in any depth is reached again"
        debug_stop_at="$raw_debug_path_to_source_file $debug_line_num"
        debug_r=0
        debug_long_command=t
        debug_subshell=t
        debug_max_depth=99999
        debug_step_to_next_line=f
        debug_save_state
        ;;
      \[)
        echo >&$fd_original_err
        read -u $fd_original_in -e -p "Condition (brackets optional): " debug_condition >&$fd_original_err
        if [[ "${debug_condition:-}" ]]; then
          debug_condition_old=$debug_condition
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        fi
        ;;
      \{)
        if [[ "${debug_condition_old:-}" ]]; then
          debugger_out "# Repeating search for $debug_condition_old"
          debug_condition=${debug_condition_old:-}
          debug_search_deep=t
          debug_r=0
          debug_long_command=t
          debug_subshell=t
          debug_save_state
        else
          debugger_out "# No previous condition."
          no_follow_once=t
        fi
        ;;
      \])
        debugger_out "# Running until a mid level function is reached"
        (( debug_max_depth += 10 ))
        debug_long_command=t
        debug_step_to_mid_function=t
        debug_subshell=t
        debug_r=0
        debugging=f
        debug_save_state
        debug_untrap=t
        ;;
      \})
        debugger_out "# Running until a high level function is reached"
        (( debug_max_depth += 10 ))
        debug_r=0
        debug_long_command=t
        debug_step_to_hi_function=t
        debug_subshell=t
        debugging=f
        debug_save_state
        debug_untrap=t
        ;;
      \\)
        debugger_out "# Running until a different function is reached"
        (( debug_max_depth++ ))
        debug_step_to_next_function=t
        debug_subshell=t
        debug_r=0
        debug_save_state
        ;;
      \|)
        debugger_out "# Adding $debug_current_function to function ignore list"
        debug_ignore+=" $debug_current_function"
        debug_r=0
        debug_stepping=t
        debug_save_state
        ;;
      @)
        echo >&$fd_original_err
        echo "$raw_debug_path_to_source_file" >&$fd_original_err
        no_follow_once=t
        ;;
      \#)
        if [[ $debug_show_time == f ]]; then
          debug_show_time=t
          debugger_out "# Enabled time stamps"
        else
          debug_show_time=f
          debugger_out "# Disabled time stamps"
        fi
        no_follow_once=t
        ;;
      \$)
        debugger_out "# Entering debug shell"
        debug_shell
        no_follow_once=t
        ;;
      \%)
        if [[ $debug_trace_time == f ]]; then
          debug_trace_time=t
          debugger_out "# Enabled time tracing"
        else
          debug_trace_time=f
          debugger_out "# Disabled time tracing"
        fi
        debug_save_state
        no_follow_once=t
        ;;
      ^)
        if [[ $debug_follow_source == t ]]; then
          debugger_out "# Follow source is now off"
          debug_follow_source=f
        else
          debugger_out "# Follow source is now on"
          debug_follow_source=t
        fi
        debug_save_state
        ;;
      \>)
        if [[ $debug_expanded_search == t ]]; then
          debugger_out "# Expanded search is now off"
          debug_expanded_search=f
        else
          debugger_out "# Expanded search is now on"
          debug_expanded_search=t
        fi
        debug_save_state
        ;;
      \?)
        echo >&$fd_original_err
        echo >&$fd_original_err
        echo "b  restart command, going back to beginning of debug_id of current stack frame. (only works if the script running this is deterministic)" >&$fd_original_err
        echo "B  restart command, like b, but one debug_id earlier" >&$fd_original_err
        echo "c  list debug_list_window/2 lines of source code before and after current line" >&$fd_original_err
        echo "C  continue execution without stopping" >&$fd_original_err
        echo "d  display a variable. Works with arrays and sets also." >&$fd_original_err
        echo "   prefix with * to show declare output for all set variables matching that" >&$fd_original_err
        echo "   prefix with $ to use a raw variable expression which is fed into echo" >&$fd_original_err
        echo "   prefix with @ to show an array in long view, with one element per row" >&$fd_original_err
        echo "   prefix with @@ to show an array in table form, requiring a {var}_data and {var}_fields variables" >&$fd_original_err
        echo "   prefix with ^ to show all dim forms of that var" >&$fd_original_err
        echo "   you can also display the result of a test, example: [[ -v index ]]   or   (( x > 3 ))" >&$fd_original_err
        echo "D  repeat last display command" >&$fd_original_err
        echo "e  evaluate an expression" >&$fd_original_err
        echo "E  repeat last eval expression command" >&$fd_original_err
        echo "f  jump ahead: shallow substring find" >&$fd_original_err
        echo "F  repeat previous jump" >&$fd_original_err
        echo "g  continue until the given function is reached" >&$fd_original_err
        echo "G  continue until the previously given function is reached" >&$fd_original_err
        echo "h  toggle syntax highlighting" >&$fd_original_err
        echo "i  next instruction, stepping into function calls" >&$fd_original_err
        echo "l  list next debug_list_window (default 20) lines of source code" >&$fd_original_err
        echo "L  list previous debug_list_window (default 20) lines of source code" >&$fd_original_err
        echo "n  next line of code (even if it resolves to several different statements)," >&$fd_original_err
        echo "   not stepping into function calls" >&$fd_original_err
        echo "   WARNING: In the rare case that the debugger hangs after this command is run on a line of code, exit (control-c) and start over" >&$fd_original_err
        echo "   the debugging, except when you get to this line, press 's' to do a small step first, and then 'n' and usually it will work" >&$fd_original_err
        echo "^n like n, except it only stops at debug id increment locations (edges of functions or loops usually), and so is much faster. Use when n is too slow." >&$fd_original_err
        echo "N  continue executing until we reach a line later than the current line, completing loops if needed" >&$fd_original_err
        echo "o  step out from the current function" >&$fd_original_err
        echo "^o like o, except it only stops at debug id increment locations, making it much faster, but less precise" >&$fd_original_err
        echo "p  print variables in current line" >&$fd_original_err
        echo "P  print conditional test results of current line" >&$fd_original_err
        echo "q  quit: exit the program entirely" >&$fd_original_err
        echo "r  show full call stack" >&$fd_original_err
        echo "R  rewind: go back to the start of the last looping / try block" >&$fd_original_err
        echo "s  execute next small statement, even if multiple statements are on a line," >&$fd_original_err
        echo "   not stepping into function calls" >&$fd_original_err
        echo "s  execute next small statement, even if multiple statements are on a line," >&$fd_original_err
        echo "   stepping into function calls like the i command" >&$fd_original_err
        echo "t  show medium level call stack" >&$fd_original_err
        echo "T  show high level call stack" >&$fd_original_err
        echo "u  unignore: remove given function from ignore list" >&$fd_original_err
        echo "U  unignore all functions" >&$fd_original_err
        echo "v  adjust log level (takes same values as 'log' parameter)" >&$fd_original_err
        echo "V  restore log level to it's original" >&$fd_original_err
        echo "w  set or clear current watched expression. Expression can contain any string expression which can be given to echo as an argument." >&$fd_original_err
        echo "x  hex display of a variable" >&$fd_original_err
        echo "!  reset tty / bind variables" >&$fd_original_err
        echo "@  show full path of file containing source being executed" >&$fd_original_err
        echo "#  add timestamps to each debug trace line" >&$fd_original_err
        echo "$  enter debug shell" >&$fd_original_err
        echo "%  toggle time tracing for debug steps" >&$fd_original_err
        echo "^  toggle source following (displays source context after every command)" >&$fd_original_err
        echo "(  reduce command expansion level. Command expansion shows what the shell previously executed" >&$fd_original_err
        echo ")  increase command expansion level. Will instead reset no_trace_depth if it is set." >&$fd_original_err
        echo "-  move up stack one position and show source" >&$fd_original_err
        echo "_  move down stack one position and show source" >&$fd_original_err
        echo "=  continue until the current line is reached again at the same stack depth" >&$fd_original_err
        echo "+  continue until the current line is reached again at ANY stack depth" >&$fd_original_err
        echo "]  continue until we reach a different mid function" >&$fd_original_err
        echo "}  continue until we reach a different high level function (begin_function_hi)" >&$fd_original_err
        echo "\  continue until we reach a different function" >&$fd_original_err
        echo "[  continue until a given [[ ]] or (( )) condition is met" >&$fd_original_err
        echo "|  add current function to jump ignore list, so using ] or } will not hit this function again" >&$fd_original_err
        echo ">  toggle expanded search mode, which enables searching on evaluated string expressions" >&$fd_original_err
        echo "/  continue until a line contains the substring given" >&$fd_original_err
        echo "   put a ~ at the beginning of the search string to do a regex search" >&$fd_original_err
        echo >&$fd_original_err
        no_follow_once=t
        ;;
      *)
        echo "# Unknown command" >&$fd_original_err
        echo "Press ? for a list of commands" >&$fd_original_err
        no_follow_once=t
        ;;
    esac
  done

  if [[ $debug_show_time == t && $got_user_input == t ]]; then
    debug_start_ts=${EPOCHREALTIME/./}
    debug_save_state
  fi

  if [[ $debug_trace_time == t ]]; then
    trace_time=t
    timebox=debug_step timebox_open
  fi

}

debug_update_expansion() {
  if [[ $debug_recording_trace == f && debug_expansion -gt 0 && $debug_long_command == f ]]; then
    debug_recording_trace=t
    [[ $debug_debug == t ]] && echo "${CYAN}debug_debug: Starting debug output expansion${RESET}" >&$fd_original_err
    if [[ ! "${fd_bash_trace:-}" ]]; then
      exec {fd_bash_trace}>"$debug_out_path"
    else
      eval "exec ${fd_bash_trace}>\"$debug_out_path\""
    fi
    (( tracing_depth++ ))
    debug_original_tracefd=${BASH_XTRACEFD:-}
    BASH_XTRACEFD=$fd_bash_trace
  fi
}

debug_get_ok_to_debug() {
  if [[ $debug_immediate == t ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_immediate${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_immediate=f

  elif [[ -n "$debug_line" \
          && -z "$file_part" \
          && "$debug_line_num" -eq "$line_part" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_line${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_line_old=$debug_line
    debug_line=

  elif [[ -n "$debug_line" \
          && -n "$file_part" \
          && ( \
             "$debug_line_num" -eq "$line_part" \
             && "$debug_source_file" == "$file_part" \
             ) \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_line${RESET}" >&$fd_original_err
    ok_to_debug=t
    debug_line_old=$debug_line
    debug_line=

  elif [[ $debug_stepping == t \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_stepping${RESET}" >&$fd_original_err
    debug_stepping=f
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ "$debug_condition" ]]; then
    local condition=$debug_condition
    if [[ "$condition" != \[* && "$condition" != \(* ]]; then
      condition="[[ $condition ]]"
    fi
    condition+=" && ok_to_debug=t"
    eval "$condition"
    if [[ $ok_to_debug == t ]]; then
      debug_condition=
    fi

  elif [[ "$debug_function" \
          && $debug_function == $debug_current_function \
          || "$debug_search" \
          && $debug_search == $debug_current_function \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_function${RESET}" >&$fd_original_err
    if [[ "$debug_function" ]]; then
      debug_function_old=$debug_function
      debug_search_old=$debug_function
      debug_function=
    else
      debug_search_old=$debug_search
      debug_search=
    fi
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ "$debug_search" \
          && ( \
             $debug_search_deep == t \
             || $debug_current_depth -le $debug_max_depth \
             ) \
          && ( " $debug_command " =~ $debug_search \
             || " $expanded_command " =~ $debug_search \
             ) \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_search${RESET}" >&$fd_original_err
    debug_search=
    debug_max_depth=$debug_current_depth
    ok_to_debug=t

  elif [[ $debug_step_to_next_line == t \
          && "$raw_debug_path_to_source_file $debug_line_num" != "$debug_last_location" \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_line${RESET}" >&$fd_original_err
    ok_to_debug=t

  elif [[ $debug_step_to_later_line == t \
          && "$debug_line_num" -gt "$debug_prev_line" \
          && $debug_current_function != none \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_later_line${RESET}" >&$fd_original_err
    debug_step_to_later_line=f
    ok_to_debug=t

  elif [[ "$debug_stop_at" \
          && "$raw_debug_path_to_source_file $debug_line_num" == "$debug_stop_at" \
          && $debug_current_depth -le $debug_max_depth \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_stop_at${RESET}" >&$fd_original_err
    debug_max_depth=$debug_current_depth
    debug_stop_at=
    ok_to_debug=t

  elif [[ $debug_step_to_next_function == t \
          && "$debug_current_function" != "$debug_prev_function" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_function${RESET}" >&$fd_original_err
    debug_step_to_next_function=f
    ok_to_debug=t

  elif [[ $debug_step_to_next_file == t \
          && "$debug_current_function" != "$debug_prev_function" \
          && "$debug_source_file" != "$debug_prev_source_file" \
       ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Stopping because of debug_step_to_next_file${RESET}" >&$fd_original_err
    debug_step_to_next_file=f
    ok_to_debug=t

  fi
}

maybe_enable_debug_tracing() {
  if (( debug_expansion > 0 
        && ${no_trace_depth:-0} <= 0 \
     )); then
    if [[ $debug_long_command == f \
          && $debug_expansion == 1 \
          && $debug_current_depth -le $debug_max_depth \
          || $debug_expansion -ge 2 ]]; then
      debug_tracing=t
      [[ $debug_debug == t ]] && echo "${CYAN}debug_tracing=$debug_tracing${RESET}" >&$fd_original_err
    fi
  fi
}

debug_show_extra_backlog() {
  if [[ "$debug_prev_command" =~ for\ (.*)\ in\  || "$debug_prev_command" =~ case\ \$(.*)\ in\  ]]; then
    local w=${BASH_REMATCH[1]}
    w=${w#\$}
    eval "local s=\"+ \$w=\$$w\""
    echo "$s" >&$fd_original_err
  elif [[ "$debug_prev_command" =~ for\ \(\(\ ?(.*)\ ?= ]]; then
    local w=${BASH_REMATCH[1]}
    w=${w%% *}
    eval "local s=\"+ \$w=\$$w\""
    echo "$s" >&$fd_original_err
  elif [[ "$debug_prev_command" =~ (\[\[.*\]\]) && ! "$debug_buffered_commands" ]]; then
    local condition=${BASH_REMATCH[1]}
    eval "$condition && echo \"+ => true\" || echo \"+ => false\"" >&$fd_original_err
  elif [[ "$debug_prev_command" =~ if\ (\(\(.*\)\))\;\ then && ! "$debug_buffered_commands" ]]; then
    local condition=${BASH_REMATCH[1]}
    eval "$condition && echo \"+ => true\" || echo \"+ => false\"" >&$fd_original_err
  elif [[ "$debug_prev_command" =~ ^\ *([a-zA-Z_0-9]+)\ +.*\$ ]]; then
    local c=${BASH_REMATCH[1]}
    if [[ ! $c =~ ^(local|declare)$ ]]; then
      local c=$debug_prev_command
      c=${c//\\/\\\\}
      c=${c//\"/\\\"}
      eval "local s=\"$c\""
      echo "+ $s" >&$fd_original_err
    fi
  elif [[ "$debug_prev_command" =~ ^\ *(\$?[a-zA-Z_0-9]+)\+?=\((.*)\) ]]; then
    local w=${BASH_REMATCH[1]}
    if [[ "$w" == \$* ]]; then
      w=${w#\$}
      w=${!w}
    fi
    local v=( ${BASH_REMATCH[2]} )
    if [[ "${#v[*]}" -gt 0 ]]; then
      eval "local s=\"+ \$w=( \${$w[*]} )\""
      echo "$s" >&$fd_original_err
    fi
  elif [[ "$debug_prev_command" =~ ^\ *\(\(\ *([a-zA-Z_0-9]+)(--|\+\+|\ ?=.*)\ *\)\) ]]; then
    local w=${BASH_REMATCH[1]}
    eval "local s=\"+ \$w=\$$w\""
    echo "$s" >&$fd_original_err
  fi

  if [[ "${debug_return_vars:-}" ]]; then
    local __var
    for __var in $debug_return_vars; do
      local -n __val=$__var
      if [[ -v __val ]]; then
        local __v=$__val
        if [[ "${__v:-}" ]] && is_array __val; then
          local -n __array=$__var
          local __i __count=${#__array[*]} __max=10 __short_mode=t __result=
          if (( __count < 10 )); then
            __max=$__count
          fi
          if (( ${#__array[0]} > 20 )); then
            __short_mode=f
          fi
          for ((__i = 0; __i < __max; __i++)); do
            __v=${__array[$__i]}
            shell_quote_var __v
            if (( ${#__v} < 20 )); then
              __result+=" $__v"
            else
              __short_mode=f
              echo "+ $__var[$__i]=$__v" >&$fd_original_err
            fi
          done
          if [[ $__short_mode == f ]]; then
            echo "+ $__var __count=$__count" >&$fd_original_err
          else
            echo "+ $__var[*]=( ${__result# } )" >&$fd_original_err
          fi
        else
          shell_quote_var __v
          echo "+ $__var=$__v" >&$fd_original_err
        fi
      fi
    done
    debug_return_vars=
  fi

}

debug_inner() {
  local saved_bash_source=( "${BASH_SOURCE[@]:2}" ) \
    saved_bash_lineno=( "${BASH_LINENO[@]:2}" ) \
    saved_funcname=( "${FUNCNAME[@]:2}" ) \

  local stack_size=${#saved_funcname[*]}

  if [[ $debug_trace_time == t ]]; then
    timebox_close
    trace_time=f
    trace_time_summarize
  fi

  if [[ $debug_skip_ignore == t ]]; then
    debug_skip_ignore=f
    if [[ " $debug_ignore " == *" $debug_current_function "* ]]; then
      debug_ignore_remove "$debug_current_function" 
    fi
  fi

  debug_last_location="$raw_debug_path_to_source_file $debug_line_num"
  debug_source_update_hl

  local backlog=
  if [[ $debug_path_to_source_file != none && "$debug_prev_function" == "$debug_current_function" && "$((debug_prev_line+1))" -lt "$debug_line_num" ]]; then
    local start_line=$((debug_prev_line+1))
    local end_line=$((debug_line_num-1))
    backlog=$(sed -n "$start_line,${end_line}p;${end_line}q" "$debug_path_to_source_file")
  fi

  debug_prev_line="$debug_line_num"
  debug_prev_function=$debug_current_function
  debug_prev_source_file=$debug_source_file
  debug_step_to_next_function=f
  debug_step_to_next_file=f
  debug_step_to_hi_function=f
  debug_step_to_mid_function=f

  if [[ $debug_silent_command == f ]]; then
    debug_show_extra_backlog
  fi

  local display_command=$debug_command
  local raw_display_command=$display_command
  if [[ $debug_step_to_next_line == t || $debug_long_command == t ]] \
     && [[ $debug_current_function != none ]] \
     && [[ $debug_path_to_source_file != none ]]; then
    display_command=$(sed -E -n "${debug_line_num}{s/^ *(.*)/\\1/;p;q;}" "$debug_path_to_source_file")
    raw_display_command=$(sed -E -n "${debug_line_num}{s/^ *(.*)/\\1/;p;q;}" "$raw_debug_path_to_source_file")
  fi

  debug_step_to_next_line=f
  debug_prev_command=$raw_display_command

  debug_command_loop

  if [[ $debug_untrap == t ]]; then
    debug_tracing=f
    debug_expansion_prev=$debug_expansion
    debug_expansion=0
    debug_output_stop
  fi

  if [[ "$debug_exit" ]]; then
    if [[ "$debug_debug" == t ]]; then
      echo "${CYAN}Exiting because debug_exit=$debug_exit${RESET}" >&$fd_original_err
    fi
    exit $debug_exit
  fi

  return 0
}

debug_trap() {
  debug_saved_shell_options_short=$-
  set +evu +o pipefail

  debug_rematch=( "${BASH_REMATCH[@]}" )

  : 10<&0 11>&1 12>&2
  : <&$fd_original_in >&$fd_original_out 2>&$fd_original_err

  #if [[ $debug_debug == t ]]; then
  #  echo "${CYAN}debug_immediate=$debug_immediate${RESET}" >&$fd_original_err
  #  echo "${CYAN}debugging=$debugging${RESET}" >&$fd_original_err
  #  pause_qd
  #fi

  local saved_lineno
  (( saved_lineno = debug_trap_first_line - 1 )) 

  if [[ "${debug_var:-}" ]]; then
    local v=${!debug_var}
    if [[ "${debug_var_old:-}" != "$v" ]]; then
      echo "${CYAN}debug_id=$fork_debug_id $debug_var=$v ${FUNCNAME[1]}$RESET" >&$fd_original_err
    fi
    debug_var_old=$v
  fi

  local debug_r=0

  if [[ ${trace_debugger:-f} == t ]]; then 
    set -x
    BASH_XTRACEFD=2
  fi

  if [[ $debug_debug == t ]]; then
    log_debug_debug "debug_id=$fork_debug_id ${BASH_SOURCE[1]:-no_source}:${saved_lineno:-${BASH_LINENO[0]:-no_line}} ${FUNCNAME[1]:-no_func} ${BASH_COMMAND}" 
  fi

  local debug_path_to_source_file \
    raw_debug_path_to_source_file="${BASH_SOURCE[1]:-none}" \
    debug_line_num=$saved_lineno \
    debug_current_function=${FUNCNAME[1]:-none} \
    debug_command=${BASH_COMMAND} \
    debug_current_depth=${#FUNCNAME[*]} \
    IFS=' '$'\n'$'\t' \
    debug_full_path=${debug_full_path:-f} \
    debug_source_file \

  debug_tracing=f
  #[[ $debug_debug == t ]] && echo "${CYAN}debug_tracing=$debug_tracing${RESET}" >&$fd_original_err
  local prev_debug_out_path=$debug_out_path
  debug_out_path=$tmp_folder/debug-out.$BASHPID
  if [[ "$prev_debug_out_path" != $debug_out_path && -v cleanup_on_exit ]]; then
    defer "rm $debug_out_path"
  fi
  debug_recording_trace=f

  if [[ "$debug_exit" ]]; then
    if [[ "$debug_debug" == t ]]; then
      echo "${CYAN}Exiting because debug_exit=$debug_exit${RESET}" >&$fd_original_err
    fi
    exit $debug_exit
  fi

  if [[ " $debug_ignore " == *" $debug_current_function "* && $debug_skip_ignore == f ]]; then
    [[ $debug_debug == t ]] && echo "${CYAN}Ignoring $debug_current_function${RESET}" >&$fd_original_err
    debug_output_stop
  else

    debug_load_state || return 1

    debug_rewind=f

    debug_source_update

    local line_part=$debug_line file_part=
    if [[ "$debug_line" ]]; then
      if [[ $debug_line == *:* ]]; then
        line_part=${debug_line##*:}
        file_part=${debug_line%:*}
      fi
    fi

    local expanded_command= fixed_command=
    if [[ "$debug_search" ]]; then
      if [ "$debug_expanded_search" == t ]; then
        fixed_command=${debug_command}
        fixed_command=${fixed_command//\\/**BS**}
        fixed_command=${fixed_command//\\\$/\\\\\$}
        # temporarily hide this so we can keep $(( but transform $(
        fixed_command=${fixed_command//\$((/{{{}
        fixed_command=${fixed_command//\$(/\\\$(}
        # restore {{{ to $((
        fixed_command=${fixed_command//{{{/\$((}
        fixed_command=${fixed_command//\"/\\\"}
        fixed_command=${fixed_command//\*\*BS\*\*/\\}
        eval "expanded_command=\"$fixed_command\"" &>/dev/null || true
      fi
    fi

    local ok_to_debug=f
    debug_get_ok_to_debug

    if [[ $ok_to_debug == t ]]; then
      no_trace_depth=0
      tracing_depth=0
      debug_output_expansion
      debug_inner
    else
      [[ $debug_debug == t ]] && echo "${CYAN}Not stopping.${RESET}" >&$fd_original_err
      debug_output_stop
    fi

  fi

  debug_update_expansion
  maybe_enable_debug_tracing
  debug_list_stack_pos=0

  [[ $debug_subshell == t ]] && set -T
  [[ $debug_saved_shell_options_short == *e* ]] && set -e
  [[ $debug_saved_shell_options_short == *u* ]] && set -u
  if [[ ${trace_debugger:-f} == t ]]; then 
    set +x
    trace_debugger=f
  fi

  debug_debug=f

  BASH_REMATCH=( "${debug_rematch[@]}" )
  : <&10 >&11 2>&12
  return $debug_r
}

set_return_code() {
  if [[ $debug_tracing == t ]]; then
    set -x
  fi
  return $1
}

reserve_tmp_file() {
  local var=$1; shift
  local base=${1:-$var}; shift
  
  local internal_tmp_file=$(mktemp $tmp_folder/$base.$$.XXXXXX)
  eval "$var=$internal_tmp_file"
  eval "cleanup_on_exit+='rm ${internal_tmp_file} &>/dev/null || true;'"
}

show_table() {
  local -n fields=$1_fields data=$1_data
  if [[ -v fields && -v data ]]; then

    set +T
    {
    echo "${fields[*]}"
    local line= field_count=${#fields[*]} f

    for (( i = 0; i <= ${#data[*]}; i++ )); do
      (( f = i % field_count ))
      if (( f == 0 )) && [[ "$line" ]]; then
        echo "$line"
        line=
      fi
      if (( i < ${#data[*]} )); then
        line+="${data[$i]} "
      fi
    done
    } | column -t >&$fd_original_err
    set -T

  else
    echo "Invalid table variable: $1" >&$fd_original_err
  fi
}

log_debug_debug() {
  echo "${CYAN}debug_debug: $*$RESET" >&$fd_original_err
}

debug_always() {
  debug_skip_breakpoints=f debug_start
}

debug_start() {
  if [[ "${debug_skip_breakpoints:-}" == t ]]; then
    return 0
  fi
  debug_skip_breakpoints=t

  local unignore_this_function=${unignore_this_function:-0}

  if [[ ${debug_debug:-f} == t ]]; then
    echo "${CYAN}debug_start() debug_immediate=$debug_immediate debugging=$debugging${RESET}" >&$fd_original_err
  fi
  debug_buffered_commands=$*
  if [[ "${exiting:-f}" == t ]]; then
    echo "${NL}Exiting. Starting debugger." >&$fd_original_err
    echo "${YELLOW}Warning: because process is exiting, debugger stepping commands will NOT work${RESET}" >&$fd_original_err
  fi
  if [[ "$debug_buffered_commands" ]]; then
    debug_silent_command=t
  fi
  no_trace_depth=0
  parallel_execution=${p_par:-f}
  if [[ ! "${debugging:-}" ]]; then
    debugger_init || return 1
  fi

  debug_needs_to_load_state=t \
  debug_load_state || return 1
  if [[ "${debug_expansion_prev:-}" ]]; then
    debug_expansion=$debug_expansion_prev
    unset debug_expansion_prev
  fi

  if (( unignore_this_function > -1 )); then
    debug_ignore_remove ${FUNCNAME[*]:$unignore_this_function}
  fi

  debug_immediate=${debug_immediate:-t}
  if [[ $debugging == f ]]; then
    # export \
    debugging=t \
    debug=${debug:-} \
    debug_condition=${debug_condition:-} \
    debug_condition_old=${debug_condition_old:-} \
    debug_debug=${debug_debug:-f} \
    debug_dir=$PWD \
    debug_display=${debug_display:-none} \
    debug_exit=${debug_exit:-} \
    debug_expanded_search=${debug_expanded_search:-f} \
    debug_expanded_search=${debug_expanded_search:-f} \
    debug_expansion=${debug_expansion:-1} \
    debug_expression=${debug_expression:-echo none} \
    debug_follow_source=${debug_follow_source:-t} \
    debug_function=${debug_function:-} \
    debug_function_old=${debug_function_old:-} \
    debug_id=${debug_id:-t} \
    debug_last_location=${debug_last_location:-} \
    debug_line=${debug_line:-} \
    debug_line_old=${debug_line_old:-} \
    debug_list_dir=${debug_list_dir:-none} \
    debug_list_offset=${debug_list_offset:-0} \
    debug_list_stack_pos=${debug_list_stack_pos:-0} \
    debug_list_window=${debug_list_window:-20} \
    debug_log_level_filter=${debug_log_level_filter:-${log_level_filter:-}} \
    debug_long_command=${debug_long_command:-f} \
    debug_max_depth=${debug_max_depth:-999} \
    debug_original_tracefd=${debug_original_tracefd:-${BASH_XTRACEFD:-}} \
    debug_prev_command=${debug_prev_command:-none} \
    debug_prev_function=${debug_prev_function:-none} \
    debug_prev_line=${debug_prev_line:-0} \
    debug_prev_source_file=${debug_prev_source_file:-none} \
    debug_quick_function=${debug_quick_function:-} \
    debug_restart_command= \
    debug_rewind=${debug_rewind:-f} \
    debug_saved_params=${debug_saved_params:-} \
    debug_saved_shell_options=${debug_saved_shell_options:-} \
    debug_search=${debug_search:-} \
    debug_search_deep=${debug_search_deep:-t} \
    debug_search_old=${debug_search_old:-} \
    debug_show_time=${debug_show_time:-f} \
    debug_silent_command=${debug_silent_command:-f} \
    debug_skip_ignore=${debug_skip_ignore:-f} \
    debug_step_to_hi_function=${debug_step_to_hi_function:-f} \
    debug_step_to_later_line=${debug_step_to_later_line:-f} \
    debug_step_to_mid_function=${debug_step_to_mid_function:-f} \
    debug_step_to_next_file=${debug_step_to_next_file:-f} \
    debug_step_to_next_function=${debug_step_to_next_function:-f} \
    debug_step_to_next_line=${debug_step_to_next_line:-f} \
    debug_stepping=${debug_stepping:-f} \
    debug_stop_at=${debug_stop_at:-} \
    debug_subshell=${debug_subshell:-f} \
    debug_trace_time=${debug_trace_time:-f} \
    debug_untrap=f \
    debug_var=${debug_var:-} \
    debug_var_regex=${debug_var_regex:-} \
    new_debug_watch=${debug_watch:-${debug_var:-${trace_vars:-${trace_var:-${trace_expression:-}}}}} \

    debug_set_watch "$new_debug_watch"

    trap '
      set +x
      echo "PIPE signal was fired." >&$fd_original_err
      stack_trace
      BASH_XTRACEFD=
      debug_start
      ' PIPE
    shopt -s extdebug
    trap '
      set +x; debug_trap_first_line=${LINENO:-0} 
      debug_saved_params=( "$@" )
      debug_trap
      debug_rc=$?
      [[ $debug_untrap == t ]] && trap - DEBUG
      [[ $debug_rewind == t ]] && continue
      set_return_code $debug_rc
      ' DEBUG
  fi
}

debug() {
  local function_to_debug=$*
  debug_immediate=t
  if [[ "$function_to_debug" ]]; then
    debug_start
    $function_to_debug
  else
    debug_start
  fi
}

alias zombie_debug=debug_start

debug_handle_resolve_next() {
  local debug_item="${debug%% *}"

  if [[ "$debug" == *' '* ]]; then
    debug=${debug#* }
  else
    debug=
  fi

  if [[ "$debug_item" ]]; then
    case "$debug_item" in
      t)
        debug_immediate=t
      ;;
      f)
        debug_skip_breakpoints=t
      ;;
      *:*)
        debug_line=$debug_item
      ;;
      =*)
        debug_search=${debug_item#=}
      ;;
      \?)
        debug_id_out=t
      ;;
      *)
        if [[ "$debug_item" =~ ^[0-9\.]+$ ]]; then
          debug_id=$debug_item
        else
          debug_quick_function=$debug_item
          debug_function_old=$debug_quick_function
        fi
      ;;
    esac
  fi
}

debug_setup() {
  debugging=f

  if [[ "${debug_unignore:-}" ]]; then
    debug_ignore_remove "$debug_unignore"
  fi

  : ${debug_bisect:=${bisect:-}}
  if [[ "$debug_bisect" ]]; then

    echo "bisect not implemented yet, we need to upgrade it to support forked debug ids like 3.521.32" >&$fd_original_err
    exit 1

    if [[ "$debug_bisect" == *..* ]]; then
      debug_bisect_min=${debug_bisect%..*}
      debug_bisect_max=${debug_bisect#*..}
      if [[ $debug_bisect_max == $debug_bisect_min ]]; then
        debug_id=$debug_bisect_max
        echo "  ${CYAN}Not bisecting since we are already at a single id${RESET}" >&$fd_original_err
      else
        debug_id=$(( (debug_bisect_max - debug_bisect_min) / 2 + debug_bisect_min ))
        echo "  ${CYAN}Will bisect $debug_bisect_min to $debug_bisect_max at $debug_id${RESET}" >&$fd_original_err
      fi
    else
      echo "Invalid bisect value. Must be a range with .. between, like 5..100" >&$fd_original_err
      exit 1
    fi
  fi

  debug=${debug:-}

  if [[ "$debug" ]]; then
    debug_handle_resolve_next
  fi

  if [[ "${debug_search:-}" \
     || "${debug_search_deep:-}" \
     || "${debug_id:-}" \
     || "${debug_var:-}" \
     || "${debug_function:-}" \
     || "${debug_quick_function:-}" \
     || "${debug_immediate:-}" == t \
     || "${debug_line:-}" ]]; then

    if [[ "${debug_search:-}" == =* ]]; then
      debug_search=${debug_search#=}
      debug_expanded_search=t
    fi

    if [[ "${debug_search:-}" ]]; then
      if [[ "$debug_search" == ~* ]]; then
        # use unescaped to support regex if expression starts with ~
        debug_search=${debug_search#\~}
      else
        debug_search=${debug_search//\\/\\\\}
        debug_search=${debug_search//\$/\\\$}
        debug_search=${debug_search//[/\\[}
      fi
      echo "  ${CYAN}Will debug when code is found to contain: $debug_search${RESET}" >&$fd_original_err
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
    fi

    if [[ "${debug_quick_function:-}" ]]; then
      echo "  ${CYAN}Will debug starting at function: $debug_quick_function${RESET}" >&$fd_original_err
      debug_id=t
    fi

    if [[ "${debug_function:-}" ]]; then
      echo "  ${CYAN}Will debug starting at function: $debug_function${RESET}" >&$fd_original_err
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
      debug_ignore_remove $debug_function
    fi

    if [[ "${debug_line:-}" ]]; then
      debug_search_deep=t
      debug_long_command=t
      debug_subshell=t
    fi

    if [[ "${debug_var:-}" ]]; then
      echo "  ${CYAN}Will debug var $debug_var" >&$fd_original_err
      debug_subshell=t
    fi

    if [[ "${debug_id:-}" ]]; then
      if [[ "$debug_id" != t ]]; then
        echo "  ${CYAN}Will debug starting at debug_id $debug_id or later${RESET}" >&$fd_original_err
      fi
      debug_subshell=t
    fi

    debug_search_old=${debug_search_old:-${debug_search:-}}

    if [[ ! "${debug_id:-}" && ! "${debug_quick_function:-}" ]]; then
      debug_start
    fi
    debug_skip_breakpoints=t

  fi
}

