#!/bin/bash

type -t omni_log_init >/dev/null && return 0

# if logging_to_file is set, trace output will be sent to this file

# when a function which gets forked into it's own process is run, need to do this:
# f() {
#   change_log_file
#   begin_function
#   end_function
#   handle_return
# }

omni_log_init() {
  local command="$*"  
  omni_log_job_id=0 omni_log_fork_id=0

  if [[ "${debugger_available:-f}" == t ]]; then
    debug_at_log_id=
    if [[ "${log_id:-}" ]]; then
      echo "${CYAN}Will debug starting at log_id $log_id or later${RESET}" >&2
      debug_at_log_id=$log_id
    fi
  fi

  first_log_file=
  first_log=t
  log_depth_current=0
  omni_log_pos=1
  trace_var=${trace_var:-}
  declare -gA trace_var_value
  log=${log:-file}
  log_to_file=t
  log_to_out=f
  log_action=${log_action:-}
  log_depth=${log_depth:-}
  log_function=${log_function:-}
  log_level=${log_level:-info}
  log_format=${log_format:-default}
  cooked_stack=( ${cooked_stack[*]:-} )

  case $log in
    off|fatal|error|warn|info|debug|trace|all)
      log_level=$log
      log=file
      ;;
    file)
      # default behavior
      ;;
    out)
      log_to_out=t
      log_level=warn
      if [[ "$log_format" == default ]]; then
        log_format='$level_color$message$RESET'
      fi
      ;;
    both)
      log_to_file=t
      log_to_out=t
      ;;
    *)
      log_to_file=t
      log_to_out=t
      log_action=$log
      ;;
  esac

  case $log_level in
    none)
      log_format=
    ;;
    fatal|error|warn|info)
      if [[ "$log_format" == default ]]; then
        log_format='$level_color$message$RESET'
      fi
    ;;
    debug)
      if [[ "$log_format" == default ]]; then
        log_format='$log_id$level_color$message$RESET'
      fi
    ;;
    trace|all)
      if [[ "$log_format" == default ]]; then
        log_format='$time$pid$log_id$COL40$level_color$action$COL55$function$COL85$log_vars$message$RESET'
      fi
    ;;
    *)
      log_fatal "Invalid log_level value. Must be one of: none, error, warn, info, trace, debug"
      exit 1
    ;;
  esac

  case $log_format in
    tiny)
      log_format='$level_color$message$RESET'
    ;;
    short)
      log_format='$level_color$action$COL15$function$COL45$log_vars$message$RESET'
    ;;
    compact)
      log_format='$level_color$action$function$log_vars$message$RESET'
    ;;
  esac

  var_stack=( ) \
    var_stack2=( ) \
    logging_to_file= \
    log_vars= \
    log_show_vars= 
}

alias begin_function='
  local return_value=0 break_out=f
  write_to_log trace call
  (( log_depth_current++ ))
  var_stack+=( "$log_vars" ) 
  var_stack2+=( "$log_show_vars" ) 
  log_vars= log_show_vars=
  while true; do
'

alias end_function='
  break; done; (( log_depth_current-- ))
  log_vars=${var_stack[-1]}
  log_show_vars=${var_stack2[-1]}
  unset var_stack[-1] var_stack2[-1]
  write_to_log trace "return($return_value)"
'

# Can be called safely whether or not a log file has been set up
write_to_log() {
begin_no_tracing_zone

local level=$1 action=${2:-${1:-}} message=${3:-} \
  var_name var value new_vars= trace_vars= show_vars2=${log_show_vars:-$log_vars}

for var in log_vars ${log_vars:-} $trace_var; do

  if [[ $var == *=* ]]; then
    var_name=${var%%=*}
    var=${var#*=}
  else
    var_name=$var
  fi

  eval "value=\${$var:-}"
  if [[ $value =~ \  ]]; then
    value=${value//\\/\\\\}
    #   double quoted
    value="\"${value//\"/\\\"}\""
    #   escaped spaces
    # value=${value//\\/\\\\}
    # value=${value// /\\ }
  fi

  if [[ " $trace_var " =~ \ $var\  ]]; then

    if [[ "$value" != "${trace_var_value[$var]:-}" ]]; then
      trace_vars+="$CYAN"
    fi

    trace_vars+=" $var_name=$value"

    if [[ "$value" != "${trace_var_value[$var]:-}" ]]; then
      trace_vars+="$RESET"
      trace_var_value[$var]=$value
    fi

  else
    if [[ "$value" ]]; then
      new_vars+=" $var_name=$value"
    fi
  fi

done

local time="$EPOCHREALTIME"
local pid="$BASHPID"
local to_log="= ts=$time pid=$pid"

# if [[ "${debug_id:-}" ]]; then
#   to_log+=" debug_id=$debug_id_current"
# fi

local log_id=$omni_log_fork_id:$omni_log_pos
to_log+=" log_id=$log_id depth=$log_depth_current level=$level"

local quoted_value
if [[ "$action" ]]; then
  get_shell_quoted_value "$action"
  to_log+=" action=$quoted_value"
fi
local function=${log_function:-${FUNCNAME[1]}}
if [[ "${function:-}" ]]; then
  to_log+=" function=$function"
fi
if [[ "${show_vars2:-}" ]]; then
  get_shell_quoted_value "$show_vars2"
  to_log+=" log_show_vars=$quoted_value"
fi
to_log+="$new_vars$trace_vars"
if [[ "$message" ]]; then
  get_shell_quoted_value "$message"
  to_log+=" info=$quoted_value"
fi

if [[ $log_to_file == t && "${logging_to_file:-}" ]]; then
  echo "$to_log" >>$logging_to_file
fi

pause_tee

case $action in
  call)
    cooked_stack+=( "log_id=$log_id $function$COL35$new_vars$trace_vars" )
  ;;
  return*)
    unset cooked_stack[-1]
  ;;
esac

local out_line=
if [[ $log_to_out == t ]]; then
  out_line="$to_log$trace_vars"
  echo "$out_line" >&2
else

  local hide=f

  if [[ "$log_action" && ! $action =~ "$log_action" ]]; then
    hide=t
  fi

  if [[ "$log_function" && ! $function =~ "$log_function" ]]; then
    hide=t
  fi

  if [[ "$log_depth" && $log_depth_current -gt $log_depth ]]; then
    hide=t
  fi

  local level_num=${log_level_num_map[$level]}
  local log_level_num=${log_level_num_map[$log_level]}
  if [[ "$log_level" && $level_num -lt $log_level_num ]]; then
    hide=t
  fi

  local level_color=${log_level_color_map[$level]}
  function=" $function"
  action=" $action"
  message=" $message"
  local log_vars="$new_vars"
  time=" $time"
  pid=" pid=$pid"
  log_id=" log_id=$log_id"
  eval "local to_terminal=\"$log_format\""
  out_line="$to_terminal$trace_vars"

  if [[ $hide == f ]]; then
    echo "$out_line" >&2
  fi
fi

unpause_tee

if [[ "$debug_at_log_id" ]]; then
  local debug_at_fork_id=${debug_at_log_id%:*}
  local debug_at_log_pos=${debug_at_log_id#*:}
  if [[ $omni_log_fork_id == $debug_at_fork_id \
     && $omni_log_pos -ge $debug_at_log_pos ]]; then
    debug_at_log_id=
    if [[ ! "${debug_id:-}" ]]; then
      debug_immediate=t
      debug_start
    else
      echo "${CYAN}Will debug starting at debug_id $debug_id or later${RESET}" >&2
      debug_subshell=t
      debug_stepping=f
      debug_immediate=f
    fi
  fi
fi
(( omni_log_pos++ ))

end_no_tracing_zone
}

# Usage:
#   new_log_file=... change_log_file  point to new log file
#   new_log_file= change_log_file     stop logging
# should also include previous_fork_id
change_log_file() {
begin_function_flat

  local new_log_file=$new_log_file old_log_file \
    log_function=${log_function:-${FUNCNAME[1]}} \
    previous_fork_id=${previous_fork_id:-0} \

  if [[ "${logging_to_file:-}" == "$new_log_file" ]]; then
    succeed
  fi

  if [[ "${logging_to_file:-}" ]]; then
    if [[ "$new_log_file" ]]; then
      omni_log_fork_id=$previous_fork_id log_vars=new_log_file write_to_log trace log_to
    else
      omni_log_fork_id=$previous_fork_id write_to_log trace log_close
    fi
  fi

  if [[ "$new_log_file" ]]; then
    old_log_file=${logging_to_file:-}
    logging_to_file=$new_log_file
    omni_log_pos=1

    if [[ -f $logging_to_file ]]; then
      log_fatal "log file already exists: $logging_to_file"
      fail1
    fi

    if [[ "$old_log_file" ]]; then
      log_vars=old_log_file write_to_log trace log_from
    fi

  fi

end_function_flat
handle_return
}

log_trace() {
begin_no_tracing_zone
local message="$*"
log_function=${FUNCNAME[1]} write_to_log trace "${action:-}" "$message"
end_no_tracing_zone
return 0
}

log_debug() {
begin_no_tracing_zone
log_function=${FUNCNAME[1]} write_to_log debug "${action:-}" "$*"
end_no_tracing_zone
return 0
}

log_info() {
begin_no_tracing_zone
log_function=${FUNCNAME[1]} write_to_log info "${action:-}" "$*"
end_no_tracing_zone
return 0
}

log_warn() {
begin_no_tracing_zone
log_function=${FUNCNAME[1]} write_to_log warn "${action:-}" "$*"
end_no_tracing_zone
return 0
}

log_error() {
begin_no_tracing_zone
log_function=${FUNCNAME[1]} write_to_log error "${action:-}" "$*"
end_no_tracing_zone
return 0
}

log_fatal() {
begin_no_tracing_zone
log_function=${FUNCNAME[1]} write_to_log fatal "${action:-}" "$*"
end_no_tracing_zone
return 0
}

# zombie logs are used to output temporary debugging logs
# they should be removed from the code after the issue is resolved
log_zombie() {
begin_no_tracing_zone
echo "$CYAN$*$RESET" >&$fd_original_err
end_no_tracing_zone
return 0
}

incomplete() {
  begin_no_tracing_zone
  if [ ${tracing_midline:-f} == t ]; then
    tracing_midline=f
    echo >&2
  fi
  if [ "${1:-}" ]; then
    echo "Not implemented yet: ${1:-}" >&2
  else
    echo "Not implemented yet." >&2
  fi
  start_frame=2 stack_trace
  end_no_tracing_zone
  exit 1
}

log_and_run() {
local prefix= command=$* out_to_file=${out_to_file:-}
if [[ $pretend == t ]]; then
  prefix="PRETEND: "
fi
log_function=${FUNCNAME[1]} write_to_log debug command "$prefix$command"
if [[ $pretend == f ]]; then
  if [[ "$out_to_file" ]]; then
    eval "$command" >$out_to_file || return 1
  else
    eval "$command" || return 1
  fi
fi
return 0
}

declare -A log_level_num_map=( 
  [all]=0 
  [trace]=1 
  [debug]=2 
  [info]=3 
  [warn]=4 
  [error]=5 
  [fatal]=6 
  [off]=9
  )

declare -A log_level_color_map=( 
  [all]= 
  [trace]= 
  [debug]= 
  [info]= 
  [warn]=$YELLOW
  [error]=$RED 
  [fatal]=$RED 
  [off]=
  )

out() {
  #echo "$@" >&${fd_original_out}
  echo "$@"
}

