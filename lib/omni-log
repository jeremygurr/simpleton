#!/bin/bash

# This library of aliases and functions follows the standard hi-shell
# output interface but changes the implementation to always output trace info
# but with additional info to allow easy filtering or browsing of that info.

# if log_file is set, trace output will be sent to this file

# when a function which gets forked into it's own process is run, need to do this:
# f() {
#   change_log_file
#   begin_function
#   end_function
#   handle_return
# }

first_log=t
log_depth=0
log_id=0
trace_var=${trace_var:-}

alias begin_function='
  local return_value=0 break_out=f
  write_to_log trace call
  let log_depth++ || true
  while true; do
'

alias end_function='
  break; done; let log_depth-- || true
  write_to_log trace "return($return_value)"
'

# Usage:
#   change_log_file {log file base}   point to new log file
#   change_log_file                   point to same base but new pid (forked)
#   change_log_file -                 stop logging
change_log_file() {
begin_function_flat

  local new_base=${1:-} new_log_file old_log_file

  if [[ "$new_base" == - ]]; then
    new_log_file=
  elif [[ "$new_base" ]]; then
    base_log_file=$new_base
    new_log_file=$base_log_file-$BASHPID.olog
    local first_log=$base_log_file-first.olog
    if [[ -e "$first_log" ]]; then
      err "Log already exists: $first_log" 
      stack_trace
      fail1
    fi
    ln -s $new_log_file $first_log || fail
  else
    [[ ! "${base_log_file:-}" ]] && succeed
    new_log_file=$base_log_file-$BASHPID.olog
  fi

  if [[ "${log_file:-}" == "$new_log_file" ]]; then
    succeed
  fi

  if [[ "${log_file:-}" ]]; then
    untee_output 
    if [[ "$new_log_file" ]]; then
      function=${FUNCNAME[1]} vars=new_log_file write_to_log trace log_branch
    else
      function=${FUNCNAME[1]} write_to_log trace log_close
    fi
  fi

  if [[ "$new_log_file" ]]; then
    old_log_file=${log_file:-}
    log_file=$new_log_file

    # [[ -f $log_file ]] && rm $log_file
    if [[ -f $log_file ]]; then
      err "log file already exists: $log_file"
      fail1
    fi

    [[ "$old_log_file" ]] && vars=old_log_file write_to_log trace log_from
    #BASH_XTRACEFD=2
    if [[ "$log_to_file" ]]; then
      tee_output_to $log_file 
    fi
    #start_tracing
  else
    #stop_tracing
    #BASH_XTRACEFD=
    :
  fi

end_function_flat
handle_return
}

debug() {
begin_no_tracing_zone
  while true; do
    case "$1" in
      -*)
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done
  if [[ $log_depth -le $((trace-5)) && $log_to_out == f ]]; then
    out "$@"
  fi
  function=${FUNCNAME[1]} write_to_log debug '' "$*"
end_no_tracing_zone
return 0
}

info() {
begin_no_tracing_zone
  while true; do
    case "$1" in
      -*)
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done
  if [[ $log_to_out == f ]]; then
    out "$@"
  fi
  function=${FUNCNAME[1]} write_to_log info '' "$*"
end_no_tracing_zone
return 0
}

trace() {
begin_no_tracing_zone
  while true; do
    case "$1" in
      -a|-n|-e)
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done
  local importance=$1; shift || true
  local message="$*"
  if [[ $log_depth -le $((trace+importance)) && $log_to_out == f ]]; then
    out "$message"
  fi
  function=${FUNCNAME[1]} write_to_log trace '' "$message"
end_no_tracing_zone
return 0
}

err() {
begin_no_tracing_zone
  while true; do
    case "$1" in
      -*)
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done
  local prefix=
  if [[ "${debug_id:-}" ]]; then
    prefix="${CYAN:-}debug_id=$debug_id_current "
  fi
  out "$prefix${RED:-}$@${RESET:-}"
  function=${FUNCNAME[1]} write_to_log error '' "$*"
end_no_tracing_zone
return 0
}

warn() {
begin_no_tracing_zone
  while true; do
    case "$1" in
      -*)
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done
  out "${YELLOW:-}$@${RESET:-}"
  function=${FUNCNAME[1]} write_to_log warn '' "$*"
end_no_tracing_zone
return 0
}

log_and_run() {
local prefix=
if [[ $pretend == t ]]; then
  prefix="PRETEND: "
fi
function=${FUNCNAME[1]} write_to_log info command "$prefix$*"
if [[ $log_to_out == f ]]; then
  out "$prefix$*"
fi
if [[ $pretend == f ]]; then
  eval "$*"
fi
}

# Can be called safely whether or not a log file has been set up
write_to_log() {
begin_no_tracing_zone

local level=$1 action=$2 message=${3:-} var value var_log=

for var in $trace_var ${vars:-}; do
  eval "value=\${$var:-}"
  if [[ $value =~ \  ]]; then
    value=${value//\\/\\\\}
    #   double quoted
    value="\"${value//\"/\\\"}\""
    #   escaped spaces
    # value=${value//\\/\\\\}
    # value=${value// /\\ }
  fi
  var_log+=" $var=$value"
done

local output="= $EPOCHREALTIME pid=$BASHPID"

if [[ "${debug_id:-}" ]]; then
  output+=" debug_id=$debug_id_current"
else
  output+=" log_id=$log_id"
fi

output+=" depth=$log_depth level=$level"

if [[ "$action" ]]; then
  output+=" action=$action"
fi
local function=${function:-${FUNCNAME[1]}}
if [[ "${function:-}" ]]; then
  output+=" function=$function$var_log"
fi
if [[ "$message" ]]; then
  output+=" info=\"${message//\"/\\\"}\""
fi

let log_id++ || true

if [[ $log_to_file == t && "${log_file:-}" && $log_to_out == f ]]; then
  echo "$output" >>$log_file
elif [[ $log_to_out == t ]]; then
  local hide=f

  if [[ "$log_action" && ! $action =~ "$log_action" ]]; then
    hide=t
  fi

  if [[ "$log_function" && ! $function =~ "$log_function" ]]; then
    hide=t
  fi

  if [[ $hide == f ]]; then
    case $log_out_width in
      mid)
        echo "$action $function$var_log $message" >&$fd_trace
      ;;
      tiny)
        echo "$action $function $message" >&$fd_trace
      ;;
      *)
        echo "$output" >&$fd_trace
      ;;
    esac
  fi

fi

end_no_tracing_zone
}

out() {
  #echo "$@" >&${fd_original_out}
  echo "$@"
}

