#!/bin/bash

# This library of aliases and functions follows the standard hi-shell
# output interface but changes the implementation to always output trace info
# but with additional info to allow easy filtering or browsing of that info.

# if log_file is set, trace output will be sent to this file

# when a function which gets forked into it's own process is run, need to do this:
# f() {
#   change_log_file
#   begin_function
#   end_function
#   handle_return
# }

first_log=t
log_depth=0

alias begin_function='
  local return_value=0 break_out=f
  write_to_log "level=trace action=call function=${FUNCNAME[0]}"
  let log_depth++ || true
  while true; do
'

alias end_function='
  break; done; let log_depth-- || true
  write_to_log "level=trace action=return function=${FUNCNAME[0]}"
'

change_log_file() {
  local new_base=${1:-} new_log_file old_log_file

  if [[ "$new_base" ]]; then
    base_log_file=$new_base
    new_log_file=$base_log_file-$$-first.olog
  else
    [[ ! "$base_log_file" ]] && return 0
    new_log_file=$base_log_file-$$.olog
  fi

  if [[ "${log_file:-}" ]]; then
    untee_output 
    write_to_log "level=trace action=branch new_log=$new_log_file"
  fi

  old_log_file=${log_file:-}
  log_file=$new_log_file

  # [[ -f $log_file ]] && rm $log_file
  if [[ -f $log_file ]]; then
    err "log file already exists: $log_file"
    fail1
  fi

  [[ "$old_log_file" ]] && write_to_log "level=trace action=from_log old_log=$old_log_file"
  BASH_XTRACEFD=2
  tee_output_to $log_file 
  set -x
  tracing=t
}

info() {
  begin_no_tracing_zone
    while true; do
      case "$1" in
        -*)
          ;;
        *)
          break
          ;;
      esac
      shift || true
    done
    shift || true # ignore importance parameter
    if [[ $log_depth -le $trace ]]; then
      out "$@"
    fi
    write_to_log "level=info $@"
  end_no_tracing_zone
  return 0
}

trace() {
  begin_no_tracing_zone
    while true; do
      case "$1" in
        -*)
          ;;
        *)
          break
          ;;
      esac
      shift || true
    done
    shift || true # ignore importance parameter
    if [[ $log_depth -le $trace ]]; then
      out "$@"
    fi
    write_to_log "level=trace $@"
  end_no_tracing_zone
  return 0
}

err() {
  begin_no_tracing_zone
    while true; do
      case "$1" in
        -*)
          ;;
        *)
          break
          ;;
      esac
      shift || true
    done
    out "${RED:-}$@${RESET:-}"
    write_to_log "level=error $@"
  end_no_tracing_zone
  return 0
}

warn() {
  begin_no_tracing_zone
    while true; do
      case "$1" in
        -*)
          ;;
        *)
          break
          ;;
      esac
      shift || true
    done
    out "${YELLOW:-}$@${RESET:-}"
    write_to_log "level=warn $@"
  end_no_tracing_zone
  return 0
}

write_to_log() {
local message=$1
local var value

for var in $vars; do
  value=${!var}
  if [[ $value =~ \  ]]; then
    value=${value//\\/\\\\}
    #   double quoted
    value="\"${value//\"/\\\"}\""
    #   escaped spaces
    # value=${value//\\/\\\\}
    # value=${value// /\\ }
  fi
  message+=" $var=$value"
done

vars=
local output="= $EPOCHREALTIME depth=$log_depth $message"

if [[ $log == file && "${log_file:-}" ]]; then
  echo "$output" >> $log_file
elif [[ $log == out ]]; then
  echo "$output" >&$fd_trace
elif [[ $log == both ]]; then
  if [[ "${log_file:-}" ]]; then
    echo "$output" | tee -a $log_file >&$fd_trace
  else
    echo "$output" >&$fd_trace
  fi
fi

}

out() {
  echo "$@" >&${fd_original_out}
}

