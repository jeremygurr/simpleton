#!/bin/bash

type -t omni_navigator_init >/dev/null && return 0

omni_navigator_init() {
  omni_list_radius=${omni_list_radius:-5}
  if [[ ! -v fd_original_in ]]; then
    exec {fd_original_in}<&0
    exec {fd_original_out}>&1
    exec {fd_original_err}>&2
    exec {fd_original_trace}>&${fd_trace:-2}
  fi
}

get_log_file_token() {
  if [[ ! -f "$log_file" ]]; then
    log_fatal "Can't find log file: $log_file"
    return 1
  fi

  if [[ -L "$log_file" ]]; then
    log_file=$(realpath $log_file)
  fi

  log_file_id=${log_file%.olog}
  log_file_id=${log_file_id##*/}
  log_file_id=${log_file_id##*-}

  if [[ ! "$log_file_id" =~ ^[0-9:]+$ ]]; then
    log_fatal "Could not figure out log file id. Got [$log_file_id]"
    log_fatal "Maybe log file doesn't comply with convention: {path}/{log}-{job_id}:{fork_id}.olog"
    return 1
  fi

  log_file_token=${log_file_id//:/_}
  return 0
}

omni_change_index() {
  local new_index=$new_index
  index=$new_index
  if (( index >= 0 && index < plane_map_size )); then
    plane_id=${plane_map[$index]}
  fi
}

# input: {line}
#   line_id
omni_get_processed_line() {
  local line=$1 line_id=$line_id

  case $action in
    call)
      processed_line="[$action] $function"
    ;;
    return\(*)
      processed_line="[$action] from $function"
    ;;
    log_from)
      processed_line="[$action] $old_log_file"
    ;;
    log_to)
      processed_line="[$action] $new_log_file"
    ;;
    *)
      if [[ "${info:-}" ]]; then
        processed_line="[$action] $info"
      else
        processed_line=${line%$NL}
      fi
    ;;
  esac

  processed_line="$line_id $processed_line"
  return 0
}

# inputs: 
#   log_file log_file_id log_file_token log_fork_id
omni_load_log_array() {
  local log_vars='log_file log_file_id log_file_token log_fork_id'
  begin_function

    eval "declare -ga omni_log_array_$log_file_token"
    local -n array=omni_log_array_$log_file_token
    mapfile array < <(cat $log_file) || fail

    zombie "omni_log_file_$log_file_token=$log_file"
    eval "
      declare -ga \
        omni_plane_map_$log_file_token \
        omni_plane_depth_map_$log_file_token \
        omni_action_map_$log_file_token
      omni_log_file_$log_file_token=$log_file
      "

    local -n \
      plane_map=omni_plane_map_$log_file_token \
      plane_depth_map=omni_plane_depth_map_$log_file_token \
      action_map=omni_action_map_$log_file_token \
      output_array=omni_log_output_array_$log_file_token \

    local i array_size=${#array[*]} \
      plane_stack next_plane_id=1 plane_id=0 \
      processed_line line \
      log_fork_id=${log_file_id#*:} \
      ts pid log_id depth level action function entries info

    begin_for (( i = 0; i < array_size; i++ )); doo

      line=${array[$i]} action=none processed_line=$line
      ts= pid= log_id= depth= level= function= info=
      if [[ "$line" == \=\ * ]]; then
        entries=${line#= }
        eval "$entries" || return 1

        if [[ $action == none ]]; then
          log_fatal "Log line is missing action key: $line"
          return 1
        fi

        action_map[$i]=$action

        line_id=$log_fork_id:$i omni_get_processed_line "$line" || {
          log_fatal "Bad log line: $line"
          return 1
          }
      fi 

      output_array[$i]=$processed_line

      case $action in
        call)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
          plane_stack+=( $plane_id )
          (( plane_id = next_plane_id++ ))
        ;;
        return\(*)
          if [[ -v plane_stack && ${#plane_stack[*]} -gt 0 ]]; then
            if [[ ${#plane_stack[*]} -gt 0 ]]; then
              (( plane_id = plane_stack[-1] ))
              unset plane_stack[-1]
            else
              plane_id=0
            fi
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_id=0
            plane_depth_map[$i]=0
          fi
          plane_map[$i]=$plane_id
        ;;
        *)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
        ;;
      esac

    end_for

    plane_map_size=${#plane_map[*]}
  
  end_function
  handle_return
}

# inputs:
#   cursor
# should be evaluated after omni_change_cursor_log has selected a log for this cursor
omni_select_cursor='
  local -n \
    action_map=cursor_${cursor}_action_map \
    index=cursor_${cursor}_log_array_index \
    log_array=cursor_${cursor}_log_array \
    log_file=cursor_${cursor}_log_file \
    log_file_id=cursor_${cursor}_log_file_id \
    output_array=cursor_${cursor}_output_array \
    plane_depth_map=cursor_${cursor}_plane_depth_map \
    plane_map=cursor_${cursor}_plane_map \
    plane_stack_map=cursor_${cursor}_plane_stack_map \

  local \
    log_fork_id=${log_file_id#*:} \
    log_job_id=${log_file_id%:*} \
    plane_map_size=${#plane_map[*]} \
    plane_id=0 \
'

# inputs:
#   cursor 
#   new_log_file
#   new_index
# should be able to run even before omni_select_cursor
omni_change_cursor_log() {
  local log_vars='cursor new_log_file new_index'
  begin_function

    local log_file=$new_log_file
    local index=${new_index:-0}

    get_log_file_token || fail
    local -n old_log_file=omni_log_file_$log_file_token
    if [[ "${old_log_file:-}" && $old_log_file != $log_file ]]; then
      log_fatal "Two different logs have the same log_file_token (same fork_id):"
      debug_start
      log_fatal "$old_log_file != $log_file"
      fail1
    fi

    eval "
      cursor_${cursor}_log_file=$log_file \
      cursor_${cursor}_log_file_id=$log_file_id \
      cursor_${cursor}_log_array_index=$index \
    "
    eval "
      declare -gn \
        cursor_${cursor}_action_map=omni_action_map_$log_file_token \
        cursor_${cursor}_output_array=omni_log_output_array_$log_file_token \
        cursor_${cursor}_plane_depth_map=omni_plane_depth_map_$log_file_token \
        cursor_${cursor}_plane_map=omni_plane_map_$log_file_token \
        cursor_${cursor}_plane_stack_map=omni_plane_stack_map_$log_file_token \
    "

    if [[ ! -v omni_log_array_$log_file_token ]]; then
      omni_load_log_array || fail
    fi

    eval "declare -gn cursor_${cursor}_log_array=omni_log_array_$log_file_token"

  end_function
  handle_return
}

# inputs: next_log_start omni_list_radius plane_map plane_id output_array
omni_show_log() {
  begin_function_flat

    local -r plane_map_size=${#plane_map[*]}

    # display lines until end
    local remaining_lines=$(( omni_list_radius * 2 + 1 ))
    local found_line 
    local -n i=next_log_start

    begin_while (( remaining_lines-- > 0 )); doo
      found_line=f
      begin_while (( i < plane_map_size )); doo
        if (( plane_map[i] == plane_id )); then
          found_line=t
          break
        fi
        (( i++ ))
      end_while
      if [[ $found_line == t ]]; then
        omni_show_line $i || fail
        (( i++ ))
      else
        break
      fi
    end_while
  end_function_flat
  handle_return
}

# inputs: 
#   new_log_file
#   log_file
#   index
#   log_file_stack
#   log_file_pos_stack
enter_log_file() {
  log_file_stack+=( $log_file )
  log_file_pos_stack+=( $index )
  omni_change_cursor_log || return 1
  new_index=0 \
    omni_change_index || return 1
  return 0
}

# inputs:
#   index: where in the current log to extract the vars from
#   vars: space separated list of vars to extract from the given log line
# warning: if you localize a variable before calling this, that variable can't be set
#   by this function. Only global variables can be successfully set by this function.
#   This is because this function localizes all variables it uses, and then globalizes
#   the selected variable, which won't actually change an outer local version of the
#   variable, only the shared global version.
omni_extract_vars() {
  local line=${log_array[$index]} \
    ts pid log_id depth level action function entries info old_log_file new_log_file \
    var entries
  if [[ "$line" == \=\ * ]]; then
    entries=${line#= }
    eval "$entries" || return 1
    for var in $vars; do
      if [[ -v $var ]]; then
        eval "declare -g $var=\$$var"
      fi
    done
  fi
  return 0
}

omni_step_in() {
  local action=${action_map[$index]}
  if [[ $action == log_to ]]; then
    vars=new_log_file \
      omni_extract_vars || return 1
    if [[ ! "${new_log_file:-}" ]]; then
      log_fatal "log_to action is missing the new_log_file key"
      return 1
    fi
    enter_log_file || return 1
  else
    (( index++ ))
    if (( index >= plane_map_size )); then
      (( index = plane_map_size - 1 ))
    fi
    plane_id=${plane_map[$index]}
  fi
  return 0
}

next_or_enter_log() {
  local direction=${direction:-1}

  begin_function_flat

    if [[ ${action_map[$index]} == log_to ]]; then

      index=$from_index \
        vars=new_log_file \
        omni_extract_vars || fail

      if [[ -e "$new_log_file" ]]; then
        enter_log_file || fail
      else
        log_error "Internal error: log points to non-existent file: $new_log_file"
      fi

    else
      new_index=$((index + direction)) \
        omni_change_index || fail
    fi

  end_function_flat
  handle_return
}

# inputs:
#   from_log
#   from_index
# outputs:
#   found_index
#   found_log
omni_search() {
  local log_vars='from_log from_index'
  begin_function

    local \
      from_log=$from_log \
      from_index=$from_index \
      skip_first=${skip_first:-t} \
      direction=${direction:-1} \
      find_level=${find_level:-} \
      deep=${deep:-t} \
      omni_search_stack=${omni_search_stack:-} \

    # debug_watch='from_log'
    # debug_start

    found_index= found_log=

    local cursor=s 

    new_log_file=$from_log \
      new_index=$from_index \
      omni_change_cursor_log || fail

    if [[ -v omni_search_stack && "$omni_search_stack" =~ \ $from_log\  ]]; then
      log_fatal "Infinite loop detected in omni_search, hit $from_log twice"
      fail1
    fi
    omni_search_stack+=" $from_log "

    eval "$omni_select_cursor" || fail

    local original_plane_id=${plane_map[$index]}
    local plane_id=$original_plane_id

    if [[ $skip_first == t ]]; then
      next_or_enter_log || fail
    fi

    local entry_matches
    begin_while (( index < plane_map_size && index >= 0 )); doo
      entry_matches=t
      if [[ $deep == f && $plane_id != $original_plane_id ]]; then
        entry_matches=f
      elif [[ "$find_level" ]]; then
        level=
        vars=level \
          omni_extract_vars || fail
        if [[ "${level:-}" && ! $level =~ $find_level ]]; then
          entry_matches=f
        fi
      fi
      if [[ $entry_matches == t ]]; then
        found_log=$from_log
        found_index=$index
        break
      elif [[ $deep == t && ${action_map[$index]} == log_to ]]; then

        vars=new_log_file \
          omni_extract_vars || fail

        if [[ -e "$new_log_file" ]]; then
          # recursive
          from_log=$new_log_file \
            from_index=0 \
            skip_first=f \
            omni_search || fail
          if [[ "$found_index" ]]; then
            break
          else
            new_log_file=$from_log \
              new_index=$index \
              omni_change_cursor_log || fail
          fi
        else
          log_error "Internal error: log points to non-existent file: $new_log_file"
        fi

      fi

      new_index=$((index + direction)) \
        omni_change_index || fail
    end_while

  end_function
  omni_search_stack=${omni_search_stack// $from_log /}
  handle_return
}

omni_next_error() {

from_log=$log_file \
  from_index=$index \
  skip_first=t \
  direction=1 \
  find_level='(error|fatal)' \
  omni_search || return 1

if [[ $found_index ]]; then
  if [[ $log_file != $found_log ]]; then
    new_log_file=$found_log \
      omni_change_cursor_log || return 1
  fi
  new_index=$found_index \
    omni_change_index || return 1
fi

return 0
}

# inputs: {index} {amount}
#   plane_id plane_map
omni_offset_index() {
  local -n current_index=$var
  local amount=$offset i adjusted=0 d=1

  if (( amount < 0 )); then
    d=-1
    (( amount = -amount ))
  fi

  for (( i = current_index + d;
         i >= 0 
         && adjusted < amount 
         && i < plane_map_size;
         i += d )); do
    if (( plane_map[i] == plane_id )); then
      current_index=$i
      (( adjusted++ ))
    fi
  done
  return 0
}

omni_show_call_stack() {
  local i=$index line \
    ts pid log_id depth level action function entries info
  local -A return_map
  local functions=
  begin_while (( i-- > 0 )); doo
    line=${log_array[$i]}
    if [[ "$line" == \=\ * ]]; then
      entries=${line#= }
      eval "$entries" || return 1
      if [[ "${action:-}" == call ]]; then
        if [[ ${return_map[$function]:-0} == 0 ]]; then
          functions+="$function$NL"
        else
          (( return_map[$function]-- ))
        fi
      elif [[ "${action:-}" == return\(* ]]; then
        if [[ "${return_map[$function]:-}" ]]; then
          (( return_map[$function]++ ))
        else
          return_map[$function]=1
        fi
      fi
    fi
  end_while
  if [[ "$functions" ]]; then
    echo "${functions%$NL}" | tac >&$fd_original_err
  else
    echo "Not inside of a function" >&$fd_original_err
  fi
  return 0
}

omni_show_log_stack() {
  local i size=0
  if [[ -v log_file_stack ]]; then
    size=${#log_file_stack[*]}
  fi
  if (( size > 0 )); then
    for (( i = 0; i < size; i++ )); do
      echo " ${log_file_stack[$i]}" >&$fd_original_err
    done
  fi
  echo " $log_file" >&$fd_original_err
  return 0
}

# inputs: 
#   log_file
omni_navigator() (
  # side_log "omni_navigator()
  # FUNCNAME[0]=${FUNCNAME[0]:-}
  # FUNCNAME[1]=${FUNCNAME[1]:-}
  # FUNCNAME[2]=${FUNCNAME[2]:-}
  # BASH_LINENO[0]=${BASH_LINENO[0]:-}
  # BASH_LINENO[1]=${BASH_LINENO[1]:-}
  # LINENO=${LINENO:-}
  # "

  begin_function_flat

    local cursor=a

    new_log_file=$log_file \
      omni_change_cursor_log || fail
    eval "$omni_select_cursor" || fail
    next_log_start=$index
    new_index=$index \
      omni_change_index || fail

    var=next_log_start offset=-$omni_list_radius \
      omni_offset_index || fail

    local debug_r=-1 no_follow_once
    begin_while [[ $debug_r == -1 ]]; doo

      if [[ ${no_follow_once:=f} == t ]]; then
        no_follow_once=f
      else
        omni_show_log || fail
      fi

      echo -n "${NL}${YELLOW}job_id=$log_job_id log_id=$log_fork_id:$index ${GREEN}omni-log-navigator> $RESET" >&$fd_original_err
      local debug_c
      read -rs -n1 debug_c <&$fd_original_in

      case "$debug_c" in
        b)
          echo "# Step back, until next function call" >&$fd_original_err
          local p=$index
          var=index offset=-1 match_action=call omni_offset_index || fail
          if [[ $p == $index ]]; then
            (( index-- ))
            if (( index < 0 )); then
              index=0
            fi
            plane_id=${plane_map[$index]}
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        c)
          echo "# Show context" >&$fd_original_err
          omni_show_context || fail
          no_follow_once=t
          ;;
        i)
          echo "# Step in, forwards" >&$fd_original_err
          omni_step_in || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        l)
          echo -n "$CLEAR_LINE" >&$fd_original_err
          echo -n "$CURSOR_UP$CLEAR_LINE" >&$fd_original_err
          omni_show_log || fail
          no_follow_once=t
          ;;
        L)
          echo -n "$CLEAR_SCREEN" >&$fd_original_err
          var=next_log_start offset=$((-omni_list_radius*4-2)) omni_offset_index || fail
          omni_show_log || fail
          no_follow_once=t
          ;;
        n)
          echo "# Step over, until function call" >&$fd_original_err
          local p=$index
          var=index offset=1 match_action=call omni_offset_index || fail
          if [[ $p == $index ]]; then
            (( index++ ))
            if (( index >= plane_map_size )); then
              (( index = plane_map_size - 1 ))
            fi
            plane_id=${plane_map[$index]}
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        o)
          echo "# Step out" >&$fd_original_err
          local i=$index base_depth=${plane_depth_map[$index]}
          begin_while (( ++i < plane_map_size )); doo
            if (( ${plane_depth_map[$i]} < base_depth )); then
              index=$i
              plane_id=${plane_map[$index]}
              break
            fi
          end_while
          omni_show_context || fail
          no_follow_once=t
          ;;
        p)
          echo "# Print details" >&$fd_original_err
          omni_print_details || fail
          no_follow_once=t
          ;;
        q)
          echo "# Quitting" >&$fd_original_err
          debug_r=0
          ;;
        s)
          echo "# Step over, until next entry" >&$fd_original_err
          local p=$index
          var=index offset=1 omni_offset_index || fail
          if [[ $p == $index ]]; then
            (( index++ ))
            if (( index >= plane_map_size )); then
              (( index = plane_map_size - 1 ))
            fi
            plane_id=${plane_map[$index]}
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        S)
          echo "# Entering debug shell" >&$fd_original_err
          set +u
          debug_shell
          set -u
          no_follow_once=t
          ;;
        t)
          echo "# Show call stack" >&$fd_original_err
          omni_show_call_stack || fail
          no_follow_once=t
          ;;
        T)
          echo "# Show log stack" >&$fd_original_err
          omni_show_log_stack || fail
          no_follow_once=t
          ;;
        \!)
          echo "# Jump to next error" >&$fd_original_err
          omni_next_error || fail
          ;;
        \?)
          echo >&$fd_original_err
          echo >&$fd_original_err
          echo "b  back: go to the previous log line of the same depth or shallower" >&$fd_original_err
          echo "c  list a few lines of logs before and after current line" >&$fd_original_err
          echo "i  step in: go to the next log line of the same depth or deeper" >&$fd_original_err
          echo "l  list next few log lines" >&$fd_original_err
          echo "L  list previous log lines" >&$fd_original_err
          echo "n  next: (step over) go to the next log line with a function call of the same depth or shallower" >&$fd_original_err
          echo "o  out: (step out) go to the next log line that is shallower" >&$fd_original_err
          echo "p  print: show all details of current log line" >&$fd_original_err
          echo "q  quit: leave the omni navigator" >&$fd_original_err
          echo "s  step: step to the next log line even if it's not a function call" >&$fd_original_err
          echo "t  stack: show call stack" >&$fd_original_err
          echo "T  stack: show log stack" >&$fd_original_err
          echo "!  go to next error" >&$fd_original_err
          no_follow_once=t
          ;;
        *)
          echo "# Unknown command" >&$fd_original_err
          echo "Press ? for a list of commands" >&$fd_original_err
          no_follow_once=t
          ;;
      esac
    end_while
  end_function_flat

  handle_return
)

omni_print_details() {
  local line=${log_array[$index]}
  if [[ "$line" == \=\ * ]]; then
    local ts pid log_id depth level action function entries info
    entries=${line#= }
    eval "$entries" || return 1

    local kvs=( ${entries} )
    local kv keys=
    for kv in "${kvs[@]}"; do
      keys+="${kv%%=*}$NL"
    done

    keys=$(echo "${keys[*]}" | sort)
    local key
    for key in $keys; do
      echo "$key: ${!key}" >&$fd_original_err
    done
  else
    echo "No further details available." >&$fd_original_err
  fi
  return 0
}

omni_show_context() {
  next_log_start=$index
  var=next_log_start offset=-$omni_list_radius omni_offset_index || return 1
  omni_show_log || return 1
  return 0
}

# inputs: {index}
#   output_array
omni_show_line() {
  local index=$1

  local reverse=f
  if (( index == cursor_a_log_array_index )); then
    reverse=t
  fi

  if [[ $reverse == t ]]; then
    echo -n "$REVERSE" >&$fd_original_err
  fi

  if [[ ! -v output_array ]]; then
    log_fatal "Internal error: Missing output_array"
    return 1
  fi

  local line=${output_array[$index]}

  if [[ $reverse == t ]]; then
    local pad_size line_length=${#line}
    (( pad_size = COLUMNS - line_length ))
    echo -n "$line" >&$fd_original_err
    printf %${pad_size}s >&$fd_original_err
    echo "$RESET" >&$fd_original_err
  else
    echo "$line" >&$fd_original_err
  fi

  return 0
}

