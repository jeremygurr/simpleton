#!/bin/bash

type -t omni_navigator_init >/dev/null && return 0

omni_navigator_init() {
  ansi=${ansi:-t}

  omni_var_filter=
  omni_list_radius=${omni_list_radius:-5}
  if [[ ! -v fd_original_in ]]; then
    exec {fd_original_in}<&0
    exec {fd_original_out}>&1
    exec {fd_original_err}>&2
    exec {fd_original_trace}>&${fd_trace:-2}
  fi

  go_until=${go_until:-}
}

# input:
#   log_file
# output:
#   log_file_id
#   log_file_token
get_log_file_token() {
  if [[ ! -f "$log_file" ]]; then
    log_fatal "Can't find log file: $log_file"
    return 1
  fi

  if [[ -L "$log_file" ]]; then
    log_file=$(realpath $log_file)
  fi

  log_file_id=${log_file%.olog}
  log_file_id=${log_file_id##*/}
  log_file_id=${log_file_id##*-}

  if [[ ! "$log_file_id" =~ ^[0-9:]+$ ]]; then
    log_fatal "Could not figure out log file id. Got [$log_file_id]"
    log_fatal "Maybe log file doesn't comply with convention: {path}/{log}-{job_id}:{fork_id}.olog"
    return 1
  fi

  log_file_token=${log_file_id//:/_}
  return 0
}

# input: {line}
#   line_id
omni_get_processed_line2() {
  local line=$1 log_id=$log_id var

  processed_line=
  apad processed_line log_id "$log_id " action "[$log_action] "
  case $log_action in
    call|return\(*)
      apad processed_line function "$log_function "
      for var in ${log_show_vars:-}; do
        local shorten=f real_var
        if [[ "$var" == ^* ]]; then
          real_var=${var#^}
          shorten=t
        else
          real_var=$var
        fi
        if [[ -v $real_var ]]; then
          local value=${!real_var}
          if [[ $shorten == t ]]; then
            auto_shorten value
          fi
          processed_line+="$var=$value "
        fi
      done
    ;;
    log_from)
      processed_line+="$old_log_file "
    ;;
    log_to)
      processed_line+="$new_log_file "
    ;;
    log_close)
      :
    ;;
    *)
      if [[ "${log_message:-}" ]]; then
        processed_line+="$log_message "
      else
        processed_line+="${line%$NL} "
      fi
    ;;
  esac

  for var in ${trace_vars:-}; do
    local shorten=f real_var
    if [[ "$var" == ^* ]]; then
      real_var=${var#^}
      shorten=t
    else
      real_var=$var
    fi
    if [[ -v $real_var ]]; then
      local value=${!real_var} changed=f adjusted
      if [[ "$value" != "${trace_var_value[$real_var]:-}" ]]; then
        changed=t
        processed_line+="$CYAN"
      fi
      adjusted=$value
      if [[ $shorten == t ]]; then
        auto_shorten adjusted
      fi
      processed_line+="$var=$adjusted "
      if [[ $changed == t ]]; then
        processed_line+="$RESET"
        trace_var_value[$real_var]=$value
      fi
    fi
  done

  processed_line=${processed_line% }

  return 0
}

# inputs:
#   index: where in the current log to extract the vars from
#   vars: space separated list of vars to extract from the given log line
# warning: if you localize a variable before calling this, that variable can't be set
#   by this function. Only global variables can be successfully set by this function.
#   This is because this function localizes all variables it uses, and then globalizes
#   the selected variable, which won't actually change an outer local version of the
#   variable, only the shared global version.
omni_extract_vars() {
  local log_vars='index vars' \
    index=$index
  begin_function

    local line=${log_array[$index]} \
      entries \
      entry \
      var \
      vars=$vars \
      value \

    vars=" $vars "
    if [[ "$line" =~ ^\=\  ]]; then
      set +u
      eval "entries=( ${line#= } )"
      set -u
      for entry in "${entries[@]}"; do
        var=${entry%%=*}
        if [[ "$vars" == *\ $var\ * ]]; then
          value=${entry#*=}
          shell_quote_var value
          eval "$var=$value"
          vars=${vars/$var /}
        fi
      done
    fi

  end_function
  handle_return
}

omni_get_processed_line() {
  local last_log_id=${last_log_id:-} \
    log_show_vars_2=${log_show_vars:-} \
    index=$index \
    override_vars=f

  begin_function_flat

    if [[ "$log_show_vars_2" ]]; then
      override_vars=t
    fi

    local trace_vars=

    vars='log_id log_action log_function log_message old_log_file 
          new_log_file log_show_vars trace_vars ts' \
      omni_extract_vars || fail
    if [[ ! "$log_show_vars_2" ]]; then
      log_show_vars_2=$log_show_vars
    fi

    if [[ "$log_id" ]]; then
      last_log_id=$log_id
    fi

    if [[ $log_action == none ]]; then
      log_fatal "Log line is missing log_action key: $line"
      fail1
    fi

    if [[ "${log_show_vars_2:-}" ]]; then
      local adjusted_vars=${log_show_vars_2//^/}
      eval "local $adjusted_vars"
      vars="$adjusted_vars" \
        omni_extract_vars || fail
    fi

    if [[ "$override_vars" == f && "${trace_vars:-}" ]]; then
      local adjusted_vars=${trace_vars//^/}
      eval "local $adjusted_vars"
      vars="$adjusted_vars" \
        omni_extract_vars || fail
    fi

    log_id=$last_log_id \
      log_show_vars=$log_show_vars_2 \
      trace_vars=$trace_vars \
      omni_get_processed_line2 "$line" || {
        log_fatal "Bad log line: $line"
        fail1
        }

  end_function
  handle_return
}

# inputs: 
#   log_file 
#   log_file_id 
#   log_file_token 
#   log_fork_id
omni_load_log_array() {
  local log_vars='log_file log_file_id log_file_token log_fork_id'
  begin_function

    eval "declare -ga omni_log_array_$log_file_token"
    local -n log_array=omni_log_array_$log_file_token
    readarray log_array < <(cat $log_file) || fail

    eval "
      declare -ga \
        omni_log_id_array_$log_file_token \
        omni_plane_map_$log_file_token \
        omni_plane_depth_map_$log_file_token \
        omni_action_map_$log_file_token \
        omni_time_map_$log_file_token \
      omni_log_file_$log_file_token=$log_file
      "

    local -n \
      log_id_array=omni_log_id_array_$log_file_token \
      plane_map=omni_plane_map_$log_file_token \
      plane_depth_map=omni_plane_depth_map_$log_file_token \
      action_map=omni_action_map_$log_file_token \
      output_array=omni_log_output_array_$log_file_token \
      time_map=omni_time_map_$log_file_token \

    local i array_size=${#log_array[*]} \
      plane_stack next_plane_id=1 plane_id=0 \
      processed_line line last_log_id= \
      log_fork_id=${log_file_id#*:} \
      log_action log_function log_message old_log_file new_log_file log_id

    begin_for (( i = 0; i < array_size; i++ )); doo

      line=${log_array[$i]} log_action=none processed_line=
      log_function= log_message= old_log_file= new_log_file= log_show_vars= \
        log_show_vars_2= log_id= trace_vars= ts=

      line=${line//$CR/}
      if [[ "$line" =~ $ESC ]]; then
        ansi_filter_var line
        log_array[$i]=$line
      fi

      if [[ "$line" =~ ^\=\  ]]; then
        index=$i \
          omni_get_processed_line || fail
      else
        if [[ "$line" == +* ]]; then
          line=${line#*(+) }
          line="+ $line"
        fi
        action_map[$i]=debug
        log_action=debug
        apad processed_line log_id "$last_log_id " action "[debug] "
        processed_line+="$line"
      fi 

      log_id_array[$i]=$last_log_id
      output_array[$i]=$processed_line
      action_map[$i]=$log_action
      time_map[$i]=$ts

      case $log_action in
        call)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
          plane_stack+=( $plane_id )
          (( plane_id = next_plane_id++ ))
        ;;
        return\(*)
          if [[ -v plane_stack && ${#plane_stack[*]} -gt 0 ]]; then
            if [[ ${#plane_stack[*]} -gt 0 ]]; then
              (( plane_id = plane_stack[-1] ))
              unset plane_stack[-1]
            else
              plane_id=0
            fi
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_id=0
            plane_depth_map[$i]=0
          fi
          plane_map[$i]=$plane_id
        ;;
        *)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
        ;;
      esac

    end_for

    log_array_size=${#log_array[*]}
  
  end_function
  handle_return
}

update_cursor_vars() {
  local -n \
    log_file_id=cursor_${cursor}_log_file_id \
    log_array=cursor_${cursor}_log_array \

  log_fork_id=${log_file_id#*:} \
  log_job_id=${log_file_id%:*} \
  log_array_size=${#log_array[*]} 
}

# inputs:
#   new_cursor
# should be evaluated after omni_change_cursor_log has selected a log for this cursor
omni_select_cursor() {
  if [[ "$new_cursor" != "${last_cursor_selected:-}" ]]; then
    cursor=$new_cursor
    last_cursor_selected=$new_cursor
    declare -gn \
      action_map=cursor_${cursor}_action_map \
      time_map=cursor_${cursor}_time_map \
      log_array_index=cursor_${cursor}_log_array_index \
      log_array=cursor_${cursor}_log_array \
      log_id_array=cursor_${cursor}_log_id_array \
      log_file=cursor_${cursor}_log_file \
      log_file_id=cursor_${cursor}_log_file_id \
      output_array=cursor_${cursor}_output_array \
      plane_depth_map=cursor_${cursor}_plane_depth_map \
      plane_map=cursor_${cursor}_plane_map \
      plane_stack_map=cursor_${cursor}_plane_stack_map \
      log_file_stack=cursor_${cursor}_log_file_stack \
      log_file_pos_stack=cursor_${cursor}_log_file_pos_stack \
      function_call_stack=cursor_${cursor}_function_call_stack \
      time_stack=cursor_${cursor}_time_stack \

    update_cursor_vars || return 1
  fi

  return 0
}

# inputs:
#   cursor 
#   new_log_file
# NOTE: This does not update function_call_stack or log_file_pos_stack or log_file_stack
#   you'll need to either manually update these or use the omni_enter_sub_log / omni_exit_sub_log
#   functions to manage it automatically. 
omni_change_cursor_log() {
  if [[ ! "${cursor:-}" ]]; then
    log_fatal "Missing cursor"
    return 1
  fi

  if [[ ! "${new_log_file:-}" ]]; then
    log_fatal "Missing new_log_file"
    return 1
  fi

  local log_vars='cursor new_log_file'
  begin_function

    eval "local old_log_file=\${cursor_${cursor}_log_file:-}"
    if [[ "$old_log_file" != "$new_log_file" ]]; then

      local log_file=$new_log_file

      get_log_file_token || fail
      eval "old_log_file=\${omni_log_file_$log_file_token:-}"

      if [[ "${old_log_file:-}" && $old_log_file != $log_file ]]; then
        log_fatal "Two different logs have the same log_file_token (same fork_id):"
        log_fatal "$old_log_file != $log_file"
        fail1
      fi

      eval "
        cursor_${cursor}_log_file=$log_file \
        cursor_${cursor}_log_file_id=$log_file_id \
        cursor_${cursor}_log_array_index=0 \
      "
      eval "
        declare -gn \
          cursor_${cursor}_log_id_array=omni_log_id_array_$log_file_token \
          cursor_${cursor}_action_map=omni_action_map_$log_file_token \
          cursor_${cursor}_time_map=omni_time_map_$log_file_token \
          cursor_${cursor}_output_array=omni_log_output_array_$log_file_token \
          cursor_${cursor}_plane_depth_map=omni_plane_depth_map_$log_file_token \
          cursor_${cursor}_plane_map=omni_plane_map_$log_file_token \
          cursor_${cursor}_plane_stack_map=omni_plane_stack_map_$log_file_token \
      "

      if [[ ! -v omni_log_array_$log_file_token ]]; then
        omni_load_log_array || fail
      fi

      eval "declare -gn cursor_${cursor}_log_array=omni_log_array_$log_file_token"

      update_cursor_vars || return 1

    fi

  end_function
  handle_return
}

# inputs:
#   new_log_file
#   new_index
omni_enter_sub_log() {
  local new_index=${new_index:-0}
  local log_show_vars="new_index log_file"
  begin_function
    log_file_stack+=( $log_file )
    log_file_pos_stack+=( $log_array_index )
    omni_change_cursor_log || fail
    if [[ $new_index == -1 ]]; then
      (( new_index = log_array_size - 1 ))
    fi
    log_array_index=$new_index
  end_function
  handle_return
}

# inputs:
#   direction
omni_exit_sub_log() {
  local direction=${direction:-0}

  local log_show_vars="direction log_file index"
  begin_function
    if (( ${#log_file_stack[*]} == 0 )); then
      log_warn "Internal error: attempted omni_exit_sub_log when log_file_stack size is 0"
    else

      local parent_log_file=${log_file_stack[-1]}
      unset log_file_stack[-1]

      local parent_pos=${log_file_pos_stack[-1]}
      unset log_file_pos_stack[-1]

    fi

    new_log_file=$parent_log_file \
      omni_change_cursor_log || fail
    (( log_array_index = parent_pos + direction ))

    if (( log_array_index < 0 || log_array_index >= log_array_size )); then
      if (( ${#log_file_stack[*]} > 0 )); then
        omni_exit_sub_log || fail
      else
        if (( log_array_index < 0 )); then
          log_array_index=0
          went_out_of_bounds=t
        elif (( log_array_index >= log_array_size )); then
          (( log_array_index = log_array_size - 1 ))
          went_out_of_bounds=t
        fi
      fi
    fi

  end_function
  handle_return
}

abbreviate_ts() {
  local -n from=$1 to=$2
  to=${from//./}
  local skip=${to%?????????}
  to=${to#$skip}
  to=${to%???}
  to=${to%???}.${to#???}
}

# inputs: 
#   cursor
#   reverse_index: (optional)  which line to show in reverse
#   index: (optional)          overrides the cursor index
omni_show_line() {
  local reverse_index=${reverse_index:-} \
    cursor=$cursor \
    index=${index:-} \
    out_to_var=${out_to_var:-} \
    result= \
    pad \

  local -n output_array=cursor_${cursor}_output_array

  if [[ ! "$index" ]]; then
    eval "index=\$cursor_${cursor}_log_array_index"
  fi

  local reverse=f
  if [[ "$reverse_index" ]] && (( reverse_index == index )); then
    reverse=t
  fi

  if [[ $reverse == t ]]; then
    result+="$REVERSE"
  fi

  local line

  if [[ "$omni_var_filter" ]]; then
    line=${log_array[$index]} \
      log_show_vars=$omni_var_filter \
      last_log_id= \
      index=$index \
      omni_get_processed_line || fail
    line=$processed_line
  else
    if [[ ! -v output_array ]]; then
      log_fatal "Internal error: Missing output_array"
      return 1
    fi
    line=${output_array[$index]}
  fi

  if [[ "${omni_show_time:-}" == t ]]; then
    local ts=
    vars=ts \
      omni_extract_vars || fail

    local ts_start
    abbreviate_ts ts ts_start

    local new_line
    apad new_line ts_start "$ts_start"

    if [[ ! "$omni_prev_timestamp" && "${time_stack:-}" ]]; then
      omni_prev_timestamp=${time_stack[-1]}
      abbreviate_ts omni_prev_timestamp omni_prev_timestamp
    fi

    local ts_duration
    if [[ "$omni_prev_timestamp" ]]; then
      ts_duration=$(dc -e "3k $ts_start $omni_prev_timestamp - p")
      apad new_line ts_duration " +$ts_duration"
    else
      apad new_line ts_duration " "
    fi

    line="$new_line $line"
    omni_prev_timestamp=$ts_start
  fi

  line=${line//$NL/ }
  line=${line//$TAB/ }

  local pad_size line_length=${#line}
  (( pad_size = COLUMNS - line_length ))

  if (( ${#line} > $COLUMNS )); then
    line=${line:0:$((COLUMNS-3))}$RESET..
  fi
  
  if [[ $reverse == t ]]; then
    debug_start
    result+="$line"
    if (( pad_size > 0 )); then
      printf -v pad %${pad_size}s
      result+="$pad"
    fi
    result+="$RESET"
  else
    result+="$line"
  fi

  if [[ "$out_to_var" ]]; then
    eval "$out_to_var=\"\$result\$NL\""
  else
    echo "$result" >&$fd_original_err
  fi

  return 0
}

push_to_function_stack() {
  local index=$1
  local entry=${output_array[$index]} \
    lid
  lid=${entry%% *}
  entry=${entry#* * }
  function_call_stack+=( "$lid $entry" )
  time_stack+=( "${time_map[$index]}" )
}

pop_function_stack() {
  unset function_call_stack[-1]
  if [[ "${time_stack:-}" ]]; then
    unset time_stack[-1]
  fi
}

# Move to the next log line to search
# This is meant to be able to move past the boundaries if there are no other possibilities
omni_search_next() {
  local log_show_vars="log_file index direction"
  begin_function

    local original_index=$index \
      original_log=$log_file
    went_out_of_bounds=f

    if [[ ${action_map[$index]} == log_to && $allow_in_log == t ]]; then

      local new_index=0
      if [[ $direction == -1 ]]; then
        new_index=-1
      fi
      vars=new_log_file \
        omni_extract_vars || fail
      omni_enter_sub_log || fail

    else

      local pre_action= post_action=

      if (( index >= 0 && index < log_array_size )) \
         && [[ -v action_map[$index] ]]; then
        pre_action=${action_map[$index]}
      fi
      (( index += direction ))
      if (( index >= 0 && index < log_array_size )) \
         && [[ -v action_map[$index] ]]; then
        post_action=${action_map[$index]}
      fi

      if [[ $direction == 1 ]]; then

        if [[ "$pre_action" == call ]]; then
          push_to_function_stack $(( index - 1 )) || fail
        fi

        if [[ "$post_action" == return\(* && -v function_call_stack && ${#function_call_stack[*]} -gt 0 ]]; then
          pop_function_stack
        fi

      fi

      if [[ $direction == -1 ]]; then

        if [[ "$post_action" == call && -v function_call_stack && ${#function_call_stack[*]} -gt 0 ]]; then
          pop_function_stack
        fi

        if [[ "$pre_action" == return\(* ]]; then
          push_to_function_stack $((index + 1 )) || fail
        fi

      fi

      if (( index >= log_array_size || index < 0 )); then
        # out of bounds
        if [[ $direction == 1 ]]; then
          if [[ $allow_out_log == t && -v log_file_stack ]] && (( ${#log_file_stack[*]} > 0 )); then
            omni_exit_sub_log || fail
          else
            (( index = log_array_size - 1 ))
            went_out_of_bounds=t
          fi
        elif [[ $direction == -1 ]]; then
          if [[ $allow_out_log == t && -v log_file_stack ]] && (( ${#log_file_stack[*]} > 0 )); then
            omni_exit_sub_log || fail
          else
            index=0
            went_out_of_bounds=t
          fi
        else
          log_fatal "omni_search_next: invalid direction: $direction"
          fail1
        fi
      fi

    fi

    if [[ $original_index == $index 
       && $original_log == $log_file 
       ]]; then
      failed_to_move=t
    else
      failed_to_move=f
    fi

  end_function
  handle_return
}

omni_search_get_matches() {

  local plane_id=${plane_map[$index]} 
  local plane_depth=${plane_depth_map[$index]}
  local log_string=${log_array[$index]}

  if [[ "$log_file" == "$original_log_file" ]]; then
    if [[ $allow_in == f ]] \
       && (( plane_depth > original_plane_depth )); then
      found_matching_line=f
    elif [[ $allow_out == f ]] \
       && (( plane_depth < original_plane_depth )); then
      found_matching_line=f
    elif [[ $allow_flat == f ]] \
       && (( plane_depth == original_plane_depth )); then
      found_matching_line=f
    elif [[ $allow_same_plane == f ]] \
       && (( plane_id == original_plane_id )); then
      found_matching_line=f
    elif [[ $allow_diff_plane == f ]] \
       && (( plane_id != original_plane_id )); then
      found_matching_line=f
    fi
  fi

  if [[ $found_matching_line == t \
     && ( "$find_level" || "$find_action" \
        || "$find_log_id" || "$find_function" \
        || "$find_substring" || "$find_regex" \
        ) \
     ]]; then
    local log_level log_action log_id log_function
    found_matching_line=f

    if [[ $found_matching_line == f && "$find_level" ]]; then
      log_level=
      vars=log_level \
        omni_extract_vars || fail
      if [[ "${log_level:-}" && $log_level =~ $find_level ]]; then
        found_matching_line=t
      fi
    fi

    if [[ $found_matching_line == f && "$find_action" ]]; then
      log_action=${action_map[$index]}
      if [[ "${log_action:-}" && $log_action =~ $find_action ]]; then
        found_matching_line=t
      fi
    fi

    if [[ $found_matching_line == f && "$find_log_id" ]]; then
      log_id=
      vars=log_id \
        omni_extract_vars || fail
      if [[ "${log_id:-}" && $log_id =~ $find_log_id ]]; then
        found_matching_line=t
      fi
    fi

    if [[ $found_matching_line == f && "$find_function" ]]; then
      log_function=
      vars=log_function \
        omni_extract_vars || fail
      if [[ "${log_function:-}" && $log_function =~ $find_function ]]; then
        found_matching_line=t
      fi
    fi

    if [[ $found_matching_line == f && "$find_substring" ]]; then
      local sub=${find_substring// /\\ /}
      if [[ "$log_string" == *$sub* ]]; then
        found_matching_line=t
      fi
    fi

    if [[ $found_matching_line == f && "$find_regex" ]]; then
      local find_regex=$find_regex
      escape_regex find_regex
      if [[ "$log_string" =~ $find_regex ]]; then
        found_matching_line=t
      fi
    fi

  fi
}

omni_copy_cursor() {
  local from=$1 to=$2

  local log_show_vars="from to"
  begin_function

    if [[ $from != $to ]]; then
      local -n \
        from_log_file=cursor_${from}_log_file \
        to_log_index=cursor_${to}_log_array_index \
        from_log_index=cursor_${from}_log_array_index \
        from_log_file_stack=cursor_${from}_log_file_stack \
        from_log_file_pos_stack=cursor_${from}_log_file_pos_stack \
        from_function_call_stack=cursor_${from}_function_call_stack \
        to_log_file_stack=cursor_${to}_log_file_stack \
        to_log_file_pos_stack=cursor_${to}_log_file_pos_stack \
        to_function_call_stack=cursor_${to}_function_call_stack \

      new_log_file=$from_log_file \
        cursor=$to \
        omni_change_cursor_log || fail

      to_log_index=$from_log_index

      to_log_file_stack=( "${from_log_file_stack[@]}" )
      to_log_file_pos_stack=( "${from_log_file_pos_stack[@]}" )
      to_function_call_stack=( "${from_function_call_stack[@]}" )
    fi

  end_function
  handle_return
}

# will move the cursor according to the parameters given
# inputs
#   count=1           set to inf for unlimited matches
#   each_match=       function to execute each time a match is found
#   from_cursor=      cursor to copy to move_cursor. Determines starting point of search
#   move_cursosr=s    which cursor is changed in the process
omni_search() {
  local log_vars='from_log from_index move_cursor count deep'
  begin_function

    local \
      from_cursor=${from_cursor:-} \
      original_cursor=${cursor:-} \
      move_cursor=${move_cursor:-s} \
      each_match=${each_match:-} \
      find_level=${find_level:-} \
      find_action=${find_action:-} \
      find_log_id=${find_log_id:-} \
      find_function=${find_function:-} \
      find_substring=${find_substring:-} \
      find_regex=${find_regex:-} \
      allow_in=${allow_in:-f} \
      allow_out=${allow_out:-f} \
      allow_in_log=${allow_in_log:-f} \
      allow_out_log=${allow_out_log:-f} \
      allow_flat=${allow_flat:-f} \
      allow_same_plane=${allow_same_plane:-f} \
      allow_diff_plane=${allow_diff_plane:-f} \
      allow_all=${allow_all:-f} \
      allow_all_in_same_log=${allow_all_in_same_log:-f} \
      count=${count:-1} 
    local -n log_file=cursor_${move_cursor}_log_file

    # implications
    if [[ $allow_all == t ]]; then
      allow_in=t         \
      allow_out=t        \
      allow_in_log=t     \
      allow_out_log=t    \
      allow_flat=t       \
      allow_same_plane=t \
      allow_diff_plane=t 
    elif [[ $allow_all_in_same_log == t ]]; then
      allow_in=t         \
      allow_out=t        \
      allow_flat=t       \
      allow_same_plane=t \
      allow_diff_plane=t 
    else 
      if [[ $allow_same_plane == t ]]; then
        allow_flat=t
      fi
      if [[ $allow_out     == t || $allow_in     == t \
         || $allow_out_log == t || $allow_in_log == t \
         ]]; then
        allow_diff_plane=t
      fi
    fi

    local direction count_is_infinite=f
    if [[ "$count" == inf ]]; then
      direction=1 \
      count_is_infinite=t
    elif [[ "$count" == -inf ]]; then
      direction=-1 \
      count_is_infinite=t
    elif (( count < 0 )); then
      direction=-1
    elif (( count > 0 )); then
      direction=1
    else
      log_fatal "Invalid count=$count"
    fi

    cursor_moved=0

    if [[ "$from_cursor" ]]; then
      omni_copy_cursor $from_cursor $move_cursor || fail
    fi

    new_cursor=$move_cursor \
      omni_select_cursor || fail

    local -n index=log_array_index

    local original_plane_id=${plane_map[$index]} \
      original_plane_depth=${plane_depth_map[$index]} \
      original_log_file=$log_file \

    local plane_id=$original_plane_id \
      found_matching_line=t \
      restore_backup=f \
      lid \
      visited=() \
      visited_backup=()

    begin_loop

      # infinite loop detection
      lid=$log_file:$index
      if [[ " ${visited[*]} " =~ \ $lid\  ]]; then
        log_fatal "Infinite loop detected in omni_search"
        fail1
      fi
      visited+=( $lid )

      if [[ $found_matching_line == t ]]; then
        omni_copy_cursor $cursor backup
        visited_backup=( "${visited[@]}" )
      fi

      local went_out_of_bounds failed_to_move
      omni_search_next || fail

      if [[ $failed_to_move == t || $went_out_of_bounds == t ]]; then
        break
      fi

      found_matching_line=t
      omni_search_get_matches || fail
      
      if [[ $found_matching_line == t ]]; then

        (( cursor_moved += direction ))
        if [[ $count_is_infinite == f ]]; then
          (( count -= direction ))
        fi
        restore_backup=f

        if [[ "$each_match" ]]; then
          eval "$each_match" || fail
        fi

        if [[ $count == 0 ]]; then
          break
        fi

      else
        restore_backup=t
      fi

    end_loop

    if [[ $restore_backup == t ]]; then
      omni_copy_cursor backup $cursor || fail
      visited=( "${visited_backup[@]}" )
    fi

    # restore original cursor
    if [[ "$original_cursor" ]]; then
      new_cursor=$original_cursor \
        omni_select_cursor || fail
    fi

  end_function
  handle_return
}

# inputs: 
#   next_log_start  (relative to current index)
#   max_count
#   plane_map
#   output_array
omni_show_log() {

  begin_function_flat

    # display lines until end
    local remaining_lines=$max_count
    local offset=$next_log_start

    # get cursor to correct starting point
    local cursor_moved=0

    count=$offset \
      from_cursor=$cursor \
      allow_same_plane=t \
      omni_search || fail

    next_log_start=$cursor_moved
    local entries= buf= omni_prev_timestamp=

    begin_while (( remaining_lines-- > 0 )); doo

      cursor=s \
        reverse_index=$log_array_index \
        out_to_var=buf \
        index= \
        omni_show_line || fail
      entries+=$buf

      allow_same_plane=t \
        omni_search || fail
      if [[ $cursor_moved == 0 ]]; then
        break
      fi

      (( next_log_start++ ))
        
    end_while

    echo -n "$entries" >&$fd_original_err

  end_function
  handle_return
}

omni_show_call_stack() {
  if [[ -v function_call_stack && ${#function_call_stack[*]} -gt 0 ]]; then
    local i=$log_array_index
    local stack_size=${#function_call_stack[*]}

    if (( stack_size > 0 )); then
      for (( i = 0; i < stack_size; i++ )); do
        echo " ${function_call_stack[$i]}" >&$fd_original_err
      done
    else
      echo "Not inside of a function" >&$fd_original_err
    fi
  else
    echo "Not inside of a function" >&$fd_original_err
  fi

  return 0
}

omni_show_log_stack() {
  local i size=0
  if [[ -v log_file_stack ]]; then
    size=${#log_file_stack[*]}
  fi
  if (( size > 0 )); then
    for (( i = 0; i < size; i++ )); do
      echo " ${log_file_stack[$i]}" >&$fd_original_err
    done
  fi
  echo " $log_file" >&$fd_original_err
  return 0
}

omni_show_source() {
  local log_function log_source_file log_source_line
  index=$log_array_index \
  vars='log_function log_source log_source_caller' \
    omni_extract_vars || return 1

  local log_source_file=${log_source%:*} \
    log_source_line=${log_source#*:} \
    log_source_caller_file=${log_source_caller%:*} \
    log_source_caller_line=${log_source_caller#*:} \

  local debug_list_window=10
  debug_path_to_source_file=$log_source_caller_file \
    raw_debug_path_to_source_file=$log_source_caller_file \
    debug_list_offset=$((-debug_list_window/2+1)) \
    debug_line_num=$log_source_caller_line \
    debug_display_source
  echo "===========================================================================" >&$fd_original_err
  debug_path_to_source_file=$log_source_file \
    raw_debug_path_to_source_file=$log_source_file \
    debug_list_offset=$((-debug_list_window/2+1)) \
    debug_line_num=$log_source_line \
    debug_display_source

  return 0
}

omni_show_debug_command() {
  local record folder log_source_file log_source_line

  index=$log_array_index \
    vars='log_source log_source_caller' \
    omni_extract_vars || fail

  local log_source_file=${log_source%:*} \
    log_source_line=${log_source#*:} \
    log_source_caller_file=${log_source_caller%:*} \
    log_source_caller_line=${log_source_caller#*:} \

  echo " source: $log_source_caller_file:$log_source_caller_line -> $log_source_file:$log_source_line" >&$fd_original_err

  if [[ ! -v log_job_id ]]; then
    log_fatal "Missing log_job_id"
    return 1
  fi
  if [[ -v job_id_log ]]; then
    if [[ -f $job_id_log ]]; then
      record=$(cat $job_id_log | grep "^$log_job_id ")
      record=${record#* }
      folder=${record%% *}
      echo " cell=$folder" >&$fd_original_err
      record=${record#* }
      echo " cell $record log_id=$log_id" >&$fd_original_err
    else
      log_fatal "file doesn't exist for job_id_log: $job_id_log"
      return 1
    fi
  else
    log_fatal "Missing job_id_log"
    return 1
  fi

  return 0
}

format_ts() {
  value=$1
  local nice_date=$(date -d @$value)
  value="$value ($nice_date)"
}

omni_print_details() {
  local line=${log_array[$log_array_index]}

  echo "log file: $log_file" >&$fd_original_err
  echo "fork_id: $log_fork_id" >&$fd_original_err
  echo "line: $((log_array_index + 1))" >&$fd_original_err

  if [[ "$line" =~ ^\=\  ]]; then
    local entries kv key value extra quoted_value
    local -A count
    eval "entries=( ${line#= } )"

    for kv in "${entries[@]}"; do
      if [[ "$kv" == *=* ]]; then
        key="${kv%%=*}"
        value="${kv#*=}"
        shell_quote_var value

        if [[ -v count[$key] ]]; then
          (( count[$key]++ ))
          extra=" (${count[$key]})"
        else
          count[$key]=1
          extra=
        fi

        local format_function=format_$key
        if type -t $format_function &>/dev/null; then
          $format_function "$value"
        fi

        if [[ $value =~ \\n ]]; then
          value=${value//\\n/$NL}
        fi

        echo "$key$extra: $value" >&$fd_original_err
      fi
    done

  else
    echo "Raw text, bytes ${#line}" >&$fd_original_err
    echo "$line" >&$fd_original_err
  fi
  return 0
}

omni_go_until() {

  local find_log_id find_function
  if [[ "$go_until" =~ ^[0-9:]+$ ]]; then
    find_log_id=$go_until
  else
    find_function=$go_until
  fi
  move_cursor=$cursor \
    allow_all=t \
    omni_search || return 1
  return 0
}

omni_show_context() {
  (( next_log_start = -omni_list_radius ))
  max_count=$max_log_lines \
    omni_show_log
}

# inputs: 
#   log_file
omni_navigator() (
  begin_function_flat

    apad_min[log_id]=6 apad_max[log_id]=12
    apad_min[action]=16 apad_max[action]=20
    apad_min[function]=24 apad_max[function]=40
    apad_min[ts_start]=6 apad_max[ts_start]=6
    apad_min[ts_duration]=8 apad_max[ts_duration]=8

    local cursor=

    new_log_file=$log_file \
      cursor=a \
      omni_change_cursor_log || fail
    new_cursor=a \
      omni_select_cursor || fail
    (( next_log_start = -omni_list_radius ))
    log_array_index=0
    local -n log_file=cursor_${cursor}_log_file

    local debug_r=-1 no_follow_once max_log_lines
    (( max_log_lines = omni_list_radius * 2 + 1 ))

    if [[ "${go_until:-}" ]]; then
      omni_go_until "$go_until" 
    fi

    begin_while [[ $debug_r == -1 ]]; doo

      if [[ ${no_follow_once:=f} == t ]]; then
        no_follow_once=f
      else
        max_count=$max_log_lines \
          omni_show_log || fail
      fi

      echo "$NL${LIGHT_BLUE}log: $log_file" >&$fd_original_err
      if [[ -v function_call_stack && ${#function_call_stack[*]} -gt 0 ]]; then
        local function=$(echo "${function_call_stack[-1]}" | awk '{print $3 " " $4 " " $5 " " $6 " " $7}')
        echo "${LIGHT_BLUE}function: $function" >&$fd_original_err
      fi
      echo -n "$RESET"

      local log_id=${log_id_array[$log_array_index]}
      echo -n "${YELLOW}job_id=$log_job_id log_id=$log_id line=$((log_array_index+1)) ${GREEN}omni-log-navigator> $RESET" >&$fd_original_err
      local debug_c
      read -rs -n1 debug_c <&$fd_original_in

      case "$debug_c" in
        b)
          echo "# Step back, until next function call" >&$fd_original_err
          move_cursor=$cursor \
            count=-1 \
            allow_out=t \
            allow_out_log=t \
            allow_same_plane=t \
            find_level=trace \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        c)
          echo "# Show context" >&$fd_original_err
          omni_show_context || fail
          no_follow_once=t
          ;;
        f)
          if [[ "$omni_prev_go_to_string" ]]; then
            echo "# Searching for $omni_prev_go_to_string" >&$fd_original_err
            local go_to_string=$omni_prev_go_to_string
            local find_substring find_regex
            if [[ "$go_to_string" == ~* ]]; then
              find_regex=${go_to_string#\~}
              find_substring=
            else
              find_substring=$go_to_string
              find_regex=
            fi

            local cursor_moved=0
            move_cursor=$cursor \
              allow_all=t \
              omni_search || fail

            find_substring= find_regex=

            no_follow_once=t
            if (( cursor_moved == 0 )); then
              echo "Not found" >&$fd_original_err
            else
              omni_show_context || fail
            fi

          else
            echo "# No previous search" >&$fd_original_err
          fi
          ;;
        g)
          echo >&$fd_original_err
          local go_until= find_log_id= find_function=
          read -e -p "Go until function / log_id: " go_until <&$fd_original_in >&$fd_original_err
          if [[ "${go_until:-}" ]]; then
            omni_prev_go_until=$go_until
            omni_go_until "$go_until" || fail
            omni_show_context || fail
            no_follow_once=t
          fi
          ;;
        G)
          echo >&$fd_original_err
          local go_until= find_log_id= find_function=
          if [[ "${omni_prev_go_until:-}" ]]; then
            go_until=omni_prev_go_until
            omni_go_until "$go_until" || fail
            omni_show_context || fail
            no_follow_once=t
          fi
          ;;
        i)
          echo "# Step in, forwards" >&$fd_original_err
          move_cursor=$cursor \
            allow_all=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        I)
          echo "# Step in, backwards" >&$fd_original_err
          move_cursor=$cursor \
            allow_all=t \
            count=-1 \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        l)
          echo -n "$CLEAR_LINE" >&$fd_original_err
          echo -n "$CURSOR_UP$CLEAR_LINE" >&$fd_original_err
          max_count=$max_log_lines \
            omni_show_log || fail
          no_follow_once=t
          ;;
        L)
          echo -n "$CLEAR_SCREEN" >&$fd_original_err
          (( next_log_start -= omni_list_radius * 4 - 2 )) 
          max_count=$max_log_lines \
            omni_show_log || fail
          no_follow_once=t
          ;;
        n)
          echo "# Step over, until function call" >&$fd_original_err
          move_cursor=$cursor \
            find_level=trace \
            allow_out=t \
            allow_out_log=t \
            allow_same_plane=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        o)
          echo "# Step out" >&$fd_original_err
          move_cursor=$cursor \
            allow_out=t \
            allow_out_log=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        O)
          echo "# Backwards step out" >&$fd_original_err
          move_cursor=$cursor \
            count=-1 \
            allow_out=t \
            allow_out_log=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        p)
          echo "# Print details" >&$fd_original_err
          omni_print_details || fail
          no_follow_once=t
          ;;
        q)
          echo "# Quitting" >&$fd_original_err
          debug_r=0
          ;;
        s)
          echo "# Step over, until next entry" >&$fd_original_err
          move_cursor=$cursor \
            allow_out=t \
            allow_out_log=t \
            allow_same_plane=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        S)
          echo "# Step over backwards, until next entry" >&$fd_original_err
          move_cursor=$cursor \
            allow_out=t \
            allow_out_log=t \
            allow_same_plane=t \
            count=-1 \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        t)
          echo "# Show call stack" >&$fd_original_err
          omni_show_call_stack || fail
          no_follow_once=t
          ;;
        T)
          echo "# Show log stack" >&$fd_original_err
          omni_show_log_stack || fail
          no_follow_once=t
          ;;
        v)
          if [[ "$omni_var_filter" ]]; then
            echo "# Disabling var filter" >&$fd_original_err
            omni_var_filter_prev=$omni_var_filter
            omni_var_filter=
            omni_show_context || fail
          else
            if [[ "$omni_var_filter_prev" ]]; then
              omni_var_filter=$omni_var_filter_prev
              echo "# Enabling var filter: $omni_var_filter" >&$fd_original_err
              omni_show_context || fail
            else
              echo "# No previous var filter defined. Use V to define one." >&$fd_original_err
            fi
          fi
          no_follow_once=t
          ;;
        V)
          echo >&$fd_original_err
          local omni_var_filter=
          read -e -p "Var filter: " omni_var_filter <&$fd_original_in >&$fd_original_err
          omni_show_context || fail
          no_follow_once=t
          ;;
        \!)
          echo "# Jump to next error" >&$fd_original_err
          local cursor_moved=0
          move_cursor=$cursor \
            find_level='(error|fatal)' \
            find_action='return\([^0].*\)' \
            allow_all=t \
            omni_search || return 1
          if (( cursor_moved == 0 )); then
            echo "No errors found." >&$fd_original_err
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        @)
          echo "# Show debug command" >&$fd_original_err
          omni_show_debug_command || fail
          no_follow_once=t
          ;;
        \#)
          echo "# Show source" >&$fd_original_err
          omni_show_source || fail
          no_follow_once=t
          ;;
        \$)
          echo "# Entering debug shell" >&$fd_original_err
          set +u
          debug_shell
          set -u
          no_follow_once=t
          ;;
        %)
          if [[ "${omni_show_time:-f}" == t ]]; then
            echo "# Disabling time info" >&$fd_original_err
            omni_show_time=f
          else
            echo "# Enabling time info" >&$fd_original_err
            omni_show_time=t
            omni_prev_timestamp=
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        ^)
          echo "# Jump to next log file change" >&$fd_original_err
          local cursor_moved=0
          move_cursor=$cursor \
            find_action=log_to \
            allow_all=t \
            omni_search || return 1
          if (( cursor_moved == 0 )); then
            echo "No log changes found." >&$fd_original_err
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        \[)
          echo "# Go to the first line in same plane" >&$fd_original_err
          move_cursor=$cursor \
            count=-inf \
            allow_same_plane=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        \])
          echo "# Go to the last line in same plane" >&$fd_original_err
          move_cursor=$cursor \
            count=inf \
            allow_same_plane=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        \{)
          echo "# Go to the first line in the log" >&$fd_original_err
          move_cursor=$cursor \
            count=-inf \
            allow_all_in_same_log=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        \})
          echo "# Go to the last line in the log" >&$fd_original_err
          move_cursor=$cursor \
            count=inf \
            allow_all_in_same_log=t \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        ,)
          echo >&$fd_original_err
          read -er -p "Search for substring: " omni_prev_grep_string <&$fd_original_in >&$fd_original_err
          if [[ "${omni_prev_grep_string:-}" ]]; then
            local find_substring find_regex
            if [[ "$omni_prev_grep_string" == ~* ]]; then
              find_regex=${omni_prev_grep_string#\~}
              find_substring=
            else
              find_substring=$omni_prev_grep_string
              find_regex=
            fi

            local omni_prev_timestamp= cursor_moved=0
            from_cursor=$cursor \
              allow_all=t \
              each_match='cursor=s omni_show_line' \
              count=inf \
              omni_search || fail

            find_substring= find_regex=

            if (( cursor_moved == 0 )); then
              echo "Not found" >&$fd_original_err
            else
              echo "Found $cursor_moved log entries" >&$fd_original_err
            fi
            no_follow_once=t

          fi
          ;;
        /)
          echo >&$fd_original_err
          local go_to_string=
          read -er -p "Search for substring: " go_to_string <&$fd_original_in >&$fd_original_err
          if [[ "${go_to_string:-}" ]]; then
            omni_prev_go_to_string=$go_to_string
            local find_substring find_regex
            if [[ "$go_to_string" == ~* ]]; then
              find_regex=${go_to_string#\~}
              find_substring=
            else
              find_substring=$go_to_string
              find_regex=
            fi

            local cursor_moved=0
            move_cursor=$cursor \
              allow_all=t \
              omni_search || fail

            find_substring= find_regex=

            if (( cursor_moved == 0 )); then
              echo "Not found" >&$fd_original_err
            else
              omni_show_context || fail
              no_follow_once=t
            fi

          fi
          ;;
        \?)
          echo >&$fd_original_err
          echo >&$fd_original_err
          echo "b  back: go to the previous log line of the same depth or shallower" >&$fd_original_err
          echo "c  list a few lines of logs before and after current line" >&$fd_original_err
          echo "i  step in: go to the next log line of the same depth or deeper" >&$fd_original_err
          echo "I  backward step in: go to the previous log line of the same depth or deeper" >&$fd_original_err
          echo "f  repeat last find forward" >&$fd_original_err
          echo "g  go to the given function or log_id" >&$fd_original_err
          echo "G  repeat previous g command" >&$fd_original_err
          echo "l  list next few log lines" >&$fd_original_err
          echo "L  list previous log lines" >&$fd_original_err
          echo "n  next: (step over) go to the next log line with a function call of the same depth or shallower" >&$fd_original_err
          echo "o  out: (step out) go to the next log line that is shallower" >&$fd_original_err
          echo "O  backward out: (step out) go to the previous log line that is shallower" >&$fd_original_err
          echo "p  print: show all details of current log line" >&$fd_original_err
          echo "q  quit: leave the omni navigator" >&$fd_original_err
          echo "s  step: step to the next log line even if it's not a function call" >&$fd_original_err
          echo "S  backward step: step to the previous log line even if it's not a function call" >&$fd_original_err
          echo "t  stack: show call stack" >&$fd_original_err
          echo "T  stack: show log stack" >&$fd_original_err
          echo "v  var filter toggle: turn on or off var filter" >&$fd_original_err
          echo "V  var filter: choose which vars to show in each line" >&$fd_original_err
          echo "!  go to next error" >&$fd_original_err
          echo "@  show debug command to get to current log position" >&$fd_original_err
          echo "#  show source code that logged this line" >&$fd_original_err
          echo "$  enter debug shell" >&$fd_original_err
          echo "%  show timestamp and duration info" >&$fd_original_err
          echo "^  go to next log file change" >&$fd_original_err
          echo "[  go to first log line within the same plane" >&$fd_original_err
          echo "]  go to last log line within the same plane" >&$fd_original_err
          echo "{  go to first log line within the log file" >&$fd_original_err
          echo "}  go to last log line within the log file" >&$fd_original_err
          echo ",  grep logs for a given string, listing all matching lines" >&$fd_original_err
          echo ".  repeat previous grep" >&$fd_original_err
          echo "/  search forward for a string" >&$fd_original_err
          no_follow_once=t
          ;;
        *)
          echo "# Unknown command" >&$fd_original_err
          echo "Press ? for a list of commands" >&$fd_original_err
          no_follow_once=t
          ;;
      esac
    end_while
  end_function

  handle_return
)

