#!/bin/bash

type -t omni_navigator_init >/dev/null && return 0

omni_navigator_init() {
  omni_list_radius=${omni_list_radius:-5}
  if [[ ! -v fd_original_in ]]; then
    exec {fd_original_in}<&0
    exec {fd_original_out}>&1
    exec {fd_original_err}>&2
    exec {fd_original_trace}>&${fd_trace:-2}
  fi
}

# input:
#   log_file
# output:
#   log_file_id
#   log_file_token
get_log_file_token() {
  if [[ ! -f "$log_file" ]]; then
    log_fatal "Can't find log file: $log_file"
    return 1
  fi

  if [[ -L "$log_file" ]]; then
    log_file=$(realpath $log_file)
  fi

  log_file_id=${log_file%.olog}
  log_file_id=${log_file_id##*/}
  log_file_id=${log_file_id##*-}

  if [[ ! "$log_file_id" =~ ^[0-9:]+$ ]]; then
    log_fatal "Could not figure out log file id. Got [$log_file_id]"
    log_fatal "Maybe log file doesn't comply with convention: {path}/{log}-{job_id}:{fork_id}.olog"
    return 1
  fi

  log_file_token=${log_file_id//:/_}
  return 0
}

# input: {line}
#   line_id
omni_get_processed_line() {
  local line=$1 line_id=$line_id

  case $action in
    call)
      processed_line="[$action] $function"
    ;;
    return\(*)
      processed_line="[$action] from $function"
    ;;
    log_from)
      processed_line="[$action] $old_log_file"
    ;;
    log_to)
      processed_line="[$action] $new_log_file"
    ;;
    *)
      if [[ "${info:-}" ]]; then
        processed_line="[$action] $info"
      else
        processed_line=${line%$NL}
      fi
    ;;
  esac

  processed_line="$line_id $processed_line"
  return 0
}

# inputs: 
#   log_file 
#   log_file_id 
#   log_file_token 
#   log_fork_id
omni_load_log_array() {
  local log_vars='log_file log_file_id log_file_token log_fork_id'
  begin_function

    eval "declare -ga omni_log_array_$log_file_token"
    local -n array=omni_log_array_$log_file_token
    mapfile array < <(cat $log_file) || fail

    eval "
      declare -ga \
        omni_plane_map_$log_file_token \
        omni_plane_depth_map_$log_file_token \
        omni_action_map_$log_file_token
      omni_log_file_$log_file_token=$log_file
      "

    local -n \
      plane_map=omni_plane_map_$log_file_token \
      plane_depth_map=omni_plane_depth_map_$log_file_token \
      action_map=omni_action_map_$log_file_token \
      output_array=omni_log_output_array_$log_file_token \

    local i array_size=${#array[*]} \
      plane_stack next_plane_id=1 plane_id=0 \
      processed_line line \
      log_fork_id=${log_file_id#*:} \
      ts pid log_id depth level action function entries info old_log_file new_log_file

    begin_for (( i = 0; i < array_size; i++ )); doo

      line=${array[$i]} action=none processed_line=$line
      ts= pid= log_id= depth= level= function= info= old_log_file= new_log_file=
      if [[ "$line" == \=\ * ]]; then
        entries=${line#= }
        eval "$entries" || return 1

        if [[ $action == none ]]; then
          log_fatal "Log line is missing action key: $line"
          return 1
        fi

        action_map[$i]=$action

        line_id=$log_fork_id:$((i+1)) omni_get_processed_line "$line" || {
          log_fatal "Bad log line: $line"
          return 1
          }
      fi 

      output_array[$i]=$processed_line

      case $action in
        call)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
          plane_stack+=( $plane_id )
          (( plane_id = next_plane_id++ ))
        ;;
        return\(*)
          if [[ -v plane_stack && ${#plane_stack[*]} -gt 0 ]]; then
            if [[ ${#plane_stack[*]} -gt 0 ]]; then
              (( plane_id = plane_stack[-1] ))
              unset plane_stack[-1]
            else
              plane_id=0
            fi
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_id=0
            plane_depth_map[$i]=0
          fi
          plane_map[$i]=$plane_id
        ;;
        *)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
        ;;
      esac

    end_for

    log_array_size=${#array[*]}
  
  end_function
  handle_return
}

update_cursor_vars() {
  local -n \
    log_file_id=cursor_${cursor}_log_file_id \
    log_array=cursor_${cursor}_log_array \

  log_fork_id=${log_file_id#*:} \
  log_job_id=${log_file_id%:*} \
  log_array_size=${#log_array[*]} 
}

# inputs:
#   new_cursor
# should be evaluated after omni_change_cursor_log has selected a log for this cursor
omni_select_cursor() {
  if [[ "$new_cursor" != "$cursor" ]]; then
    cursor=$new_cursor
    declare -gn \
      action_map=cursor_${cursor}_action_map \
      log_array_index=cursor_${cursor}_log_array_index \
      log_array=cursor_${cursor}_log_array \
      log_file=cursor_${cursor}_log_file \
      log_file_id=cursor_${cursor}_log_file_id \
      output_array=cursor_${cursor}_output_array \
      plane_depth_map=cursor_${cursor}_plane_depth_map \
      plane_map=cursor_${cursor}_plane_map \
      plane_stack_map=cursor_${cursor}_plane_stack_map \
      log_file_stack=cursor_${cursor}_log_file_stack \
      log_file_pos_stack=cursor_${cursor}_log_file_pos_stack \
      function_call_stack=cursor_${cursor}_function_call_stack \

    update_cursor_vars || return 1
  fi

  return 0
}

# inputs:
#   cursor 
#   new_log_file
# NOTE: This does not update function_call_stack or log_file_pos_stack or log_file_stack
#   you'll need to either manually update these or use the omni_enter_sub_log / omni_exit_sub_log
#   functions to manage it automatically. 
omni_change_cursor_log() {
  local log_vars='cursor new_log_file'
  begin_function

    eval "local old_log_file=\${cursor_${cursor}_log_file:-}"
    if [[ "$old_log_file" != "$new_log_file" ]]; then

      local log_file=$new_log_file

      get_log_file_token || fail
      if [[ "${old_log_file:-}" && $old_log_file != $log_file ]]; then
        log_fatal "Two different logs have the same log_file_token (same fork_id):"
        log_fatal "$old_log_file != $log_file"
        fail1
      fi

      eval "
        cursor_${cursor}_log_file=$log_file \
        cursor_${cursor}_log_file_id=$log_file_id \
        cursor_${cursor}_log_array_index=0 \
      "
      eval "
        declare -gn \
          cursor_${cursor}_action_map=omni_action_map_$log_file_token \
          cursor_${cursor}_output_array=omni_log_output_array_$log_file_token \
          cursor_${cursor}_plane_depth_map=omni_plane_depth_map_$log_file_token \
          cursor_${cursor}_plane_map=omni_plane_map_$log_file_token \
          cursor_${cursor}_plane_stack_map=omni_plane_stack_map_$log_file_token \
      "

      if [[ ! -v omni_log_array_$log_file_token ]]; then
        omni_load_log_array || fail
      fi

      eval "declare -gn cursor_${cursor}_log_array=omni_log_array_$log_file_token"

      update_cursor_vars || return 1

    fi

  end_function
  handle_return
}

# inputs:
#   new_log_file
#   new_index
omni_enter_sub_log() {
  local new_index=${new_index:-0}
  log_file_stack+=( $log_file )
  log_file_pos_stack+=( $log_array_index )
  omni_change_cursor_log || return 1
  if [[ $new_index == -1 ]]; then
    (( new_index = log_array_size - 1 ))
  fi
  log_array_index=$new_index
  return 0
}

# inputs:
#   direction
omni_exit_sub_log() {
  local direction=${direction:-0}

  if (( ${#log_file_stack[*]} == 0 )); then
    log_fatal "Internal error: attempted omni_exit_sub_log when log_file_stack size is 0"
    return 1
  fi

  local parent_log_file=${log_file_stack[-1]}
  unset log_file_stack[-1]

  local parent_pos=${log_file_pos_stack[-1]}
  unset log_file_pos_stack[-1]

  new_log_file=$parent_log_file \
    omni_change_cursor_log || return 1
  (( log_array_index = parent_pos + direction ))

  if (( log_array_index < 0 || log_array_index >= log_array_size )); then
    omni_exit_sub_log || return 1
  fi

  return 0
}

# inputs: 
#   cursor
#   reverse_index
omni_show_line() {
  local reverse_index=$reverse_index \
    cursor=$cursor \

  local -n \
    output_array=cursor_${cursor}_output_array \
    index=cursor_${cursor}_log_array_index \

  local reverse=f
  if (( reverse_index == index )); then
    reverse=t
  fi

  if [[ ! -v output_array ]]; then
    log_fatal "Internal error: Missing output_array"
    return 1
  fi

  if [[ $reverse == t ]]; then
    echo -n "$REVERSE" >&$fd_original_err
  fi

  local line=${output_array[$index]}

  local pad_size line_length=${#line}
  (( pad_size = COLUMNS - line_length ))

  if [[ $reverse == t ]]; then
    if (( ${#line} > $COLUMNS )); then
      line=${line:0:$((COLUMNS-3))}..
    fi
    echo -n "$line" >&$fd_original_err
    if (( pad_size > 0 )); then
      printf %${pad_size}s >&$fd_original_err
    fi
    echo "$RESET" >&$fd_original_err
  else
    echo "$line" >&$fd_original_err
  fi

  return 0
}

# inputs:
#   index: where in the current log to extract the vars from
#   vars: space separated list of vars to extract from the given log line
# warning: if you localize a variable before calling this, that variable can't be set
#   by this function. Only global variables can be successfully set by this function.
#   This is because this function localizes all variables it uses, and then globalizes
#   the selected variable, which won't actually change an outer local version of the
#   variable, only the shared global version.
omni_extract_vars() {
  local line=${log_array[$index]} \
    ts pid log_id depth level action function entries info old_log_file new_log_file \
    var entries
  if [[ "$line" == \=\ * ]]; then
    entries=${line#= }
    eval "$entries" || return 1
    for var in $vars; do
      if [[ -v $var ]]; then
        eval "declare -g $var=\$$var"
      fi
    done
  fi
  return 0
}

# Move to the next log line to search
# This is meant to be able to move past the boundaries if there are no other possibilities
omni_search_next() {
  begin_function_flat

    failed_to_move=f

    if [[ $deep == t && ${action_map[$index]} == log_to ]]; then

      local new_index=0
      if [[ $direction == -1 ]]; then
        new_index=-1
      fi
      local new_log_file
      vars=new_log_file \
        omni_extract_vars || fail
      omni_enter_sub_log || fail

    else

      local pre_action= post_action=

      if (( index >= 0 && index < log_array_size )); then
        pre_action=${action_map[$index]}
      fi
      (( index += direction ))
      if (( index >= 0 && index < log_array_size )); then
        post_action=${action_map[$index]}
      fi

      if [[ $direction == 1 ]]; then

        if [[ "$pre_action" == call ]]; then
          function=
          vars=function \
          index=$((index - 1)) \
            omni_extract_vars || fail
          if [[ ! "$function" ]]; then
            log_error "Bad log file: has call action without function"
          fi
          function_call_stack+=( $function )
        fi

        if [[ "$post_action" == return\(* && -v function_call_stack && ${#function_call_stack[*]} -gt 0 ]]; then
          unset function_call_stack[-1]
        fi

      fi

      if [[ $direction == -1 ]]; then

        if [[ "$post_action" == call && -v function_call_stack && ${#function_call_stack[*]} -gt 0 ]]; then
          unset function_call_stack[-1]
        fi

        if [[ "$pre_action" == return\(* ]]; then
          function=
          vars=function \
          index=$((index - 1)) \
            omni_extract_vars || fail
          if [[ ! "$function" ]]; then
            log_error "Bad log file: has call action without function"
          fi
          function_call_stack+=( $function )
        fi

      fi

      if (( index >= log_array_size || index < 0 )); then
        # out of bounds
        if [[ $direction == 1 ]]; then
          if (( ${#log_file_stack[*]} > 0 )); then
            omni_exit_sub_log || fail
          else
            (( index = log_array_size - 1 ))
            failed_to_move=t
          fi
        elif [[ $direction == -1 ]]; then
          if (( ${#log_file_stack[*]} > 0 )); then
            omni_exit_sub_log || fail
          else
            index=0
            failed_to_move=t
          fi
        else
          log_fatal "omni_search_next: invalid direction: $direction"
          fail1
        fi
      fi

    fi
  end_function_flat
  handle_return
}

omni_search_get_matches() {

  local plane_id=${plane_map[$index]} 
  if [[ $deep == f && $plane_id -gt $original_plane_id ]]; then
    found_matching_line=f
  fi

  if [[ $found_matching_line == t && ( "$find_level" || "$find_action" ) ]]; then
    found_matching_line=f

    if [[ $go_out_of == function \
       && $plane_id -lt $original_plane_id \
       ]]; then
       found_matching_line=t
    fi

    if [[ "$find_level" ]]; then
      level=
      vars=level \
        omni_extract_vars || fail
      if [[ "${level:-}" && $level =~ $find_level ]]; then
        #zombie "level matches"
        found_matching_line=t
      fi
    fi

    if [[ $found_matching_line == f && "$find_action" ]]; then
      action=
      vars=action \
        omni_extract_vars || fail
      if [[ "${action:-}" && $action =~ $find_action ]]; then
        #zombie "action matches"
        found_matching_line=t
      fi
    fi

  fi
}

omni_copy_cursor() {
  local from=$1 to=$2

  if [[ $from != $to ]]; then
    local -n \
      from_log_file=cursor_${from}_log_file \
      to_log_index=cursor_${to}_log_array_index \
      from_log_index=cursor_${from}_log_array_index \
      from_log_file_stack=cursor_${from}_log_file_stack \
      from_log_file_pos_stack=cursor_${from}_log_file_pos_stack \
      from_function_call_stack=cursor_${from}_function_call_stack \
      to_log_file_stack=cursor_${to}_log_file_stack \
      to_log_file_pos_stack=cursor_${to}_log_file_pos_stack \
      to_function_call_stack=cursor_${to}_function_call_stack \

    new_log_file=$from_log_file \
      cursor=$to \
      omni_change_cursor_log || return 1

    to_log_index=$from_log_index

    to_log_file_stack=( "${from_log_file_stack[@]}" )
    to_log_file_pos_stack=( "${from_log_file_pos_stack[@]}" )
    to_function_call_stack=( "${from_function_call_stack[@]}" )
  fi

  return 0
}

# will move the cursor according to the parameters given
omni_search() {
  local log_vars='from_log from_index move_cursor count deep'
  begin_function

    local \
      from_cursor=${from_cursor:-} \
      original_cursor=${cursor:-} \
      move_cursor=${move_cursor:-s} \
      find_level=${find_level:-} \
      find_action=${find_action:-} \
      deep=${deep:-t} \
      go_out_of=${go_out_of:-} \
      count=${count:-1} \

    local direction
    if (( count < 0 )); then
      direction=-1
    elif (( count > 0 )); then
      direction=1
    else
      log_fatal "Invalid count=$count"
    fi

    cursor_moved=0

    #zombie "Starting omni_search: from_cursor=$from_cursor move_cursor=$move_cursor count=$count deep=$deep"

    if [[ "$from_cursor" ]]; then
      omni_copy_cursor $from_cursor $move_cursor || fail
    fi

    new_cursor=$move_cursor \
      omni_select_cursor || fail

    local -n index=log_array_index

    local original_plane_id=${plane_map[$index]}
    local plane_id=$original_plane_id
    local found_matching_line=t

    begin_loop

      if [[ $found_matching_line == t ]]; then
        omni_copy_cursor $cursor backup
      fi

      omni_search_next || fail
      #zombie "Checking index $index / $log_array_size of $log_file"

      found_matching_line=t
      omni_search_get_matches || fail
      
      if [[ $failed_to_move == t ]]; then
        break
      fi
      if [[ $found_matching_line == t ]]; then
        (( cursor_moved += direction ))
        (( count -= direction ))
        if [[ $count == 0 ]]; then
          break
        fi
      fi

    end_loop

    if [[ $failed_to_move == f && $found_matching_line == f ]]; then
      omni_copy_cursor backup $cursor || fail
    fi

    # restore original cursor
    if [[ "$original_cursor" ]]; then
      new_cursor=$original_cursor \
        omni_select_cursor || fail
    fi

  end_function
  handle_return
}

# inputs: 
#   next_log_start  (relative to current index)
#   max_count
#   plane_map
#   output_array
omni_show_log() {
  begin_function_flat

    # display lines until end
    local remaining_lines=$max_count
    local offset=$next_log_start

    omni_copy_cursor $cursor s || fail

    # get cursor to correct starting point
    local cursor_moved=0 deep=f

    count=$offset \
      omni_search || fail

    next_log_start=$cursor_moved

    begin_while (( remaining_lines-- > 0 )); doo

      cursor=s \
        reverse_index=$log_array_index \
        omni_show_line $i || fail

      omni_search || fail
      if [[ $cursor_moved == 0 ]]; then
        break
      fi

      (( next_log_start++ ))
        
    end_while

  end_function_flat
  handle_return
}

omni_next_error() {

  local cursor_moved=0

  move_cursor=$cursor \
    find_level='(error|fatal)' \
    find_action='return\([^0].*\)' \
    omni_search || return 1

  if (( $cursor_moved > 0 )); then
    echo "No errors found." >&$fd_original_err
  fi

  return 0

}

omni_show_call_stack() {
  if [[ -v function_call_stack && ${#function_call_stack[*]} -gt 0 ]]; then
    local i=$index
    local stack_size=${#function_call_stack[*]}

    if (( stack_size > 0 )); then
      for (( i = 0; i < stack_size; i++ )); do
        echo " ${function_call_stack[$i]}" >&$fd_original_err
      done
    else
      echo "Not inside of a function" >&$fd_original_err
    fi
  else
    echo "Not inside of a function" >&$fd_original_err
  fi

  return 0
}

omni_show_log_stack() {
  local i size=0
  if [[ -v log_file_stack ]]; then
    size=${#log_file_stack[*]}
  fi
  if (( size > 0 )); then
    for (( i = 0; i < size; i++ )); do
      echo " ${log_file_stack[$i]}" >&$fd_original_err
    done
  fi
  echo " $log_file" >&$fd_original_err
  return 0
}

# inputs: 
#   log_file
omni_navigator() (
  # side_log "omni_navigator()
  # FUNCNAME[0]=${FUNCNAME[0]:-}
  # FUNCNAME[1]=${FUNCNAME[1]:-}
  # FUNCNAME[2]=${FUNCNAME[2]:-}
  # BASH_LINENO[0]=${BASH_LINENO[0]:-}
  # BASH_LINENO[1]=${BASH_LINENO[1]:-}
  # LINENO=${LINENO:-}
  # "

  begin_function_flat

    local cursor=a

    new_log_file=$log_file \
      omni_change_cursor_log || fail
    new_cursor=$cursor \
      omni_select_cursor || fail
    (( next_log_start = -omni_list_radius ))
    log_array_index=0

    local debug_r=-1 no_follow_once max_log_lines
    (( max_log_lines = omni_list_radius * 2 + 1 ))

    begin_while [[ $debug_r == -1 ]]; doo

      if [[ ${no_follow_once:=f} == t ]]; then
        no_follow_once=f
      else
        max_count=$max_log_lines \
          omni_show_log || fail
      fi

      echo "${NL}${LIGHT_BLUE}current log: $log_file" >&$fd_original_err
      echo -n "${YELLOW}job_id=$log_job_id log_id=$log_fork_id:$((log_array_index+1)) ${GREEN}omni-log-navigator> $RESET" >&$fd_original_err
      local debug_c
      read -rs -n1 debug_c <&$fd_original_in

      case "$debug_c" in
        b)
          echo "# Step back, until next function call" >&$fd_original_err
          move_cursor=$cursor \
            count=-1 \
            deep=f \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        c)
          echo "# Show context" >&$fd_original_err
          omni_show_context || fail
          no_follow_once=t
          ;;
        i)
          echo "# Step in, forwards" >&$fd_original_err
          move_cursor=$cursor \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        l)
          echo -n "$CLEAR_LINE" >&$fd_original_err
          echo -n "$CURSOR_UP$CLEAR_LINE" >&$fd_original_err
          max_count=$max_log_lines \
            omni_show_log || fail
          no_follow_once=t
          ;;
        L)
          echo -n "$CLEAR_SCREEN" >&$fd_original_err
          (( next_log_start -= omni_list_radius * 4 - 2 )) 
          max_count=$max_log_lines \
            omni_show_log || fail
          no_follow_once=t
          ;;
        n)
          echo "# Step over, until function call" >&$fd_original_err
          move_cursor=$cursor \
            deep=f \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        o)
          echo "# Step out" >&$fd_original_err
          move_cursor=$cursor \
            go_out_of=function \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        p)
          echo "# Print details" >&$fd_original_err
          omni_print_details || fail
          no_follow_once=t
          ;;
        q)
          echo "# Quitting" >&$fd_original_err
          debug_r=0
          ;;
        s)
          echo "# Step over, until next entry" >&$fd_original_err
          move_cursor=$cursor \
            deep=f \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        S)
          echo "# Entering debug shell" >&$fd_original_err
          set +u
          debug_shell
          set -u
          no_follow_once=t
          ;;
        t)
          echo "# Show call stack" >&$fd_original_err
          omni_show_call_stack || fail
          no_follow_once=t
          ;;
        T)
          echo "# Show log stack" >&$fd_original_err
          omni_show_log_stack || fail
          no_follow_once=t
          ;;
        \!)
          echo "# Jump to next error" >&$fd_original_err
          omni_next_error || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        \?)
          echo >&$fd_original_err
          echo >&$fd_original_err
          echo "b  back: go to the previous log line of the same depth or shallower" >&$fd_original_err
          echo "c  list a few lines of logs before and after current line" >&$fd_original_err
          echo "i  step in: go to the next log line of the same depth or deeper" >&$fd_original_err
          echo "l  list next few log lines" >&$fd_original_err
          echo "L  list previous log lines" >&$fd_original_err
          echo "n  next: (step over) go to the next log line with a function call of the same depth or shallower" >&$fd_original_err
          echo "o  out: (step out) go to the next log line that is shallower" >&$fd_original_err
          echo "p  print: show all details of current log line" >&$fd_original_err
          echo "q  quit: leave the omni navigator" >&$fd_original_err
          echo "s  step: step to the next log line even if it's not a function call" >&$fd_original_err
          echo "t  stack: show call stack" >&$fd_original_err
          echo "T  stack: show log stack" >&$fd_original_err
          echo "!  go to next error" >&$fd_original_err
          no_follow_once=t
          ;;
        *)
          echo "# Unknown command" >&$fd_original_err
          echo "Press ? for a list of commands" >&$fd_original_err
          no_follow_once=t
          ;;
      esac
    end_while
  end_function_flat

  handle_return
)

omni_print_details() {
  local line=${log_array[$log_array_index]}
  if [[ "$line" == \=\ * ]]; then
    echo "log file: $log_file"
    echo "fork_id: $log_fork_id"
    echo "line: $((log_array_index + 1))"
    local ts pid log_id depth level action function entries info
    entries=${line#= }
    eval "$entries" || return 1

    local kvs=( ${entries} )
    local kv keys=
    for kv in "${kvs[@]}"; do
      if [[ "$kv" == *=* ]]; then
        key="${kv%%=*}"
        if [[ "$key" =~ ^[a-zA-Z0-9_]+$ ]]; then
          keys+="$key$NL"
        fi
      fi
    done

    keys=$(echo "${keys[*]}" | sort)
    local key
    for key in $keys; do
      echo "$key: ${!key}" >&$fd_original_err
    done
  else
    echo "No further details available." >&$fd_original_err
  fi
  return 0
}

omni_show_context() {
  (( next_log_start = -omni_list_radius ))
  max_count=$max_log_lines \
    omni_show_log
}

