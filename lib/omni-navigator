#!/bin/bash

type -t omni_navigator_init >/dev/null && return 0

omni_navigator_init() {
  omni_list_radius=${omni_list_radius:-5}
  if [[ ! -v fd_original_in ]]; then
    exec {fd_original_in}<&0
    exec {fd_original_out}>&1
    exec {fd_original_err}>&2
    exec {fd_original_trace}>&${fd_trace:-2}
  fi
}

# input:
#   log_file
# output:
#   log_file_id
#   log_file_token
get_log_file_token() {
  if [[ ! -f "$log_file" ]]; then
    log_fatal "Can't find log file: $log_file"
    return 1
  fi

  if [[ -L "$log_file" ]]; then
    log_file=$(realpath $log_file)
  fi

  log_file_id=${log_file%.olog}
  log_file_id=${log_file_id##*/}
  log_file_id=${log_file_id##*-}

  if [[ ! "$log_file_id" =~ ^[0-9:]+$ ]]; then
    log_fatal "Could not figure out log file id. Got [$log_file_id]"
    log_fatal "Maybe log file doesn't comply with convention: {path}/{log}-{job_id}:{fork_id}.olog"
    return 1
  fi

  log_file_token=${log_file_id//:/_}
  return 0
}

# input: {line}
#   line_id
omni_get_processed_line() {
  local line=$1 line_id=$line_id

  case $action in
    call)
      processed_line="[$action] $function"
    ;;
    return\(*)
      processed_line="[$action] from $function"
    ;;
    log_from)
      processed_line="[$action] $old_log_file"
    ;;
    log_to)
      processed_line="[$action] $new_log_file"
    ;;
    *)
      if [[ "${info:-}" ]]; then
        processed_line="[$action] $info"
      else
        processed_line=${line%$NL}
      fi
    ;;
  esac

  processed_line="$line_id $processed_line"
  return 0
}

# inputs: 
#   log_file 
#   log_file_id 
#   log_file_token 
#   log_fork_id
omni_load_log_array() {
  local log_vars='log_file log_file_id log_file_token log_fork_id'
  begin_function

    eval "declare -ga omni_log_array_$log_file_token"
    local -n array=omni_log_array_$log_file_token
    mapfile array < <(cat $log_file) || fail

    eval "
      declare -ga \
        omni_plane_map_$log_file_token \
        omni_plane_depth_map_$log_file_token \
        omni_action_map_$log_file_token
      omni_log_file_$log_file_token=$log_file
      "

    local -n \
      plane_map=omni_plane_map_$log_file_token \
      plane_depth_map=omni_plane_depth_map_$log_file_token \
      action_map=omni_action_map_$log_file_token \
      output_array=omni_log_output_array_$log_file_token \

    local i array_size=${#array[*]} \
      plane_stack next_plane_id=1 plane_id=0 \
      processed_line line \
      log_fork_id=${log_file_id#*:} \
      ts pid log_id depth level action function entries info old_log_file new_log_file

    begin_for (( i = 0; i < array_size; i++ )); doo

      line=${array[$i]} action=none processed_line=$line
      ts= pid= log_id= depth= level= function= info= old_log_file= new_log_file=
      if [[ "$line" == \=\ * ]]; then
        entries=${line#= }
        eval "$entries" || return 1

        if [[ $action == none ]]; then
          log_fatal "Log line is missing action key: $line"
          return 1
        fi

        action_map[$i]=$action

        line_id=$log_fork_id:$((i+1)) omni_get_processed_line "$line" || {
          log_fatal "Bad log line: $line"
          return 1
          }
      fi 

      output_array[$i]=$processed_line

      case $action in
        call)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
          plane_stack+=( $plane_id )
          (( plane_id = next_plane_id++ ))
        ;;
        return\(*)
          if [[ -v plane_stack && ${#plane_stack[*]} -gt 0 ]]; then
            if [[ ${#plane_stack[*]} -gt 0 ]]; then
              (( plane_id = plane_stack[-1] ))
              unset plane_stack[-1]
            else
              plane_id=0
            fi
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_id=0
            plane_depth_map[$i]=0
          fi
          plane_map[$i]=$plane_id
        ;;
        *)
          plane_map[$i]=$plane_id
          if [[ -v plane_stack ]]; then
            plane_depth_map[$i]=${#plane_stack[*]}
          else
            plane_depth_map[$i]=0
          fi
        ;;
      esac

    end_for

    log_array_size=${#log_array[*]}
  
  end_function
  handle_return
}

update_cursor_vars() {
  log_fork_id=${log_file_id#*:} \
  log_job_id=${log_file_id%:*} \
  log_array_size=${#log_array[*]} 
}

# inputs:
#   new_cursor
# should be evaluated after omni_change_cursor_log has selected a log for this cursor
omni_select_cursor() {
  if [[ "$new_cursor" != "$cursor" ]]; then
    cursor=$new_cursor
    declare -gn \
      action_map=cursor_${cursor}_action_map \
      log_array_index=cursor_${cursor}_log_array_index \
      log_array=cursor_${cursor}_log_array \
      log_file=cursor_${cursor}_log_file \
      log_file_id=cursor_${cursor}_log_file_id \
      output_array=cursor_${cursor}_output_array \
      plane_depth_map=cursor_${cursor}_plane_depth_map \
      plane_map=cursor_${cursor}_plane_map \
      plane_stack_map=cursor_${cursor}_plane_stack_map \
      log_file_stack=cursor_${cursor}_log_file_stack \
      log_file_pos_stack=cursor_${cursor}_log_file_pos_stack \
      function_call_stack=cursor_${cursor}_function_call_stack \

    update_cursor_vars || return 1
  fi

  return 0
}

# inputs:
#   cursor 
#   new_log_file
omni_change_cursor_log() {
  local log_vars='cursor new_log_file'
  begin_function

    eval "local old_log_file=\${cursor_${cursor}_log_file:-}"
    if [[ "$old_log_file" != "$new_log_file" ]]; then

      local log_file=$new_log_file

      get_log_file_token || fail
      if [[ "${old_log_file:-}" && $old_log_file != $log_file ]]; then
        log_fatal "Two different logs have the same log_file_token (same fork_id):"
        log_fatal "$old_log_file != $log_file"
        fail1
      fi

      eval "
        cursor_${cursor}_log_file=$log_file \
        cursor_${cursor}_log_file_id=$log_file_id \
        cursor_${cursor}_log_array_index=0 \
      "
      eval "
        declare -gn \
          cursor_${cursor}_action_map=omni_action_map_$log_file_token \
          cursor_${cursor}_output_array=omni_log_output_array_$log_file_token \
          cursor_${cursor}_plane_depth_map=omni_plane_depth_map_$log_file_token \
          cursor_${cursor}_plane_map=omni_plane_map_$log_file_token \
          cursor_${cursor}_plane_stack_map=omni_plane_stack_map_$log_file_token \
      "

      if [[ ! -v omni_log_array_$log_file_token ]]; then
        omni_load_log_array || fail
      fi

      eval "declare -gn cursor_${cursor}_log_array=omni_log_array_$log_file_token"

      update_cursor_vars || return 1

    fi

  end_function
  handle_return
}

# inputs:
#   new_log_file
#   new_index
omni_enter_sub_log() {
  local new_index=${new_index:-0}
  log_file_stack+=( $log_file )
  log_file_pos_stack+=( $log_array_index )
  omni_change_cursor_log || return 1
  if [[ $new_index == -1 ]]; then
    (( new_index = log_array_size - 1 ))
  fi
  log_array_index=$new_index
  return 0
}

# inputs:
#   direction
omni_exit_sub_log() {
  local direction=${direction:-0}

  if (( ${#log_file_stack[*]} == 0 )); then
    log_fatal "Internal error: attempted omni_exit_sub_log when log_file_stack size is 0"
    return 1
  fi

  local parent_log_file=${log_file_stack[-1]}
  unset log_file_stack[-1]

  local parent_pos=${log_file_pos_stack[-1]}
  unset log_file_pos_stack[-1]

  new_log_file=$parent_log_file \
    omni_change_cursor_log || return 1
  (( log_array_index = parent_pos + direction ))

  if (( ${#log_file_stack[*]} > 0 && \
     ( log_array_index < 0 || log_array_index >= log_array_size ) \
     )); then
    omni_exit_sub_log || return 1
  fi

  return 0
}

# inputs: {index}
#   output_array
#   cursor
omni_show_line() {
  local index=$1

  local reverse=f
  if (( index == log_array_index )); then
    reverse=t
  fi

  if [[ ! -v output_array ]]; then
    log_fatal "Internal error: Missing output_array"
    return 1
  fi

  if [[ $reverse == t ]]; then
    echo -n "$REVERSE" >&$fd_original_err
  fi

  local line=${output_array[$index]}

  local pad_size line_length=${#line}
  (( pad_size = COLUMNS - line_length ))

  if [[ $reverse == t ]]; then
    if (( ${#line} > $COLUMNS )); then
      line=${line:0:$((COLUMNS-3))}..
    fi
    echo -n "$line" >&$fd_original_err
    if (( pad_size > 0 )); then
      printf %${pad_size}s >&$fd_original_err
    fi
    echo "$RESET" >&$fd_original_err
  else
    echo "$line" >&$fd_original_err
  fi

  return 0
}

# inputs: 
#   next_log_start 
#   omni_list_radius
#   plane_map
#   output_array
omni_show_log() {
  begin_function_flat

    local -r log_array_size=${#log_array[*]}

    # display lines until end
    local remaining_lines=$(( omni_list_radius * 2 + 1 ))
    local found_line 
    local -n i=next_log_start

    begin_while (( remaining_lines-- > 0 )); doo
      count=1 \
      deep=f \
      from_log=$log_file \
      from_index=$i \
        omni_search || fail
      if [[ ! "$found_index" ]]; then
        break
      fi
      omni_show_line $i || fail
      (( i++ ))
    end_while

  end_function_flat
  handle_return
}

# inputs:
#   index: where in the current log to extract the vars from
#   vars: space separated list of vars to extract from the given log line
# warning: if you localize a variable before calling this, that variable can't be set
#   by this function. Only global variables can be successfully set by this function.
#   This is because this function localizes all variables it uses, and then globalizes
#   the selected variable, which won't actually change an outer local version of the
#   variable, only the shared global version.
omni_extract_vars() {
  local line=${log_array[$index]} \
    ts pid log_id depth level action function entries info old_log_file new_log_file \
    var entries
  if [[ "$line" == \=\ * ]]; then
    entries=${line#= }
    eval "$entries" || return 1
    for var in $vars; do
      if [[ -v $var ]]; then
        eval "declare -g $var=\$$var"
      fi
    done
  fi
  return 0
}

# Move to the next log line to search
# This is meant to be able to move past the boundaries if there are no other possibilities
omni_search_next() {
  begin_function_flat
    if [[ $deep == t && ${action_map[$index]} == log_to ]]; then
      local new_index=0
      if [[ $direction == -1 ]]; then
        new_index=-1
      fi
      local new_log_file
      vars=new_log_file \
        omni_extract_vars || fail
      omni_enter_sub_log || fail
    else

      local plane_id=${plane_map[$index]} \
        action

      if [[ $deep == t && $direction == 1 ]]; then
        action=${action_map[$index]}
        if [[ $action == call ]]; then
          function=
          vars=function \
            omni_extract_vars || fail
          if [[ ! "$function" ]]; then
            log_error "Bad log file: has call action without function"
          fi
          function_call_stack+=( $function )
        fi
      fi

      (( index += direction ))

      if [[ $direction == -1 ]]; then
        action=${action_map[$index]}
        if [[ $action == call ]]; then
          unset function_call_stack[-1]
        fi
      fi

      if (( index >= log_array_size || index < 0 )); then
        # out of bounds
        if [[ $direction == 1 ]]; then
          if (( index >= log_array_size && ${#log_file_stack[*]} > 0 )); then
            omni_exit_sub_log || fail
          fi
        elif [[ $direction == -1 ]]; then
          if (( index < 0 && ${#log_file_stack[*]} > 0 )); then
            omni_exit_sub_log || fail
          fi
        else
          log_fatal "omni_search_next: invalid direction: $direction"
          fail1
        fi
      fi
    fi
  end_function_flat
  handle_return
}

omni_search_get_matches() {
  if [[ $deep == f && $plane_id != $original_plane_id ]]; then
    entry_matches=f
  fi

  if [[ $entry_matches == t && ( "$find_level" || "$find_action" ) ]]; then
    entry_matches=f

    if [[ "$find_level" ]]; then
      level=
      vars=level \
        omni_extract_vars || fail
      if [[ "${level:-}" && $level =~ $find_level ]]; then
        zombie "level matches"
        entry_matches=t
      fi
    fi

    if [[ $entry_matches == f && "$find_action" ]]; then
      action=
      vars=action \
        omni_extract_vars || fail
      if [[ "${action:-}" && $action =~ $find_action ]]; then
        zombie "action matches"
        entry_matches=t
      fi
    fi

  fi
}

# will move the cursor according to the parameters given
omni_search() {
  local log_vars='from_log from_index move_cursor direction count deep'
  begin_function

    local \
      from_log=${from_log:-} \
      from_index=${from_index:-} \
      original_cursor=${cursor:-} \
      move_cursor=${move_cursor:-s} \
      direction=${direction:-1} \
      count=${count:-} \
      find_level=${find_level:-} \
      find_action=${find_action:-} \
      deep=${deep:-t} \

    entry_matches=f

    zombie "Starting omni_search: from_log=$from_log from_index=$from_index move_cursor=$move_cursor"

    if [[ "$from_log" ]]; then
      new_log_file=$from_log \
        omni_change_cursor_log || fail
    fi

    new_cursor=$move_cursor \
      omni_select_cursor || fail

    local -n index=log_array_index
    if [[ "$from_index" ]]; then
      index=$from_index
    fi

    local original_log=$log_file \
      original_index=$index

    local original_plane_id=${plane_map[$index]}
    local plane_id=$original_plane_id

    begin_while true; doo

      if [[ $count ]] && (( count-- <= 0 )); then
        break
      fi
      
      omni_search_next || fail
      zombie "Checking index $index / $log_array_size of $log_file"

      if (( index >= log_array_size || index < 0 )); then
        break
      fi

      entry_matches=t
      omni_search_get_matches || fail
      
      if [[ $entry_matches == t ]]; then
        break
      fi

    end_while

    # restore position of this cursor
    new_log_file=$original_log \
      omni_change_cursor_log || fail
    index=$original_index

    # restore original cursor
    if [[ "$original_cursor" ]]; then
      new_cursor=$original_cursor \
        omni_select_cursor || fail
    fi

  end_function
  handle_return
}

omni_copy_cursor() {
  local from=$1 to=$2

  local -n \
    from_log_file=cursor_${from}_log_file \
    to_log_index=cursor_${to}_log_array_index \

  new_log_file=$from_log_file \
    cursor=$to \
    omni_change_cursor_log || return 1

  to_log_index=from_log_index

  return 0
}

omni_next_error() {

  local entry_matches

  from_log=$log_file \
    from_index=$index \
    direction=1 \
    find_level='(error|fatal)' \
    find_action='return\([^0].*\)' \
    omni_search || return 1

  if [[ $entry_matches == t ]]; then
    omni_copy_cursor s $cursor || return 1
    new_cursor=$cursor omni_select_cursor || return 1
  else
    echo "No errors found." >&$fd_original_err
  fi

  return 0

}

omni_show_call_stack() {
  local i=$index line \
    ts pid log_id depth level action function entries info
  local -A return_map
  local functions=
  begin_while (( i-- > 0 )); doo
    line=${log_array[$i]}
    if [[ "$line" == \=\ * ]]; then
      entries=${line#= }
      eval "$entries" || return 1
      if [[ "${action:-}" == call ]]; then
        if [[ ${return_map[$function]:-0} == 0 ]]; then
          functions+="$function$NL"
        else
          (( return_map[$function]-- ))
        fi
      elif [[ "${action:-}" == return\(* ]]; then
        if [[ "${return_map[$function]:-}" ]]; then
          (( return_map[$function]++ ))
        else
          return_map[$function]=1
        fi
      fi
    fi
  end_while
  if [[ "$functions" ]]; then
    echo "${functions%$NL}" | tac >&$fd_original_err
  else
    echo "Not inside of a function" >&$fd_original_err
  fi
  return 0
}

omni_show_log_stack() {
  local i size=0
  if [[ -v log_file_stack ]]; then
    size=${#log_file_stack[*]}
  fi
  if (( size > 0 )); then
    for (( i = 0; i < size; i++ )); do
      echo " ${log_file_stack[$i]}" >&$fd_original_err
    done
  fi
  echo " $log_file" >&$fd_original_err
  return 0
}

# inputs: 
#   log_file
omni_navigator() (
  # side_log "omni_navigator()
  # FUNCNAME[0]=${FUNCNAME[0]:-}
  # FUNCNAME[1]=${FUNCNAME[1]:-}
  # FUNCNAME[2]=${FUNCNAME[2]:-}
  # BASH_LINENO[0]=${BASH_LINENO[0]:-}
  # BASH_LINENO[1]=${BASH_LINENO[1]:-}
  # LINENO=${LINENO:-}
  # "

  begin_function_flat

    local cursor=a

    new_log_file=$log_file \
      omni_change_cursor_log || fail
    eval "$omni_select_cursor" || fail
    next_log_start=$index
    new_index=$index \
      omni_change_index || fail

    #var=next_log_start offset=-$omni_list_radius \
    #  omni_offset_index || fail
    from_log=$

    local debug_r=-1 no_follow_once
    begin_while [[ $debug_r == -1 ]]; doo

      if [[ ${no_follow_once:=f} == t ]]; then
        no_follow_once=f
      else
        omni_show_log || fail
      fi

      echo -n "${NL}${YELLOW}job_id=$log_job_id log_id=$log_fork_id:$((index+1)) ${GREEN}omni-log-navigator> $RESET" >&$fd_original_err
      local debug_c
      read -rs -n1 debug_c <&$fd_original_in

      case "$debug_c" in
        b)
          echo "# Step back, until next function call" >&$fd_original_err
          local p=$index
          var=index offset=-1 match_action=call omni_offset_index || fail
          if [[ $p == $index ]]; then
            (( index-- ))
            if (( index < 0 )); then
              index=0
            fi
            plane_id=${plane_map[$index]}
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        c)
          echo "# Show context" >&$fd_original_err
          omni_show_context || fail
          no_follow_once=t
          ;;
        i)
          echo "# Step in, forwards" >&$fd_original_err
          move_cursor=$cursor \
            count=1 \
            omni_search || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        l)
          echo -n "$CLEAR_LINE" >&$fd_original_err
          echo -n "$CURSOR_UP$CLEAR_LINE" >&$fd_original_err
          omni_show_log || fail
          no_follow_once=t
          ;;
        L)
          echo -n "$CLEAR_SCREEN" >&$fd_original_err
          var=next_log_start offset=$((-omni_list_radius*4-2)) omni_offset_index || fail
          omni_show_log || fail
          no_follow_once=t
          ;;
        n)
          echo "# Step over, until function call" >&$fd_original_err
          local p=$index
          var=index offset=1 match_action=call omni_offset_index || fail
          if [[ $p == $index ]]; then
            (( index++ ))
            if (( index >= log_array_size )); then
              (( index = log_array_size - 1 ))
            fi
            plane_id=${plane_map[$index]}
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        o)
          echo "# Step out" >&$fd_original_err
          local i=$index base_depth=${plane_depth_map[$index]}
          begin_while (( ++i < log_array_size )); doo
            if (( ${plane_depth_map[$i]} < base_depth )); then
              index=$i
              plane_id=${plane_map[$index]}
              break
            fi
          end_while
          omni_show_context || fail
          no_follow_once=t
          ;;
        p)
          echo "# Print details" >&$fd_original_err
          omni_print_details || fail
          no_follow_once=t
          ;;
        q)
          echo "# Quitting" >&$fd_original_err
          debug_r=0
          ;;
        s)
          echo "# Step over, until next entry" >&$fd_original_err
          local p=$index
          var=index offset=1 omni_offset_index || fail
          if [[ $p == $index ]]; then
            (( index++ ))
            if (( index >= log_array_size )); then
              (( index = log_array_size - 1 ))
            fi
            plane_id=${plane_map[$index]}
          fi
          omni_show_context || fail
          no_follow_once=t
          ;;
        S)
          echo "# Entering debug shell" >&$fd_original_err
          set +u
          debug_shell
          set -u
          no_follow_once=t
          ;;
        t)
          echo "# Show call stack" >&$fd_original_err
          omni_show_call_stack || fail
          no_follow_once=t
          ;;
        T)
          echo "# Show log stack" >&$fd_original_err
          omni_show_log_stack || fail
          no_follow_once=t
          ;;
        \!)
          echo "# Jump to next error" >&$fd_original_err
          omni_next_error || fail
          omni_show_context || fail
          no_follow_once=t
          ;;
        \?)
          echo >&$fd_original_err
          echo >&$fd_original_err
          echo "b  back: go to the previous log line of the same depth or shallower" >&$fd_original_err
          echo "c  list a few lines of logs before and after current line" >&$fd_original_err
          echo "i  step in: go to the next log line of the same depth or deeper" >&$fd_original_err
          echo "l  list next few log lines" >&$fd_original_err
          echo "L  list previous log lines" >&$fd_original_err
          echo "n  next: (step over) go to the next log line with a function call of the same depth or shallower" >&$fd_original_err
          echo "o  out: (step out) go to the next log line that is shallower" >&$fd_original_err
          echo "p  print: show all details of current log line" >&$fd_original_err
          echo "q  quit: leave the omni navigator" >&$fd_original_err
          echo "s  step: step to the next log line even if it's not a function call" >&$fd_original_err
          echo "t  stack: show call stack" >&$fd_original_err
          echo "T  stack: show log stack" >&$fd_original_err
          echo "!  go to next error" >&$fd_original_err
          no_follow_once=t
          ;;
        *)
          echo "# Unknown command" >&$fd_original_err
          echo "Press ? for a list of commands" >&$fd_original_err
          no_follow_once=t
          ;;
      esac
    end_while
  end_function_flat

  handle_return
)

omni_print_details() {
  local line=${log_array[$index]}
  if [[ "$line" == \=\ * ]]; then
    echo "log file: $log_file"
    echo "fork_id: $log_fork_id"
    echo "line: $((index + 1))"
    local ts pid log_id depth level action function entries info
    entries=${line#= }
    eval "$entries" || return 1

    local kvs=( ${entries} )
    local kv keys=
    for kv in "${kvs[@]}"; do
      if [[ "$kv" == *=* ]]; then
        key="${kv%%=*}"
        if [[ "$key" =~ ^[a-zA-Z0-9_]+$ ]]; then
          keys+="$key$NL"
        fi
      fi
    done

    keys=$(echo "${keys[*]}" | sort)
    local key
    for key in $keys; do
      echo "$key: ${!key}" >&$fd_original_err
    done
  else
    echo "No further details available." >&$fd_original_err
  fi
  return 0
}

omni_show_context() {
  next_log_start=$index
  var=next_log_start offset=-$omni_list_radius omni_offset_index || return 1
  omni_show_log || return 1
  return 0
}

