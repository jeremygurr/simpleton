#!/bin/bash

type -t cube_update >/dev/null && return 0
readonly failed_but_can_retry=2 skip=2 somethings_wrong=1 everythings_fine=0

# never run as background process. 
# Instead pass in run_in_background=t and this function will handle the rest.
cube_update() {
local cube_path=$1 view=${view:-} \
      run_in_background=${run_in_background:-f} \
      processes= 
local short_cube=${cube_path##*/work/} \
      cube_name=${cube_path##*/}

begin_function_flat

  if [[ ! -f "$cube_path/cube-context" ]]; then
    err "cube_update called on $short_cube which is not a cube"
    fail1
  fi

  # decide whether to run in background or in subshell
  if [[ $run_in_background == t ]]; then
    cube_update_inner &
    processes+=" $!"
  else
    # running in a subshell to fully isolate changes from this calling context
    # but it's not actually in the background
    ( cube_update_inner ) || fail
  fi

  wait_for_sub_processes || fail

end_function_flat
handle_return
}

# This is guaranteed to be run in a subshell, so every var and function is local automatically
cube_update_inner() {

dimensions=() dimension_files=() localize_dim_vars= dim_string= 
if [ -d "$cube_path/dim" ]; then
  gather_dims || return 1
fi
trace $log_trace "Updating cube $short_cube $dim_string"

begin_function

  run_in_background=f
  setup_exit_trap

  parallel_default=t
  [[ $debug == t ]] && parallel_default=f
  parallel_execution=${parallel_execution:-${par:-$parallel_default}}

  init_context || fail
  load_context || fail
  if [[ -f $cube_path/cube-vars ]]; then
    source $cube_path/cube-vars || fail
  fi
  strategies=${strategies:-$default_strategies}
  expand_strategies || fail

  fresh=${fresh2:-${fresh:-$default_fresh}}

  if [[ "$cube_expiration" && -d $cube_path/cell ]]; then
    trace $log_trace "Deleting cached data older than $cube_expiration"
    local expiration_minutes
    convert_to_seconds $cube_expiration expiration_minutes || fail
    let expiration_minutes/=60
    find1 $cube_path/cell -mmin +$expiration_minutes -exec rm -r \{\} + || fail
  fi

  cube_validate || fail
  eval "$localize_dim_vars" || fail

  if [[ ${#dimensions[*]} -eq 0 ]]; then
    ( cell_update ) || fail
  else
    cube_update_pivot 0 || fail
  fi

end_function
handle_return

}

expand_strategies() {
local new_strategies=
for strategy in $strategies; do
  case $strategy in
    cached|c)
      new_strategies+=" cached"
    ;;
    reliable|reliability|r)
      new_strategies+=" reliable"
    ;;
    latency|l)
      new_strategies+=" latency"
    ;;
    throughput|t)
      new_strategies+=" throughput"
    ;;
    crt)
      new_strategies+=" cached reliable throughput"
    ;;
    crl)
      new_strategies+=" cached reliable latency"
    ;;
    *)
      err "Invalid strategy: $strategy"
      return 1
    ;;
  esac
done
strategies=${new_strategies# }
}

load_context() {
local f=$cube_path
local parent=$(realpath "${f%/*}")
handler_folders=( )

if [[ "${parent##*/work}" != $parent ]]; then
  load_context_before "$parent" || return 1
fi

[[ -f "$f/cube-context-before" ]] && source "$f/cube-context-before"
[[ -f "$f/cube-context" ]] && source "$f/cube-context"
[[ -f "$f/cube-context-after" ]] && source "$f/cube-context-after"
[[ -d "$f/handlers" ]] && handler_folders+=( "$f/handlers" )

if [[ "${parent##*/work}" != $parent ]]; then
  load_context_after "$parent" || return 1
fi

return 0
}

load_context_before() {
local f=$1 
local parent=${f%/*}
if [[ "${parent##*/work}" != $parent ]]; then
  load_context_before "$parent" || return 1
fi
[[ -f "$f/cube-context-before" ]] && source "$f/cube-context-before"
return 0
}

load_context_after() {
local f=$1 
local parent=${f%/*}
[[ -f "$f/cube-context-after" ]] && source "$f/cube-context-after"
[[ -d "$f/handlers" ]] && handler_folders+=( "$f/handlers" )
if [[ "${parent##*/work}" != $parent ]]; then
  load_context_after "$parent" || return 1
fi
return 0
}

execute_update_copy() {
if [[ "$cube_in_path" && "$out_path" ]]; then
  rsync -a --exclude='*.safe' $cube_in_path/ $out_path.new/ || return 1
fi
if [[ "$in_path" && "$out_path" ]]; then
  rsync -a --exclude='*.safe' $in_path/ $out_path.new/ || return 1
fi
return 0
}

# should only be called if there are dimensions remaining to be pivoted. 
# Otherwise cell_update should be called.
cube_update_pivot() {

local index=$1
local dim=${dimensions[$index]} 
local dim_file=${dimension_files[$index]}
local processes=

trace $log_trace2 "Pivoting $short_cube: $dim"
begin_function_flat

  get_dim_functions || fail
  expand_values || fail
  cube_update_pivot_values || fail
  wait_for_sub_processes || fail

end_function_flat
handle_return
}

cube_update_pivot_values() {
trace $log_trace2 "Pivoting over values of $dim: ${values[*]}"
begin_function_flat

  local parallel=f
  if [[ "${#values[*]}" -gt 1 && "$parallel_execution" == t ]]; then
    parallel=t
    wait_for_low_load || fail
  fi

  local value
  begin_for value in "${values[@]}"; doo
    eval "$dim='$value'"
    eval "d_$dim='$value'"
    if [[ ${#dimensions[*]} -gt $((index + 1)) ]]; then
      if [[ $parallel == t ]]; then
        cube_update_pivot $((index + 1)) &
        processes+=" $!"
      else
        cube_update_pivot $((index + 1)) || fail
      fi
    else
      if [[ $parallel == t ]]; then
        cell_update &
        processes+=" $!"
      else
        ( cell_update ) || fail
      fi
    fi
  end_for

end_function_flat
handle_return
}

# guaranteed to run in a subshell
cell_update() {

lock_timeout=${lock_timeout:-30} \

debug_path= in_path= cube_in_path= up_path= cube_up_path= \
cube_down_path= down_path= lock_path= cube_log_path= \
log_path= status_path= cube_status_path= out_path= tmp_path= cleanup_on_exit= \
cell_id= dim_string= cell_path= cube_up_before_path= up_before_path=

setup_exit_trap

get_cell_id || return 1
trace $log_info "Updating cell $short_cube $dim_string"

begin_function

  local start_time=$EPOCHSECONDS
  cell_feature_setup || fail
  cell_validate || fail

  if [[ "$cube_up_before_path" ]]; then
    new_stage update-deps-before || fail
    cell_update_deps_before || fail
    # TODO if this changed, must refresh the up folder below
  fi

  if [[ "$cube_up_path" && "$cube_up_path" -nt "$up_path" ]]; then
    if [[ -d $up_path ]]; then
      rm -r $up_path || fail
    fi
    mkdir $up_path || fail
    cell_setup_up || { rm -r $up_path; fail1; }
  fi

  if [[ "$cube_down_path" && "$cube_down_path" -nt "$down_path" ]]; then
    if [[ -d $down_path ]]; then
      rm -r $down_path || fail
    fi
    mkdir $down_path || fail
    cell_setup_down || { rm -r $down_path; fail1; }
  fi

  if [[ ${#cell_storage[*]} -gt 0 ]]; then
    handle_cell_storage || fail
  fi

  local maybe_deps_changed \
        local_inputs_changed \
        not_fresh \
        always_update \
        local_failure=f \
        has_lock=f \
        update_successful=f \
        need_update \
        deps_updated_successfully=t \
        cell_was_changed=f

  does_cell_need_update $cell_path || fail
  if [[ $needs_update == t ]]; then
    local consecutive_failures=${consecutive_failures:-0} \
          upstream_changed=f
    cell_pre_update || fail
    if [[ $needs_update == t || $force_update == t ]]; then
      if [[ $needs_update == f && $force_update == t ]]; then
        trace $log_info "Forcing update even though it's not needed"
      fi
      cell_execute_update || fail
    fi
    cell_post_update || fail
  else
    trace $log_trace "Update not needed"
    update_successful=t
  fi

  cell_handle_output || fail

end_function
handle_return

}

handle_cell_storage() {

trace $log_trace2 "Handling cell storage"
begin_function

  local storage_index var_name var_default storage_count=${#cell_storage[*]} \
    value update_value

  if [[ ! "$in_path" ]]; then
    in_path=$cube_path/cell-in/$cell_id
    mkdir -p $in_path || return 1
    for ((storage_index=0; storage_index < storage_count; storage_index+=2)); do
      var_name=${cell_storage[$storage_index]}
      var_default=${cell_storage[$((storage_index+1))]}
      if [[ "$var_default" ]]; then
        echo "$var_default" >$in_path/$var_name || return 1
      fi
    done
  fi

  for ((storage_index=0; storage_index < storage_count; storage_index+=2)); do

    var_name=${cell_storage[$storage_index]}
    update_value=f
    eval "value=\${p_$var_name:-}"

    # TODO .safe var names should be encrypted
    local previous_value= new_value=
    if [[ -f $in_path/$var_name ]]; then
      previous_value=$(<$in_path/$var_name)
      new_value=$previous_value
    fi

    if [[ "$value" && "$previous_value" != "$value" ]]; then
      echo "$value" >$in_path/$var_name || return 1
      new_value=$value
      touch $in_path || return 1
    fi

    if [[ "$new_value" ]]; then
      eval "$var_name=\$new_value"
      eval "s_$var_name=\$new_value"
    else
      err "Required parameter $var_name is missing. Set it on the commandline."
      fail1
    fi

  done

end_function
handle_return

}

cell_handle_output() {
begin_function
  if [[ $update_successful == t ]]; then
    case $view in
      default)
        if [[ -f $out_path/output ]]; then
          cat $out_path/output || fail
          echo
        fi
      ;;
    esac
  else
    if [[ -f $out_path/error ]]; then
      cat $out_path/error || fail
      echo
    fi
    fail1
  fi
end_function
handle_return
}

cell_post_update() {

begin_function

  new_stage complete || fail
  local end_time=$EPOCHSECONDS
  local duration_of_update=$((end_time-start_time))

  if [[ "$status_path" ]]; then
    local avg_duration_short=${avg_duration_short:-$duration_of_update} \
          avg_duration_long=${avg_duration_long:-$duration_of_update} \
          avg_failure_rate_short=${avg_failure_rate_short:-0} \
          avg_failure_rate_long=${avg_failure_rate_long:-0} \
          max_duration_short=${max_duration_short:-0} \
          max_duration_short_age=${max_duration_short_age:-0} \
          max_duration_long=${max_duration_long:-0} \
          max_duration_long_age=${max_duration_long_age:-0} \
          cube_avg_duration_short=${cube_avg_duration_short:-$duration_of_update} \
          cube_avg_duration_long=${cube_avg_duration_long:-$duration_of_update} \
          cube_avg_failure_rate_short=${cube_avg_failure_rate_short:-0} \
          cube_avg_failure_rate_long=${cube_avg_failure_rate_long:-0} \
          cube_max_duration_short=${cube_max_duration_short:-0} \
          cube_max_duration_short_age=${cube_max_duration_short_age:-0} \
          cube_max_duration_long=${cube_max_duration_long:-0} \
          cube_max_duration_long_age=${cube_max_duration_long_age:-0} \
          sample_count=${sample_count:-0} \
          update_id=1000 \
          cube_sample_count=${cube_sample_count:-0}
    read_persist_file || fail
    read_cube_persist_file || fail
  fi

  if [[ $update_successful == t ]]; then

    trace $log_info "Update successful."

    if [[ -d "$out_path.new" ]]; then

      if [[ -d "$out_path" ]]; then
        if files_are_different -r "$out_path" "$out_path.new" >/dev/null; then
          [[ -d "$out_path.old" ]] && rm -r "$out_path.old"
          mv "$out_path" "$out_path.old" || fail
          mv "$out_path.new" "$out_path" || fail
          if [[ ! "$debug_path" ]]; then
            rm -r "$out_path.old" || fail
          fi
          cell_was_changed=t
        else
          rm -r "$out_path.new" || fail
        fi
      else
        mv "$out_path.new" "$out_path" || fail
        cell_was_changed=t
      fi

      if [[ $ignore_fresh == f ]]; then
        touch -d @$start_time $status_path/freshness || fail
      fi

    fi

    if [[ "$tmp_path" && -d "$tmp_path" && ! "$debug_path" ]]; then
      rm -r "$tmp_path" || fail
    fi

    consecutive_failures=0

    if [[ "$status_path" ]]; then
      if [[ $debugging == f ]]; then
        update_max_duration max_duration_short 10
        update_max_duration max_duration_long 100
        update_max_duration cube_max_duration_short 10
        update_max_duration cube_max_duration_long 100
        let 'avg_duration_short = (avg_duration_short * 9 + duration_of_update * 1000) / 10'
        let 'avg_duration_long = (avg_duration_long * 99 + duration_of_update * 1000) / 100'
        let 'cube_avg_duration_short = (cube_avg_duration_short * 9 + duration_of_update * 1000) / 10'
        let 'cube_avg_duration_long = (cube_avg_duration_long * 99 + duration_of_update * 1000) / 100'
      fi

      let 'avg_failure_rate_short = (avg_failure_rate_short * 9) / 10'
      let 'avg_failure_rate_long = (avg_failure_rate_long * 99) / 100'
      let 'cube_avg_failure_rate_short = (cube_avg_failure_rate_short * 9) / 10'
      let 'cube_avg_failure_rate_long = (cube_avg_failure_rate_long * 99) / 100'
    fi
    let cube_sample_count++
    let sample_count++

  else

    trace $log_warn "Update of $short_cube cell $cell_id failed."
    if [[ $local_failure == t ]]; then
      let consecutive_failures++
      if [[ "$cube_status_path" ]]; then
        let 'avg_failure_rate_short = (avg_failure_rate_short * 9 + 1000) / 10'
        let 'avg_failure_rate_long = (avg_failure_rate_long * 99 + 1000) / 100'
        let 'cube_avg_failure_rate_short = (cube_avg_failure_rate_short * 9 + 1000) / 10'
        let 'cube_avg_failure_rate_long = (cube_avg_failure_rate_long * 99 + 1000) / 100'
      fi
      let cube_sample_count++
      let sample_count++
    fi

  fi

  if [[ "$status_path" ]]; then
    write_persist_file || fail
    write_cube_persist_file || fail
  fi

  if [[ "$log_path" ]]; then

    local success_string=good
    [[ $update_successful == f ]] && success_string=bad
    echo "update_id=$update_id start=$start_time duration=$duration_of_update from=$called_from" \
      "result=$success_string changed=$cell_was_changed" >>$log_path/history || fail
    echo "update_id=$update_id start=$start_time duration=$duration_of_update from=$called_from" \
      "result=$success_string changed=$cell_was_changed $dim_string" >>$cube_log_path/history || fail

    untee_output || fail

    if [[ "$debug_path" ]]; then
      mv $log_path/update-log-id-* $debug_path/ &>/dev/null
      mv $log_path/stage-timing-id-* $debug_path/ &>/dev/null
    else
      rm $log_path/update-log-id-* &>/dev/null
      rm $log_path/stage-timing-id-* &>/dev/null
    fi

    mv $log_path/update-log-current $log_path/update-log-id-$update_id || fail
    ln -f $log_path/update-log-id-$update_id $log_path/update-log-last-$success_string || fail
    mv $log_path/stage-timing-current $log_path/stage-timing-id-$update_id || fail
    ln -f $log_path/stage-timing-id-$update_id $log_path/stage-timing-last-$success_string || fail

  fi

  if [[ $update_successful == t ]]; then
    if [[ -f $status_path/upstream-changed ]]; then
      rm $status_path/upstream-changed || fail
    fi
    if [[ $cell_was_changed == t ]]; then
      trace $log_trace2 "Notifying downstream cells of change"
      notify_downstream_of_change $cell_path || fail
    fi
    touch $status_path/updated || fail
  fi

  if [[ $has_lock == t ]]; then
    trace $log_trace "Releasing lock $lock_path"
    folder_to_unlock=$lock_path pid_file=$lock_path/pid folder_unlock || fail
  fi

end_function
handle_return

}

update_max_duration() {
local var=$1
local window=$2
local age_var=${var}_age
if [[ $duration_of_update -gt ${!var} ]]; then
  eval "$var=$duration_of_update; $age_var=0"
elif [[ ${!age_var} -gt $window ]]; then
  eval "let $var=($var+$duration_of_update)/2; $age_var=0"
else
  eval "let $age_var++"
fi
}

notify_downstream_of_change() {
begin_function
  local cell=$1 down_cell down_cube
  if [[ -d $cell/down ]]; then
    begin_for down_cube in $(find1 $cell/down); doo or_fail
    begin_for down_cell in $(find1 $down_cube); doo or_fail
      if [[ ! -e $down_cell ]]; then
        trace $log_trace "Removing broken link: $down_cell"
        rm $down_cell || fail
      elif [[ ! -f $down_cell/status/upstream-changed ]]; then
        local nice_down_cell=
        should_trace && nice_down_cell=$(realpath $down_cell)
        trace $log_trace2 "Notifying ${nice_down_cell#*/work/} of change"
        if [[ ! -d $down_cell/status ]]; then
          mkdir -p $down_cell/status || fail
        fi
        touch $down_cell/status/upstream-changed || fail
        local cube
        get_cube $down_cell || fail
        local min_fresh_file=$cube/status/min-upstream-freshness
        if [[ -f $min_fresh_file ]]; then
          rm $min_fresh_file || fail
        fi
        # recursive
        notify_downstream_of_change $down_cell || fail
      fi
    true; end_for
    true; end_for
  fi
end_function
handle_return
}

read_persist_file() {
if [[ -e $status_path/persist ]]; then
  source $status_path/persist || fail
fi
return 0
}

read_cube_persist_file() {
if [[ -e $cube_status_path/persist ]]; then
  source $cube_status_path/persist || fail
fi
return 0
}

cell_execute_update() {
trace $log_info "Executing update"
begin_function
  if type execute_update &>/dev/null; then
    new_stage execute-update || fail
    local rc delay=$retry_delay
    for ((retry=0; retry < retry_max; retry++)); do
      execute_update; rc=$?
      case $rc in
        $failed_but_can_retry)
          [[ $retry -lt $((retry_max-1)) ]] && trace $log_info "execute_update failed. Will retry"
        ;;
        $everythings_fine)
          update_successful=t
          break
        ;;
        *)
          trace $log_warn "execute_update returned $rc"
          break
        ;;
      esac
      trace $log_info "Waiting $delay seconds before retrying."
      sleep $delay
      let 'delay *= retry_scale'
    done
  else
    update_successful=t
  fi
  if [[ $update_successful == f ]]; then
    local_failure=t
  fi
end_function
handle_return
}

cell_pre_update() {

begin_function

  if [[ "$log_path" ]]; then
    tee_output_to $log_path/update-log-current || fail
  fi

  new_stage begin-update || fail

  if [[ -d $out_path.new ]]; then 
    rm -r $out_path.new || fail
  fi
  if [[ "$out_path" ]]; then
    mkdir $out_path.new || fail
  fi

  if [[ $maybe_deps_changed == t && "$cube_up_path" ]]; then
    new_stage update-deps || fail
    cell_update_deps || { needs_update=f; update_successful=f; }
  fi

  if [[ $needs_update == t ]]; then

    if [[ "$status_path" ]]; then

      read_persist_file || fail

      if [[ "${update_id:-}" ]]; then
        let update_id++
      fi

      maybe_apply_cooldown || fail

    fi

    if [[ "$lock_path" && $has_lock == f ]]; then
      trace $log_trace "Getting write lock for cell"
      new_stage write-lock-cell || fail
      folder_to_lock=$lock_path timeout=$lock_timeout pid_file=$lock_path/pid folder_lock || fail
      has_lock=t
    fi

    if [[ "$up_path" ]]; then
      local cell_up_dep
      if [[ ! -d $up_path ]]; then
        err "Internal error: invalid up_path=$up_path"
        stack_trace
        fail1
      fi

      begin_for cell_up_dep in $(find1 $up_path); doo or_fail
        handle_cube_reply $cell_up_dep || fail
      true; end_for
    fi

  fi

end_function
handle_return

}

tee_output_to() {
local target=$1
exec 1> >(tee "$target")
exec 2> >(tee -a "$target")
eval "exec $fd_trace> >(tee -a '$target')"
}

untee_output() {
exec 1>&$fd_original_out
exec 2>&$fd_original_err
eval "exec $fd_trace>&$fd_original_trace"
}

maybe_apply_cooldown() {
begin_function
  # If cell recently failed, wait until cooldown period is complete
  if [[ $consecutive_failures -gt 0 ]]; then
    get_cooldown_delay || fail
    if [[ $cooldown_delay -gt 0 ]]; then
      trace $log_warn "Too many errors have occurred, waiting for cooldown period of $cooldown_delay seconds"
      new_stage cooldown || fail
      sleep $cooldown_delay
    fi
  else
    cooldown_delay=1
  fi
end_function
handle_return
}

new_stage() {
local stage=$1
if [[ "${previous_stage:-}" ]]; then
  trace $log_trace2 "Finished stage $previous_stage" \
    "in $(echo "$EPOCHSECONDS - $stage_start_time" | bc) seconds"
fi
[[ "$log_path" ]] && echo "$stage $EPOCHSECONDS" >>"$log_path/stage-timing-current"
trace $log_trace2 "Starting stage $stage"
stage_start_time=$EPOCHSECONDS
previous_stage=$stage
}

write_cube_persist_file() {
echo "\
cube_avg_duration_short=$cube_avg_duration_short
cube_avg_duration_long=$cube_avg_duration_long
cube_avg_failure_rate_short=$cube_avg_failure_rate_short
cube_avg_failure_rate_long=$cube_avg_failure_rate_long
cube_max_duration_short=$cube_max_duration_short
cube_max_duration_short_age=$cube_max_duration_short_age
cube_max_duration_long=$cube_max_duration_long
cube_max_duration_long_age=$cube_max_duration_long_age
cube_sample_count=$cube_sample_count
" >$cube_status_path/persist
}

write_persist_file() {
echo "\
update_id=$update_id
cooldown_delay=${cooldown_delay:-0}
consecutive_failures=$consecutive_failures
avg_duration_short=$avg_duration_short
avg_duration_long=$avg_duration_long
avg_failure_rate_short=$avg_failure_rate_short
avg_failure_rate_long=$avg_failure_rate_long
max_duration_short=$max_duration_short
max_duration_short_age=$max_duration_short_age
max_duration_long=$max_duration_long
max_duration_long_age=$max_duration_long_age
sample_count=$sample_count
" >$status_path/persist
}

cell_update_deps_before() {
trace $log_trace "Updating up-before cells of $short_cube"
begin_function

  local dep 
  local parallel=f processes=

  local deps=( $(find1 "$cube_up_before_path" -type d | sort) )

  begin_for dep in ${deps[*]}; doo
    local dep_name=${dep##*/}
    if [[ $parallel == t ]]; then
      update_dep "$dep" &
      processes+=" $!"
    else
      update_dep "$dep" || fail
    fi
  end_for
  # TODO if anything changed, must refresh other deps somehow

  wait_for_sub_processes || fail

end_function
handle_return
}

cell_update_deps() {
trace $log_trace "Updating upstream cells of $short_cube"
begin_function

  local dep 
  local parallel=f processes=

  local parallel_deps=( $(
    find1 "$cube_up_path" -type d \
      -not -regex "$cube_up_path/[0-9]+-.*" \
      | sort) )

  local serial_deps=( $(
    find1 "$cube_up_path" -type d \
      -regex "$cube_up_path/[0-9]+-.*" \
      | sort) )

  local total_parallel=${#parallel_deps[*]}
  [[ "${serial_deps:-}" ]] && let total_parallel++

  if [[ $total_parallel -gt 1 && $parallel_execution == t ]]; then
    parallel=t
    wait_for_low_load || fail
  fi

  begin_for dep in ${parallel_deps[*]}; doo
    local dep_name=${dep##*/}
    if [[ $parallel == t ]]; then
      update_dep "$dep" &
      processes+=" $!"
    else
      ( update_dep "$dep" ) || fail
    fi
  end_for

  if [[ $parallel == t ]]; then
    cell_update_deps_serial &
    processes+=" $!"
  else
    ( cell_update_deps_serial ) || fail
  fi

  wait_for_sub_processes || fail

end_function
handle_return
}

cell_update_deps_serial() {
for dep in ${serial_deps[*]}; do
  update_dep "$dep" || return 1
done
return 0
}

# inputs: $1 (cell up/{dep} folder)
handle_cube_reply() {
local dep=$1 cell multi dep2
if [[ $dep == ${dep%\?} ]]; then
  # not multipath
  handle_cube_reply_cells $dep || return 1
else
  # multipath dep
  for dep2 in $(find1 $dep); do or_fail
    handle_cube_reply_cells $dep2 || return 1
  true; done
fi
return 0
}

handle_cube_reply_cells() {
for cell in $(find1 $dep); do or_fail
  if [[ -f $cell/out/cell-context ]]; then
    source $cell/out/cell-context || return 1
  fi
  if [[ $cell/out -nt $out_path ]]; then
    upstream_changed=t
  fi
true; done; or_fail
return 0
}

# This performs an update on a dep given a cube dep, not a cell one
update_dep() {
local cube_dep=$1 choice multipath=f
local choices=( $cube_dep ) 
trace $log_trace "Updating dependency $cube_dep"
begin_function

  local cube_dep_name=${cube_dep##*/}
  if [[ $cube_dep == *\? ]]; then
    multipath=t

    local OIFS=$IFS
    IFS=$NL choices=( $(find1 $cube_dep) ); or_fail
    IFS=$OIFS
    local choice_count=${#choices[*]} result results

    if [[ $choice_count == 0 ]]; then
      err 'No choices available for $cube_dep'
      fail1
    elif [[ $choice_count -gt 1 ]]; then
      local i choice_path choice_name choice_cell cells 

      results=( )
      for ((i=0; i<choice_count; i++)); do
        results[$i]=
      done

      local strategy
      trace $log_trace "Computing strategies: $strategies"
      begin_for strategy in $strategies; doo
        if type strategy_$strategy &>/dev/null; then
          begin_for ((i=0; i<choice_count; i++)); doo

            choice="${choices[$i]}"
            choice_name=${choice##*/}
            if [[ $choice_name =~ ^[0-9]+-(.*) ]]; then
              choice_name=${BASH_REMATCH[1]}
            fi

            if [[ ! -d $up_path/$cube_dep_name/$choice_name ]]; then
             err "Invalid choice: $choice_cell"
             fail1
            fi

            choice_cell=$up_path/$cube_dep_name/$choice_name/only
            if [[ ! -d $choice_cell ]]; then
              local cells=( $(find1 ${choice_cell%/*}) )
              if [[ ${#cells[*]} -lt 2 ]]; then
                err "Invalid up_path: $choice_cell, will attempt to repair."
                err "Rerun this update to see if it worked."
                rm -r $up_path || fail
                fail1
              else
                incomplete "Can't handle multiple cells in a multi-path dependency yet: $choice_cell"
              fi
            fi

            result=${results[$i]}
            strategy_$strategy || fail
            results[$i]=$result

          end_for
        else
          err "Missing strategy function: strategy_$strategy"
          fail1
        fi
      end_for

      for ((i=0; i<choice_count; i++)); do
        results[$i]+=" ${choices[$i]}$NL"
      done
      #results[0]=" ${results[0]}" # necessary to align results for echo command
      OIFS=$IFS IFS=$NL choices=( $(echo "${results[*]}" | sort) ) IFS=$OIFS

      # avoid strategy starvation by occasionally allowing the underdog to be on top
      if [[ $((RANDOM % 1000)) -lt $shuffle_chance ]]; then
        local c=${#choices[*]}
        let c--
        OIFS=$IFS IFS=$NL choices=( ${choices[-1]} ${choices[*]:0:$c} ) IFS=$OIFS
        trace $log_trace "Shuffled strategies"
      fi

      trace $log_trace "Strategy results:"
      for ((i=0; i<choice_count; i++)); do
        choice=${choices[$i]}
        trace $log_trace "$choice"
        choices[$i]="${choice##* }"
      done

    fi

  fi

  local chosen= failed new_fresh=${fresh2:-} new_fresh2=
  if [[ $ignore_fresh == t ]]; then
    new_fresh=$fresh new_fresh2=${fresh2:-}
  fi

  # attempt update of each option, until one succeeds
  view= fresh=$new_fresh fresh2=$new_fresh2 \
    called_from=$cube_name parent= 
  begin_for choice in ${choices[*]}; doo
    failed=f
    handle_member_override || fail
    choice_name=$choice cube_update $choice || failed=t
    if [[ $failed == f ]]; then
      chosen=$choice
      break
    fi
  end_for

  if [[ ! "$chosen" ]]; then
    trace $log_warn "Failed to update dependency: $cube_dep"
    fail1
  fi

  if [[ $multipath == t ]]; then
    local chosen_name=${chosen##*/} 
    if [[ $chosen_name =~ ^[0-9]+-(.*) ]]; then
      chosen_name=${BASH_REMATCH[1]}
    fi
    local target=$up_path/${cube_dep_name%\?}
    safe_link $up_path/$cube_dep_name/$chosen_name $target || fail
    trace $log_info "Chose $chosen_name for $cube_dep"
  fi

end_function
handle_return
}

# Does a given dependency already have fresh data?
# input: result choice_cell
# output: result
strategy_cached() {
trace $log_trace "Calculating cached score for $choice"
begin_function

  local needs_update cube_path= out_path= in_path= cube_in_path= status_path= \
    up_before_path= up_path= cube_up_before_path= cube_up_path= \
    cube_status_path=
  setup_path_vars $choice_cell || fail
  does_cell_need_update $choice_cell || fail

  if [[ $needs_update == t ]]; then
    result+=" 1"
  else
    result+=" 0"
  fi

end_function
handle_return
}

# Computes the error rate of a given dependency?
# input: result choice_cell
# output: result
strategy_throughput() {
trace $log_trace "Calculating throughput score for $choice"
begin_function

  local avg_duration=0

  if [[ -e $choice_cell/status/persist ]]; then
    source $choice_cell/status/persist || fail
  fi

  if [[ -e $choice/status/persist ]]; then
    source $choice/status/persist || fail
  fi

  if [[ ${sample_count:-0} -lt 3 ]]; then
    avg_duration=${cube_avg_duration_long:-0}
  else
    avg_duration=${avg_duration_long:-0}
  fi

  result+=" $(printf "%04d" $avg_duration)"

end_function
handle_return
}

# Computes the error rate of a given dependency?
# input: result choice_cell
# output: result
strategy_latency() {
trace $log_trace "Calculating latency score for $choice"
begin_function

  local max_duration=0

  if [[ -e $choice_cell/status/persist ]]; then
    source $choice_cell/status/persist || fail
  fi

  if [[ -e $choice/status/persist ]]; then
    source $choice/status/persist || fail
  fi

  if [[ ${sample_count:-0} -lt 3 ]]; then
    max_duration=${cube_max_duration_long:-0}
  else
    max_duration=${max_duration_long:-0}
  fi

  result+=" $(printf "%04d" $max_duration)"

end_function
handle_return
}

# Computes the error rate of a given dependency?
# input: result choice_cell
# output: result
strategy_reliable() {
trace $log_trace "Calculating reliable score for $choice"
begin_function

  local avg_fail_rate=0

  if [[ -e $choice_cell/status/persist ]]; then
    source $choice_cell/status/persist || fail
  fi

  if [[ -e $choice/status/persist ]]; then
    source $choice/status/persist || fail
  fi

  if [[ ${sample_count:-0} -lt 3 ]]; then
    avg_fail_rate=${cube_avg_failure_rate_short:-0}
  else
    avg_fail_rate=${avg_failure_rate_short:-0}
  fi

  result+=" $(printf "%04d" $avg_fail_rate)"

end_function
handle_return
}

# input: parallel processes
wait_for_sub_processes() {
if [[ "$processes" ]]; then
  trace $log_info "Waiting for sub processes to complete"
  local process last_err_code= last_failed_process= rc
  for process in $processes; do
    trace $log_trace "Waiting for process $process"
    wait $process &>/dev/null; rc=$?
    if [[ $rc -gt 0 && $rc -lt 127 ]]; then
      if [[ ! "$last_err_code" ]]; then
        last_err_code=$rc
        last_failed_process=$process
      else
        trace $log_warn "Subprocess $process failed to terminate successfully"
        return 1
      fi
    fi
  done
  if [[ "$last_err_code" ]]; then
    if [[ "$last_err_code" == 1 ]]; then
      trace $log_warn "Subprocess $last_failed_process failed to terminate successfully"
      return 1
    fi
    return $last_err_code
  fi
fi
return 0
}

wait_for_low_load() {
local cube_max_load=${cube_max_load:-10}
local cube_load_wait_timeout=${cube_load_wait_timeout:-600}
local current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
if [[ $current_load -gt $cube_max_load ]]; then
  trace $log_warn "Load average is too high ($current_load > $cube_max_load)," \
    "waiting until things cool down first."
  local time_waited=0
  while [[ $current_load -gt $cube_max_load ]]; do
    current_load=$(uptime | sed -E 's/.*average: ([0-9]*).*/\1/')
    sleep 5; let time_waited+=5
    if [[ "$cube_load_wait_timeout" -gt 0 && $time_waited -ge $cube_load_wait_timeout ]]; then
      err "Timed out waiting for cpu load to be low enough. Aborting"
      return 1
    fi
  done
fi
return 0
}

does_cell_need_update() {
local cell_path=$1
  
trace $log_trace "Checking if update is needed for ${cell_path#*/work/}"
begin_function

  needs_update=t local_inputs_changed=t maybe_deps_changed=t not_fresh=t always_update=f

  if [[ ! "$out_path" ]]; then
    trace $log_trace "This cube is a trigger, will always update"
    always_update=t
    local_inputs_changed=f
  elif [[ "$out_path" && ! -d "$out_path" ]]; then
    trace $log_trace "Out path is missing, needs update"
  elif [[ "$in_path" && "$in_path" -nt "$status_path/updated" 
    || "$cube_in_path" && "$cube_in_path" -nt "$status_path/updated"
    ]]; then
    trace $log_trace "Local changes were made, needs update"
  elif [[ $cube_path/cube-context -nt $status_path/updated ]]; then
    trace $log_trace "cube-context has changed, needs update"
  elif [[ $cube_path/cube-vars -nt $status_path/updated ]]; then
    trace $log_trace "cube-vars has changed, needs update"
  else
    local_inputs_changed=f
  fi

  if [[ "${fresh2:-}" ]]; then
    trace $log_trace "Fresh2 is set, so forcing update of upstream"
  elif [[ "$up_before_path" && 
       ( "$up_before_path" -nt "$status_path/updated" 
       || "$cube_up_before_path" -nt "$status_path/updated" 
       || -f $status_path/upstream-changed 
       )
       ]]; then
    trace $log_trace "Up-before changes were made, needs update"
  elif [[ "$up_path" && 
       ( "$up_path" -nt "$status_path/updated" 
       || "$cube_up_path" -nt "$status_path/updated" 
       || -f $status_path/upstream-changed 
       ) 
       ]]; then
    trace $log_trace "Upstream changes were made, needs update"
  else
    maybe_deps_changed=f
  fi

  if [[ "$out_path" ]]; then
    if [[ $fresh == inf ]]; then
      not_fresh=f
    elif [[ $fresh != 0 ]]; then

      local fresh_seconds
      convert_to_seconds $fresh fresh_seconds || fail
      local fresh_cutoff=$((EPOCHSECONDS-fresh_seconds))
      local out_timestamp=
      if [[ -f $status_path/freshness ]]; then
        out_timestamp=$(date -r $status_path/freshness +%s)
      fi

      if [[ $ignore_fresh == f 
        && ( ! "$out_timestamp" || $out_timestamp -lt $fresh_cutoff )
        ]]; then

        trace $log_trace "Freshness requirement ($fresh) not met, needs update"

      else

        local min_upstream_freshness=inf

        if [[ ! -f $cube_status_path/min-upstream-freshness ]]; then
          derive_min_upstream_freshness "$up_path" || fail
          echo "min_upstream_freshness=$min_upstream_freshness" >$cube_status_path/min-upstream-freshness || fail
        else
          source $cube_status_path/min-upstream-freshness || fail
        fi

        if [[ $min_upstream_freshness != inf ]]; then
          fresh_cutoff=$((EPOCHSECONDS-min_upstream_freshness))
          if [[ $out_timestamp -lt $fresh_cutoff ]]; then
            trace $log_trace "Freshness requirement ($fresh) not met because of upstream, needs update"
          else
            not_fresh=f
          fi
        else
          not_fresh=f
        fi

      fi
    fi

  else
    not_fresh=f
  fi

  if [[ $maybe_deps_changed == f && $local_inputs_changed == f && $not_fresh == f && $always_update == f ]]; then
    needs_update=f
  fi

end_function
handle_return
}

# input: $1 (up_path of a cell to be analyzed)
# output: min_upstream_freshness
derive_min_upstream_freshness() {
local up_path=$1
[[ ! "$up_path" || ! -d "$up_path" ]] && return 0
begin_function

  local cube default_fresh=inf \
        result
  get_cube $(realpath $up_path) || fail
  local cube_status_path=$cube/status

  if [[ -f $cube/cube-vars ]]; then
    source $cube/cube-vars || fail
  fi

  if [[ -f $cube_status_path/min-upstream-freshness ]]; then
    local prev=$min_upstream_freshness
    source $cube_status_path/min-upstream-freshness || fail
    min $min_upstream_freshness $prev || fail
    min_upstream_freshness=$result
    succeed
  fi

  if [[ $default_fresh != inf ]]; then
    local default_fresh_seconds
    convert_to_seconds $default_fresh default_fresh_seconds || fail
    min $min_upstream_freshness $default_fresh_seconds || fail
    min_upstream_freshness=$result
  fi

  local group dep

  begin_for group in $(find1 $up_path -name '*\?' -type d); doo or_fail
    begin_for dep in $(find1 $group -type d); doo or_fail
      derive_min_upstream_freshness_handle_group $dep || fail
    true; end_for
  true; end_for

  begin_for dep in $(find1 $up_path -not -name '*\?' -type d); doo or_fail
    derive_min_upstream_freshness_handle_group $dep || fail
  true; end_for

  echo "min_upstream_freshness=$min_upstream_freshness" >$cube_status_path/min-upstream-freshness || fail

end_function
handle_return
}

derive_min_upstream_freshness_handle_group() {
local dep=$1 cell cube
for cell in $(find1 $dep -type d); do or_fail
  # recursive
  derive_min_upstream_freshness $cell/up || return 1
true; done
return 0
}

cube_validate() {

begin_function

  if [[ "$require_fresh_greater_than" ]]; then
    local require_seconds fresh_seconds
    convert_to_seconds $require_fresh_greater_than require_seconds || fail
    convert_to_seconds $fresh fresh_seconds || fail
    if [[ $fresh_seconds -lt $require_seconds ]]; then
      if [[ $called_from != cli ]]; then
        log $log_info "Freshness is too strict for this cube: $fresh < $require_fresh_greater_than. Try a different freshness or cube."
        return_value=$skip
        break_out=t
        break
      else
        err "Freshness is too strict for this cube: $fresh < $require_fresh_greater_than. Try a different freshness or cube."
        fail1
      fi
    fi
  fi

  local missing_dims=
  if ! validate_members; then
    if [[ $called_from != cli ]]; then
      trace $log_trace "Dims for this cube aren't valid. Maybe we can try another."
      return_value=$skip
      break_out=t
      break
    else
      err "Missing or invalid parameters:$missing_dims"
      fail1
    fi
  fi

end_function
handle_return

}

# usually this doesn't need to be overridden, since it uses expand_members to determine if it's valid
validate_members() {
local out= i count=${#dimensions[*]} dim dims
for ((i=0; i<count; i++)); do
  local dim=${dimensions[$i]}
  local dim_file=${dimension_files[$i]}
  local dims=${dim}s
  local value=
  get_dim_functions || return 1
  invalid=f
  if [[ "${!dim:-}" ]]; then
    value=${!dim} result_var=out expand_member || invalid=t
  elif [[ "${!dims:-}" ]]; then
    value=${!dims} result_var=out expand_members || invalid=t
  fi
  if [[ ! "$out" || $invalid == t ]]; then
    missing_dims+=" $dim"
  fi
done
if [[ "$missing_dims" ]]; then
  return 1
fi
return 0
}

cell_validate() {

begin_function

  if ! are_cell_params_valid; then
    err "Invalid parameters."
    fail1
  fi

  if ! is_cell_id_valid; then
    trace $log_trace "Skipping cell because of mismatching cell id: $cell_id"
    return_value=$skip
    break_out=t
    break
  fi

end_function
handle_return

}

init_context() {

  # default_fresh should be set in cube-vars file instead of cube-context, since cube-context is
  #   only read during an update, and cube-vars can be checked during a needs-update check
  # inf means infinite (never refresh based on time). 30s means refresh if it is older than 30 seconds.
  # 1w means refresh if it's older than a week.
  default_fresh=inf \
  require_fresh_greater_than= \
  retry_max=1 \
  retry_delay=1 \
  retry_scale=2 \
  cube_expiration= \
  high_volume_cube=f \
  # whether freshness is used to determine if a cell needs to be updated
  ignore_fresh=f \
  default_strategies=crl \
  # contains pairs of var_name/default values used to store data in this cell
  cell_storage=() \
  # chance out of 1000 of not following the computed strategy order
  shuffle_chance=100 \
  force_update=${p_force_update:-f} \
  features=

  # override this if there are parameter requirements that must be met before attempting to update the cell
  are_cell_params_valid() {
    return 0
  }

  # override this if there are some cell id combinations which are not valid even when
  # composed of valid dim members
  # returns 1 if it's not a valid combination of members
  is_cell_id_valid() {
    return 0
  }

  # this may be overridden to provide a custom cooldown calculation
  get_cooldown_delay() {
    [[ -z "${cooldown_delay:-}" ]] && cooldown_delay=1
    let cooldown_delay*=2
  }

  # override this to implement custom update logic
  execute_update() {
    if [[ "$out_path" ]]; then
      execute_update_decrypt || return 1
      execute_update_copy || return 1
    fi
  }

}

execute_update_decrypt() {
begin_function
  if [[ "$cube_in_path" ]]; then
    execute_update_decrypt_folder $cube_in_path || fail
  fi
  if [[ "$in_path" ]]; then
    execute_update_decrypt_folder $in_path || fail
  fi
end_function
handle_return
}

execute_update_decrypt_folder() {
local path=$1
begin_function
  local need_decrypt ofile file files=
  files+=" $(find -L $path -name '*.safe' -type f)"
  begin_for ofile in $files; doo
    file=${ofile#$path/}
    file=${file%.safe}
    local parent_folder=${file%/*}
    if [[ "$parent_folder" && "$parent_folder" != "$file" ]]; then
      mkdir -p $out_path.new/$parent_folder || fail
    fi
    if [[ -f $out_path/$file && $out_path/$file -nt $ofile ]]; then
      ln $out_path/$file $out_path.new/$file || fail
    else
      from="$ofile" to="$out_path.new/$file" decrypt_file || fail
    fi
  end_for
end_function
handle_return
}

cell_feature_setup() {

begin_function

  cell_path=$cube_path/cell/$cell_id
  if [[ ! -d $cell_path ]]; then
    mkdir -p $cell_path || fail
    local dim cell_dim_path=$cell_path/dims value
    [[ -e $cell_dim_path ]] && { rm $cell_dim_path || fail; }
    for dim in "${dimensions[@]}"; do
      value="${!dim}"
      echo "$dim='$value'"
    done >>$cell_dim_path || fail
  fi

  setup_path_vars $cell_path || fail

  [[ ! -d $status_path ]] && { mkdir $status_path || fail; }
  [[ ! -d $cube_status_path ]] && { mkdir $cube_status_path || fail; }

  local feature
  for feature in ${features:-}; do
    case $feature in
      debug)
        debug_path=$cell_path/debug
        [[ ! -d $debug_path ]] && { mkdir -p $debug_path || fail; }
      ;;
      lock)
        lock_path=$cell_path/lock
      ;;
      out)
        out_path=$cell_path/out
      ;;
      log)
        log_path=$cell_path/log
        cube_log_path=$cube_path/log
        [[ ! -d $log_path ]] && { mkdir -p $log_path || fail; }
        [[ ! -d $cube_log_path ]] && { mkdir -p $cube_log_path || fail; }
      ;;
      *)
        err "Unknown feature '$feature'"
        fail1
      ;;
    esac
  done

end_function
handle_return

}

setup_path_vars() {
cell_path=$(realpath $1)
local cube
get_cube $cell_path || return 1
cube_path=$cube

if [[ -f $cube_path/cube-vars ]]; then
  source $cube_path/cube-vars || return 1
fi

if [[ -d $cube_path/in ]]; then
  cube_in_path=$cube_path/in
fi

if [[ -d $cube_path/cell-in/$cell_id ]]; then
  in_path=$cube_path/cell-in/$cell_id
fi

if [[ -d $cube_path/up-before ]]; then
  cube_up_before_path=$cube_path/up-before
  up_before_path=$cell_path/up-before
fi

if [[ -d $cube_path/up ]]; then
  cube_up_path=$cube_path/up
  up_path=$cell_path/up
fi

if [[ -d $cube_path/down ]]; then
  cube_down_path=$cube_path/down
  down_path=$cell_path/down
fi

status_path=$cell_path/status
cube_status_path=$cube_path/status

# created on demand
tmp_path=$cell_path/tmp

}

cell_setup_up() {

trace $log_trace "Setting up 'up' folder for cell"
begin_function

  local dep_name target group
  begin_for group in $(find1 $cube_up_path -name '*\?'); doo or_fail
    dep_name=${group##*/}
    target=$up_path/$dep_name
    mkdir $target || fail
    cell_setup_x_deps up $group $target || fail
  true; end_for

  cell_setup_x_deps up $cube_up_path $up_path || fail

end_function
handle_return

}

cell_setup_down() {

trace $log_trace "Setting up 'down' folder for cell"
begin_function

  cell_setup_x_deps down $cube_down_path $down_path || fail

end_function
handle_return

}

cell_setup_x_deps() {

begin_function_flat

  local direction=$1; shift
  local cube_x_path=$1; shift
  local cell_x_path=$1
  
  local dep dep_name target cell_ids dep_cell_id
  begin_for dep in $(find1 $cube_x_path -not -name '*\?'); doo or_fail

    if [[ ! -f $dep/cube-context ]]; then
      err "$dep is not a cube"
      fail1
    fi

    dep_name=${dep##*/}
    local real_dep=$(realpath $dep)

    if [[ $direction == up ]]; then
      if [[ ! -e $dep/down/$cube_name ]]; then
        if [[ ! -d $dep/down ]]; then
          mkdir $dep/down || fail
        fi
        trace $log_trace "Creating cube down link: $dep/down/$cube_name"
        safe_link $real_dep $dep/down/$cube_name || fail
      fi
    fi

    local cell_dep_name=$dep_name
    if [[ $cell_dep_name =~ ^[0-9]+-(.*) ]]; then
      cell_dep_name=${BASH_REMATCH[1]}
    fi
    target=$cell_x_path/$cell_dep_name
    mkdir $target || fail
    get_cell_ids $dep || fail

    local link_count=0
    begin_for dep_cell_id in $cell_ids; doo

      local x_cell=$real_dep/cell
      if [[ ! -d $x_cell ]]; then
        err "Internal error: folder doesn't exist: $x_cell"
        fail1
      fi
      x_cell+=/$dep_cell_id
      if [[ ! -d $x_cell ]]; then
        mkdir $x_cell || fail
      fi

      safe_link $x_cell $target/ || fail

      if [[ $direction == up ]]; then

        local up_down_path=$x_cell/down/$cube_name/$cell_id

        if [[ ! -e $up_down_path ]]; then
          if [[ ! -d $x_cell/down/$cube_name ]]; then
            mkdir -p $x_cell/down/$cube_name || fail
          fi
          safe_link $cell_path $up_down_path || fail
        fi

        if [[ $link_count == 0 ]]; then
          safe_link $x_cell $target/only || fail
        elif [[ $link_count == 1 ]]; then
          rm $target/only || fail
        fi

      fi

      let link_count++

    end_for

  true; end_for

end_function_flat
handle_return

}

# inputs: $1 (cube)
# outputs: cell_ids
get_cell_ids() {
begin_function
  local cube_path=$1 
  local short_cube=${cube_path##*/work/}
  cell_ids=
  local dimensions localize_dim_vars dim_string cell_id
  gather_dims || fail
  if [[ ${#dimensions[*]} -eq 0 ]]; then
    cell_ids=only
    succeed
  else
    eval "$localize_dim_vars" || fail
    if [[ "${choice_name:-}" ]]; then
      handle_member_override || fail
    fi
    get_cell_ids_pivot 0 || fail
  fi
  cell_ids=${cell_ids# }
end_function
handle_return
}

handle_member_override() {
local override_function=override_members_of_${choice_name//-/_}
if type $override_function &>/dev/null; then
  # used by the child/downstream cell to alter the members of an upstream cell
  $override_function || return 1
fi
return 0
}

# inputs: $1 (dim index)
# outputs: cell_ids
get_cell_ids_pivot() {
begin_function_flat
  local index=$1 \
        values
  local dim=${dimensions[$index]} \
        dim_file=${dimension_files[$index]} 
  get_dim_functions || fail
  expand_values || fail
  get_cell_ids_pivot_values || fail
end_function_flat
handle_return
}

# inputs: short_cube cube_path
# outputs: dimensions dim_string
gather_dims() {
trace $log_trace2 "Gathering dimensions for $short_cube"
local dimension dimension_file dimension_plural
localize_dim_vars=
dimensions=()
dim_string=
begin_function
  if [[ -d $cube_path/dim ]]; then
    begin_for dimension_file in \
      $(find1 $cube_path/dim -type f | sort); doo
      dimension=${dimension_file##*/}
      dimension=${dimension##*-}
      if [[ ! "$dimension" =~ ^[a-zA-Z0-9_]+$ ]]; then
        err "Invalid dimension name [$dimension] derived from folder $dimension_file"
        err "Dimensions must only have alphanumeric or _ characters in it."
        fail1
      fi
      dimension_plural=${dimension}s
      dimensions+=( $dimension )
      dimension_files+=( "$dimension_file" )
      localize_dim_vars+="local $dimension=\${$dimension:-} $dimension_plural=\${$dimension_plural:-}; "
      if [[ "${!dimension_plural:-}" ]]; then
        dim_string+="$dimension_plural=[ ${!dimension_plural:-} ] "
      else
        dim_string+="$dimension=${!dimension:-} "
      fi
    end_for
  fi
end_function
handle_return
}

# input: dim
# output: values 
expand_values() {
trace $log_trace2 "Expanding values for $dim"
begin_function

  local dims=${dim}s
  local new_value_list= new_values new_value value
  values=( ${!dim} )

  if [[ ! "${values:-}" ]]; then

    # handle plural dim
    values=( ${!dims} )

    if [[ ! "${values:-}" ]]; then

      # see if a default value is defined
      value= result_var=new_values expand_member || fail
      if [[ ! "${new_values:-}" ]]; then
        err "Missing value for dimension $dim"
        fail1
      fi

    else

      begin_for value in "${values[@]}"; doo
        value=$value result_var=new_values expand_members || fail
        if [[ ! "${new_values:-}" ]]; then
          value=$value result_var=new_values expand_member || fail
          if [[ ! "${new_values:-}" ]]; then
            err "Dim $dims has invalid value '$value'"
            fail1
          fi
        fi
      end_for

    fi

    for new_value in $new_values; do
      if [[ ! $new_value_list =~ \ $new_value\  ]]; then
        new_value_list+=" $new_value "
      fi
    done

  else

    # handle singular dim
    if [[ "${#values[*]}" -gt 1 ]]; then
      err "Too many values for a singular dim $dim." \
        "Use plural dim $dims if you intend to have multiple values."
      fail1
    fi

    local value=$values new_values

    value=$value result_var=new_value expand_member || fail
    if [[ ! "$new_value" ]]; then
      err "Dim $dim has invalid value '$value'"
      fail1
    fi

    new_value_list+="$new_value"

  fi

  values=( $new_value_list )

end_function
handle_return
}

# input: dim dim_file
# output: expand_members expand_member
get_dim_functions() {

  if [[ ! -f "$dim_file" ]]; then
    err "Internal error: cube_update_pivot was called with an index which doesn't corrospond with a dimension file: $dim_file"
    return 1
  fi

  # set these to a basic default
  expand_member() {
    eval "$result_var='$value'"
  }

  expand_members() {
    eval "$result_var='$value'"
  }

  source $dim_file

}

# inputs: values
# outputs: cell_ids
get_cell_ids_pivot_values() {
begin_function_flat
  begin_for value in "${values[@]}"; doo
    eval "$dim='$value'"
    if [[ ${#dimensions[*]} -gt $((index + 1)) ]]; then
      get_cell_ids_pivot $((index + 1)) || fail
    else
      get_cell_id || fail
      cell_ids+=" $cell_id"
    fi
  end_for
end_function_flat
handle_return
}

# input: dimensions 
# output: cell_id, dim_string
get_cell_id() {

local dim dims cell_dim_part= value hash 

begin_function
  
  for dim in "${dimensions[@]}"; do
    value="${!dim}"
    dim_string+="$dim=$value "
    if [[ ${#value} -lt 40 && "$value" =~ ^[A-Za-z0-9_\.:\-]+$ ]]; then
      cell_dim_part+="$value,"
    else
      hash=$(echo "$value" | cksum -a md5 | awk '{ print $4 }')
      cell_dim_part+="${hash:0:8},"
    fi
  done

  if [[ "$cell_dim_part" ]]; then
    cell_dim_part=${cell_dim_part%,}
    cell_id=$cell_dim_part
    if [[ $high_volume_cube == t ]]; then
      hash=$(echo "$cell_dim_part" | cksum -a md5 | awk '{ print $4 }') 
      hash=${hash:0:2}
      cell_id=$hash/$cell_dim_part
    fi
  else
    cell_id=only
  fi

end_function
handle_return

}

