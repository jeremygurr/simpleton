#!/bin/bash

type -t bash_lib_loaded >/dev/null && return 0
bash_lib_loaded=t

set -ue +Hm -o pipefail
shopt -s expand_aliases   # make sure aliases are expanded even for non-interactive scripts
shopt -s extglob

umask 0077  # to make created files readable only by the user by default

if [[ ! -v fd_original_in ]]; then
  exec {fd_original_in}<&0
  exec {fd_original_out}>&1
  exec {fd_original_err}>&2
  exec {fd_original_trace}>&${fd_trace:-2}
fi

# used for temporary logging to debug issues. Uses of this should be removed before
#   committing changes. 
zombie() {
  echo "$*" >&$fd_original_trace
}

# use this to make vars local which are computed by another function call
alias local_vars='[[ "${to_local_vars:-}" ]] && eval "local $to_local_vars"'

# some required defaults
export tmp_folder="${tmp_folder:-/tmp}"
export EDITOR=${EDITOR:-vim}

export tracing_depth=${tracing_depth:-0}
export no_trace_depth=${no_trace_depth:-0}

alias start_tracing='
  [[ $tracing_depth -eq 0 ]] && set -x
  let tracing_depth++ || true
  '
alias stop_tracing='
  let tracing_depth-- || true
  [[ $tracing_depth -le 0 ]] && { set +x; tracing_depth=0; }
  '

alias begin_no_tracing_zone='[[ $no_trace_depth == 0 && $tracing_depth -gt 0 ]] && set +x || true; let no_trace_depth++ || true'
alias end_no_tracing_zone='let no_trace_depth-- || true; [[ $no_trace_depth -le 0 && $tracing_depth -gt 0 ]] && set -x || true'

alias       begin_function='local return_value=0 break_out=f deep_function=t; while true; do'
alias  begin_function_flat='local return_value=0 break_out=f deep_function; while true; do'
alias          begin_while='break_out=f; while'
alias            begin_for='break_out=f; for'
alias           begin_loop='break_out=f; while true; do'
alias         end_function='break; done'
alias    end_function_flat='break; done' # deprecated, use end_function instead
alias            end_while='done; [[ $break_out == t ]] && break; true'
alias              end_for='done; [[ $break_out == t ]] && break; true'
alias             end_loop='done; [[ $break_out == t ]] && break; true'

# to avoid bash syntax parsing problems
alias doo='do'

# used after a direct command which may fail: cd /somewhere || fail
alias fail='{ return_value=$?; break_out=t; break; }'
alias fail1='{ return_value=1; break_out=t; break; }'
alias fail2='{ return_value=2; break_out=t; break; }'

# used to check if something failed: failed && break
alias failed='[[ $return_value -gt 0 ]]'

alias succeed='{ return_value=0; break_out=t; break; }'
alias succeeded='[[ $return_value -eq 0 ]]'

# should be at the end of every function which contains a try / end_try block
alias handle_return='
  if [[ "${deep_function:-}" ]]; then
    (( log_depth_current-- ))
  fi
  return $return_value
'
alias handle_exit='exit $return_value'

# used in if condition to be more clear.
# instead of:
#   if ! diff $f1 $f2; then ...
# write:
#   if are_different $f1 $f2; then ...
alias files_are_different='! diff'
alias files_are_same='diff'

ansi_filter_stream() {
  local line
  local IFS=
  while read -r line || [[ "$line" ]]; do
    printf '%s\n' "${line//$ESC[\[(]*([0-9;])[@-n]/}"
  done
}

ansi_filter_var() {
  local -n var=$1
  var="${line//$ESC[\[(]*([0-9;])[@-n]/}"
}

plural() {
local count=$1 word=$2
if [[ $count -eq 1 ]]; then
  echo "$count $word"
else
  echo "$count ${word}s"
fi
}

find1() {
if [[ ! -d "${1:-}" ]]; then
  echo "find1: directory missing: ${1:-}" >&$fd_original_err
  stack_trace
  return 1
fi
local path=$1; shift
find -L "$path" -mindepth 1 -maxdepth 1 "$@"
return 0
}

NL=$'\n'
TAB=$'\t'
ESC=$'\e'
DQ='"'

   LIGHT_RED=$'\033[0;31m'
         RED=$'\033[1;31m'
 LIGHT_GREEN=$'\033[0;32m'
       GREEN=$'\033[1;32m'
LIGHT_YELLOW=$'\033[0;33m'
      YELLOW=$'\033[1;33m'
  LIGHT_BLUE=$'\033[0;34m'
        BLUE=$'\033[1;34m'
LIGHT_PURPLE=$'\033[0;35m'
      PURPLE=$'\033[1;35m'
  LIGHT_CYAN=$'\033[0;36m'
        CYAN=$'\033[1;36m'
 LIGHT_WHITE=$'\033[0;37m'
       WHITE=$'\033[1;37m'
 LIGHT_BLACK=$'\033[0;38m'
       BLACK=$'\033[1;38m'
       RESET=$'\033[0m'
  CLEAR_LINE=$'\033[2K\r'
       CLEAR=$'\033[2J'
CLEAR_SCREEN=$'\033[2J\r\033[H'
   CURSOR_UP=$'\033[1A'
     REVERSE=$'\033[7m'

COL0=$'\n\e[A\e[0G' COL5=$'\n\e[A\e[5G' COL10=$'\n\e[A\e[10G'
COL15=$'\n\e[A\e[15G' COL20=$'\n\e[A\e[20G' COL25=$'\n\e[A\e[25G'
COL30=$'\n\e[A\e[30G' COL35=$'\n\e[A\e[35G' COL40=$'\n\e[A\e[40G'
COL45=$'\n\e[A\e[45G' COL50=$'\n\e[A\e[50G' COL55=$'\n\e[A\e[55G'
COL60=$'\n\e[A\e[60G' COL65=$'\n\e[A\e[65G' COL70=$'\n\e[A\e[70G'
COL75=$'\n\e[A\e[75G' COL80=$'\n\e[A\e[80G' COL85=$'\n\e[A\e[85G'
COL90=$'\n\e[A\e[90G' COL95=$'\n\e[A\e[95G' COL100=$'\n\e[A\e[100G'
COL110=$'\n\e[A\e[110G' COL120=$'\n\e[A\e[120G' COL130=$'\n\e[A\e[130G'
COL140=$'\n\e[A\e[140G' COL150=$'\n\e[A\e[150G' COL160=$'\n\e[A\e[160G'
COL170=$'\n\e[A\e[170G' COL180=$'\n\e[A\e[180G' COL190=$'\n\e[A\e[190G'
COL200=$'\n\e[A\e[200G'

hydrate_template() {
if [[ "$line" =~ \$ ]]; then
  line="${line//\"/\\\"}"
  eval "echo \"$line\"" || return 1
else
  echo "$line"
fi
}

# prompt_ynsq {message} {var to save result into}
# Allows: (y)es (n)o (s)kip (q)uit
prompt_ynq() {
  begin_no_tracing_zone
  local message=$1 var=$2
  if [[ ${tracing_midline:-f} == t ]]; then
    tracing_midline=f
    echo >&2
  fi

  while true; do
    read -s -n 1 -p "${GREEN:-}$message${RESET:-}" $var >&2
    case ${!var} in
      y)
        echo "Yes" >&2  
        ;;
      n)
        echo "No" >&2 
        ;;
      q)
        echo "Quit" >&2 
        ;;
      *)
        log_fatal "Pick one of: (y)es (n)o (q)uit"
        continue
        ;;
    esac
    break
  done
  end_no_tracing_zone
}

# should pass in a single command or a { } block of commands
# will run this command after script terminates (whether successfully or in error)
defer() {
eval "cleanup_on_exit+='$1 &>/dev/null || true;'"
}

# usage: random {p=number of possibilities}
#   sets r={random number between 0 and p-1}
#   it will be fairly evenly distributed below about 1000, but will become more biased as it gets higher
unset random
random() {
  local p=$1
  r=$((RANDOM % p))
}

# usage: random_sleep {min} {max}
#   will sleep for a random interval between min and max
unset random_sleep
random_sleep() {
  local min=$1; shift
  local max=$1
  random $((max-min))
  sleep $((min+r))
}

split_to_array() {
  local var=$1; shift
  local separator=${1:-$'\n'}

  local OIFS=$IFS
  IFS=$separator
  eval "$var=( \$$var )"

  IFS=$OIFS
}

escape_regex() {
  local var=$1

  eval "$var="'${'"$var"'//\"/\\\"}'
  eval "$var="'${'"$var"'// /\\ }'
  eval "$var="'${'"$var"'//\(/\\\(}'
  eval "$var="'${'"$var"'//)/\\)}'
  eval "$var="'${'"$var"'//\?/\\\?}'
}

get_shell_quoted_value() {
  local value=$1
  quoted_value=$value
  if [[ "$quoted_value" =~ \(|\)|\"|\'|\\|\  ]]; then
    value=${value//\\/\\\\}
    value=${value//\"/\\\"}
    value=${value//\$/\\\$}
    quoted_value="$DQ$value$DQ"
  fi
}

dir_is_empty() {
	local content=( "$1"/* )
	[[ ! -e $content ]]
}

# usage: echo -e "\n\n blah  \n\n" | trim_newlines
# will trim empty lines from beginning and end of given string
# will leave exactly one trailing newline at the end
trim_stream_nl() {
  begin_no_tracing_zone
  local block
  read -r -d '' block
  block=${block##*($NL)}
  block=${block%%*($NL)}
  echo "$block"
  end_no_tracing_zone
}

# usage: echo " blah   " | trim
# will trim whitespace from beginning and end of each line in the given input
trim_stream() {
  sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | grep -v '^$'
}

declare -A apad_size apad_min apad_max
# append a string to another string + padding according to the class of item being added
# Usage: apad {base var name} [{class of append string} {append string}]...
# The base var will be directly appended to with the append string and maybe padding
# You should include spaces in the append string itself if you want to guarantee a minimum
#   amount of space.
# You may define explicit min/maxes for various classes by adding entries to the apad_min and
#   apad_max maps, and can setup initial sizes with the apad_size map
apad() {
  local -n base=$1; shift
  local class append append_size class_size class_min class_max pad pad_size
  while (( $# > 1 )); do

    class=$1 append=$2; shift 2
    append_size=${#append}

    if [[ ! -v apad_min[$class] ]]; then
      apad_min[$class]=0
    fi
    class_min=${apad_min[$class]}

    if [[ ! -v apad_size[$class] ]]; then
      apad_size[$class]=$class_min
    fi
    class_size=${apad_size[$class]}

    if [[ ! -v apad_max[$class] ]]; then
      apad_max[$class]=1000
    fi
    class_max=${apad_max[$class]} 

    if (( append_size > class_size && class_size < class_max )); then
      apad_size[$class]=$append_size
      if (( class_size > class_max )); then
        apad_size[$class]=$class_max
      fi
    fi

    pad_size=0
    if (( class_size > append_size )); then
      (( pad_size = class_size - append_size ))
    fi

    base+=$append

    if (( pad_size > 0 )); then
      printf -v pad %${pad_size}s
      base+=$pad
    fi

  done
}

# For debugging: shows the current apad padding information
apad_info() {
  local k
  for k in "${!apad_size[@]}"; do
    echo "$k: size=${apad_size[$k]} min=${apad_min[$k]} max=${apad_max[$k]}"
  done
}

upper_first_char() {
  local string=$1
  local first=${string:0:1}
  first=$(echo -n "$first" | tr '[:lower:]' '[:upper:]')
  echo -n "$first${string:1}"
}

# usage: convert_to_seconds {from time period} {to var name}
convert_to_seconds() {
  local from=$1; shift
  local to=$1
  case "$from" in
    *s)
      eval "$to=${from%s}"
    ;;
    *m)
      eval "$to=$((${from%m}*60))"
    ;;
    *h)
      eval "$to=$((${from%h}*60*60))"
    ;;
    *d)
      eval "$to=$((${from%d}*24*60*60))"
    ;;
    *w)
      eval "$to=$((${from%w}*7*24*60*60))"
    ;;
    *y)
      eval "$to=$((${from%y}*365*24*60*60))"
    ;;
    *)
      if [[ "$from" =~ ^[0-9]+$ ]]; then
        # default to seconds
        eval "$to=$from"
      else
        log_fatal "Unknown time format, use something like: 4h, 3d, 5m"
        return 1
      fi
    ;;
  esac
  return 0
}

get_overlap() {
  local i
  result=
  for ((i=0; i<${#1}; i++)); do
    [[ "${1:$i:1}" != "${2:$i:1}" ]] && break
    result+=${1:$i:1}
  done
}

# inputs: 
#   from    directory to link to target
#   to      target to link to
#   timeout how long to wait in miliseconds
# if timeout is not given, then attempt will immediately fail if it can not get the lock right away
#   otherwise it will keep trying until the timeout is reached or the lock is obtained.
link_lock() {
local from=$from
local to=$to
local timeout=${timeout:-}
local pid_file=${pid_file:-$to/pid}

local log_vars='from to timeout'
begin_function

  if [[ ! -e "$from" ]]; then
    log_fatal "$from doesn't exist, can't link lock it"
    fail1
  fi
  
  if [[ -L "$to" ]]; then

    log_debug "Lock link exists already: $to"
    local pid=

    if [[ -f "$pid_file" ]]; then
      pid=$(<"$pid_file")
      if [[ "$pid" == $$ ]]; then
        log_debug "This process already owns the lock, so we are done."
        succeed
      fi
    fi

    # check to see if the process is still running
    if [[ ! "$pid" ]] || ! ps $pid &>/dev/null; then
      rm "$to" || fail
      log_debug "Removed stale lock: $to with pid: $pid"
    fi

  elif [[ -e "$to" ]]; then
    log_fatal "$to already exists and it's not a link. Can't obtain lock."
    fail1
  fi

  local parent=${to%/*}
  if [[ ! -d "$parent" ]]; then
    log_fatal "Target of link lock isn't in a folder ($to)"
    fail1
  fi

  local timeleft
  let timeleft=timeout
  local delay=250
  local success=f
  begin_while true; doo
    ln -sn "$from" "$to" &>/dev/null && success=t
    if [[ $success == t ]]; then
      echo $$ >"$pid_file" || fail
      break
    fi

    if [ ! "$timeout" ]; then
      break
    fi

    local seconds_to_wait=$(dc -e "2 k $delay 1000 / p")
    log_debug "Failed to obtain lock. Waiting $seconds_to_wait seconds before trying again."
    sleep $seconds_to_wait
    timeleft=$((timeleft-delay))

    let delay*=2
    if (( delay > 10000 )); then
      delay=10000
    fi

    if (( timeleft <= 0 )); then
      log_warn "Timeout reached. Couldn't obtain the lock in time."
      break
    fi

  end_while

  if [[ $success == f ]]; then
    log_debug "Failed to obtain lock."
    fail1
  fi

  defer "rm '$pid_file' '$to' &>/dev/null"

  # lock obtained
  log_debug "Succeeded in obtaining lock."

end_function
handle_return
}

link_unlock() {
local to=$to
local pid_file=${pid_file:-$to/pid}

if [[ -f "$pid_file" ]]; then
  rm "$pid_file" || return 1
fi

if [[ -L "$to" ]]; then
  rm "$to" || return 1
elif [[ -e "$to" ]]; then
  log_fatal "$to is not a link, can't unlock it"
  return 1
fi

return 0
}

# inputs: folder_to_lock timeout pid_file
# if timeout is not given, then attempt will immediately fail if it can't get the lock right away
#   otherwise it will keep trying until the timeout is reached or the lock is obtained.
folder_lock() {
local folder_to_lock=${folder_to_lock}
local timeout=${timeout:-$lock_timeout}
local pid_file=${pid_file:-$folder_to_lock/pid}
local remove_folder_when_unlocked=${remove_folder_when_unlocked:-f}

local log_vars='folder_to_lock timeout'
begin_function

  if [[ -d "$folder_to_lock" ]]; then

    log_debug "Lock folder exists already: $folder_to_lock"
    local pid=

    if [[ -f "$pid_file" ]]; then
      pid=$(<"$pid_file")
      if [[ "$pid" == $$ ]]; then
        log_debug "This process already owns the lock, so we are done."
        succeed
      fi
    fi

    # check to see if the process is still running
    if [[ ! "$pid" ]] || ! ps $pid &>/dev/null; then
      rm -rf "$folder_to_lock" || fail
      log_debug "Removed stale lock: $folder_to_lock with pid: $pid"
    fi

  fi

  local timeleft
  let timeleft=timeout*1000
  local delay=250
  local success=f
  local parent=${folder_to_lock%/*}
  if [[ -d "$parent" ]]; then
    begin_while true; doo
      mkdir "$folder_to_lock" &>/dev/null && success=t
      if [[ $success == t ]]; then
        echo $$ >"$pid_file" || fail
        break
      fi

      if [ ! "$timeout" ]; then
        break
      fi

      local seconds_to_wait=$(dc -e "2 k $delay 1000 / p")
      log_debug "Failed to obtain lock. Waiting $seconds_to_wait seconds before trying again."
      sleep $seconds_to_wait
      timeleft=$((timeleft-delay))
      let delay*=2
      if [ "$timeleft" -le 0 ]; then
        log_warn "Timeout reached. Couldn't obtain the lock in time."
        break
      fi
    end_while
  else
    log_fatal "Attempting to obtain a folder lock when it's parent doesn't exist: $parent"
    stack_trace
    fail1
  fi

  if [[ $success == f ]]; then
    log_debug "Failed to obtain lock."
    fail1
  fi

  if [[ $remove_folder_when_unlocked == t ]]; then
    defer "rm -r '$pid_file' '$folder_to_lock' &>/dev/null"
  fi

  # lock obtained
  log_debug "Succeeded in obtaining lock."

end_function
handle_return
}

folder_is_locked() {
local folder_to_lock=$folder_to_lock
local pid_file=${pid_file:-$folder_to_lock/pid}
local is_locked=f
if [[ -d "$folder_to_lock" ]]; then
  if [[ -f "$pid_file" ]]; then
    pid=$(<"$pid_file")
    if [[ "$pid" ]] && ps $pid &>/dev/null; then
      is_locked=t
    fi
  fi
fi
[[ "$is_locked" == t ]]
}

# inputs: folder_to_unlock pid_file
folder_unlock() {
local folder_to_unlock=$folder_to_unlock
local pid_file=${pid_file:-$folder_to_unlock/pid}
local remove_folder_when_unlocked=${remove_folder_when_unlocked:-f}

if [[ ! "$folder_to_unlock" ]]; then
  log_fatal "Usage: folder_to_unlock=... folder_unlock "
  return 1
fi

if [[ -d "$folder_to_unlock" && $remove_folder_when_unlocked == t ]]; then
  rm -r "$folder_to_unlock" || return 1
fi

if [[ -f "$pid_file" ]]; then
  rm "$pid_file" || return 1
fi

return 0
}

fd_read_lock() {
local lock_path=$lock_path timeout=$timeout
if [[ ! -d "${lock_path%/*}" ]]; then
  log_fatal "Bad lock path: $lock_path. It must either exist, or point to a file in a folder that exists."
  return 1
fi
if [[ ! -e "$lock_path" ]]; then
  touch "$lock_path" || return 1
fi
exec {lock_fd}<>$lock_path
flock -s -w $timeout $lock_fd || {
  log_fatal "Failed to get read lock for $lock_path within $timeout seconds"
  return 1
  }
}

fd_write_lock() {
local lock_path=$lock_path timeout=$timeout
if [[ ! -d "${lock_path%/*}" ]]; then
  log_fatal "Bad lock path: $lock_path. It must either exist, or point to a file in a folder that exists."
  return 1
fi
if [[ ! -e "$lock_path" ]]; then
  touch "$lock_path" || return 1
fi
exec {lock_fd}<>$lock_path
flock -e -w $timeout $lock_fd || {
  log_fatal "Failed to get write lock for $lock_path within $timeout seconds"
  return 1
  }
}

fd_unlock() {
flock -u $lock_fd
}

get_next_fd() {
next_fd=$(ls -1 /proc/self/fd | tail -n1)
let next_fd++
}

is_dir_empty() {
eval "local contents=( $1/* )"
local first=${contents[0]}
[[ "${first%\*}" != "$first" ]]
}

# TODO: should be defaulted to ask
pretend=${pretend:-f}
maybe() {
local command_to_execute="$*"
local execute

case $pretend in
  f)
    execute=t
  ;;
  t)
    echo "Pretending: $command_to_execute" >&2
    execute=f
  ;;
  a|ask)
    local response
    echo "Will execute: $command_to_execute" >&2
    sleep 0.5
    read -p 'Are you sure? [yes/no/All/None/quit] ' -s -n1 response >&2
    case $response in
      y)
        echo "yes" >&2
        execute=t
      ;;
      A)
        echo "all" >&2
        pretend=f
        execute=t
      ;;
      N)
        echo "none" >&2
        pretend=t
        execute=f
      ;;
      q)
        echo "quit" >&2
        exit 1
      ;;
      *)
        echo "no" >&2
        execute=f
      ;;
    esac
  ;;
  *)
    log_fatal "Invalid pretend setting: $pretend. Must be one of: t f ask"
    return 1
  ;;
esac

if [[ $execute == t ]]; then
  log_info "Executing: $command_to_execute"
  eval "$command_to_execute" || return $?
fi

return 0
}

min() {
result=$1
if [[ $1 == inf || $2 -lt $1 ]]; then
  result=$2
fi
}

max() {
result=$1
if [[ $2 == inf || $2 -gt $1 ]]; then
  result=$2
fi
}

# input: $1 (name of array variable which was already populated 
#   with string values)
enum() {
local i count array=$1 var
eval "count=\${#$array[*]}"
for ((i=0; i < count; i++)); do
  eval "var=\${$array[$i]}"
  eval "$var=$i"
done
}

safe_link() {
local from=$1 to=$2 force=${force:-f} from_must_exist=${from_must_exist:-t}
local log_show_vars="from to" log_vars="force from_must_exist"
begin_function

  if [[ $to != */ && -L "$to" ]]; then
    rm "$to" || fail
  fi

  if [[ $from_must_exist == t && ! -e "$from" ]]; then
    log_fatal "Internal error: Source of link doesn't exist: $from"
    stack_trace
    fail1
  fi

  local to_parent=${to%/*}
  if [[ ! -d "$to_parent" ]]; then
    log_fatal "Missing target folder for link: $to_parent"
  fi

  if [[ $force == t ]]; then
    ln -sfn "$from" "$to" || fail
  else
    ln -sn "$from" "$to" || fail
  fi

end_function
handle_return
}

pause() {
read -p "${1:-Press any key}" -n 1 none || true
}

# resolves relative paths but does not resolve symlinks
# should run in a subprocess so dir change doesn't affect caller
# normal usage: x=$(unrealpath "$some_path")
unrealpath() {
local p=$PWD x=$1
if [[ "$x" != /* ]]; then
  x="$p/$x"
fi
realpath -s "$x" || {
  log_fatal "Internal error: could not resolve $x"
  return 1 
  }
return 0
}

remove_from_string() {
local from_var=$1 remove_value=$2
if [[ -v $from_var ]]; then
  local old_value=${!from_var}
  local left=${old_value% $remove_value *}
  local right=${old_value#* $remove_value }
  eval "$from_var=\"\$left \$right\""
fi
}

cooked_stack_trace() {
echo "Cooked call stack:" >&$fd_original_err
local count=${#cooked_stack[*]} n
for ((n = 0; n < count; n++)); do
  echo " ${cooked_stack[$n]}" >&$fd_original_err
done
return 0
}

stack_trace() {
local start_frame=${start_frame:-1}
local count=${#FUNCNAME[*]}
local p n

if [ ${tracing_midline:-f} == t ]; then
  tracing_midline=f
  echo >&$fd_original_err
fi

echo "Raw call stack:" >&$fd_original_err
for ((n = count - 1; n >= start_frame; n--)) ; do
  let p=n-1
  echo "  ${BASH_SOURCE[$n]} ${FUNCNAME[$n]} ${BASH_LINENO[$p]}" >&$fd_original_err
done
return 0
}

show_array() {
local -n array=$1
if [[ -v array ]]; then
  local i size=${#array[*]}
  echo "size=$size" >&$fd_original_err
  for ((i=0; i<size; i++)); do
    if [[ ! -v array[$i] ]]; then
      echo "$i: << MISSING >>" >&$fd_original_err
    else
      echo "$i: ${array[$i]:-}" >&$fd_original_err
    fi
  done
fi
}

# make sure we clean up after ourselves whether we've launched a background job or allocated resources
# this needs to be run again whenever forking to a subprocess
setup_exit_trap() {
trap '
  trap - DEBUG ERR EXIT RETURN QUIT &>/dev/null
  set +TeuExvm
  eval "${cleanup_on_exit:-}" &>/dev/null
  ' EXIT
  # { kill $(jobs -p); } 2>/dev/null || true; 
# trap '
#   zombie "ERR $BASH_COMMAND"
#   ' ERR
# trap '
#   zombie "QUIT $BASH_COMMAND"
#   ' QUIT
# trap '
#   zombie "RETURN $BASH_COMMAND"
#   f=( "${FUNCNAME[@]:1}" )
#   show_array f
#   ' RETURN
}
setup_exit_trap

