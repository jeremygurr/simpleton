#!/usr/bin/env bash

# inputs:
#   i     index of parameter to show
show_parameter_help_inner() {
  begin_function

    local indent=${indent:-0} \
      parameter="${parameter_names[$i]}" \
      description="${parameter_descriptions[$i]}" \
      aliases="${parameter_aliases[$i]}" \
      dq=${parameter_delay_questions[$i]} \

    if [[ $dq == t ]]; then
      local best_alias=$parameter
      if [[ "$aliases" ]]; then
        best_alias=${aliases%% *}
      fi
      description+="Use $best_alias=? to see a list of valid values. "
    fi
    trim_ws description

    choices=
    if [[ -v parameter_choices[$i] && "${parameter_choices[$i]:-}" ]]; then
      choices=${parameter_choices[$i]}
    elif function_exists ${name}_get_choices; then
      ${name}_get_choices || fail
    fi

    default="${parameter_defaults[$i]}"

    out_wrap "$parameter: $description"
    (( indent += 2 ))
    [[ "$choices" ]] && out_wrap "choices: $choices"
    [[ "$default" ]] && out_wrap "default: $default"
    [[ "$aliases" ]] && out_wrap "aliases: $aliases"
  end_function
  handle_return
}

show_help_for_command() {
  local command=$1
  begin_function
    [[ $first_command == f ]] && out ''
    if [[ $multi_commands == t ]]; then
      out_wrap "$hbar_equals"
    fi

    out_wrap "${WHITE}Command: ${command//-/ }$RESET"
    if [[ -f $path_to_commands/$command.info ]]; then
      source $path_to_commands/$command.info || fail
      indent=2 out_wrap "$command_description"
      local name description default i choices aliases dq
      local types=command
      if (( help_depth > 1 )); then
        types='command global'
      fi
      begin_for type in $types; doo

        local -n parameter_names=parameter_names_$type \
          parameter_descriptions=parameter_descriptions_$type \
          parameter_choices=parameter_choices_$type \
          parameter_defaults=parameter_defaults_$type \
          parameter_aliases=parameter_aliases_$type \
          parameter_delay_questions=parameter_delay_questions_$type \

        if [[ "${parameter_names:-}" ]]; then
          out_wrap "$NL$WHITE${type^} Parameters:$RESET"
        fi
        begin_for ((i=0; i<${#parameter_names[*]}; i++)); doo
          show_parameter_help_inner || fail
        end_for
      end_for
    fi
  end_function
  handle_return
}

show_dimension_details() {
  local dim=$1
  begin_function
    if function_exists ${dim_type}_${dim}_expand; then
      values=

      local problem= 

      eval "value=all ${dim_type}_${dim}_expand" &>/dev/null
      if [[ ! "$problem" && $values != all ]]; then
        out_wrap "choices: ${values[*]}"
      fi

      eval "value= ${dim_type}_${dim}_expand" &>/dev/null || is_required=t
      if [[ "$problem" ]]; then
        required+=( $dim )
      else
        if [[ "${values:-}" ]]; then
          if [[ "$values" == $empty_member ]]; then
            out_wrap "default: (empty)"
          else
            out_wrap "default: ${values[*]}"
          fi
        else
          out_wrap "optional"
        fi
      fi
    fi

    if [[ -v ${dim_type}_${dim}_examples ]]; then
      eval "local examples=( \"\${${dim_type}_${dim}_examples[@]}\" )"
      local example_count=${#examples[*]} i index_string=
      begin_for ((i=0; i<example_count; i++)); doo
        if [[ example_count -gt 1 ]]; then
          index_string=" #$((i+1))"
        fi
        out_wrap "example$index_string: ${examples[$i]}"
      end_for
    fi

    if [[ -v ${dim_type}_${dim}_aliases ]]; then
      eval "local aliases=( \"\${${dim_type}_${dim}_aliases[@]}\" )"
      local full_alias
      begin_for full_alias in "${aliases[@]}"; doo
        out_wrap "alias: ${full_alias/ / -> }"
      end_for
    fi

    if [[ -v ${dim_type}_${dim}_derived_from ]]; then
      local -n df_var=${dim_type}_${dim}_derived_from
      local derived_string
      for derived_string in "${df_var[@]}"; do
        local derived_array=( $derived_string )
        out_wrap "derived from: ${derived_array[*]}"
      done
    elif [[ -v ${dim_type}_${dim}_derive_fields ]]; then
      local -n df_var=${dim_type}_${dim}_derive_fields
      local f derived_from=
      for f in ${df_var[*]}; do
        if [[ "$f" != "$dim" ]]; then
          derived_from+="$f "
        fi
      done
      derived_from=${derived_from% }
      out_wrap "derived from: $derived_from"
    fi

  end_function
  handle_return
}

show_dimension() {
  local dim=$1 help_depth=${help_depth:-2} indent=${indent:-0}
  begin_function
    (( indent += 2 ))
    if [[ -v ${dim_type}_${dim}_description ]]; then
      eval "description=\$${dim_type}_${dim}_description" || fail
    else
      description='No description'
    fi
    out_wrap "$dim: $description"
    if (( help_depth > 1 )); then
      indent=$((indent+2)) show_dimension_details $dim || fail
    fi
  end_function
  handle_return
}

show_dimensions() {
  local dims=( $* ) dim dim_type=$dim_type description values 
  begin_function
    begin_for dim in ${dims[*]}; doo
      if [[ " ${branch_dims[*]:-} " == *" $dim "* ]]; then
        continue
      fi
      show_dimension $dim || fail
    end_for
  end_function
  handle_return
}

show_cell_help() {
  local cell_path=$1
  begin_function

    command_requires_cell=t \
    command_requires_resolved_dims=f \
    trunk_changed=f \
    command_allows_logs=f \
    switch_context $cell_path || fail

    indent=0

    if [[ $multi_cell == t ]]; then
      out_wrap "$hbar_equals"
    fi

    out_wrap "Cell: $short_cell"
    (( indent += 2 ))
    if [[ "${cell_description:-}" ]]; then
      out_wrap "$cell_description"
    else
      out_wrap "No description for this cell. Set cell_description variable in context file."
    fi

    local required=()

    if [[ "${trunk_dims:-}" ]]; then
      out_wrap "${NL}Dimensions: (add {dim}=? to command to see details, or cell . ?? to show all details)"
      dim_type=trunk_dims \
      show_dimensions ${trunk_dims[*]} || fail
    fi

    if [[ "${sub_dims:-}" || "${data_props:-}" || "${control_props:-}" ]]; then
      out_wrap "${NL}Other parameters:"
      if [[ "${sub_dims:-}" ]]; then
        dim_type=sub_dims \
        show_dimensions ${sub_dims[*]} || fail
      fi
      if [[ "${control_props:-}" ]]; then
        dim_type=control_props \
        show_dimensions ${control_props[*]} || fail
      fi
      if [[ "${data_props:-}" ]]; then
        dim_type=data_props \
        show_dimensions ${data_props[*]} || fail
      fi
    fi

    if [[ "${required:-}" ]]; then
      out_wrap "${NL}Required parameters: ${required[*]}"
    fi

    if [[ "${trunk_dims:-}" ]]; then
      out_wrap "${NL}Branch dimensions:"
      local i pretty_form= member dim
      #begin_for (( i = 0; i < ${#branch_dims[*]}; i++ )); doo
      #  dim=${branch_dims[$i]}
      #  eval "member=\${branch_members[$i]}"
      #  local pretty_function_name=trunk_dims_${dim}_pretty
      #  if function_exists $pretty_function_name; then
      #    eval "$pretty_function_name member" || fail
      #    pretty_form=" ($member)"
      #  else
      #    pretty_form=
      #  fi
      #  out_wrap "  $dim=${branch_members[$i]}$pretty_form"
      #end_for
      (( indent += 2 ))
      begin_for (( i = 0; i < ${#trunk_dims[*]}; i++ )); doo
        dim_var=${trunk_dims[$i]}
        local -n dim=d_$dim_var
        local pretty_function_name=trunk_dims_${dim_var}_pretty
        if function_exists $pretty_function_name; then
          eval "$pretty_function_name $dim_var" || fail
          pretty_form=" ($value)"
        else
          pretty_form=
        fi
        local value=${dim:-}
        if [[ "${value:-}" ]]; then
          if [[ "$value" == $empty_member ]]; then
            value='(empty)'
          fi
          out_wrap "$dim_var=$value$pretty_form"
        fi
      end_for
    fi

  end_function
  handle_return
}

show_parameter_help_single() {
  local name=$1 indent=${indent:-0}
  begin_function

    begin_for type in command global; doo

      local -n parameter_names=parameter_names_$type \
        parameter_descriptions=parameter_descriptions_$type \
        parameter_choices=parameter_choices_$type \
        parameter_defaults=parameter_defaults_$type \
        parameter_aliases=parameter_aliases_$type \
        parameter_delay_questions=parameter_delay_questions_$type \

      begin_for i in ${!parameter_names[*]}; doo
        if [[ " $names " == *" ${parameter_names[$i]} "* ]]; then
          show_parameter_help_inner || fail
          found=t
          succeed
        fi
      end_for
    end_for

    local dim_type dim
    begin_for dim_type in trunk_dims sub_dims control_props data_props; doo
      local -n dims=$dim_type
      begin_for dim in ${dims[*]}; doo
        if [[ " $names " == *" $dim "* ]]; then
          show_dimension $dim || fail
          found=t
          succeed
        fi
      end_for
    end_for

  end_function
  handle_return
}

show_parameter_help() {
  local names=$* indent=${indent:-0}
  begin_function
    local found
    out_wrap "Parameters:"
    begin_for name in $names; doo
      found=f
      indent=$((indent+2)) show_parameter_help_single $name || fail
      if [[ $found == f ]]; then
        log_warn "No description found for parameter $name" || fail
      fi
    end_for
  end_function
  handle_return
}

show_parameters_help() {
  begin_function
    local p
    begin_for p in ${parameter_questions[*]}; doo
      if [[ " ${parameter_delayed_questions:-} " == *\ $p\ * ]]; then
        continue
      fi
      show_parameter_help $p || fail
      showed_parameter_help=t
    end_for
  end_function
  handle_return
}

