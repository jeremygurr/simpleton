#!/usr/bin/env bash

# inputs:
#   i     index of parameter to show
show_parameter_help_inner() {
  begin_function

    local indent=${indent:-0} \
      name="${parameter_names[$i]}" \
      description="${parameter_descriptions[$i]}" \
      aliases="${parameter_aliases[$i]}" \
      dq=${parameter_delay_questions[$i]} \
      show_use_eq=${show_use_eq:-f} \

    if [[ $dq == t && $show_use_eq == t ]]; then
      local best_alias=$name
      if [[ "$aliases" ]]; then
        best_alias=${aliases%% *}
      fi
      description+="${NL}Use $best_alias=? to see a list of valid values. "
    fi
    trim_ws description

    choices=
    if [[ -v parameter_choices[$i] && "${parameter_choices[$i]:-}" ]]; then
      choices=${parameter_choices[$i]}
    elif [[ -v ${name}_choices ]]; then
      local -n n_choices=${name}_choices
      choices=$n_choices
    elif function_exists ${name}_get_choices; then
      ${name}_get_choices || fail
    fi

    default="${parameter_defaults[$i]}"

    out "$name:"
    (( indent += 2 ))
    out "$description"
    [[ "$choices" ]] && out "choices: $choices"
    [[ "$default" ]] && out "default: $default"
    [[ "$aliases" ]] && out "aliases: $aliases"
  end_function
  handle_return
}

show_help_for_command() {
  local command=$1 indent=${indent:-0}
  begin_function
    [[ $first_command == f ]] && out ''
    if [[ $multi_commands == t ]]; then
      out "$hbar_equals"
    fi

    out "${WHITE}Command: ${command//-/ }$RESET"
    if [[ -f $path_to_commands/$command.info ]]; then
      source $path_to_commands/$command.info || fail
      indent=2 out "$command_description"
      local name description default i choices aliases dq
      local types=command
      if (( help_depth > 1 )); then
        types='command global'
      fi
      begin_for type in $types; doo

        local -n parameter_names=parameter_names_$type \
          parameter_descriptions=parameter_descriptions_$type \
          parameter_choices=parameter_choices_$type \
          parameter_defaults=parameter_defaults_$type \
          parameter_aliases=parameter_aliases_$type \
          parameter_delay_questions=parameter_delay_questions_$type \

        if [[ "${parameter_names:-}" ]]; then
          out "$NL$WHITE${type^} Parameters:$RESET"
        fi
        begin_for ((i=0; i<${#parameter_names[*]}; i++)); doo
          show_use_eq=t indent=$((indent+2)) show_parameter_help_inner || fail
        end_for
      end_for
    fi
  end_function
  handle_return
}

show_dimension_details() {
  local dim=$1
  begin_function
    if function_exists ${dim_type}_${dim}_expand; then
      values=

      local problem= 

      eval "value=all ${dim_type}_${dim}_expand" &>/dev/null
      if [[ ! "$problem" && $values != all ]]; then
        out "choices: ${values[*]}"
      fi

      eval "value= ${dim_type}_${dim}_expand" &>/dev/null || is_required=t
      if [[ "$problem" ]]; then
        required+=( $dim )
      else
        if [[ "${values:-}" ]]; then
          if [[ "$values" == $empty_member ]]; then
            out "default: (empty)"
          else
            out "default: ${values[*]}"
          fi
        else
          out "optional (not required to be set)"
        fi
      fi
    fi

    if [[ -v ${dim_type}_${dim}_examples ]]; then
      eval "local examples=( \"\${${dim_type}_${dim}_examples[@]}\" )"
      local example_count=${#examples[*]} i index_string=
      begin_for ((i=0; i<example_count; i++)); doo
        if [[ example_count -gt 1 ]]; then
          index_string=" #$((i+1))"
        fi
        out "example$index_string: ${examples[$i]}"
      end_for
    fi

    if [[ -v ${dim_type}_${dim}_aliases ]]; then
      eval "local aliases=( \"\${${dim_type}_${dim}_aliases[@]}\" )"
      local full_alias
      begin_for full_alias in "${aliases[@]}"; doo
        out "alias: ${full_alias/ / -> }"
      end_for
    fi

    local -n is_shortcut=${dim_type}_${dim}_is_shortcut
    if [[ -v is_shortcut ]]; then
      out "shortcut (used to derive other dims)"
    fi

    if [[ -v ${dim_type}_${dim}_derived_from ]]; then
      local -n df_var=${dim_type}_${dim}_derived_from
      local derived_string
      for derived_string in "${df_var[@]}"; do
        local derived_array=( $derived_string )
        out "derived from: ${derived_array[*]}"
      done
    elif [[ -v ${dim_type}_${dim}_derive_fields ]]; then
      local -n df_var=${dim_type}_${dim}_derive_fields
      local f derived_from=
      for f in ${df_var[*]}; do
        if [[ "$f" != "$dim" ]]; then
          derived_from+="$f "
        fi
      done
      derived_from=${derived_from% }
      out "derived from: $derived_from"
    fi

  end_function
  handle_return
}

show_dimension() {
  local dim=$1 help_depth=${help_depth:-2} indent=${indent:-0}
  begin_function
    if [[ -v ${dim_type}_${dim}_description ]]; then
      eval "description=\$${dim_type}_${dim}_description" || fail
    else
      description='No description'
    fi
    out "$dim: $description"
    if (( help_depth > 1 )); then
      indent=$((indent+2)) show_dimension_details $dim || fail
    fi
  end_function
  handle_return
}

show_dimensions() {
  local dims=( $* ) dim dim_type=$dim_type description values 
  begin_function
    begin_for dim in ${dims[*]}; doo
      if [[ " ${branch_dims[*]:-} " == *" $dim "* ]]; then
        continue
      fi
      show_dimension $dim || fail
    end_for
  end_function
  handle_return
}

show_cell_help() {
  local cell_path=$1
  begin_function

    load_branch_info || fail

    command_requires_cell=t \
    trunk_changed=f \
    command_allows_logs=f \
    switch_context $cell_path || fail

    indent=0

    if [[ $multi_cell == t ]]; then
      out "$hbar_equals"
    fi

    out "Cell: $short_cell"
    (( indent += 2 ))
    if [[ "${cell_description:-}" ]]; then
      out "$cell_description"
    else
      out "No description for this cell. Set cell_description variable in context file."
    fi

    local required=()

    if [[ "${trunk_dims:-}" ]]; then
      out "${NL}Dimensions: (add {dim}=? to command to see details, or cell . ?? to show all details)"
      dim_type=trunk_dims \
      show_dimensions ${trunk_dims[*]} || fail
    fi

    if [[ "${sub_dims:-}" || "${data_props:-}" || "${control_props:-}" ]]; then
      out "${NL}Other parameters:"
      if [[ "${sub_dims:-}" ]]; then
        dim_type=sub_dims \
        show_dimensions ${sub_dims[*]} || fail
      fi
      if [[ "${control_props:-}" ]]; then
        dim_type=control_props \
        show_dimensions ${control_props[*]} || fail
      fi
      if [[ "${data_props:-}" ]]; then
        dim_type=data_props \
        show_dimensions ${data_props[*]} || fail
      fi
    fi

    if [[ "${required:-}" ]]; then
      out "${NL}Required parameters: ${required[*]}"
    fi

#    if [[ "${trunk_dims:-}" ]]; then
#      local i pretty_form= member dim show_header=t
#      #begin_for (( i = 0; i < ${#branch_dims[*]}; i++ )); doo
#      #  dim=${branch_dims[$i]}
#      #  eval "member=\${branch_members[$i]}"
#      #  local pretty_function_name=trunk_dims_${dim}_pretty
#      #  if function_exists $pretty_function_name; then
#      #    eval "$pretty_function_name member" || fail
#      #    pretty_form=" ($member)"
#      #  else
#      #    pretty_form=
#      #  fi
#      #  out "  $dim=${branch_members[$i]}$pretty_form"
#      #end_for
#      (( indent += 2 ))
#      begin_for (( i = 0; i < ${#trunk_dims[*]}; i++ )); doo
#        dim_var=${trunk_dims[$i]}
#        local -n dim=d_$dim_var
#        local pretty_function_name=trunk_dims_${dim_var}_pretty
#        if function_exists $pretty_function_name; then
#          eval "$pretty_function_name $dim_var" || fail
#          pretty_form=" ($value)"
#        else
#          pretty_form=
#        fi
#        local value=${dim:-}
#        if [[ "${value:-}" ]]; then
#          if [[ $show_header == t ]]; then
#            indent=$((indent-2)) out "${NL}Branch dimensions:"
#            show_header=f
#          fi
#          if [[ "$value" == $empty_member ]]; then
#            value='(empty)'
#          fi
#          out "$dim_var=$value$pretty_form"
#        fi
#      end_for
#    fi

  end_function
  handle_return
}

show_parameter_help_single() {
  local name=$1 indent=${indent:-0}
  begin_function

    begin_for type in command global; doo

      local -n parameter_names=parameter_names_$type \
        parameter_descriptions=parameter_descriptions_$type \
        parameter_choices=parameter_choices_$type \
        parameter_defaults=parameter_defaults_$type \
        parameter_aliases=parameter_aliases_$type \
        parameter_delay_questions=parameter_delay_questions_$type \

      begin_for i in ${!parameter_names[*]}; doo
        local aliases=${parameter_aliases[$i]:-}
        if [[ "$name" == "${parameter_names[$i]}"
           || " $aliases " == *" $name "* ]]; then
          found=t
          show_parameter_help_inner || fail
          succeed
        fi
      end_for
    end_for

    local dim_type dim
    begin_for dim_type in trunk_dims sub_dims control_props data_props; doo
      local -n dims=$dim_type
      begin_for dim in ${dims[*]}; doo
        if [[ "$name" == "$dim" ]]; then
          show_dimension $dim || fail
          found=t
          succeed
        fi
      end_for
    end_for

  end_function
  handle_return
}

show_parameter_help() {
  local names=$* indent=${indent:-0}
  begin_function
    local found
    out "Parameters:"
    indent=$((indent+2)) 
    begin_for name in $names; doo
      found=f
      show_parameter_help_single $name || fail
      if [[ $found == f ]]; then
        log_warn "No description found for parameter $name" || fail
      fi
    end_for
  end_function
  handle_return
}

show_parameters_help() {
  begin_function
    local p
    load_branch_info || fail
    switch_context $cell_path || fail
    begin_for p in ${parameter_questions[*]}; doo
      if [[ " ${parameter_delayed_questions:-} " == *\ $p\ * ]]; then
        continue
      fi
      show_parameter_help $p || fail
      showed_parameter_help=t
    end_for
  end_function
  handle_return
}

