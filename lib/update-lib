#!/usr/bin/env bash

type -t update_lib_loaded >/dev/null && return 0
update_lib_loaded=t

# will write all trunk and sub dim names to the output file
write_output_fields() {
  begin_function_lo
    if [[ $cell_is_leaf == f ]]; then
      log_fatal "write_update_fields should only be run on a leaf cell"
      fail1
    fi
    local d result=
    for d in ${trunk_dims_expanded[*]:-} ${sub_dims_expanded[*]:-}; do
      result+=" $d"
    done
    echo "${result# }" >$out_path/$out_file || fail
  end_function
  handle_return
}

# will write a row of data to the output file based on current dim values
write_output_row() {
  begin_function_lo
    if [[ $cell_is_leaf == f ]]; then
      log_fatal "write_update_row should only be run on a leaf cell"
      fail1
    fi
    local d result=
    for d in ${trunk_dims_expanded[*]:-} ${sub_dims_expanded[*]:-}; do
      local -n m=d_$d
      local s=${m:-}
      shell_quote_var s
      result+=" $s"
    done
    echo "${result# }" >>$out_path/$out_file || fail
  end_function
  handle_return
}

# inputs: 
#   upstream
#   upstream_var
prep_upstream() {
  local log_show_vars=^upstream
  begin_function

    # down_fresh may be used by prep script to propagate freshness requirements to upstream
    down_fresh=$required_freshness

    # Don't inherit parent's freshness requirements, 
    #   only what upstream prep explicitly states
    # extra_dims includes dimensions that need to be promoted in upstream that don't
    #   exist in branch_dims
    fresh=$down_fresh required_freshness= default_freshness= extra_dims=
    get_required_freshness || fail

  end_function
  handle_return
}

# inputs:
#   target_cell
#   prefix
load_upstream_vars() {
  begin_function

    if [[ ! -d "${target_cell:-}" ]]; then
      log_fatal "Internal error: missing target_cell $target_cell"
    fi

    local export_path=$target_cell/export \
      out_path=$target_cell \
      prefix=${prefix:-}${target_cell##*/}_ \
      dna_roots= \
      context_type= \

    prefix=${prefix//-/_}

    pass_thru=t \
    recursive=f \
    ignore_unknown=t \
    auto_load_tab_vars=t \
    load_dna_contents $out_path || fail

    if [[ -d $export_path ]]; then
      ignore_unknown=t \
      pass_thru=t \
      load_dna_contents $export_path || fail
    fi

  end_function

  if failed; then
    update_successful=f
  fi

  handle_return
}

execute_up_inner() {
  begin_function

    local all_prep_function=${up_cell_type}_all_prep
    if function_exists $all_prep_function; then
      log_debug "Executing all prep function: $all_prep_function"
      $all_prep_function || fail
    fi

    # other preps are only run if there isn't a specific prep function for the upstream
    local other_prep_function=${up_cell_type}_other_prep
    local prep_function=${up_cell_type}_${up_var}_prep
    if function_exists $prep_function; then
      log_debug "Executing prep function: $prep_function"
      $prep_function || fail
    elif function_exists $other_prep_function; then
      log_debug "Executing other prep function: $other_prep_function"
      $other_prep_function || fail
    fi

    local up_cell_path \
      short_cell \
      upstream_cell_link \
      downstream_cell_name \

    if [[ $needs_update == t ]]; then
      
      maybe_fix_up || fail

      upstream_cell_link=$up_cell
      get_short_cell $cell_path

      if [[ $up_cell_type == up ]]; then
        downstream_cell_name=${short_cell//\//_}
      else
        downstream_cell_name=
      fi

      up_cell_path=$(realpath $up_cell) || fail
      if [[ $up_cell_path == */.cyto/* ]]; then
        log_fatal "Internal error: up_cell_path is in cyto: $up_cell_path"
        fail1
      fi

      needs_update=

      anchor_dims= \
      get_needs_update $up_cell_path || fail

      if [[ $needs_update == t ]]; then
        execute_commands "$up_cell_path" update || fail
      fi

    else
      log_verbose "Skipping update of upstream $up_name because prep function set needs_update=f"
      reply_to_caller "update_skipped=t"
    fi

    #    not sure why this is here
    # reply_to_caller "needs_update=$needs_update"

  end_function
  handle_return
}

# inputs:
#   up_cell_type
#   up_cell
execute_up() {
  begin_function
    if [[ ! "${up_cell:-}" ]]; then
      log_fatal "Internal error: up_cell was not passed into execute_up"
      fail1
    fi

    if [[ ! "${up_cell_type:-}" ]]; then
      log_fatal "Internal error: up_cell_type was not passed into execute_up"
      fail1
    fi

    local up_name=${up_cell##*/}
    log_debug "Checking $up_cell_type $up_name"

    local needs_update=t \
      up_var=${up_name//-/_} \

    update_skipped=f
    fork execute_up_inner || fail

    target_cell=$up_cell \
    prefix=${up_cell_type}_ \
    load_upstream_vars || fail

    local all_post_function=${up_cell_type}_all_post
    if function_exists $all_post_function; then
      log_debug "Executing all post function: $all_post_function"
      $all_post_function || fail
    fi

    # other posts are only run if there isn't a specific post function for the upstream
    local other_post_function=${up_cell_type}_other_post
    local post_function=${up_cell_type}_${up_var}_post
    if function_exists $post_function; then
      log_debug "Executing post function: $post_function"
      $post_function || fail
    elif function_exists $other_post_function; then
      log_debug "Executing other post function: $other_post_function"
      $other_post_function || fail
    fi
    
  end_function
  handle_return
}

# inputs:
#   validate_type (pre or post)
# output:
#   validation_says_already_done   left unset if there is no validation
#
validate_cell() {
  begin_function

    if [[ $cell_is_leaf == t && "${validator:-}" ]]; then
      local target target_var target_name target_cell real_cell
      begin_for target in "${validator[@]}"; doo

        target_name=${target%%,*}
        target_var=${target_name//-/_}

        strong_log=t log_verbose "${validate_type^}-validating using $target_var (from $short_cell)"

        local conditions=
        if [[ $target_var != "$target" ]]; then
          conditions=${target#*,}
        fi

        local target_cell=$validator_path/$target_name \
          invalid_dep=f \
          fresh \

        case $validate_type in
          pre)
            # If we just ran these cells a few minutes ago, no need to run them again
            fresh=5m
          ;;
          post)
            # However, for post-validation, it is assumed that a change in the current cell
            # will impact the valdation, and so that always needs to be fresh
            fresh=0
          ;;
          *)
            log_fatal "Internal error: Invalid validate_type: $validate_type. It should be either pre or post"
            fail1
          ;;
        esac

        local validation_message= validation_object= validation_result=

        local update_skipepd=f 

        during_validation=t \
        up_cell_type=validator \
        up_cell=$target_cell \
        execute_up || fail

        if [[ $update_skipepd == t ]]; then
          log_verbose "Validation skipped"
        else

          validation_says_already_done=
          if [[ "$conditions" ]]; then
            local condition key value negative
            for condition in ${conditions//,/ }; do
              key=${condition%%:*}
              value=${condition#*:}
              negative=f
              if [[ $value == -* ]]; then
                negative=t
                value=${value#-}
              fi
              local -n up_var=validator_${target_var}_$key
              if [[ $negative == f ]]; then
                if [[ "${up_var:-}" == "$value" ]]; then
                  validation_says_already_done=t
                else
                  validation_says_already_done=f
                  break
                fi
              else
                if [[ "${up_var:-}" != "$value" ]]; then
                  validation_says_already_done=t
                else
                  validation_says_already_done=f
                  break
                fi
              fi
            done

            local -n up_validation_message=validator_${target_var}_validation_message
            local -n up_validation_object=validator_${target_var}_validation_object
            local -n up_validation_result=validator_${target_var}_validation_result

            if [[ ! "${up_validation_message:-}" ]]; then
              if [[ "${up_validation_object:-}" ]]; then
                validation_message=$up_validation_object
                if [[ "${up_validation_result:-}" ]]; then
                  validation_message+=" $up_validation_result"
                fi
              else
                if [[ "${up_validation_result:-}" ]]; then
                  validation_message+="$up_validation_result"
                fi
              fi
            else
              validation_message=$up_validation_message
            fi

            if [[ "$validation_message" ]]; then
              validation_message=" ($validation_message)"
            fi

            if [[ $validation_says_already_done == t ]]; then
              touch $status_path/last-validation-good || fail
              touch $status_path/last-validation-${target_var}-good || fail
              strong_log=t log_verbose "${validate_type^}-validation result: DONE$validation_message"
            else
              touch $status_path/last-validation-bad || fail
              touch $status_path/last-validation-${target_var}-bad || fail
              strong_log=t log_verbose "${validate_type^}-validation result: NOT DONE$validation_message"
              break
            fi

          fi

        fi

      end_for
    fi
  end_function
  handle_return
}

get_needs_update_internal() {
  local target_cell=$1
  begin_function

    cell_is_outdated=f

    if [[ "$pause_at_cells" ]]; then
      local pac
      for pac in $pause_at_cells; do
        if [[ "$target_cell" == *"$pac"* ]]; then
          handle_user_interrupt "Cell reached (get_needs_update): $pac."
        fi
      done
    fi

    if [[ "${needs_update:-}" ]]; then
      # needs_update is already known, don't need to compute it again
      log_message="needs_update is already set to $needs_update"
      level=log_debug
      abort
    fi

    if [[ ! -e $target_cell/.dna ]]; then
      log_fatal "Attempted to run get_needs_update on folder that is not a cell: $target_cell"
      fail1
    fi

    if [[ ! -d $cyto_path ]]; then
      needs_update=t
      log_message="Needs update because cyto folder doesn't exist"
      abort
    fi

    local check_context=$cyto_path/context-check
    if [[ ! -f $check_context ]]; then
      needs_update=t
      log_message="Needs update because check context doesn't exist"
      abort
    fi

    if [[ "$clean_cells" ]]; then
      local cell_to_clean
      for cell_to_clean in $clean_cells; do
        if [[ "$target_cell/" == */$cell_to_clean/* ]]; then
          needs_update=t
          log_message="Needs update because output file doesn't exist"
          abort
        fi
      done
    fi

    local out_file= out_path= cell_is_leaf=f check_op_var=f \
      data_props_expanded=() default_freshness= \

    local context_check_var_eval= context_check_vars=
    source $check_context || fail

    if [[ "$context_check_vars" ]]; then
      local $context_check_vars || fail
    fi

    if [[ "${context_check_var_eval:-}" ]]; then
      eval "$context_check_var_eval" || fail
    fi

    local required_freshness x
    get_required_freshness

    if [[ $cell_is_leaf == f ]]
    then
      needs_update=t
      log_message="Needs update because cell is not a leaf"
    elif [[ "$out_file" && ! -e "$out_path/$out_file" ]]; then
      needs_update=t
      log_message="Needs update because output file doesn't exist"
    elif [[ ! -e $status_path/last-good-update-end ]]
    then
      needs_update=t
      log_message="Needs update because cell has never been updated successfully"
    elif [[ ! -e $status_path/up-to-date ]]
    then
      needs_update=t
      log_message="Needs update because cell definition has changed"
      cell_is_outdated=t
    elif [[ ! -e $status_path/deps-up-to-date ]]
    then
      needs_update=t
      log_message="Needs update because upstream has changed"
      cell_is_outdated=t
    elif [[ "${default_freshness:-}" ]] && \
      convert_to_seconds ${default_freshness:-0} x && \
      (( x == 0 ))
    then
      needs_update=t
      log_message="Needs update because cell always needs to update"
      cell_is_outdated=t
    elif [[ $required_freshness == 0 ]]
    then
      needs_update=t
      if [[ ${cell_is_used_for_validation:-f} == t ]]; then
        log_message="Needs update because this cell is being used for validation"
      else
        log_message="Needs update because refresh has been forced (fresh=0)"
      fi
      cell_is_outdated=t
    elif get_is_stale $status_path || fail
         [[ $is_stale == t ]]
    then
      needs_update=t
      log_message="Needs update because cell is stale"
      cell_is_outdated=t
    elif local data_valid=f missing
      ignore_missing=t execute_op check || fail
      [[ $data_valid == f && $missing == f ]]
    then
      needs_update=t
      log_message="Needs update because validity check failed"
      cell_is_outdated=t
    elif local prop_changed
      get_data_prop_changed $target_cell || fail
      [[ $prop_changed == t ]]
    then
      needs_update=t
      log_message="Needs update because a data property was changed"
      cell_is_outdated=t
    elif 
      local problem_found=f
      broken_link_check || fail
      [[ $problem_found == t ]]
    then
      needs_update=t
      log_message="Needs update because cyto contains broken links"
      needs_pruning=t
    fi

  end_function
  handle_return
}

# returns needs_update
# context does not need to be loaded
get_needs_update() {
  local log_show_vars=^target_cell target_cell=$1
  begin_function

    log_debug "Does ${target_cell#/*/*/} need updating?"

    # do we need to delete branches of this cell
    needs_pruning=f

    local cyto_path=$target_cell/.cyto

    local level=log_verbose
    #if [[ ${top_level_command:-t} == t ]]; then
    #  level=log_info
    #fi

    local status_path=$cyto_path/status \
      up_path=$cyto_path/up \
      log_message="No update needed" \

    get_needs_update_internal $target_cell || fail

  end_function

  if succeeded; then
    #if [[ ${needs_update:-f} == f && $top_level_command == f ]]; then
    #  level=log_info
    #fi
    action=update_check $level "$log_message (${target_cell#/*/*/})"
  else
    action=update_check log_fatal "Failed to check update need of ${target_cell#/*/*/}"
  fi

  if [[ $needs_pruning == t ]]; then
    rm -rf $cyto_path || fail
    build_cyto $target_cell || fail
  fi

  if [[ ! "$needs_update" ]]; then
    needs_update=f
  fi

  local log_return_vars=needs_update
  handle_return
}

update_upstream_get_locks() {
  local log_show_vars=^upstream
  begin_function

    local lock 
    local -r export_path=$upstream/export
    if [[ -d $export_path ]]; then

      local shared_locks
      shared_locks=$(find1 $export_path -not -name ".*" -name "shared-lock-*" | sort -g) || fail
      begin_for lock in $shared_locks; doo
        write_lock=f \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for

      local exclusive_locks
      exclusive_locks=$(find1 $export_path -not -name ".*" -name "lock-*" | sort -g) || fail
      begin_for lock in $exclusive_locks; doo
        write_lock=t \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for

    fi

  end_function
  handle_return
}

# inputs: 
#   upstream: a folder in .dna/up
#   upstream_name
update_upstream() {

  local original_cell_path=${cell_path:-} \
    upstream=$1 \

  local log_show_vars=^upstream 
  begin_function

    local needs_update=t upstream_cell_link= \
      anchor_dims= \
      required_freshness= fresh= \
      default_freshness= \
      risk_tolerance=$risk_tolerance \
      command_history=${command_history:-} \
      upstream_var=${upstream_name//-/_} \

    local cell_path=${upstream%/.cyto/up/$upstream_name}
    if [[ $cell_path == $upstream ]]; then
      log_fatal "Invalid upstream: $upstream, it should be within .cyto/up"
      fail1
    fi

    local cyto_path=$cell_path/.cyto
    local up_path=$cyto_path/up

    localize
    prep_upstream || fail

    up_cell_type=up \
    up_cell=$upstream \
    execute_up || fail

  end_function
  handle_return
}

update_upstreams() {
  begin_function

    update_successful=t
    if [[ "${last_upstream_updated:-}" == "${up_path:-}" ]]; then
      abort
    else
      last_upstream_updated=${up_path:-}
    fi

    if [[ -d "${up_path:-}" ]]; then

      local upstream upstreams \
        top_level_command=f

      # This will eventually be done in parallel
      begin_for upstream_name in "${up[@]}"; doo

        if [[ "${up_only:-}" && $up_only != *$upstream_name* ]]; then
          local u found=f
          for u in $up_only; do
            if [[ $upstream_name == *$u* ]]; then
              found=t
              break
            fi
          done
          if [[ $found == f ]]; then
            log_warn "Skipping upstream $upstream_name because up_only=$up_only"
            continue
          fi
        fi

        upstream=$up_path/$upstream_name

        update_upstream $upstream || fail
        if [[ $update_successful == f ]]; then
          break
        fi

      end_for

    fi

  end_function

  if failed; then
    update_successful=f
  fi

  handle_return
}

get_prop_hash() {
  local prop= prop_string=
  for prop in ${data_props_expanded[*]:-}; do
    if [[ -v d_$prop ]]; then
      eval "value=\$d_$prop"
      prop_string+="$prop=$value "
    fi
  done
  prop_hash=$(echo "$prop_string" | sha1sum) || return 1
  return 0
}

get_data_prop_changed() {
  local cell_path=$1
  local status_path=$cell_path/.cyto/status \
    prop_hash=0 \
    value
  prop_changed=f
  if [[ "${data_props_expanded:-}" ]]; then

    local prop all_set=t
    for prop in ${data_props_expanded[*]}; do
      local -n v=$prop
      if [[ ! "${v:-}" ]]; then
        all_set=f
        break
      fi
    done

    if [[ $all_set == t ]]; then
      prop_changed=t
      local -r status_file=$status_path/last-run-prop-hash
      if [[ -f $status_file ]]; then
        get_prop_hash || return 1
        if [[ $prop_hash == $(<$status_file) ]]; then
          prop_changed=f
        fi
      fi
    fi

  fi
  return 0
}

update_prop_hash() {
  local prop_hash
  get_prop_hash || return 1
  local -r status_file=$status_path/last-run-prop-hash
  echo "$prop_hash" >$status_file || return 1
  return 0
}

propagate_change_to_downstream2() {
  begin_function

    local cell
    cell=$(realpath $value) || fail

    local t1 t2 trunk_cell
    get_trunk_cell $cell
    t1=$trunk_cell
    get_trunk_cell $from_cell
    t2=$trunk_cell
    if [[ $t1 == $t2 ]]; then
      log_fatal "Cell is propagating change to itself: $cell" 
      fail1
    fi
    
    local status_self=$cell/.cyto/status
    
    if array_contains dep_stack $cell; then
      abort
    fi
    dep_stack+=( $cell )

    if [[ -d $cell ]]; then
      if [[ -d $status_self ]]; then
        # can't combine these if statements or it will alter the else condition
        #   and break things
        if [[ -f $status_self/deps-up-to-date ]]; then
          rm $status_self/deps-up-to-date || fail
          # recursive
          from_cell=$cell \
            propagate_change_to_downstream || fail
        fi
      else
        # recursive
        from_cell=$cell \
          propagate_change_to_downstream || fail
      fi
    fi

  end_function
  handle_return
}

propagate_change_to_downstream() {
  begin_function

    local from_cell=$from_cell \
      down_path=$from_cell/.cyto/down down_folder folders

    if [[ -d $down_path ]]; then
      local dep_stack=( ${downstream_cell_stack[*]} )
      folders=( $(find1 $down_path -not -name '.*' -type d) ) || fail

      if [[ "${folders:-}" ]]; then
        loop_over_var=folders \
        background=f \
        par=f fork=f \
        body=propagate_change_to_downstream2 \
        parallel_loop || fail
      fi

    fi

  end_function
  handle_return
}

repair_pre_update() {
  if [[ ! -d $status_path ]]; then
    mkdir $status_path || return 1
    repair_successful=t
  fi
  return 0
}

pre_update() {
  begin_function

    something_changed=f \
    member_count=0 \
    cell_locks= \

    if [[ "${pretend_filter:-}" ]]; then
      local filter
      local pretend=f
      for filter in ${pretend_filter}; do
        if [[ "$cell_path" == *"$filter"* ]]; then
          pretend=t
        fi
      done
    fi

    write_lock=t \
      timeout=$lock_timeout \
      cell_lock $cell_path || fail

    defer "cell_unlock $cell_path"

    #  not using this
    #if [[ "${current_job_path:-}" ]]; then
    #  safe_link $current_job_path $running_job_path || fail
    #  defer "rm $running_job_path"
    #else
    #  log_fatal "Missing current_job_path"
    #  fail1
    #fi

    touch $status_path/last-update-start || fail
    # this needs to be at the beginning of the update so other processes
    #   could potentially invalidate it, requiring another update
    touch $status_path/up-to-date || fail

    can_agg=f
    if [[ "$out_file" && "${current_branch_dim:-}" ]]; then
      local current_branch_dim_var=$current_branch_dim
      local -n dim_type=${current_branch_dim_var}_dim_type
      local -n member_type=dim_${current_branch_dim_var}_member_type
      can_agg=t
      if [[ "$member_type" == static ]]; then
        local m s
        local -n members=dim_${current_branch_dim_var}_members
        if [[ -v members ]]; then
          for m in $members; do
            get_sane_value $m s
            if [[ ! -d $cell_path/${current_branch_dim}:$s ]]; then
              can_agg=f
              break
            fi
          done
        fi
      fi
    fi

    if [[ $can_agg == t ]]; then
      local parent_cell=${cell_path%/*}
      while [[ -d $parent_cell/.dna ]]; do
        if [[ -e $parent_cell/$out_file ]]; then
          rm $parent_cell/$out_file || fail
        fi
        parent_cell=${parent_cell%/*}
      done
    fi

    if [[ $reuse_existing_out == t && -f $status_path/last-good-update-end ]]; then
      # Don't allow cells to reuse old data when it is mid-modification and this update fails
      rm $status_path/last-good-update-end || fail
    fi

    if [[ $cell_is_leaf == t ]]; then
      calc_coords_leaf || fail
    fi

  end_function
  handle_return
}

create_downstream_links() {
  begin_function

    local down_cell_path down_cell_name

    get_bottom_cell ${upstream_cell_link%/*} || fail
    down_cell_path=$bottom_cell

    local down_link=$down_path/$downstream_cell_name
    if [[ ! -d $down_path ]]; then
      mkdir $down_path || fail
    fi
    force=t safe_link $down_cell_path $down_link || fail

#      let's just replace this each time for now
#    if [[ -e $down_link ]]; then
#      local link_target
#      link_target=$(readlink $down_link) || fail
#      if [[ $link_target != $down_cell_path ]]; then
#        log_fatal "Link conflict: A link already exists but doesn't point to the same place."
#        log_fatal "  source:   $down_link"
#        log_fatal "  target 1: $down_cell_path"
#        log_fatal "  target 2: $link_target"
#        fail1
#      fi
#    fi

  end_function
  handle_return
}

link_dim_parts() {
  local from_path=$from_path to_path=$to_path
  begin_function
    local contents
    contents=$(find1 $from_path -not -name '.*') || fail
    for part in $contents; do
      if [[ "$part" == */up \
         || "$part" == */down \
         || "$part" == */out \
         ]]; then
        continue
      elif [[ "$part" == */var \
           || "$part" == */fun \
           ]]; then
        contents=$(find1 $part -not -name '.*') || fail
        local folder=${part##*/} part2
        for part2 in $contents; do
          if [[ ! -d $to_path/$folder ]]; then
            mkdir $to_path/$folder || fail
          fi
          safe_link $(realpath $part2) $to_path/$folder/ || fail
        done; maybe_break
      else
        safe_link $(realpath $part) $to_path/ || fail
      fi
    done; maybe_break
  end_function
  handle_return
}

create_sub_cell() {
  local sub_cell=$sub_cell \
    parent_cell=$parent_cell \
    parent_seed=$parent_seed

  local log_show_vars='^sub_cell'
  begin_function

    log_debug "Creating sub cell $cell_path"

    if [[ "$sub_cell" == */.dna* ]]; then
      log_fatal "Internal error: Invalid sub_cell $sub_cell."
      log_fatal "We should not be creating a sub cell inside of a dna folder"
      fail1
    fi

    if [[ "$parent_cell" == "$sub_cell" ]]; then
      log_fatal "Can't create sub cells in a cell without parents: $sub_cell"
      stack_trace
      fail1
    fi

    deep=t \
    parent_path=$parent_cell \
    seed_path=$parent_seed \
    member=$member \
    repair=t \
    plant_member || fail

  end_function
  handle_return
}

update_downstream() {
  begin_function

    local old_link=$upstream_cell_link \
      old_target=$(readlink $upstream_cell_link) \
      new_target=$cell_path || fail

    if [[ $cell_is_leaf == t && "${downstream_cell_name:-}" ]]; then
      create_downstream_links || fail
    fi

    local update_downstream_link=f
    if [[ ! -e $old_link ]]; then
      log_debug "Will update downstream link because chosen file is missing"
      update_downstream_link=t
    else
      local new_target_length=${#new_target} \
        old_target_length=${#old_target}

      if (( new_target_length > old_target_length )); then
        log_debug "Will update downstream link because new target is more specific"
        update_downstream_link=t
      elif [[ ${old_target#$new_target} == ${old_target} ]]; then
        log_debug "Will update downstream link because new target is different"
        update_downstream_link=t
      fi
    fi

    if [[ $update_downstream_link == t ]]; then
      log_debug "Linking upstream cell to it's downstream cell cyto up folder"
      force=t safe_link $cell_path $old_link || fail
    fi

  end_function
  handle_return
}

update_member() {
  local sane_value member_path \
    log_vars=member log_show_vars=member \
    upstream_cell_link=${upstream_cell_link:-} \
    cell_path=$cell_path \
    original_cell_path=$cell_path \
    anchor_dims=${anchor_dims:-} \
    dim=$dim \

  begin_function_hi

    get_sane_value "$member" || fail
    member_path=$cell_path/$dim:$sane_value

    log_debug "Updating member $dim:$sane_value"

    local needs_update=
    if [[ ! -d $member_path/.dna ]]; then
      parent_cell=$cell_path \
      parent_seed=$seed_path \
      sub_cell=$member_path \
      create_sub_cell || fail
      needs_update=t
    else
      cell_path=$member_path
      get_needs_update $member_path || fail
    fi

    if [[ "${upstream_cell_link:-}" ]]; then
      cell_path=$member_path update_downstream || fail
    fi

    if [[ $needs_update == t ]]; then

      if (( member_count > 1 )); then
        log_debug "More than one member found ($member_count), not passing upstream_cell_link."
        upstream_cell_link=
      elif [[ "$upstream_cell_link" ]]; then
        log_debug "Only one member found, passing upstream_cell_link: $upstream_cell_link"
      fi

      fork execute_commands $member_path update || fail

      if [[ $update_successful == f ]]; then
        #log_error "Failed to update member cell $member_path"
        reply_to_caller "update_successful=f" || fail
      else 
        update_successful=t
      fi
    fi

    if (( member_count == 1 )); then
      upstream_cell_link=
    fi
  end_function
  handle_return
}

update_members() {
  begin_function

    local dim=${child_dims[0]}
    update_successful=t
    par=t fork=f function=update_member for_each_member $dim || fail

    #if [[ ${update_successful:=t} == f ]]; then
    #  log_warn "Failed to update some member(s)"
    #  #fail1
    #fi

  end_function
  handle_return
}

update_aggregation() {
  begin_function
    if [[ "$out_file" == output.tab ]]; then
      if [[ ! "${current_branch_dim:-}" ]]; then
        log_fatal "Internal error: missing current_branch_dim"
        fail1
      fi

      if [[ $can_agg == t ]]; then

        local target=$out_path/$out_file member \
          branches branch wrote_header=f \

        branches=$(find1 $cell_path -type d -name "*:*" | sort) || fail

        for branch in $branches; do
          if [[ -f $branch/$out_file ]]; then
            if [[ $wrote_header == f ]]; then
              cp $branch/$out_file $target || fail
              wrote_header=t
            else
              tail +2 $branch/$out_file >>$target || fail
            fi
          fi
        done

      fi
    fi
  end_function
  handle_return
}

compare_files_or_dirs() {
  local left=$1 right=$2
  begin_function
    if [[ -d $left ]]; then
      if [[ -d $right ]]; then
        local sub_full sub already_checked files

        files=$(find1 $left -not -name '.*') || fail
        for sub_full in $files; do
          sub=${sub_full##*/}
          compare_files_or_dirs $left/$sub $right/$sub || fail
          if [[ $changed == t ]]; then
            abort
          fi
          already_checked+=" $sub"
        done; maybe_break
        already_checked+=' '

        files=$(find1 $right -not -name '.*') || fail
        for sub_full in $files; do
          sub=${sub_full##*/}
          if [[ "$already_checked" =~ \ "$sub"\  ]]; then
            continue
          fi
          compare_files_or_dirs $right/$sub $left/$sub || fail
          if [[ $changed == t ]]; then
            abort
          fi
        done; maybe_break

      else
        changed=t
      fi
    elif [[ -f $left ]]; then
      if [[ -f $right ]]; then
        if files_are_different $left $right &>/dev/null; then
          changed=t
        else
          changed=f
        fi
      else
        changed=t
      fi
    else
      changed=f
    fi
  end_function
  handle_return
}

update_self_move_out_path() {
  begin_function

    if [[ -e $out_path.old ]]; then
      rm -rf $out_path.old || fail
    fi

    local f
    begin_for f in .dna .cyto .dim; doo
      if [[ -e $out_path/$f ]]; then
        if [[ ! -e $out_path.new/$f ]]; then
          mv $out_path/$f $out_path.new/$f || fail
        else
          log_fatal "Target $f folder already exists, when it shouldn't"
          fail1
        fi
      fi
    end_for

    if [[ -d $out_path ]]; then
      mv $out_path $out_path.old || fail
    fi

    mv $out_path.new $out_path || fail
    something_changed=t

    if [[ -e $out_path.old ]]; then
      rm -rf $out_path.old || fail
    fi

  end_function
  handle_return
}

# not used at the moment
get_max_color() {
  begin_function_lo
    local a=$1 b=$2

    case $b in 
      green|yellow|red|blue|black) 
        max_color=$b
      ;;
      *)
        log_fatal "Invalid color: $b"
        fail1
      ;;
    esac

    case $a in
      green)
        :
      ;;
      yellow)
        case $b in 
          green) 
            max_color=$a
          ;;
        esac
      ;;
      red)
        case $b in 
          green|yellow) 
            max_color=$a
          ;;
        esac
      ;;
      blue)
        case $b in 
          green|yellow|red) 
            max_color=$a
          ;;
        esac
      ;;
      black)
        case $b in 
          green|yellow|red|blue) 
            max_color=$a
          ;;
        esac
      ;;
      *)
        log_fatal "Invalid color: $a"
        fail1
      ;;
    esac
  end_function
  handle_return
}

write_fields_to_output_tab() {
  local fields=( "$@" )
  begin_function_lo
    local line=
    if [[ "${branch_dims:-}" ]]; then
      line+="${branch_dims[*]} "
    fi
    line+="${fields[*]}"
    echo "$line" >$cell_path/output.tab || fail
  end_function
  handle_return
}

write_row_to_output_tab() {
  local data=( "$@" )
  begin_function_lo
    local line= d
    if [[ "${branch_dims:-}" ]]; then
      for d in ${branch_dims[*]}; do
        local dim=d_$d
        local m=${dim:-}
        newlines=escaped shell_quote_var m
        line+="$m "
      done
    fi
    for d in "${data[@]}"; do
      newlines=escaped shell_quote_var d
      line+="$d "
    done
    echo "${line% }" >>$cell_path/output.tab || fail
  end_function
  handle_return
}

update_self() {
  local log_vars='short_cell'
  begin_function

    log_debug "Executing local update of $short_cell$attempt_string" 

    update_successful=
    can_retry=t

    local reuse_existing_out=${reuse_existing_out:-t} \
      original_out_path=$out_path out_path=$out_path \

    if [[ $reuse_existing_out == f ]]; then
      if [[ -d $out_path.new ]]; then
        rm -rf $out_path.new || fail
      fi
      if [[ ! -d $out_path.new ]] && ! mkdir $out_path.new 2>/dev/null; then
        log_debug "Could not make dir $out_path.new, falling back to $out_path"
      fi
      out_path=$out_path.new
    else
      # allow update code to set this, since we can't compare when changes are made in place
      something_changed=
    fi

    local missing=t
    #tee_output_to_log || fail
    if [[ $current_mock == f ]]; then
      localize

      ignore_missing=t execute_op update || {
        log_fatal "Internal error while executing update operator."
        fail1
      }

      local raws raw_path part
      if [[ -e $out_path ]]; then
        raws=( $(find1 $out_path -name 'raw-*') ) || fail
        for raw_path in ${raws[*]}; do
          part=${raw_path##*/}
          part=${part#raw-}
          coord_type=tree append_coords_to_file $raw_path $out_path/$part || fail
        done
      fi

    else # mocking

      log_warn "Using mock: $current_mock ($short_cell)"
      local -r export_path=$mock_path/$current_mock/export

      if function_exists mock_update_op; then
        missing=f
        mock_update_op || fail
      fi

      if [[ -d $export_path ]]; then
        pass_thru=t \
        context_type= \
        load_dna_contents $export_path || fail
      fi

      update_successful=${update_successful:-t}

    fi

    completion_time=$EPOCHSECONDS
    untee_output || fail

    if [[ $missing == t ]]; then
      update_successful=t
    else
      update_successful=${update_successful:-f}
    fi

    if [[ $reuse_existing_out == f && -d $out_path ]]; then
      out_path=$original_out_path
      if [[ $update_successful == t ]]; then
        local changed
        compare_files_or_dirs $out_path $out_path.new || fail
        if [[ $changed == f ]]; then
          rm -rf $out_path.new || fail
        else
          update_self_move_out_path || fail
        fi
      fi
    else # $reuse_existing_out == t
      # if update code didn't set this, we must assume the worst
      if [[ ! "$something_changed" ]]; then
        something_changed=t
      fi
    fi

  end_function
  #untee_output  # in case update failed and block was exited early
  handle_return
}

update_reactor() {
  local r=$1
  begin_function

    log_verbose "Executing reactor $r (from $short_cell)"
    local reactor_cell=$reactor_path/$r

    up_cell_type=reactor \
    up_cell=$reactor_cell \
    execute_up || fail

  end_function
  handle_return
}

update_reactors() {
  begin_function
    local r r_short
    begin_for r in ${reactor[*]}; doo

      r_short=${r%%,*}
      for pr in ${pre_react:-}; do
        if [[ $r_short == $pr
           || $r_short == *-$pr
           ]]; then
          log_debug "Skipping reactor $r_short because pre_react already was run for it"
          continue 2
        fi
      done

      local conditions= execute_reactor=t
      if [[ $r == *,* ]]; then
        conditions=${r#*,}
        r=${r%%,*}

        local condition key expected_value negative all_conditions_match=t
        for condition in ${conditions//,/ }; do
          key=${condition%%:*}
          expected_value=${condition#*:}
          negative=f
          if [[ $expected_value == -* ]]; then
            negative=t
            expected_value=${expected_value#-}
          fi

          local -n current_value=$key
          if [[ "${current_value:-}" == "$expected_value"
             && $negative == t
             ]]; then
            all_conditions_match=f
            break
          elif [[ "${current_value:-}" != "$expected_value"
             && $negative == f
             ]]; then
            all_conditions_match=f
            break
          fi
        done

        execute_reactor=$all_conditions_match

      fi

      if [[ $execute_reactor == t ]]; then
        update_successful=f
        update_reactor $r || fail
        if [[ $update_successful == f ]]; then
          log_fatal "Failed to update reactor $r (from $short_cell)"
          fail1
        fi
      fi

    end_for
  end_function
  handle_return
}

update_self_retry_loop() {
  begin_function

    ref_group=none \
    delay=$retry_delay \
    can_update=t \

    local attempt=1 \
      max_attempts=$max_attempts \

    while true; do

      local attempt_string=
      if (( max_attempts > 1 )); then
        attempt_string=", attempt $attempt of $max_attempts"
      fi

      update_successful=t
      can_retry=f
      if (( attempt < max_attempts )); then
        can_retry=t
      fi
        
      update_upstreams || fail

      if [[ $update_successful == t ]]; then
        touch $status_path/deps-up-to-date || fail
        update_self || fail
      fi

      if [[ $update_successful == t && $post_validate == t ]]; then
        local validation_says_already_done
        validate_type=post \
        validate_cell || fail
        if [[ ${validation_says_already_done:-t} == f ]]; then
          update_successful=f
        fi
      fi

      if [[ "${reactor:-}" ]]; then
        update_reactors || fail
      fi

      [[ $can_retry == f \
      || $update_successful == t \
      || $attempt -ge $max_attempts \
      ]] && break

      log_info "Waiting $delay seconds before trying again" 
      sleep $delay
      (( delay *= retry_scale )) || true
      (( delay > retry_delay_max )) && delay=$retry_delay_max

      (( attempt++ ))

    done

  end_function
  handle_return
}

post_update() {
  local result_string
  begin_function

    completion_time=${completion_time:-$EPOCHSECONDS}
    if [[ $update_successful == t ]]; then
      result_string="successful"
    else
      result_string="failed"
      update_successful=f
    fi

    if [[ $update_successful == t ]]; then
      touch -d @$completion_time $status_path/last-good-update-end || fail
      cp -a $status_path/last-update-start \
            $status_path/last-good-update-start || fail
      #if [[ -v current_job_path ]]; then
      #  force=t safe_link $current_job_path $job_path/last-success || fail
      #fi
      if [[ "${data_props_expanded:-}" ]]; then
        update_prop_hash || fail
      fi
      if [[ $something_changed == t ]]; then
        from_cell=$cell_path \
          propagate_change_to_downstream || fail
      fi
    else
      touch -d @$completion_time $status_path/last-bad-update-end || fail
      #force=t safe_link $current_job_path $job_path/last-failure || fail
      cp -a $status_path/last-update-start \
            $status_path/last-bad-update-start || fail
    fi

    local level=debug
    if [[ $top_level_command == t ]]; then
      level=info
    elif [[ $cell_is_leaf == t ]]; then
      level=verbose
    fi
    log_$level "Update $result_string. ($cell_path)"

    reply_to_caller "update_successful=${update_successful:-}" || fail

    cell_unlock $cell_path || fail

    if [[ -v running_job_path && -e $running_job_path ]]; then
      rm $running_job_path || fail
    fi

  end_function
  handle_return
}

get_dep_member() {

  if [[ -f $dep_cell/.dna/context-before ]]; then
    source $dep_cell/.dna/context-before || return 1
  else
    log_fatal "Missing context-before in $dep_cell/.dna."
    log_fatal "Should have been generated by update of it's trunk."
    log_fatal "Maybe try to run a clean on it and update again."
    return 1
  fi

  if [[ ! -v $dep_dim ]]; then
    log_fatal "Missing member for $dep_dim."
    log_fatal "This should have been defined in $dep_cell/.dna/context-before"
    return 1
  fi

  dep_member=${!dep_dim}
  return 0
}

update_command() {
  begin_function

    local leave_loop=0 \
      something_changed=f \
      needs_update=${needs_update:-} \
      needs_inner=f \

    local update_successful=t

    if [[ "${refresh:-f}" == t ]]; then
      refresh=f
      find $cell_path -path '*/.cyto/status/up-to-date' -delete || fail
    fi

    switch_context $cell_path || fail
    fence

    if [[ $current_mock == disabled ]]; then
      log_fatal "Cell is disabled. Use mock command to change it if this is not intended."
      fail1
    fi

    setup_dims || fail

    if [[ "${auto_loads:-}" ]]; then
      execute_auto_loads "${auto_loads[@]}" || fail
    fi

    if [[ ${branches_only:-f} == t && $cell_is_leaf == t ]]; then
      abort
    fi

    if function_exists get_update_risk; then
      get_update_risk || fail
    fi

    if (( update_risk > risk_tolerance )); then

      case $update_risk in
        1)
          echo "${YELLOW}There is a small amount of risk in updating this cell (level 1)." >&$fd_original_err
        ;;
        2)
          echo "${YELLOW}There is a moderate amount of risk in updating this cell (level 2). Continuing without really knowing what you are doing could result in production outage." >&$fd_original_err
        ;;
        3)
          echo "${RED}There is a significant amount of risk in updating this cell (level 3). Continuing without really knowing what you are doing could result in severe production outage." >&$fd_original_err
        ;;
        *)
          log_fatal "Internal error: Invalid risk level: $update_risk. Should be 0-3"
          fail1
        ;;
      esac

      local result
      prompt_ynq "Are you sure you want to proceed?" result
      case $result in
        n|q)
          echo "Update aboorted by user" >&$fd_original_err
          fail1
        ;;
      esac

      risk_tolerance=$update_risk

    fi

    if [[ "${upstream_cell_link:-}" ]]; then
      update_downstream || fail
    fi

    # Actually, it's worth the tradeoff not to double check all updates. Ignore the following for now:
    # This needs to not come in from downstream cell call, even though it may mean the check happens
    #   multiple times. It's possible that building the context solves the need for updating, so this
    #   needs to be checked again here. 
    #needs_update=

    get_needs_update $cell_path || fail

    if [[ $needs_update == t ]]; then

      calc_coords_branch || fail
      fence

      if [[ -v branch_coordinate_data && $top_level_command == t ]] && ( (( update_risk > 1 )) || [[ ${confirm_dims:-t} == t ]] ); then
        echo "Because updating this cell involves some risk, confirm that these are the intended coordinates:" >&$fd_original_err
        coord_type=branch \
        display_coordinates || fail
        local result
        prompt_ynq "Should we proceed to update with these coordinates?" result
        case $result in
          n|q)
            echo "Update aboorted by user" >&$fd_original_err
            fail1
          ;;
        esac
      fi

      if [[ $cell_is_leaf == t ]]; then
        handle_no_coords=ignore \
        calc_coords_sub || fail
        fence

        # make sure convert_table_to_dims doesn't try to hit any other row
        local row_index=0

        if [[ -v branch_coordinate_fields ]]; then
          table=branch_coordinate \
          target_dim_var_types='ddim ddims' \
          convert_table_to_dims || fail
        fi

        if [[ -v sub_coordinate_fields ]]; then
          table=sub_coordinate \
          target_dim_var_types='ddim ddims' \
          convert_table_to_dims || fail
        fi

      fi

      local can_agg=f
      pre_update || fail
      deep=t plant_seed_internal "$seed_path" "$cell_path" || fail

      if [[ "$update_successful" == t ]]; then
        if [[ $current_mock == f && $cell_is_leaf == t ]]; then
          local validation_says_already_done \
            pre_react=${pre_react:-} \
            r \

          if [[ "${reactor:-}" ]]; then
            local rs
            begin_for r in $pre_react; doo
              begin_for rs in ${reactor_short[*]}; doo
                if [[ "$rs" == "$r"
                  || "$rs" == *"-$r"
                  ]]; then
                  update_successful=f
                  update_reactor $rs || fail
                  if [[ $update_successful == f ]]; then
                    log_warn "Failed to update reactor $rs as pre_react (from $short_cell)"
                    update_successful=t
                  fi
                fi
              end_for
            end_for
          fi

          if [[ $pre_validate == t ]]; then
            validate_type=pre \
            validate_cell || fail
          fi

        else
          update_successful=t
        fi
      fi

      if [[ $update_successful == t && ${validation_says_already_done:-f} == f ]]; then
        if [[ $cell_is_leaf == t ]]; then

          update_self_retry_loop || fail

        else
          if [[ "${child_dims:-}" ]]; then
            update_members || fail
            if [[ $update_successful == t ]]; then
              update_aggregation || fail
            fi
          else
            log_fatal "Internal error: cell is not a leaf, yet it doesn't have child dims?"
            fail1
          fi
        fi
      fi

      post_update || fail

    else
      update_successful=t
      abort
    fi

  end_function

  command_successful=${update_successful:-f}
  reply_to_caller "command_successful=${command_successful:-}"

  handle_return
}

