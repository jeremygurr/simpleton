#!/usr/bin/env bash

type -t update_lib_loaded >/dev/null && return 0
update_lib_loaded=t

# will write all trunk and sub dim names to the output file
write_output_fields() {
  begin_function_lo
    if [[ $cell_is_leaf == f ]]; then
      log_fatal "write_update_fields should only be run on a leaf cell"
      fail1
    fi
    local d result=
    for d in ${trunk_dims[*]:-} ${sub_dims[*]:-}; do
      result+=" $d"
    done
    echo "${result# }" >$out_path/$out_file || fail
  end_function
  handle_return
}

# will write a row of data to the output file based on current dim values
write_output_row() {
  begin_function_lo
    if [[ $cell_is_leaf == f ]]; then
      log_fatal "write_update_row should only be run on a leaf cell"
      fail1
    fi
    local d result=
    for d in ${trunk_dims[*]:-} ${sub_dims[*]:-}; do
      local -n m=d_$d
      local s=${m:-}
      quotes=single shell_quote_var s
      result+=" $s"
    done
    echo "${result# }" >>$out_path/$out_file || fail
  end_function
  handle_return
}

# inputs: 
#   upstream
prep_upstream() {
  local log_show_vars=^upstream
  begin_function

    # down_fresh may be used by prep script to propagate freshness requirements to upstream
    down_fresh=$required_freshness

    # This may be overridden by upstream prep file to customize how failure of this upstream is handled
    handle_upstream_result() {
      if [[ $update_successful == f ]]; then
        log_error "Failed to update upstream cell $upstream"
      fi
    }

    # Don't inherit parent's freshness requirements, 
    #   only what upstream prep explicitly states
    # extra_dims includes dimensions that need to be promoted in upstream that don't
    #   exist in branch_dims
    fresh=$down_fresh required_freshness= default_freshness= extra_dims=

    local prep_function=up_${upstream_var}_prep
    if function_exists $prep_function; then
      log_debug "Executing upstream prep: $prep_function"
      get_required_freshness || fail
      $prep_function || fail
    fi

    if [[ ! -d $up_chosen_path ]]; then
      mkdir $up_chosen_path || fail
    fi
      
    chosen_target_link=$up_chosen_path/$upstream_name

  end_function
  handle_return
}

maybe_fix_choice() {
  local choice=$1
  begin_function
    if [[ ! -e "$choice" ]]; then
      local choice_target trunk_cell invalid_dep=f
      choice_target=$(realpath $choice 2>/dev/null) || invalid_dep=t
      if [[ $invalid_dep == f ]]; then
        get_trunk_cell $choice_target || fail
        if [[ ! -e $trunk_cell ]]; then
          invalid_dep=t
        fi
      fi

      if [[ $invalid_dep == t ]]; then
        rm -rf ${choice%/choices/*} || fail
        make_cyto_up_single ${choice##*/} || fail
        choice_target=$(realpath $choice 2>/dev/null) || invalid_dep=t
        get_trunk_cell $choice_target || fail
        invalid_dep=f
      fi

      if [[ $invalid_dep == f ]]; then
        safe_link $trunk_cell $choice || fail
      else
        log_fatal "Invalid upstream link in $upstream/choices: ${choice##*/}. Maybe try a clean build."
        fail1
      fi
    fi
  end_function
  handle_return
}

get_needs_update_internal() {
  local target_cell=$1
  begin_function_lo

    if [[ "$pause_at_cells" ]]; then
      local pac
      for pac in $pause_at_cells; do
        if [[ "$cell_path" == *"$pac"* ]]; then
          handle_user_interrupt "Cell reached (get_needs_update): $pac."
        fi
      done
    fi

    if [[ "${needs_update:-}" ]]; then
      # needs_update is already known, don't need to compute it again
      log_message="needs_update is already set to $needs_update"
      level=log_debug
      abort
    fi

    if [[ ! -e $target_cell/.dna ]]; then
      log_fatal "Attempted to run get_needs_update on folder that is not a cell: $target_cell"
      fail1
    fi

    if [[ ! -d $cyto_path ]]; then
      needs_update=t
      log_message="Needs update because cyto folder doesn't exist"
      abort
    fi

    local check_context=$cyto_path/context-check
    if [[ ! -f $check_context ]]; then
      needs_update=t
      log_message="Needs update because check context doesn't exist"
      abort
    fi

    if [[ "$clean_cells" ]]; then
      local cell_to_clean
      for cell_to_clean in $clean_cells; do
        if [[ "$target_cell/" == */$cell_to_clean/* ]]; then
          needs_update=t
          log_message="Needs update because output file doesn't exist"
          abort
        fi
      done
    fi

    local out_file= out_path= cell_is_leaf=f check_op_var=f data_props=()
    source $check_context || fail

    local required_freshness
    get_required_freshness

    if [[ $cell_is_leaf == f ]]
    then
      needs_update=t
      log_message="Needs update because cell is not a leaf"
    elif [[ "$out_file" && ! -e "$out_path/$out_file" ]]; then
      needs_update=t
      log_message="Needs update because output file doesn't exist"
    elif [[ ! -e $status_path/last-good-update-end ]]
    then
      needs_update=t
      log_message="Needs update because cell has never been updated successfully"
    elif [[ ! -e $status_path/up-to-date ]]
    then
      needs_update=t
      log_message="Needs update because cell definition has changed"
    elif [[ ! -e $status_path/deps-up-to-date ]]
    then
      needs_update=t
      log_message="Needs update because upstream has changed"
    elif get_is_stale $status_path || fail
         [[ $is_stale == t ]]
    then
      needs_update=t
      log_message="Needs update because cell is stale"
    elif local data_valid=f missing
      ignore_missing=t execute_op check || fail
      [[ $data_valid == f && $missing == f ]]
    then
      needs_update=t
      log_message="Needs update because validity check failed"
    elif local prop_changed
      get_data_prop_changed $target_cell || fail
      [[ $prop_changed == t ]]
    then
      needs_update=t
      log_message="Needs update because a data property was changed"
    elif 
      local problem_found=f
      broken_link_check || fail
      [[ $problem_found == t ]]
    then
      needs_update=t
      log_message="Needs update because cyto contains broken links"
      needs_pruning=t
    fi

  end_function
  handle_return
}

# returns needs_update
# context does not need to be loaded
get_needs_update() {
  local log_show_vars=^target_cell target_cell=$1
  begin_function

    log_debug "Does ${target_cell#/*/*/} need updating?"

    # do we need to delete branches of this cell
    needs_pruning=f

    local cyto_path=$target_cell/.cyto

    local level=log_verbose
    if [[ ${top_level_command:-t} == t ]]; then
      level=log_info
    fi

    local status_path=$cyto_path/status \
      up_path=$cyto_path/up \
      log_message="No update needed" \

    get_needs_update_internal $target_cell || fail

  end_function

  if succeeded; then
    if [[ ${needs_update:-f} == f && $top_level_command == f ]]; then
      level=log_info
    fi
    action=update_check $level "$log_message (${target_cell#/*/*/})"
  else
    action=update_check log_fatal "Failed to check update need of ${target_cell#/*/*/}"
  fi

  if [[ $needs_pruning == t ]]; then
    rm -rf $cyto_path || fail
    build_cyto $target_cell || fail
  fi

  if [[ ! "$needs_update" ]]; then
    needs_update=f
  fi

  local log_return_vars=needs_update
  handle_return
}

update_upstream_choose_multi() {
  begin_function
    local anchor_dims=

    if [[ "$chosen" ]]; then
      if [[ -e "$chosen/.dna" ]]; then
        upstream_cell_link=$chosen
        cell_path=$(realpath $chosen) || fail
        get_needs_update $cell_path || fail
      else
        needs_update=t
      fi
      if [[ $needs_update == t ]]; then
        chosen=
      fi
    fi

    # This must be separate from the previous if block because chosen may have been unset in the
    #   previous block.
    if [[ ! "$chosen" ]]; then
      begin_for choice in "${choices[@]}"; doo
        maybe_fix_choice $choice || fail
        needs_update=
        cell_path=$(realpath $choice) || fail
        get_needs_update $cell_path || fail
        if [[ $needs_update == f ]]; then
          chosen=$choice
          break
        fi
      end_for
      if [[ ! "$chosen" ]]; then
        chosen=${choices[0]}
      fi
    fi

  end_function
  handle_return
}

repair_update_upstream_choose() {
  if [[ $problem == no_choices ]]; then
    rm -rf $up_path || return 1
    make_cyto_up || return 1
    problem=
    repair_successful=t
  fi
  return 0
}

# needs_update is guaranteed to be set after this completes successfully
# returns: chosen needs_update
update_upstream_choose() {

  local log_show_vars=^upstream problem=
  begin_function_hi

    local choices
    if [[ -d $upstream/choices ]]; then
      choices=( $(find1 $upstream/choices -not -name ".*" | sort -g) ) || fail
    else
      choices=( $upstream )
    fi

    if [[ ! "${choices:-}" ]]; then
      log_fatal "No choices defined for upstream $upstream"
      problem=no_choices
      fail1
    fi

    chosen=
    if [[ -e "$chosen_target_link" ]]; then
      chosen=$(readlink $chosen_target_link) || fail
    fi

    needs_update=
    if (( ${#choices[*]} == 1 )); then
      chosen=$choices
      maybe_fix_choice $chosen || fail
    else # more than one choice available
      update_upstream_choose_multi
    fi

    if [[ ! -e $chosen_target_link ]]; then
      safe_link $chosen $chosen_target_link || fail
    fi
    upstream_cell_link=$chosen
    cell_path=$(realpath $chosen) || fail
    anchor_dims=
    get_needs_update $cell_path || fail

  end_function
  local log_return_vars=chosen
  handle_return

}

update_upstream_get_locks() {
  local log_show_vars=^upstream
  begin_function

    local lock 
    local -r export_path=$upstream/chosen/export
    if [[ -d $export_path ]]; then

      local shared_locks
      shared_locks=$(find1 $export_path -not -name ".*" -name "shared-lock-*" | sort -g) || fail
      begin_for lock in $shared_locks; doo
        write_lock=f \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for

      local exclusive_locks
      exclusive_locks=$(find1 $export_path -not -name ".*" -name "lock-*" | sort -g) || fail
      begin_for lock in $exclusive_locks; doo
        write_lock=t \
          timeout=$lock_timeout \
          cell_lock $lock || fail
      end_for

    fi

  end_function
  handle_return
}

repair_update_upstream() {
  # check for duplicate dims
  if [[ "${up_cell:-}" && "${chosen_target_link:-}" ]]; then
    local -A dims_found
    local cyto_up_link=$(readlink $chosen_target_link 2>/dev/null) || return 1
    local remaining=$up_cell part dim dup_found=f
    while [[ $remaining == *:* && $remaining == */* ]]; do
      part=${remaining##*/}
      remaining=${remaining%/$part}
      if [[ "$part" == *:* ]]; then
        dim=${part%%:*}
        if [[ "${dims_found[$dim]:-}" ]]; then
          dup_found=t
          break
        fi
        dims_found[$dim]=1
      fi
    done
    if [[ $dup_found == t ]]; then
      log_debug "Auto repairing duplicate dim upstream link"
      if [[ -L $cyto_up_link ]]; then
        rm $cyto_up_link || return 1
      fi
      if [[ -L $chosen_target_link ]]; then
        rm $chosen_target_link || return 1
      fi
      repair_successful=t
    fi
  fi

  return 0
}

# inputs: 
#   upstream: a folder in .dna/up
update_upstream() {

  local original_cell_path=${cell_path:-} \
    upstream=$1 \

  local log_show_vars=^upstream 
  begin_function

    local needs_update= upstream_cell_link= \
      chosen= anchor_dims= \
      chosen_target_link \
      required_freshness= fresh= \
      default_freshness= \
      risk_tolerance=$risk_tolerance \
      command_history=${command_history:-} \

    local upstream_name=${upstream##*/.cyto/up/}
    local cell_path=${upstream%/.cyto/up/$upstream_name}
    if [[ $cell_path == $upstream ]]; then
      log_fatal "Invalid upstream: $upstream, it should be within .cyto/up"
      fail1
    fi

    local cyto_path=$cell_path/.cyto
    local up_path=$cyto_path/up up_chosen_path=$cyto_path/up-chosen

    log_debug "Updating upstream $upstream_name"

    localize
    prep_upstream || fail
    update_upstream_choose || fail

    if [[ "$needs_update" != f ]]; then

      local up_cell
      up_cell=$(realpath $chosen) || fail

      downstream_cell_name=${short_cell//\//_} \
      fork execute_commands "$up_cell" update || fail

      if [[ $something_changed == t ]]; then
        previous_upstream_changed=t
      fi

      handle_upstream_result || fail

      if [[ $update_successful == f ]]; then
        break
      fi

    fi
    
    update_upstream_get_locks || fail

  end_function
  handle_return
}

# inputs:
#   up_chosen_path
#   upstream
#   upstream_name
load_upstream_vars() {
  begin_function

    if [[ -d "${up_chosen_path:-}" ]]; then

      update_successful=t
      local export_path=$upstream/export \
        out_path=$up_chosen_path/$upstream_name \
        prefix=${upstream##*/}_ \
        auto_load=() \
        dna_roots= \
        context_type= \

      pass_thru=t \
      recursive=f \
      ignore_unknown=t \
      prefix= \
      load_dna_contents $out_path || fail

      if [[ -d $export_path ]]; then
        pass_thru=t \
        prefix= \
        load_dna_contents $export_path || fail
      fi

      prefix=
      execute_auto_loads "${auto_load[@]}" || fail

      if [[ $update_successful == f ]]; then
        break
      fi

    fi

  end_function

  if failed || [[ $update_successful == f ]]; then
    update_successful=f
  fi

  handle_return
}

update_upstreams() {
  local execute_update=${execute_update:-t}
  begin_function

    update_successful=t
    if [[ "${last_upstream_updated:-}" == "${up_path:-}" ]]; then
      abort
    else
      last_upstream_updated=${up_path:-}
    fi

    if [[ -d "${up_path:-}" ]]; then

      local previous_upstream_changed=f upstream upstreams \
        top_level_command=f

      upstreams=$(find1 $up_path -not -name '.*' | sort -g) || fail
      # This will eventually be done in parallel
      begin_for upstream in $upstreams; doo

        local upstream_name=${upstream##*/} o
        split_ordinal upstream_name o upstream_name
        local upstream_var=${upstream_name//-/_} \
          orig_up_chosen_path=$up_chosen_path \

        if [[ $execute_update == t ]]; then
          update_upstream $upstream || fail
          if [[ $update_successful == f ]]; then
            break
          fi
        fi

        up_chosen_path=$orig_up_chosen_path
        load_upstream_vars || fail

      end_for

    fi

    if [[ $execute_update == t ]]; then
      touch $status_path/deps-up-to-date || fail
    fi

  end_function

  if failed || [[ $update_successful == f ]]; then
    if [[ -f $status_path/deps-up-to-date ]]; then
      rm $status_path/deps-up-to-date 
    fi
    update_successful=f
  fi

  handle_return
}

get_prop_hash() {
  local prop= prop_string=
  for prop in ${data_props[*]:-}; do
    if [[ -v d_$prop ]]; then
      eval "value=\$d_$prop"
      prop_string+="$prop=$value "
    fi
  done
  prop_hash=$(echo "$prop_string" | sha1sum) || return 1
  return 0
}

get_data_prop_changed() {
  local cell_path=$1
  local status_path=$cell_path/.cyto/status \
    prop_hash=0 \
    value
  prop_changed=f
  if [[ "${data_props:-}" ]]; then

    local prop all_set=t
    for prop in ${data_props[*]}; do
      local -n v=$prop
      if [[ ! "${v:-}" ]]; then
        all_set=f
        break
      fi
    done

    if [[ $all_set == t ]]; then
      prop_changed=t
      local -r status_file=$status_path/last_run_prop_hash
      if [[ -f $status_file ]]; then
        get_prop_hash || return 1
        if [[ $prop_hash == $(<$status_file) ]]; then
          prop_changed=f
        fi
      fi
    fi

  fi
  return 0
}

update_prop_hash() {
  local prop_hash
  get_prop_hash || return 1
  local -r status_file=$status_path/last_run_prop_hash
  echo "$prop_hash" >$status_file || return 1
  return 0
}

already_in_dep_stack() {
  local find_dep=$1
  local dep
  for dep in ${dep_stack[*]}; do
    if [[ $dep == $find_dep ]]; then
      return 0
    fi
  done
  return 1
}

propagate_change_to_downstream2() {
  begin_function

    local cell
    cell=$(realpath $value) || fail

    local t1 t2 trunk_cell
    get_trunk_cell $cell
    t1=$trunk_cell
    get_trunk_cell $from_cell
    t2=$trunk_cell
    if [[ $t1 == $t2 ]]; then
      log_fatal "Cell is propagating change to itself: $cell" 
      fail1
    fi
    
    local status_self=$cell/.cyto/status
    
    if already_in_dep_stack $cell; then
      abort
    fi
    dep_stack+=( $cell )

    if [[ -d $cell ]]; then
      if [[ -d $status_self ]]; then
        # can't combine these if statements or it will alter the else condition
        #   and break things
        if [[ -f $status_self/deps-up-to-date ]]; then
          rm $status_self/deps-up-to-date || fail
          # recursive
          from_cell=$cell \
            propagate_change_to_downstream || fail
        fi
      else
        # recursive
        from_cell=$cell \
          propagate_change_to_downstream || fail
      fi
    fi

  end_function
  handle_return
}

propagate_change_to_downstream() {
  begin_function

    local from_cell=$from_cell \
      down_path=$from_cell/.cyto/down down_folder folders

    if [[ -d $down_path ]]; then
      local dep_stack=( ${downstream_cell_stack[*]} )
      folders=( $(find1 $down_path -not -name '.*' -type d) ) || fail
      loop_over_var=folders \
      background=f \
        par=f fork=f \
        body=propagate_change_to_downstream2 \
        parallel_loop || fail
    fi

  end_function
  handle_return
}

repair_pre_update() {
  if [[ ! -d $status_path ]]; then
    mkdir $status_path || return 1
    repair_successful=t
  fi
  return 0
}

pre_update() {
  begin_function

    update_successful= \
    something_changed=f \
    member_count=0 \
    cell_locks= \

    if [[ "${pretend_filter:-}" ]]; then
      local filter
      local pretend=f
      begin_for filter in ${pretend_filter}; doo
        if [[ "$cell_path" == *"$filter"* ]]; then
          pretend=t
        fi
      end_for
    fi

    write_lock=t \
      timeout=$lock_timeout \
      cell_lock $cell_path || fail

    defer "cell_unlock $cell_path"

    if [[ "${current_job_path:-}" ]]; then
      safe_link $current_job_path $running_job_path || fail
      defer "rm $running_job_path"
    else
      log_fatal "Missing current_job_path"
      fail1
    fi

    touch $status_path/last-update-start || fail
    # this needs to be at the beginning of the update so other processes
    #   could potentially invalidate it, requiring another update
    touch $status_path/up-to-date || fail

    if [[ $reuse_existing_out == t && -f $status_path/last-good-update-end ]]; then
      # Don't allow cells to reuse old data when it is mid-modification and this update fails
      rm $status_path/last-good-update-end || fail
    fi

    setup_dims || fail
    calc_coords_leaf || fail
    fence

    # This should have already happened when the mock was set in the first place
    #if [[ $current_mock != f ]]; then
    #  kind=data clean_cell $cell_path || fail
    #fi

    # This already happens in switch_context
    #if [[ $cell_is_leaf == t ]]; then
    #  local known_dims=()
    #  local missing_dims=()
    #  prep_dims sub_dims control_props data_props || fail
    #  expand_dims || fail
    #  coord_type=leaf \
    #  calc_coordinates || fail
    #fi

  end_function
  handle_return
}

create_outer_links() {
  begin_function

    local outer_cell_path outer_cell_name

    get_bottom_cell ${inner_cell_link%/*} || fail
    outer_cell_path=$bottom_cell

    local outer_link=$outer_path/$outer_cell_name
    if [[ ! -e $outer_link ]]; then
      if [[ ! -d $outer_path ]]; then
        mkdir $outer_path || fail
      fi
      safe_link $outer_cell_path $outer_link || fail
    else
      local link_target
      link_target=$(readlink $outer_link) || fail
      if [[ $link_target != $outer_cell_path ]]; then
        log_fatal "Link conflict: A link already exists but doesn't point to the same place."
        log_fatal "  source:   $outer_link"
        log_fatal "  target 1: $outer_cell_path"
        log_fatal "  target 2: $link_target"
        fail1
      fi
    fi

  end_function
  handle_return
}

create_downstream_links() {
  begin_function

    local down_cell_path down_cell_name

    get_bottom_cell ${upstream_cell_link%/*} || fail
    down_cell_path=$bottom_cell

    local down_link=$down_path/$downstream_cell_name
    if [[ ! -d $down_path ]]; then
      mkdir $down_path || fail
    fi
    force=t safe_link $down_cell_path $down_link || fail

#      let's just replace this each time for now
#    if [[ -e $down_link ]]; then
#      local link_target
#      link_target=$(readlink $down_link) || fail
#      if [[ $link_target != $down_cell_path ]]; then
#        log_fatal "Link conflict: A link already exists but doesn't point to the same place."
#        log_fatal "  source:   $down_link"
#        log_fatal "  target 1: $down_cell_path"
#        log_fatal "  target 2: $link_target"
#        fail1
#      fi
#    fi

  end_function
  handle_return
}

link_dim_parts() {
  local from_path=$from_path to_path=$to_path
  begin_function
    local contents
    contents=$(find1 $from_path -not -name '.*') || fail
    begin_for part in $contents; doo
      if [[ "$part" == */up \
         || "$part" == */down \
         || "$part" == */out \
         ]]; then
        continue
      elif [[ "$part" == */var \
           || "$part" == */fun \
           ]]; then
        contents=$(find1 $part -not -name '.*') || fail
        local folder=${part##*/} part2
        begin_for part2 in $contents; doo
          if [[ ! -d $to_path/$folder ]]; then
            mkdir $to_path/$folder || fail
          fi
          safe_link $(realpath $part2) $to_path/$folder/ || fail
        end_for
      else
        safe_link $(realpath $part) $to_path/ || fail
      fi
    end_for 
  end_function
  handle_return
}

create_sub_cell() {
  local sub_cell=$sub_cell \
    parent_cell=$parent_cell \
    parent_seed=$parent_seed

  local log_show_vars='^sub_cell'
  begin_function

    log_debug "Creating sub cell $cell_path"

    if [[ "$sub_cell" == */.dna* ]]; then
      log_fatal "Internal error: Invalid sub_cell $sub_cell."
      log_fatal "We should not be creating a sub cell inside of a dna folder"
      fail1
    fi

    if [[ "$parent_cell" == "$sub_cell" ]]; then
      log_fatal "Can't create sub cells in a cell without parents: $sub_cell"
      stack_trace
      fail1
    fi

    deep=t \
    parent_path=$parent_cell \
    seed_path=$parent_seed \
    member=$member \
    repair=t \
    plant_member || fail

  end_function
  handle_return
}

update_inner() {
  begin_function

    local old_link=$inner_cell_link \
      old_target=$(readlink $inner_cell_link) \
      new_target=$cell_path || fail

    if [[ $cell_is_leaf == t ]]; then
      create_outer_links || fail
    fi

    local update_outer_link=f
    if [[ ! -e $old_link ]]; then
      log_debug "Will update outer link because file is missing"
      update_outer_link=t
    else
      local new_target_length=${#new_target} \
        old_target_length=${#old_target}

      if (( new_target_length > old_target_length )); then
        log_debug "Will update outer link because new target is more specific"
        update_outer_link=t
      elif [[ ${old_target#$new_target} == ${old_target} ]]; then
        log_debug "Will update outer link because new target is different"
        update_outer_link=t
      fi
    fi

    if [[ $update_outer_link == t ]]; then
      log_debug "Linking upstream cell to it's outer cell cyto up folder"
      force=t safe_link $cell_path $old_link || fail
    fi

  end_function
  handle_return
}

update_downstream() {
  begin_function

    local old_link=$upstream_cell_link \
      old_target=$(readlink $upstream_cell_link) \
      new_target=$cell_path || fail

    if [[ $cell_is_leaf == t ]]; then
      create_downstream_links || fail
    fi

    local update_downstream_link=f
    if [[ ! -e $old_link ]]; then
      log_debug "Will update downstream link because chosen file is missing"
      update_downstream_link=t
    else
      local new_target_length=${#new_target} \
        old_target_length=${#old_target}

      if (( new_target_length > old_target_length )); then
        log_debug "Will update downstream link because new target is more specific"
        update_downstream_link=t
      elif [[ ${old_target#$new_target} == ${old_target} ]]; then
        log_debug "Will update downstream link because new target is different"
        update_downstream_link=t
      fi
    fi

    if [[ $update_downstream_link == t ]]; then
      log_debug "Linking upstream cell to it's downstream cell cyto up folder"
      force=t safe_link $cell_path $old_link || fail
    fi

  end_function
  handle_return
}

update_member() {
  local sane_value member_path \
    log_vars=member log_show_vars=member \
    upstream_cell_link=${upstream_cell_link:-} \
    cell_path=$cell_path \
    original_cell_path=$cell_path \
    anchor_dims=${anchor_dims:-} \
    dim=$dim \

  begin_function_hi

    get_sane_value "$member" || fail
    member_path=$cell_path/$dim:$sane_value

    log_debug "Updating member $dim:$sane_value"

    local needs_update=
    if [[ ! -d $member_path/.dna ]]; then
      parent_cell=$cell_path \
      parent_seed=$seed_path \
      sub_cell=$member_path \
      create_sub_cell || fail
      needs_update=t
    else
      cell_path=$member_path
      get_needs_update $member_path || fail
    fi

    if [[ "${upstream_cell_link:-}" ]]; then
      cell_path=$member_path update_downstream || fail
    fi

    if [[ $needs_update == t ]]; then

      if (( member_count > 1 )); then
        log_debug "More than one member found ($member_count), not passing upstream_cell_link."
        upstream_cell_link=
      elif [[ "$upstream_cell_link" ]]; then
        log_debug "Only one member found, passing upstream_cell_link: $upstream_cell_link"
      fi

      downstream_cell_name=${short_cell//\//_} \
      fork execute_commands $member_path update || fail

      if [[ $update_successful == f ]]; then
        log_error "Failed to update member cell $member"
        reply_to_caller "update_successful=f" || fail
      else 
        update_successful=
      fi
    fi

    if (( member_count == 1 )); then
      upstream_cell_link=
    fi
  end_function
  handle_return
}

update_members() {
  begin_function

    local dim=${child_dims[0]}
    update_successful=
    par=t fork=f function=update_member for_each_member $dim || fail

    if [[ ${update_successful:=t} == f ]]; then
      log_fatal "Failed to update some member(s)"
      fail1
    fi

  end_function
  handle_return
}

update_aggregation() {
  begin_function
    if [[ "$out_file" ]]; then
      if [[ ! "${current_branch_dim:-}" ]]; then
        log_fatal "Internal error: missing current_branch_dim"
        fail1
      fi

      local -n dim_type=${current_branch_dim}_dim_type
      local -n member_type=${dim_type}_${current_branch_dim}_member_type
      local can_agg=t
      if [[ "$member_type" == static ]]; then
        local m s
        local -n members=${dim_type}_${current_branch_dim}_members
        for m in $members; do
          get_sane_value $m s
          if [[ ! -d $cell_path/${current_branch_dim}:$s ]]; then
            can_agg=f
            break
          fi
        done
      fi

      if [[ $can_agg == t ]]; then

        local target=$out_path/$out_file member \
          branches branch wrote_header=f \

        branches=$(find1 $cell_path -type d -name "*:*" | sort) || fail

        for branch in $branches; do
          if [[ -f $branch/$out_file ]]; then

            if [[ $wrote_header == f ]]; then
              cp $branch/$out_file $target || fail
              wrote_header=t
            else
              tail +2 $branch/$out_file >>$target || fail
            fi

          else
            log_warn "Missing data file for branch $branch"
          fi
        done

      fi
    fi
  end_function
  handle_return
}

compare_files_or_dirs() {
  local left=$1 right=$2
  begin_function
    if [[ -d $left ]]; then
      if [[ -d $right ]]; then
        local sub_full sub already_checked files

        files=$(find1 $left -not -name '.*') || fail
        begin_for sub_full in $files; doo
          sub=${sub_full##*/}
          compare_files_or_dirs $left/$sub $right/$sub || fail
          if [[ $changed == t ]]; then
            abort
          fi
          already_checked+=" $sub"
        end_for
        already_checked+=' '

        files=$(find1 $right -not -name '.*') || fail
        begin_for sub_full in $files; doo
          sub=${sub_full##*/}
          if [[ "$already_checked" =~ \ "$sub"\  ]]; then
            continue
          fi
          compare_files_or_dirs $right/$sub $left/$sub || fail
          if [[ $changed == t ]]; then
            abort
          fi
        end_for

      else
        changed=t
      fi
    elif [[ -f $left ]]; then
      if [[ -f $right ]]; then
        if files_are_different $left $right &>/dev/null; then
          changed=t
        else
          changed=f
        fi
      else
        changed=t
      fi
    else
      changed=f
    fi
  end_function
  handle_return
}

update_self_move_out_path() {
  begin_function

    if [[ -e $out_path.old ]]; then
      rm -rf $out_path.old || fail
    fi

    local f
    begin_for f in .dna .cyto .dim; doo
      if [[ -e $out_path/$f ]]; then
        if [[ ! -e $out_path.new/$f ]]; then
          mv $out_path/$f $out_path.new/$f || fail
        else
          log_fatal "Target $f folder already exists, when it shouldn't"
          fail1
        fi
      fi
    end_for

    if [[ -d $out_path ]]; then
      mv $out_path $out_path.old || fail
    fi

    mv $out_path.new $out_path || fail
    something_changed=t

    if [[ -e $out_path.old ]]; then
      rm -rf $out_path.old || fail
    fi

  end_function
  handle_return
}

update_self() {
  local log_vars='short_cell'
  begin_function

    log_debug "Executing local update of $short_cell$attempt_string" 

    update_successful=
    can_retry=f

    local reuse_existing_out=${reuse_existing_out:-t}

    local original_out_path=$out_path out_path=$out_path
    if [[ $reuse_existing_out == f ]]; then
      if [[ -d $out_path.new ]]; then
        rm -rf $out_path.new || fail
      fi
      if [[ ! -d $out_path.new ]] && ! mkdir $out_path.new 2>/dev/null; then
        log_debug "Could not make dir $out_path.new, falling back to $out_path"
      fi
      out_path=$out_path.new
    else
      # allow update code to set this, since we can't compare when changes are made in place
      something_changed=
    fi

    local missing=t
    tee_output_to_log || fail
    if [[ $current_mock == f ]]; then
      localize
      ignore_missing=t execute_op update || {
        log_fatal "Internal error while executing update operator."
        fail1
      }
    else # mocking

      log_warn "Using mock: $current_mock ($short_cell)"
      local -r export_path=$mock_path/$current_mock/export

      if function_exists mock_update_op; then
        missing=f
        mock_update_op || fail
      fi

      if [[ -d $export_path ]]; then
        pass_thru=t \
        context_type= \
        load_dna_contents $export_path || fail
      fi

      update_successful=${update_successful:-t}

    fi
    completion_time=$EPOCHSECONDS
    untee_output || fail

    if [[ $missing == t ]]; then
      update_successful=t
    else
      update_successful=${update_successful:-f}
    fi

    if [[ $reuse_existing_out == f && -d $out_path ]]; then
      out_path=$original_out_path
      if [[ $update_successful == t ]]; then
        local changed
        compare_files_or_dirs $out_path $out_path.new || fail
        if [[ $changed == f ]]; then
          rm -rf $out_path.new || fail
        else
          update_self_move_out_path || fail
        fi
      fi
    else # $reuse_existing_out == t
      # if update code didn't set this, we must assume the worst
      if [[ ! "$something_changed" ]]; then
        something_changed=t
      fi
    fi

  end_function
  untee_output  # in case update failed and block was exited early
  handle_return
}

update_self_retry_loop() {
  begin_function

    ref_group=none \
    delay=$retry_delay \
    can_update=t \

    if [[ "$update_successful" ]]; then
      can_update=f
    fi

    if [[ $can_update == t ]]; then
      for ((retry=0; retry < retry_max; retry++)); do

        if [[ $retry -gt 0 ]]; then
          log_info "Waiting $delay seconds before trying again" 
          sleep $delay
          let 'delay *= retry_scale' || true
        fi

        local attempt_string=
        if (( retry_max > 1 )); then
          attempt_string=", attempt $((retry+1)) of $retry_max"
        fi
          
        update_self || fail

        [[ $can_retry == f || $update_successful == t ]] && break

      done
    fi

    update_successful=${update_successful:-t}

  end_function
  handle_return
}

check_results() {
  begin_function_hi

    if [[ $can_update == t ]]; then
      if [[ $update_successful == t && $post_validate == t ]]; then
        log_debug "Post validating"
        local data_valid=f
        can_retry=f
        execute_op check || return 1
        if [[ $data_valid == f ]]; then
          log_warn "Data is not valid"
          update_successful=f
        else
          log_debug "Data is valid"
        fi
      fi
    else
      update_successful=t
    fi

  end_function
  handle_return
}

post_update() {
  local result_string
  begin_function_hi

    completion_time=${completion_time:-$EPOCHSECONDS}
    if [[ $update_successful == t ]]; then
      result_string="successful"
    else
      result_string="failed"
      update_successful=f
    fi

    if [[ $update_successful == t ]]; then
      touch -d @$completion_time $status_path/last-good-update-end || fail
      cp -a $status_path/last-update-start \
            $status_path/last-good-update-start || fail
      if [[ -v current_job_path ]]; then
        force=t safe_link $current_job_path $job_path/last-success || fail
      fi
      if [[ "${data_props:-}" ]]; then
        update_prop_hash || fail
      fi
      if [[ $something_changed == t ]]; then
        from_cell=$cell_path \
          propagate_change_to_downstream || fail
      fi
    else
      touch -d @$completion_time $status_path/last-bad-update-end || fail
      force=t safe_link $current_job_path $job_path/last-failure || fail
      cp -a $status_path/last-update-start \
            $status_path/last-bad-update-start || fail
    fi

    if [[ $cell_is_leaf == t ]]; then
      log_info "Update $result_string. ($short_cell)"
    else
      log_debug "Update $result_string. ($short_cell)"
    fi

    reply_to_caller "update_successful=${update_successful:-}" || fail

    cell_unlock $cell_path || fail

    if [[ -v running_job_path && -e $running_job_path ]]; then
      rm $running_job_path || fail
    fi

  end_function
  handle_return
}

get_dep_member() {

  if [[ -f $dep_cell/.dna/context-before ]]; then
    source $dep_cell/.dna/context-before || return 1
  else
    log_fatal "Missing context-before in $dep_cell/.dna."
    log_fatal "Should have been generated by update of it's trunk."
    log_fatal "Maybe try to run a clean on it and update again."
    return 1
  fi

  if [[ ! -v $dep_dim ]]; then
    log_fatal "Missing member for $dep_dim."
    log_fatal "This should have been defined in $dep_cell/.dna/context-before"
    return 1
  fi

  dep_member=${!dep_dim}
  return 0
}

update_inners() {
  begin_function
    local i_path needs_update= inners
    inners=$(find1 $inner_path -type d -not -name '.*') || fail
    begin_for i_path in $inners; doo
      outer_cell_name=${short_cell//\//_} \
      inner_cell_link=$i_path \
      anchor_dims= \
      fork execute_commands $i_path update || fail
    end_for
  end_function
  handle_return
}

update_command() {
  begin_function

    local leave_loop=0 \
      something_changed=f \
      needs_update=${needs_update:-} \
      needs_inner=f \

    update_successful=f

    if [[ "${refresh:-f}" == t ]]; then
      refresh=f
      find $cell_path -path '*/.cyto/status/up-to-date' -delete || fail
    fi

    switch_context $cell_path || fail
    fence

    if [[ $current_mock == disabled ]]; then
      log_fatal "Cell is disabled. Use mock command to change it if this is not intended."
      fail1
    fi

    setup_dims || fail
    if [[ $cell_is_leaf == f ]]; then
      # If the cell is a leaf, this has already been done in switch_context
      calc_coords_branch || fail
      fence
    fi

    if [[ ${branches_only:-f} == t && $cell_is_leaf == t ]]; then
      update_successful=t
      abort
    fi

    if function_exists get_update_risk; then
      get_update_risk || fail
    fi

    if (( update_risk > risk_tolerance )); then
      log_fatal "Risk too high"
      log_fatal "The risk of updating $short_cell is too high for the specified tolerance ($update_risk > $risk_tolerance)."
      log_fatal "Try a less risky strategy or increase the risk tolerance of this command (with the risk parameter)"
      fail1
    fi

    if [[ "${upstream_cell_link:-}" ]]; then
      update_downstream || fail
    fi

    if [[ "${inner_cell_link:-}" ]]; then
      update_inner || fail
    fi

    get_needs_update $cell_path || fail

    if [[ $needs_update == t ]]; then

      pre_update || fail
      deep=t plant_seed_internal "$seed_path" "$cell_path" || fail

      if [[ "$update_successful" != f ]]; then
        if [[ $current_mock == f ]]; then
          update_upstreams || fail
          fence
        else
          update_successful=t
        fi
      fi

      if [[ $update_successful == t ]]; then
        if [[ $cell_is_leaf == t ]]; then
          if function_exists update_op; then
            update_successful=
            update_self_retry_loop || fail
            check_results || fail
          fi
        else
          if [[ "${child_dims:-}" ]]; then
            update_members || fail
            fence
            update_aggregation || fail
          else
            log_fatal "Internal error: cell is not a leaf, yet it doesn't have leaf dims?"
            fail1
          fi
        fi
      fi

      post_update || fail

    else
      update_successful=t
      abort
    fi

    if [[ $update_successful == t
       && $cell_is_leaf == t
       && $needs_inner == t
       && "${inner:-}" ]]; then
      log_debug "Updating inner cells"
      update_inners || fail
    fi

  end_function

  if [[ "$update_successful" == t ]]; then
    command_successful=t
  fi
  reply_to_caller "command_successful=${command_successful:-}"

  handle_return
}

